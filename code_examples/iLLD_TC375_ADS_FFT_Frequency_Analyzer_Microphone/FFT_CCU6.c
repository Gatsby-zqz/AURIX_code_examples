/**********************************************************************************************************************
 * \file FFT_CCU6.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "FFT_CCU6.h"
#include "Ifx_Types.h"
#include "IfxCcu6_Timer.h"
#include "IfxEvadc_Adc.h"
#include "Ifx_FftF32.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_ADC                4                               /* ADC result interrupt's priority          */
#define ADC_CHANNEL                     1                               /* ADC channel number                       */
#define ADC_GROUP                       IfxEvadc_GroupId_0              /* EVADC group                              */
#define ENABLE_EXTERNAL_TRIGGER         0x80                            /* Mask to enable external triggers on ADC  */

#define CCU6_T12_TIMER_FREQ             48828                           /* T12 Timer module frequency in Hz         */
#define CCU6_T13_TIMER_FREQ             48828                           /* T13 Timer module frequency in Hz         */
#define CCU6_T12_TIMER_MATCH_FREQ       20000                           /* T12 Period Match frequency in Hz         */
#define CCU6_T13_TIMER_MATCH_PERIOD     0.00005f                        /* T13 Period Match time in seconds         */

/* Timers period in ticks */
#define CCU6_T12_TIMER_PERIOD           (CCU6_T12_TIMER_FREQ / CCU6_T12_TIMER_MATCH_FREQ) - 1
#define CCU6_T13_TIMER_PERIOD           (CCU6_T13_TIMER_FREQ * CCU6_T13_TIMER_MATCH_PERIOD) - 1

/* Analog Samples Buffer */
#define ANALOG_BUFFER_SIZE 8192
/* Frequency resolution must be power of 2 */
#define FFT_RESOLUTION 128

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
 /* EVADC handle */
IfxEvadc_Adc         g_evadc;
IfxEvadc_Adc_Group   g_adcGroup;
IfxEvadc_Adc_Channel g_adcChannel;

/* Timer handle */
IfxCcu6_Timer g_timer;

/* FFT calculation variables */
cfloat32 g_AnalogSamplesBuffer[ANALOG_BUFFER_SIZE];
cfloat32 g_AnalogSamplesFFT[FFT_RESOLUTION];
float g_FFTAmplitude[FFT_RESOLUTION];
uint16 g_SamplesBufferIndex;
boolean g_bufferReady;

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the CCU6 module */
void init_CCU6(void)
{
    IfxCcu6_Timer_Config timerConfig;
    IfxCcu6_Timer_initModuleConfig(&timerConfig, &MODULE_CCU60);

    /* Configure the T12 timer frequency/period (trigger for T13 timer) and T13 timer frequency/period (trigger
     * for ADC). Timer T13 starts counting in single shot mode triggered by a period-match event of the T12 timer.
     * The period of the timer T13 represents a delay (from the period-match event of the T12 timer) of the ADC
     * trigger event.
     */
    timerConfig.base.t12Frequency = CCU6_T12_TIMER_FREQ;                /* Timer T12 frequency                      */
    timerConfig.base.waitingTime = CCU6_T12_TIMER_PERIOD;               /* waitingTime is the period of T12 timer   */
    timerConfig.base.t13Frequency = CCU6_T13_TIMER_FREQ;                /* Timer T13 frequency                      */
    timerConfig.base.t13Period = CCU6_T13_TIMER_PERIOD;                 /* Timer T13 period                         */
    timerConfig.timer = IfxCcu6_TimerId_t13;                            /* Select the timer, T13 is the master      */
    timerConfig.synchronousOperation = FALSE;                           /* Disable synchronous start of the timers  */
    timerConfig.trigger.t13InSyncWithT12 = TRUE;                        /* T12 timer starts the T13 timer           */

    /* Configure the T13 timer start event */
    timerConfig.timer13.t12SyncEvent = IfxCcu6_T13TriggerEvent_onT12Period;
    timerConfig.timer13.t12SyncDirection = IfxCcu6_T13TriggerDirection_onT12CountingUp;

    /* Apply the configuration to the CCU6 module */
    IfxCcu6_Timer_initModule(&g_timer, &timerConfig);

    /* Activate the line ServiceRequest_3 to route the T13 period match event trigger to the EVADC module */
    IfxCcu6_enableInterrupt(&MODULE_CCU60, IfxCcu6_InterruptSource_t13PeriodMatch);
    IfxCcu6_routeInterruptNode(&MODULE_CCU60, IfxCcu6_InterruptSource_t13PeriodMatch, IfxCcu6_ServiceRequest_3);

    /* Configure the T13 timer for single shot mode */
    IfxCcu6_enableSingleShotMode(&MODULE_CCU60, IfxCcu6_TimerId_t13);
    g_bufferReady = FALSE;
}

/* Function to start the CCU6 timer, according to the configuration */
void start_CCU6_timer(void)
{
    IfxCcu6_Timer_start(&g_timer);
}

/* Function to initialize the EVADC with default parameters */
void init_EVADC()
{
    init_EVADC_module();    /* Initialize the EVADC module */
    init_EVADC_group();     /* Initialize the EVADC group  */
    init_EVADC_channels();  /* Initialize the channels     */
}

/* Function to initialize the EVADC module with default parameters */
void init_EVADC_module()
{
    /* Create configuration */
    IfxEvadc_Adc_Config adcConfig;
    IfxEvadc_Adc_initModuleConfig(&adcConfig, &MODULE_EVADC);

    /* Initialize module */
    IfxEvadc_Adc_initModule(&g_evadc, &adcConfig);
}

/* Function to initialize the EVADC group */
void init_EVADC_group()
{
    /* Create and initialize group configuration with default values */
    IfxEvadc_Adc_GroupConfig adcGroupConfig;
    IfxEvadc_Adc_initGroupConfig(&adcGroupConfig, &g_evadc);

    /* Setting user configuration using group 0 */
    adcGroupConfig.groupId = ADC_GROUP;
    adcGroupConfig.master = adcGroupConfig.groupId;

    /* Enable queue 0 source */
    adcGroupConfig.arbiter.requestSlotQueue0Enabled = TRUE;

    /* Enable all gates in "always" mode (no edge detection) */
    adcGroupConfig.queueRequest[0].triggerConfig.gatingMode = IfxEvadc_GatingMode_always;

    /* Configure the EVADC module to trigger a conversion based on CCU6 timer period match event */
    /* Trigger 0 is connected to CCU6 ServiceRequest_3 line */
    adcGroupConfig.queueRequest[0].triggerConfig.triggerSource = IfxEvadc_TriggerSource_0;

    /* Select the trigger event type */
    adcGroupConfig.queueRequest[0].triggerConfig.triggerMode = IfxEvadc_TriggerMode_uponRisingEdge;

    /* Set that requests with higher priority cancel a running lower priority conversion */
    adcGroupConfig.queueRequest[0].requestSlotStartMode = IfxEvadc_RequestSlotStartMode_cancelInjectRepeat;

    /* Initialize the group */
    IfxEvadc_Adc_initGroup(&g_adcGroup, &adcGroupConfig);
}

/* Function to initialize the EVADC channel */
void init_EVADC_channels()
{
    /* Create channel configuration */
    IfxEvadc_Adc_ChannelConfig adcChannelConfig;

    IfxEvadc_Adc_initChannelConfig(&adcChannelConfig, &g_adcGroup);

    adcChannelConfig.channelId = (IfxEvadc_ChannelId)(ADC_CHANNEL);
    adcChannelConfig.resultRegister = (IfxEvadc_ChannelResult)(ADC_CHANNEL);

    /* Interrupt for sending the data via UART */
    adcChannelConfig.resultPriority = ISR_PRIORITY_ADC;                 /* Set the EVADC interrupt priority          */
    adcChannelConfig.resultServProvider = IfxSrc_Tos_cpu0;              /* Set the EVADC interrupt service provider  */

    /* Initialize the channel */
    IfxEvadc_Adc_initChannel(&g_adcChannel, &adcChannelConfig);

    /* Add channel to queue with refill and external trigger enabled */
    IfxEvadc_Adc_addToQueue(&g_adcChannel, IfxEvadc_RequestSource_queue0, (ENABLE_EXTERNAL_TRIGGER | IFXEVADC_QUEUE_REFILL));
}

/* ADC Interrupt Service Routine */
IFX_INTERRUPT(ISR_ADC_result, 0, ISR_PRIORITY_ADC);

void ISR_ADC_result(void)
{
    if(g_bufferReady == FALSE)
    {
        /* Get the result from the EVADC result register and print it using the UART communication */
        Ifx_EVADC_G_RES conversionResult = IfxEvadc_Adc_getResult(&g_adcChannel);
        g_AnalogSamplesBuffer[g_SamplesBufferIndex].real = (float32)conversionResult.B.RESULT;
        g_SamplesBufferIndex = g_SamplesBufferIndex++;
        if(g_SamplesBufferIndex >= ANALOG_BUFFER_SIZE)
        {
            g_SamplesBufferIndex=0;
            g_bufferReady = TRUE;
        }

    }
}

/* Computing the FFT and calculate the amplitude */
void compute_FFT()
{
    if(g_bufferReady == TRUE)
    {
        Ifx_FftF32_radix2(g_AnalogSamplesFFT, g_AnalogSamplesBuffer, FFT_RESOLUTION);
        for(int i = 0; i < FFT_RESOLUTION; i++)
        {
            /* Amplitude of FFT is SQRT(RE^2+IM^2) */
            g_FFTAmplitude[i] = pow(g_AnalogSamplesFFT[i].real, 2);
            g_FFTAmplitude[i] = g_FFTAmplitude[i] + pow(g_AnalogSamplesFFT[i].imag, 2);
            g_FFTAmplitude[i] = sqrt(g_FFTAmplitude[i]);
        }
        g_bufferReady = FALSE;
    }
}
