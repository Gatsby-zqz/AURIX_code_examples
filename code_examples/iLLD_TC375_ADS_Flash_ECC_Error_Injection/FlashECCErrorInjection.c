/**********************************************************************************************************************
 * \file FlashECCErrorInjection.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "FlashECCErrorInjection.h"
#include "IfxFlash.h"
#include "IfxScuWdt.h"
#include "IfxPort.h"
#include "Bsp.h"
#include "IfxCpu_Trap.h"
#include "IfxCpu_reg.h"
#include "IfxPfi_reg.h"
#include "IfxDmu_reg.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Define LEDs port pins */
#define LED_OK              &MODULE_P00, 5              /* LED1, used to signal no errors */
#define LED_ERROR           &MODULE_P00, 6              /* LED2, used to signal an error */
#define WAIT_TIME           (500)                       /* Wait time constant in milliseconds */

#define FLASH_MODULE        (0U)                        /* Macro to select the flash (PMU) module */
#define DATA_FLASH_0        IfxFlash_FlashType_D0       /* Define the Data Flash Bank to be used */

#define ONE_BIT             (1U)
#define TWO_BITS            (2U)
#define THREE_BITS          (3U)
#define FOUR_BITS           (4U)

#define WORD_BYTES_NUM      (sizeof(uint32))            /* Number of bytes in a word */
#define WORD_BITS_NUM       (32U)                       /* Number of bits in a word */
#define ECC_BITS_NUM        (22U)                       /* Number of ECC bits in PFlash and DFlash */
#define PF_PAGE_WORDS_NUM   (IFXFLASH_PFLASH_PAGE_LENGTH / WORD_BYTES_NUM)      /* Number of words in a PFlash page */
#define DF_PAGE_WORDS_NUM   (IFXFLASH_DFLASH_PAGE_LENGTH / WORD_BYTES_NUM)      /* Number of words in a DFlash page */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Force the compiler to put the following functions into CPU0 PSPR */
#pragma section code cpu0_psram

/* Check if target address is a valid PFlash address. If so, RCODE of the target address is saved in "rcode" variable and PFlash type is saved into "type" variable */
static Flash_ResultType checkPFlashAddress(uint32 address, uint32 *rcode, IfxFlash_FlashType* type)
{
    Flash_ResultType result = NO_ERROR;
    volatile Ifx_CPU_FLASHCON1 *CPU_FLASHCON1;
    volatile Ifx_CPU_FLASHCON2 *CPU_FLASHCON2;
    volatile Ifx_PFI_ECCS *PFI_ECCS;
    volatile Ifx_PFI_ECCR *PFI_ECCR;
    volatile uint32 readData;
    uint16 endInitCpuPassword;

    /* Get the current password of the CPU WatchDog module */
    endInitCpuPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[0]);

    /* Check if the address is located in PF0 */
    if ((address >= IFXFLASH_PFLASH_P0_START) && (address < IFXFLASH_PFLASH_P0_END))
    {
        /* Defined pointers now point to CPU0 FLASHCON1, FLASHCON2, PFI_ECCS and PFI_ECCR registers */
        CPU_FLASHCON1 = &CPU0_FLASHCON1;
        CPU_FLASHCON2 = &CPU0_FLASHCON2;
        PFI_ECCS = &PFI0_ECCS;
        PFI_ECCR = &PFI0_ECCR;
        *type = IfxFlash_FlashType_P0;
    }
    /* Check if the address is located in PF1 */
    else if ((address >= IFXFLASH_PFLASH_P1_START) && (address < IFXFLASH_PFLASH_P1_END))
    {
        /* Defined pointers now point to CPU0 FLASHCON1, FLASHCON2, PFI_ECCS and PFI_ECCR registers */
        CPU_FLASHCON1 = &CPU1_FLASHCON1;
        CPU_FLASHCON2 = &CPU1_FLASHCON2;
        PFI_ECCS = &PFI1_ECCS;
        PFI_ECCR = &PFI1_ECCR;
        *type = IfxFlash_FlashType_P1;
    }
    /* Address does not belong to any existing PFlash bank */
    else
    {
        result = INVALID_PFLASH_ADDRESS;
    }

    /* Check if the address is aligned to PFlash page */
    if ((address % IFXFLASH_PFLASH_PAGE_LENGTH) != 0U)
    {
        result = NOT_ALIGNED_PFLASH_ADDRESS;
    }

    /* Address belongs to a PFlash bank */
    if (result == NO_ERROR)
    {
        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

        /* Generation of a Trap for uncorrectable errors is disabled */
        CPU_FLASHCON1->B.MASKUECC = 1U;

        /* Clear ECC status register and the xBAB buffers */
        CPU_FLASHCON2->B.ECCSCLR = 1U;
        CPU_FLASHCON2->B.SBABCLR = 1U;
        CPU_FLASHCON2->B.DBABCLR = 1U;
        CPU_FLASHCON2->B.MBABCLR = 1U;
        CPU_FLASHCON2->B.ZBABCLR = 1U;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

        /* Read data from the address where to inject the ECC error */
        readData = *(uint32 *)address;

        /* NOP instruction to wait the generation of bus error Trap. If Trap will be generated, the execution of this API will not be completed */
        __nop();

        /* There is already an ECC error in the target PF page */
        if (PFI_ECCS->U != 0)
        {
            result = ERRORED_PFLASH_ADDRESS;
        }
        else
        {
            /* Read the RCODE of the target PF page */
            *rcode = PFI_ECCR->B.RCODE;
        }
        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

        /* Generation of a Trap for uncorrectable errors is re-enabled */
        CPU_FLASHCON1->B.MASKUECC = 2U;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);
    }
    return result;
}

/* This function is really injecting the desired ECC error in the PFlash target address */
static Flash_ResultType injectPFlash(uint32 eccErrors, uint32 address, uint32 rcode, IfxFlash_FlashType type)
{
    Flash_ResultType result = NO_ERROR;
    uint32 i, j, eccs;
    uint32 errorsNum=0;
    Ifx_PFI_ECCS expectedEccs;
    volatile uint32 wordArray[PF_PAGE_WORDS_NUM];
    volatile uint32 readData;
    uint16 endInitSafetyPassword;
    uint16 endInitCpuPassword;

    /* Get the current passwords of the CPU and Safety WatchDog modules */
    endInitSafetyPassword   = IfxScuWdt_getSafetyWatchdogPasswordInline();
    endInitCpuPassword      = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[0]);

    /* Read data from the address where to inject the ECC error */
    for(i=0; i<PF_PAGE_WORDS_NUM; i++)
    {
        wordArray[i] = *(uint32 *)(address + (i * WORD_BYTES_NUM));
    }

    /* Loop to inject the desired number of ECC errors. The loop is searching for "0" inside the target page, word by word (in total 8 words).
     * If not enough "0" are found in the page, the routine will search for remaining "0" in the RCODE.
     * If there are no enough "0" in the payload and in the RCODE (which is the ECC field), then error injection is not possible */
    for(j=0; j<PF_PAGE_WORDS_NUM && errorsNum<eccErrors; j++)
    {
        for(i=0; i<WORD_BITS_NUM && errorsNum<eccErrors; i++)
        {
            if(!(wordArray[j] & (1<<i)))
            {
                wordArray[j] |= 1<<i;
                errorsNum++;
            }
        }
    }
    for(i=0; i<ECC_BITS_NUM && errorsNum<eccErrors; i++)
    {
        if(!(rcode & (1<<i)))
        {
            rcode |= 1<<i;
            errorsNum++;
        }
    }

    /* It is not possible to inject the desired number of ECC errors */
    if (errorsNum < eccErrors)
    {
        result = ERROR_INJECTION_NOT_POSSIBLE;
    }
    else
    {
        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

        /* Disable ECC code automatic generation and set the WCODE field */
        MODULE_DMU.HF_ECCW.B.PECENCDIS = 3U;
        MODULE_DMU.HF_ECCW.B.WCODE = rcode;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

        /* Reset the command sequence interpreter to its initial state */
        IfxFlash_resetToRead(FLASH_MODULE);

        /* Clear operation and error flags */
        IfxFlash_clearStatus(FLASH_MODULE);

        /* Enter in Page Mode */
        IfxFlash_enterPageMode(address);

        /* Wait until Page Mode is entered */
        while (MODULE_DMU.HF_STATUS.B.PFPAGE == 0)
        {}

        /* Write PFlash page into the assembly buffer */
        IfxFlash_loadPage(address, wordArray[0], wordArray[1]);
        IfxFlash_loadPage(address, wordArray[2], wordArray[3]);
        IfxFlash_loadPage(address, wordArray[4], wordArray[5]);
        IfxFlash_loadPage(address, wordArray[6], wordArray[7]);

        /* Disable Safety Endinit protection */
        IfxScuWdt_clearSafetyEndinitInline(endInitSafetyPassword);

        /* Write the page */
        IfxFlash_writePage(address);

        /* Re-enable Safety Endinit protection */
        IfxScuWdt_setSafetyEndinitInline(endInitSafetyPassword);

        /* Wait until PROG bit is set */
        while (MODULE_DMU.HF_OPERATION.B.PROG == 0)
        {}

        /* Wait until the page is written in the Program Flash memory */
        IfxFlash_waitUnbusy(FLASH_MODULE, type);

        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

        /* Re-enable ECC code automatic generation and set the WCODE field to 0 */
        MODULE_DMU.HF_ECCW.B.PECENCDIS = 0U;
        MODULE_DMU.HF_ECCW.B.WCODE = 0U;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);
    }

    /* Disable CPU Endinit protection */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

    /* Clear ECC status registers of all PF banks */
    CPU0_FLASHCON2.B.ECCSCLR = 1U;
    CPU1_FLASHCON2.B.ECCSCLR = 1U;

    /* Re-enable CPU Endinit protection */
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

    /* Read data from the address where error is injected */
    readData = *(uint32 *)address;

    /* Save the ECCS of the PFlash bank where error is injected */
    switch (type)
    {
        case IfxFlash_FlashType_P0:
        {
            eccs = PFI0_ECCS.U;
            break;
        }
        case IfxFlash_FlashType_P1:
        {
            eccs = PFI1_ECCS.U;
            break;
        }
        default:
        {
            eccs = 0U;
            break;
        }
    }

    /* Depending on the type of ECC error, build the expected ECCS register */
    switch (eccErrors)
    {
        case ONE_BIT:
        {
            expectedEccs.B.ERR1 = 1;
            expectedEccs.B.ERRANY = 1;
            expectedEccs.B.AER1 = 1;
            expectedEccs.B.AERANY = 1;
            break;
        }
        case TWO_BITS:
        {
            expectedEccs.B.ERR2 = 1;
            expectedEccs.B.ERRANY = 1;
            expectedEccs.B.AER2 = 1;
            expectedEccs.B.AERANY = 1;
            break;
        }
        case THREE_BITS:
        {
            expectedEccs.B.ERRM = 1;
            expectedEccs.B.ERRANY = 1;
            expectedEccs.B.AERM = 1;
            expectedEccs.B.AERANY = 1;
            break;
        }
        default:
        {
            expectedEccs.U = 0xFFFFFFFF;
            break;
        }
    }

    /* Check that ECCS register is equal to the expected value */
    if (eccs != expectedEccs.U)
    {
        result = FAILED_PFLASH_ERROR_INJECTION;
    }

    return result;
}

/* Check if target address is a valid DFlash address. If so, RCODE of the target address is saved in rcode variable */
static Flash_ResultType checkDFlashAddress(uint32 address, uint32 *rcode)
{
    Flash_ResultType result = NO_ERROR;
    volatile uint32 readData;
    uint16 endInitCpuPassword;

    /* Get the current password of the CPU WatchDog module */
    endInitCpuPassword = IfxScuWdt_getCpuWatchdogPassword();

    /* Check if the address is located in DF0 */
    if ((address >= IFXFLASH_DFLASH_START) && (address < IFXFLASH_DFLASH_END))
    {
        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinit(endInitCpuPassword);

        /* Generation of a Trap for uncorrectable errors is disabled */
        MODULE_DMU.HF_ECCC.B.TRAPDIS = 3U;

        /* Clear ECC status register */
        MODULE_DMU.HF_ECCC.B.CLR = 3U;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinit(endInitCpuPassword);

        /* Read data from the address where to inject the ECC error */
        readData = *(uint32 *)address;

        /* NOP instruction to wait the generation of bus error Trap. If Trap will be generated, the execution of this API will not be completed */
        __nop();

        /* There is already an ECC error in the target DF page */
        if (MODULE_DMU.HF_ECCS.U != 0)
        {
            result = ERRORED_DFLASH_ADDRESS;
        }
        else
        {
            /* Read the RCODE of the target PF page */
            *rcode = MODULE_DMU.HF_ECCR.B.RCODE;
        }
        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinit(endInitCpuPassword);

        /* Generation of a Trap for uncorrectable errors is re-enabled */
        MODULE_DMU.HF_ECCC.B.TRAPDIS = 0U;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinit(endInitCpuPassword);
    }
    /* Address does not belong to any PFlash */
    else
    {
        result = INVALID_DFLASH_ADDRESS;
    }
    return result;
}

/* This function is really injecting the desired ECC error in the PFlash target address */
static Flash_ResultType injectDFlash(uint32 eccErrors, uint32 address, uint32 rcode)
{
    Flash_ResultType result = NO_ERROR;
    uint32 i, j, eccs;
    uint32 errorsNum=0;
    Ifx_DMU_HF_ECCS expectedEccs;
    volatile uint32 wordArray[DF_PAGE_WORDS_NUM];
    volatile uint32 readData;
    uint32 pageAddress;
    uint16 endInitCpuPassword;

    /* Get the current password of the CPU WatchDog module */
    endInitCpuPassword = IfxScuWdt_getCpuWatchdogPassword();

    /* Get the page address of the word where to inject the ECC error */
    pageAddress = (address / IFXFLASH_DFLASH_PAGE_LENGTH) * IFXFLASH_DFLASH_PAGE_LENGTH;

    /* Read data from the address where to inject the ECC error */
    for(i=0; i<DF_PAGE_WORDS_NUM; i++)
    {
        wordArray[i] = *(uint32 *)(pageAddress + (i * WORD_BYTES_NUM));
    }

    /* Loop to inject the desired number of ECC errors. The loop is searching for "0" inside the target page, word by word (in total 2 words).
     * If not enough "0" are found in the page, the routine will search for remaining "0" in the RCODE.
     * If there are no enough "0" in the payload and in the RCODE (which is the ECC field), then error injection is not possible */
    for(j=0; j<DF_PAGE_WORDS_NUM && errorsNum<eccErrors; j++)
    {
        for(i=0; i<WORD_BITS_NUM && errorsNum<eccErrors; i++)
        {
            if(!(wordArray[j] & (1<<i)))
            {
                wordArray[j] |= 1<<i;
                errorsNum++;
            }
        }
    }
    for(i=0; i<ECC_BITS_NUM && errorsNum<eccErrors; i++)
    {
        if(!(rcode & (1<<i)))
        {
            rcode |= 1<<i;
            errorsNum++;
        }
    }

    /* It is not possible to inject the desired number of ECC errors */
    if (errorsNum < eccErrors)
    {
        result = ERROR_INJECTION_NOT_POSSIBLE;
    }
    else
    {
        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinit(endInitCpuPassword);

        /* Disable ECC code automatic generation and set the WCODE field */
        MODULE_DMU.HF_ECCW.B.DECENCDIS = 3U;
        MODULE_DMU.HF_ECCW.B.WCODE = rcode;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinit(endInitCpuPassword);

        /* Reset the command sequence interpreter to its initial state */
        IfxFlash_resetToRead(FLASH_MODULE);

        /* Clear operation and error flags */
        IfxFlash_clearStatus(FLASH_MODULE);

        /* Enter in Page Mode */
        IfxFlash_enterPageMode(pageAddress);

        /* Wait until Page Mode is entered */
        while (MODULE_DMU.HF_STATUS.B.DFPAGE == 0)
        {}

        /* Write DFlash page into the assembly buffer */
        IfxFlash_loadPage(pageAddress, wordArray[0], wordArray[1]);

        /* Write the page */
        IfxFlash_writePage(pageAddress);

        /* Wait until PROG bit is set */
        while (MODULE_DMU.HF_OPERATION.B.PROG == 0)
        {}

        /* Wait until the page is written in the Program Flash memory */
        IfxFlash_waitUnbusy(FLASH_MODULE, DATA_FLASH_0);

        /* Disable CPU Endinit protection */
        IfxScuWdt_clearCpuEndinit(endInitCpuPassword);

        /* Re-enable ECC code automatic generation and set the WCODE field to 0 */
        MODULE_DMU.HF_ECCW.B.DECENCDIS = 0U;
        MODULE_DMU.HF_ECCW.B.WCODE = 0U;

        /* Re-enable CPU Endinit protection */
        IfxScuWdt_setCpuEndinit(endInitCpuPassword);
    }

    /* Disable CPU Endinit protection */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

    /* Clear ECC status register of DFlash */
    MODULE_DMU.HF_ECCC.B.CLR = 3U;

    /* Re-enable CPU Endinit protection */
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[0], endInitCpuPassword);

    /* Read data from the address where error is injected */
    readData = *(uint32 *)address;

    /* Save DFlash ECCS register */
    eccs = MODULE_DMU.HF_ECCS.U;

    /* Depending on the type of ECC error, build the expected ECCS register */
    switch (eccErrors)
    {
        case ONE_BIT:
        {
            expectedEccs.B.ERR1 = 1;
            expectedEccs.B.ERRANY = 1;
            expectedEccs.B.AER1 = 1;
            expectedEccs.B.AERANY = 1;
            break;
        }
        case TWO_BITS:
        {
            expectedEccs.B.ERR2 = 1;
            expectedEccs.B.ERRANY = 1;
            expectedEccs.B.AER2 = 1;
            expectedEccs.B.AERANY = 1;
            break;
        }
        case THREE_BITS:
        {
            expectedEccs.B.ERR3 = 1;
            expectedEccs.B.ERRANY = 1;
            expectedEccs.B.AER3 = 1;
            expectedEccs.B.AERANY = 1;
            break;
        }
        case FOUR_BITS:
        {
            expectedEccs.B.ERRM = 1;
            expectedEccs.B.ERRANY = 1;
            expectedEccs.B.AERM = 1;
            expectedEccs.B.AERANY = 1;
            break;
        }
        default:
        {
            expectedEccs.U = 0xFFFFFFFF;
            break;
        }
    }

    /* Check that ECCS register is equal to the expected value */
    if (eccs != expectedEccs.U)
    {
        result = FAILED_DFLASH_ERROR_INJECTION;
    }

    return result;
}

/* Inject the desired ECC error in the target address of the PFlash or DFlash0. Address must be a valid 32-bits aligned word.
 * In case of a PFlash address, it must be part of the Segment 10, that is non-cached area  */
Flash_ResultType injectFlashECCError(Flash_ECCErrorType error_type, uint32 address)
{
    Flash_ResultType result = NO_ERROR;
    uint32 rcode;
    IfxFlash_FlashType type;

    /* Check if the desired error type is valid */
    switch (error_type)
    {
        /* Selected error type is the PFlash Single Bit error */
        case PFLASH_SINGLE_BIT_ERROR:
        {
            /* Check if address is valid, take the RCODE of the target PFlash page and the PFlash type */
            result = checkPFlashAddress(address, &rcode, &type);

            if (result == NO_ERROR)
            {
                /* Inject a Single Bit ECC error in the target address of the PFlash */
                result = injectPFlash(ONE_BIT, address, rcode, type);
            }
            break;
        }
        /* Selected error type is the PFlash Double Bit error */
        case PFLASH_DOUBLE_BIT_ERROR:
        {
            /* Check if address is valid, take the RCODE of the target PFlash page and the PFlash type */
            result = checkPFlashAddress(address, &rcode, &type);

            if (result == NO_ERROR)
            {
                /* Inject a Double Bit ECC error in the target address of the PFlash */
                result = injectPFlash(TWO_BITS, address, rcode, type);
            }
            break;
        }
        /* Selected error type is the PFlash Multiple Bit error */
        case PFLASH_MULTIPLE_BIT_ERROR:
        {
            /* Check if address is valid, take the RCODE of the target PFlash page and the PFlash type */
            result = checkPFlashAddress(address, &rcode, &type);

            if (result == NO_ERROR)
            {
                /* Inject a Multiple Bit ECC error in the target address of the PFlash */
                result = injectPFlash(THREE_BITS, address, rcode, type);
            }
            break;
        }
        /* Selected error type is the DFlash Single Bit error */
        case DFLASH_SINGLE_BIT_ERROR:
        {
            /* Check if address is valid and take the RCODE of the target DF page */
            result = checkDFlashAddress(address, &rcode);

            if (result == NO_ERROR)
            {
                /* Inject a Single Bit ECC error in the target address of the DFlash */
                result = injectDFlash(ONE_BIT, address, rcode);
            }
            break;
        }
        /* Selected error type is the DFlash Double Bit error */
        case DFLASH_DOUBLE_BIT_ERROR:
        {
            /* Check if address is valid and take the RCODE of the target DF page */
            result = checkDFlashAddress(address, &rcode);

            if (result == NO_ERROR)
            {
                /* Inject a Double Bit ECC error in the target address of the DFlash */
                result = injectDFlash(TWO_BITS, address, rcode);
            }
            break;
        }
        /* Selected error type is the DFlash Triple Bit error */
        case DFLASH_TRIPLE_BIT_ERROR:
        {
            /* Check if address is valid and take the RCODE of the target DF page */
            result = checkDFlashAddress(address, &rcode);

            if (result == NO_ERROR)
            {
                /* Inject a Triple Bit ECC error in the target address of the DFlash */
                result = injectDFlash(THREE_BITS, address, rcode);
            }
            break;
        }
        /* Selected error type is the DFlash Multiple Bit error */
        case DFLASH_MULTIPLE_BIT_ERROR:
        {
            /* Check if address is valid and take the RCODE of the target DF page */
            result = checkDFlashAddress(address, &rcode);

            if (result == NO_ERROR)
            {
                /* Inject a Multiple Bit ECC error in the target address of the DFlash */
                result = injectDFlash(FOUR_BITS, address, rcode);
            }
            break;
        }
        /* Selected error type is not valid */
        default:
        {
            result = INVALID_ECC_ERROR_TYPE;
            break;
        }
    }
    return result;
}

/* This function initializes the port pin which drives the LED */
void initLEDs(void)
{
    /* Initialization of the LED used in this example */
    IfxPort_setPinModeOutput(LED_OK, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LED_ERROR, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Switch OFF the LED (low-level active) */
    IfxPort_setPinHigh(LED_OK);
    IfxPort_setPinHigh(LED_ERROR);
}


/* This function toggles the port pin and wait 500 milliseconds */
void blinkLED(Flash_ResultType error_type)
{
    switch (error_type)
    {
        /* Blink the LED1 */
        case NO_ERROR:
        {
            IfxPort_togglePin(LED_OK);
            waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));
            break;
        }
        /* Blink the LED2 */
        default:
        {
            IfxPort_togglePin(LED_ERROR);
            waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));
            break;
        }
    }
}

/* Hook for the Bus Error Trap Service Routine */
void busErrorTSRHook(IfxCpu_Trap trapWatch)
{
    /* Switch on the LED2 */
    IfxPort_setPinLow(LED_ERROR);

    while (1)
    {}
}
#pragma section code restore
