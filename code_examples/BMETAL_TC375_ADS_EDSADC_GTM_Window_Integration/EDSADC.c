/**********************************************************************************************************************
 * \file EDSADC.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxEdsadc_reg.h"
#include "IfxConverter_reg.h"

#include "Ifx_Types.h"
#include "IfxEdsadc_Edsadc.h"

#include "EDSADC.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ANALOG_FULL_SCALE   3.3                     /* Analog full-scale voltage    (V_IN = V_AREF = 3.3V)          */
#define RAW_FULL_SCALE      25000.0                 /* EDSADC full-scale value (AFS), representing the analog       */

#define DECIMATION_FACTOR   8                       /* Configure the CIC decimation factor (N)                      */
#define START_DEC_VALUE     8                       /* Configure start value of the decimation counter              */
#define CIC_SHIFT           9                       /* CIC shift calculated using the selected decimation factor    */
#define GAIN_FACTOR         4499                    /* Gain factor calculated using the CIC shift                   */


#define CAL_DECIMATION_FACTOR   6                   /* Configure the CIC decimation factor (N) for calibration      */
#define CAL_CIC_SHIFT           27                  /* CIC shift for the selected calibration decimation factor     */
#define CAL_GAIN_FACTOR         4499                /* Gain factor calculated using the CIC shift                   */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* Variables to store the result */
volatile sint16 g_resultEDSADC = 0;                          /* Variable to store the EDSADC raw value                       */
volatile float32 g_resultVoltage = 0.0;                      /* Variable to store the calculated voltage value               */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/* the following functions are implemented to maximize readability rather than performance */
static void init_CONVCTRL( void );

static boolean calib_EDSADC_chan0( void );

IFX_INTERRUPT(dsadc_ch0_isr, 0, 0x01 );

void enable_EDSADC_chan0( void );

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* This function initializes Convert Control module:
 * - Enable the CONVCTRL module
 * - Set up 40MHz clock
 */
static void init_CONVCTRL( )
{
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword ());
    CONVCTRL_CLC.U = 0x00000000;        /* Enable module CONVCTRL */
    IfxScuWdt_setCpuEndinit (IfxScuWdt_getCpuWatchdogPassword ());

    while(CONVCTRL_CLC.B.DISS == 0x1)   /* Wait until module clock is enabled   */
    {;}

    CONVCTRL_CCCTRL.U = 0xB0000000;     /* Unlock converter control registers   */
    CONVCTRL_PHSCFG.U = 0x00008003;     /* fADC=160MHz, fPHSYNC=160MHz/4=40MHz  */
    CONVCTRL_CCCTRL.U = 0x00000000;     /* Lock converter control registers     */
}

/* This function initializes the EDSADC Channel 0:
 * - Enable module
 * - Set up modulator clock to 40MHz
 * - Set up CIC decimation to 8
 * - Set up FIR1 decimation to 2
 * - Enable Integration of 32 values
 * - Configure Integrator Window Control for the rising edge of the external trigger
 * - Run modulator and demodulator
 * - Request Calibration
 */
void enable_EDSADC_chan0( void )
{
    /* Enable CONVCTRL */
    init_CONVCTRL();

    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    MODULE_EDSADC.CLC.B.DISR = 0;           /* Enable the EDASDC module clock */
    while(MODULE_EDSADC.CLC.B.DISS == 0x1)  /* Wait until module is active */
    {;}

    /* Reset module by writing reset request to both EDSADC_KRST0 and EDSADC_KRST1 */
    EDSADC_KRST0.U = 1;             /* A kernel reset request 0 */
    EDSADC_KRST1.U = 1;             /* A kernel reset request 1 */
    while (EDSADC_KRST0.U != 0x2)   /* Wait until a kernel reset complete */
    {;}

    EDSADC_KRSTCLR.U = 1; /* Clear Kernel Reset Status KRST0.RSTSTAT */

    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* GLOBCFG - Global Configuration Register
     * Configure Minimum dithering intensity, Unsynchronized clock mode, 3.3V reference
     * DITRIM [8:10]   = 0x0 --> Minimum dithering intensity
     * USC[12]         = 0x1 --> Unsynchronized mode modulator
     * SUPLEV[13:14]   = 0x2 --> Supply Voltage Level 3.3 V
     * Write Control[15]
     * */
    MODULE_EDSADC.GLOBCFG.U = ( 0x1 << 12 ) | ( 0x2 << 13 ) | ( 0x1 << 15 );

    /* MODCFG Modulator Configuration Register
     * Configure on-chip modulator, single-ended mode, 40Mhz fmod clock, dithering
     * INCFGP[0:1]  - 0x0 --> Positive Input Line - Input pin
     * INCFGN[2:3]  = 0x3 --> Single ended mode, INCFGN to Vagnd
     * GAINSEL[4:7] - 0x0 --> Gain factor 1
     * INSEL[8:9]   - 0x0 --> Input pin position A
     * INMODE[12:13]- 0x0 --> Software control
     * INMAC[14]    - 0x0 --> Preset mode
     * DIVM[16:18]  - 0x0 --> Modulator Clock fMOD = 40MHz; fMOD = fADC / (4 + DIVM × 2)
     * ACSD[20:22]  - 0x0 --> Analog Clock Synchronization Delay = 0
     * DITHEN[26]   = 0x1 --> Dithering is enabled
     * IREN[27]     - 0x0 --> No integrator reset
     * APC[28:29]   - 0x0 --> Automatic Power Control = Always run
     * Write Control[15, 31]
     * */
    MODULE_EDSADC.CH[0].MODCFG.U = ( 0x3 << 2 ) | ( 0x1 << 26) | (0x1 << 15) | (0x1 << 31);

    /* IWCTR - Integration Window Control Register
     * Configure Integrator Shift value, Integration Window control
     * ISC[0:2]         = 0x5   --> Integrator Shift Control, Select bits 9 … 25 (integration of 33 … 64 values)
     * IWS[4]           = 0x1   --> External control: stop the integrator upon the inverse trigger event
     * FRC[5]           = 0x1   --> No filter chain restart upon the integrator  trigger
     * REPVAL[8:11]     = 0x1   --> Number of Integration Cycles
     * NVALINT[24:29]   = 0x3B  --> Number of Values to be Accumulated
     * */
#if defined( TRIG_CASE_3 )
    MODULE_EDSADC.CH[0].IWCTR.U = ( 0x0 << 4 ) | ( 0x1 << 5 ) | ( 0x0F << 8 ) | (0x3B << 24);
#else
    MODULE_EDSADC.CH[0].IWCTR.U = ( 0x5 ) | ( 0x1 << 4 ) | ( 0x1 << 5 ) | ( 0x0 << 8 ) | (0x3B << 24);
#endif

    /* FCFGM - Filter Configuration Register
     * FIR0EN[0]    - 0x1 --> FIR0 enabled
     * FIR1EN[1]    - 0x0 --> FIR1 disabled
     * OVCEN[2]     - 0x0 --> Overshoot Compensation disabled
     * FIR1DEC[3]   - 0x0 --> Decimation 2:1 for FIR1
     * CICMOD[4]    - 0x0 --> CIC3 mode
     * PFEN[5]      - 0x0 --> Prefilter disabled
     * OCEN[8:10]   - 0x0 --> Offset compensation filter disabled
     * OFFPROT[11]  - 0x0 --> Offset Protection disabled
     * SRGM[16:17]  - 0x01 --> Service Request Generation when gate (selected trigger signal) is high
     * SRGA[20:21]  - 0x00 --> Alternate Service Request disabled
     * ESEL[22:23]  - 0x02 --> Comparator event if result is outside the boundary band
     * EGT[24]      - 0x0 -->  Generate events according to ESEL
     * CALIB[28]    - 0x0 --> Calibration Trigger disabled
     * AUTOCAL[29]  - 0x0 --> Automatic Calibration disabled
     * Write Control[15, 31]
     * */
    MODULE_EDSADC.CH[0].FCFGM.U = ( 1 ) | ( 0x1 << 16 ) | ( 0x2 << 22 ) | ( 1 << 15 ) |( 1 << 31 );

    /* DICFG - Demodulator Input Configuration
     * DSS[0:2]         - 0x00 --> Data Stream Select - On-chip modulator
     * DSRCEX[4:6]      - 0x00 --> Data Source for External Modulator
     * CSRCEX[8:10]     - 0x00 --> Clock Source for External Modulator
     * CSRCEX[8:10]     - 0x00 --> Clock Source for External Modulator
     * TRSEL[16:19]     - 0x00 --> Trigger Select - default
     * ITRMODE[20:21]   - 0x02 --> Trigger-Controlled Mode - Trigger event upon a rising edge
     * TSTRMODE[22:23]  - 0x00 --> Timestamp Trigger disabled
     * DRM[26:27]       - 0x00 --> Data Read Mode - Single: Issue one 16-bit value per read access
     * TSM[28]          - 0x0  --> Timestamp disabled
     * RDM[29]          - 0x0  --> Result as Signed integer
     * Write Control[15, 31] - 0x1
     * */
    MODULE_EDSADC.CH[0].DICFG.U =  ( 0x0 << 16) | ( 0x02 << 20) | ( 1 << 15 ) |( 1 << 31 );

    /* DICFG - CIC Filter Configuration Register
     * CFMDF[0:8]    - DECIMATION_FACTOR --> CIC Filter Decimation Factor (OSR) = CFMDF + 1
     * CFMSV[16:24]  - 0x00 --> CIC Filter Start Value
     * */
    //MODULE_EDSADC.CH[0].FCFGC.U = 0x00070007;
    MODULE_EDSADC.CH[0].FCFGC.B.CFMDF = DECIMATION_FACTOR - 1;
    MODULE_EDSADC.CH[0].FCFGC.B.CFMSV = START_DEC_VALUE - 1;

    /* GAINCORR - Gain Correction Register
    * GAINFACTOR[0:12] - GAINFACTOR --> Multiplication Factor for Gain Correction
    * CICSHIFT[16:20]  - CICSHIFT   --> Position of the CIC Filter Output Shifter
    * */
    MODULE_EDSADC.CH[0].GAINCORR.B.CICSHIFT = CIC_SHIFT;
    MODULE_EDSADC.CH[0].GAINCORR.B.GAINFACTOR = GAIN_FACTOR;

    /* Enable Channel0 Modulator and Demodulator */
    MODULE_EDSADC.GLOBRC.B.CH0RUN = 1;
    MODULE_EDSADC.GLOBRC.B.M0RUN = 1;

    /* Wait at least 20us until modulator is running */
    for(int i=0; i < 60000; i++)
    {;}

    /* EDSADC is running and constantly converting analog input signal */

    /* Request calibration on EDSADC channel_0 */
    calib_EDSADC_chan0();

    /* Initialize CPU0 interrupt with priority 0x01 */
    IfxSrc_init( &SRC_DSADC_DSADC0_SRM, IfxSrc_Tos_cpu0, 0x01 );
    IfxSrc_enable( &SRC_DSADC_DSADC0_SRM );

}
/* This function performs calibration of the EDSADC channel_0*/
static boolean calib_EDSADC_chan0( void )
{
    /* Check if modulator and demodulator are running */
    if( ( MODULE_EDSADC.GLOBRC.B.CH0RUN != 1 ) || ( MODULE_EDSADC.GLOBRC.B.M0RUN != 1 ) )
    {
       /* Calibration can not be performed */
       return FALSE;
    }

    /* Set Target Value for Calibrated Fullscale */
    MODULE_EDSADC.CH[0].GAINCAL.B.CALTARGET = RAW_FULL_SCALE;
    /* Reset  Multiplication Factor for Gain Calibration */
    MODULE_EDSADC.CH[0].GAINCAL.B.CALFACTOR = 0;

    /* Reset Offset compensation value */
    MODULE_EDSADC.CH[0].OFFCOMP.B.OFFSET = 0;

    /* Set Decimation Rate of the CIC Filter During, Factor = 2 ^ (CICDEC + 3) */
    MODULE_EDSADC.CH[0].GAINCTR.B.CICDEC        = CAL_DECIMATION_FACTOR;
    /* Set Position of the CIC Filter Output Shifter During Calibration */
    MODULE_EDSADC.CH[0].GAINCTR.B.CICSHIFT      = CAL_CIC_SHIFT;
    /* Set Multiplication Factor for Gain Correction During Calibration */
    MODULE_EDSADC.CH[0].GAINCTR.B.GAINFACTOR    = CAL_GAIN_FACTOR;

    /* Request Calibration
     * CALIB[28]            - 0x1 --> Calibration Trigger enable
     * Write Control[31]    - 0x1
     *  */
    MODULE_EDSADC.CH[0].FCFGM.U |= ( 0x1 << 28 ) | ( 1 << 31 );

    /* Wait until calibration is complete */
    while( MODULE_EDSADC.CH[0].FCNTC.B.CAL != 0x2 )
    {;}

    /* Calibration completed successfully */
    return TRUE;
}
/* This function implements EDSADC main service request handler:
 * - Read raw result
 * - Convert raw result into voltage value
 */
IFX_INTERRUPT(dsadc_ch0_isr, 0, 0x01 )
{
    g_resultEDSADC = MODULE_EDSADC.CH[0].RESM.B.RESULTLO;

    g_resultVoltage = ( g_resultEDSADC * ANALOG_FULL_SCALE) / RAW_FULL_SCALE;   /* Calculate the corresponding voltage  */

    IfxPort_togglePin( &MODULE_P00, 2 );
}
