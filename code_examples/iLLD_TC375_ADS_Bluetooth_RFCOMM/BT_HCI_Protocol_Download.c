/**********************************************************************************************************************
 * \file BT_HCI_Protocol_Download.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Includes-----------------------------------------------------*/
/*********************************************************************************************************************/
#include "BT_HCI_Protocol_Download.h"
#include "BT_Minidriver_Binary.h"
#include "BT_RFCOMM_Binary.h"
#include "Ifx_Types.h"
#include "IfxAsclin_Asc.h"
#include "Ifx_Shell.h"
#include "Ifx_Console.h"
#include "IfxPort.h"
#include "Bsp.h"

/*********************************************************************************************************************/
/*-----------------------------------------------------Macros--------------------------------------------------------*/
/*********************************************************************************************************************/
/* Communication parameters */
#define ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_TX      9                           /* Priority for interrupt ISR Transmit  */
#define ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_RX      5                           /* Priority for interrupt ISR Receive   */
#define ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_ER      13                          /* Priority for interrupt ISR Errors    */
#define ASC_TX_HCI_FIFO_SIZE                     256                         /* Define the TX FIFO size in byte      */
#define ASC_RX_HCI_FIFO_SIZE                     256                         /* Define the RX FIFO size in byte      */
#define ASC_RX_BUFFER_SIZE                       256                         /* Define the RX buffer size in byte    */

/* Port definitions */
#define ASC_HCI_PROTOCOL_CTS_PORT                &MODULE_P21, 5
#define ASC_HCI_PROTOCOL_RTS_PORT                &MODULE_P21, 3
#define ASC_HCI_PROTOCOL_RX_PORT                 &IfxAsclin5_RXC_P22_3_IN
#define ASC_HCI_PROTOCOL_TX_PORT                 &IfxAsclin5_TX_P22_2_OUT

/* HCI commands header byte offsets */
#define CMD_TRANSFER_SIZE_OFFSET        3

#define CMD_ADDRESS_LBYTE_LWORD_OFFSET  4
#define CMD_ADDRESS_HBYTE_LWORD_OFFSET  5
#define CMD_ADDRESS_LBYTE_HWORD_OFFSET  6
#define CMD_ADDRESS_HBYTE_HWORD_OFFSET  7

#define CMD_BAUDRATE_LBYTE_LWORD_OFFSET 6
#define CMD_BAUDRATE_HBYTE_LWORD_OFFSET 7
#define CMD_BAUDRATE_LBYTE_HWORD_OFFSET 8
#define CMD_BAUDRATE_HBYTE_HWORD_OFFSET 9

#define CMD_SIZE_LBYTE_LWORD_OFFSET     8
#define CMD_SIZE_HBYTE_LWORD_OFFSET     9
#define CMD_SIZE_LBYTE_HWORD_OFFSET     10
#define CMD_SIZE_HBYTE_HWORD_OFFSET     11

#define CMD_HEADER_SIZE                 4

/* HCI responses header byte offsets */
#define RSP_CRC_LBYTE_LWORD_OFFSET      7
#define RSP_CRC_HBYTE_LWORD_OFFSET      8
#define RSP_CRC_LBYTE_HWORD_OFFSET      9
#define RSP_CRC_HBYTE_HWORD_OFFSET      10

/* Download binaries header offsets */
#define BINARY_PAYLOAD_SIZE_OFFSET      0

#define BINARY_PAYLOAD_ADDRESS_HBYTE_HWORD_OFFSET 1
#define BINARY_PAYLOAD_ADDRESS_LBYTE_HWORD_OFFSET 2
#define BINARY_PAYLOAD_ADDRESS_HBYTE_LWORD_OFFSET 3
#define BINARY_PAYLOAD_ADDRESS_LBYTE_LWORD_OFFSET 4

#define BINARY_PAYLOAD_DATA_OFFSET 5

/* Binary operations */
#define BIT_SHIFT_0_BYTE           0
#define BIT_SHIFT_1_BYTE           8
#define BIT_SHIFT_2_BYTE           16
#define BIT_SHIFT_3_BYTE           24
#define BIT_BYTE_MASK              0xff

/* Definition for milliseconds within a second */
#define MS_PER_SECOND              1000

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/**
 * @calulate_SysTicks
 * Calculate amount of systicks for a specific amount of time in milliseconds
 *
 * */
Ifx_TickTime calulate_SysTicks(uint32 time_ms);

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxStdIf_DPipe  g_asclinPipeHCIProtocol;                                    /* Standard interface object    */
IfxAsclin_Asc   g_asclinModuleHCIProtocolInterface;                         /* ASCLIN module object         */

/* The transfer buffers allocate memory for the data itself and for FIFO runtime variables.
 * 8 more bytes have to be added to ensure a proper circular buffer handling independent from
 * the address to which the buffers have been located.
 */
uint8 g_uartTxHCIFifo[ASC_TX_HCI_FIFO_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 g_uartRxHCIFifo[ASC_RX_HCI_FIFO_SIZE + sizeof(Ifx_Fifo) + 8];

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro makes following definitions:
 * 1) Define linker section as .intvec_tc<vector number>_<interrupt priority>.
 * 2) define compiler specific attribute for the interrupt functions.
 * 3) define the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */
IFX_INTERRUPT(asc5_tx_ISR, 0, ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_TX);
void asc5_tx_ISR(void)
{
    IfxStdIf_DPipe_onTransmit(&g_asclinPipeHCIProtocol);
}

IFX_INTERRUPT(asc5_rx_ISR, 0, ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_RX);

void asc5_rx_ISR(void)
{
    IfxStdIf_DPipe_onReceive(&g_asclinPipeHCIProtocol);
}

IFX_INTERRUPT(asc5_err_ISR, 0, ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_ER);
void asc5_err_ISR(void)
{
    IfxStdIf_DPipe_onError(&g_asclinPipeHCIProtocol);
}

void init_hci_protocol_UART(void)
{
    IfxAsclin_Asc_Config ascConf;

    /* Initialize the config structure with default values */
    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN5);

    /* Set the desired baud rate and over sampling factor */
    ascConf.baudrate.baudrate = ASC_HCI_PROTOCOL_BAUDRATE;
    ascConf.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;

    /* Set the desired baud rate and over sampling factor */
    ascConf.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;
    ascConf.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;

    /* Pin configuration */
    IfxAsclin_Asc_Pins pins = {
            .cts        = NULL_PTR,
            .ctsMode    = IfxPort_InputMode_pullUp,
            .rx         = ASC_HCI_PROTOCOL_RX_PORT,
            .rxMode     = IfxPort_Mode_inputNoPullDevice,
            .rts        = NULL_PTR,
            .rtsMode    = IfxPort_OutputMode_pushPull,
            .tx         = ASC_HCI_PROTOCOL_TX_PORT,
            .txMode     = IfxPort_OutputMode_pushPull,
            .pinDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;

    /* FIFO buffers configuration */
    /* Set the transmission buffer pointer and size */
    ascConf.txBuffer = g_uartTxHCIFifo;
    ascConf.txBufferSize = ASC_TX_HCI_FIFO_SIZE;
    /* Set the receive buffer pointer and size */
    ascConf.rxBuffer = g_uartRxHCIFifo;
    ascConf.rxBufferSize = ASC_RX_HCI_FIFO_SIZE;

    /* ISR priorities and interrupt target */
    ascConf.interrupt.txPriority = ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_TX;  /* Set the interrupt priority for TX event  */
    ascConf.interrupt.rxPriority = ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_RX;  /* Set the interrupt priority for RX event  */
    ascConf.interrupt.erPriority = ISR_PRIORITY_ASCLIN_HCI_PROTOCOL_ER;  /* Set the interrupt priority for Err event */
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    /* Initialize ASCLIN module with the given configuration */
    IfxAsclin_Asc_initModule(&g_asclinModuleHCIProtocolInterface, &ascConf);

    /* Initialize the Standard Interface pipe*/
    IfxAsclin_Asc_stdIfDPipeInit(&g_asclinPipeHCIProtocol, &g_asclinModuleHCIProtocolInterface);

    /* Set RTS pin high, before enabling RTS pin as output. */
    IfxPort_setPinHigh(ASC_HCI_PROTOCOL_RTS_PORT);
    /* Enable RTS pin as output. Use software RTS implementation */
    IfxPort_setPinModeOutput(ASC_HCI_PROTOCOL_RTS_PORT, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Enable CTS pin as input */
    IfxPort_setPinModeInput(ASC_HCI_PROTOCOL_CTS_PORT, IfxPort_InputMode_pullUp);

    /* Wait for reset cycle of CYW20819 */
    while(IfxPort_getPinState(ASC_HCI_PROTOCOL_CTS_PORT) == TRUE){};
    while(IfxPort_getPinState(ASC_HCI_PROTOCOL_CTS_PORT) == FALSE){};

}

Ifx_TickTime calulate_SysTicks(uint32 time_ms)
{
    sint32 Fsys = IfxStm_getFrequency(&MODULE_STM0);
    return (Fsys / (MS_PER_SECOND / time_ms));
}

void send_command_generic(const uint8 data[], Ifx_SizeT noOfBytes)
{
    /* Disable remote side TX, before sending request.
     * Needs to be enabled again once response is expected.
     */
    IfxPort_setPinHigh(ASC_HCI_PROTOCOL_RTS_PORT);

    /* Send data of the generic command */
    IfxStdIf_DPipe_write(&g_asclinPipeHCIProtocol, (void*)data, &noOfBytes, TIME_INFINITE);

    /* Wait until all data is sent by flushing pipe */
    IfxStdIf_DPipe_flushTx(&g_asclinPipeHCIProtocol, TIME_INFINITE);
}

void send_request_reset_hci(void)
{
    /* Bit pattern of command: reset HCI */
    const uint8 cmdResetHCI[] = {0x01, 0x03, 0x0c, 0x00};
    /* Size of command */
    Ifx_SizeT cmdLength = sizeof cmdResetHCI;

    /* Send command */
    send_command_generic(cmdResetHCI, cmdLength);
}

void send_command_download_minidriver(void)
{
    /* Bit pattern of command: download minidriver */
    const uint8 cmdDownloadMinidriverHCI[] = {0x01, 0x2e, 0xfc, 0x00};
    /* Size of command */
    Ifx_SizeT cmdLength = sizeof cmdDownloadMinidriverHCI;

    /* Send command */
    send_command_generic(cmdDownloadMinidriverHCI, cmdLength);
}

void send_command_launch_ram(uint32 launchAddress)
{
    /* Bit pattern of command: launch */
    uint8 cmdlaunchHCI[] = {0x01, 0x4e, 0xfc, 0x04, 0x00, 0x00, 0x00, 0x00};
    /* Size of command */
    Ifx_SizeT cmdLength = sizeof cmdlaunchHCI;

    cmdlaunchHCI[CMD_ADDRESS_LBYTE_LWORD_OFFSET] = (launchAddress >> BIT_SHIFT_0_BYTE) & 0xff;
    cmdlaunchHCI[CMD_ADDRESS_HBYTE_LWORD_OFFSET] = (launchAddress >> BIT_SHIFT_1_BYTE) & 0xff;
    cmdlaunchHCI[CMD_ADDRESS_LBYTE_HWORD_OFFSET] = (launchAddress >> BIT_SHIFT_2_BYTE) & 0xff;
    cmdlaunchHCI[CMD_ADDRESS_HBYTE_HWORD_OFFSET] = (launchAddress >> BIT_SHIFT_3_BYTE) & 0xff;

    /* Send command */
    send_command_generic(cmdlaunchHCI, cmdLength);
}

void send_command_update_baudrate(uint32 baudrate)
{
    /* Bit pattern of command: update baud rate */
    uint8 cmdBaudrateUpdateHCI[] = {0x01, 0x18, 0xfc, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    /* Size of command */
    Ifx_SizeT cmdLength = sizeof cmdBaudrateUpdateHCI;

    /* Patch baudrate into the command's header */
    cmdBaudrateUpdateHCI[CMD_BAUDRATE_LBYTE_LWORD_OFFSET] = (baudrate >> BIT_SHIFT_0_BYTE) & 0xff;
    cmdBaudrateUpdateHCI[CMD_BAUDRATE_HBYTE_LWORD_OFFSET] = (baudrate >> BIT_SHIFT_1_BYTE) & 0xff;
    cmdBaudrateUpdateHCI[CMD_BAUDRATE_LBYTE_HWORD_OFFSET] = (baudrate >> BIT_SHIFT_2_BYTE) & 0xff;
    cmdBaudrateUpdateHCI[CMD_BAUDRATE_HBYTE_HWORD_OFFSET] = (baudrate >> BIT_SHIFT_3_BYTE) & 0xff;

    /* Send command */
    send_command_generic(cmdBaudrateUpdateHCI, cmdLength);
}

void send_command_chip_erase(void)
{
    /* Bit pattern of command: chip erase */
    const uint8 cmdchipEraseHCI[] = {0x01, 0xce, 0xff, 0x04, 0xef, 0xee, 0xbe, 0xfc};
    /* Size of command */
    Ifx_SizeT cmdLength = sizeof cmdchipEraseHCI;

    /* Send command */
    send_command_generic(cmdchipEraseHCI, cmdLength);
}

void send_command_write_ram(Ifx_SizeT payloadSize, uint32 destinationAddress, const uint8 payloadData[])
{
    /* Bit pattern of command: write */
    uint8 cmdWriteHCI[] = {0x01, 0x4c, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00};
    /* Size of command */
    Ifx_SizeT cmdLength = sizeof cmdWriteHCI;

    /* Patch address and size into the command's header */
    cmdWriteHCI[CMD_TRANSFER_SIZE_OFFSET] = payloadSize + CMD_HEADER_SIZE;
    cmdWriteHCI[CMD_ADDRESS_LBYTE_LWORD_OFFSET] = (destinationAddress >> BIT_SHIFT_0_BYTE) & BIT_BYTE_MASK;
    cmdWriteHCI[CMD_ADDRESS_HBYTE_LWORD_OFFSET] = (destinationAddress >> BIT_SHIFT_1_BYTE) & BIT_BYTE_MASK;
    cmdWriteHCI[CMD_ADDRESS_LBYTE_HWORD_OFFSET] = (destinationAddress >> BIT_SHIFT_2_BYTE) & BIT_BYTE_MASK;
    cmdWriteHCI[CMD_ADDRESS_HBYTE_HWORD_OFFSET] = (destinationAddress >> BIT_SHIFT_3_BYTE) & BIT_BYTE_MASK;

    /* Send write command header... */
    send_command_generic(cmdWriteHCI, cmdLength);

    /* ... followed by the payload data */
    send_command_generic(payloadData, payloadSize);
}

void send_command_verify_crc(uint32 startAddress, uint32 size)
{
    /* Bit pattern of command: verifyCRC */
    uint8 cmdVerifyCRCHCI[] = {0x01, 0xCC, 0xFC, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    /* Size of command */
    Ifx_SizeT cmdLength = sizeof cmdVerifyCRCHCI;

    /* Patch address and size of flash range which is CRC checked into the command's header */
    cmdVerifyCRCHCI[CMD_ADDRESS_LBYTE_LWORD_OFFSET]  = (startAddress >> BIT_SHIFT_0_BYTE) & BIT_BYTE_MASK;
    cmdVerifyCRCHCI[CMD_ADDRESS_HBYTE_LWORD_OFFSET]  = (startAddress >> BIT_SHIFT_1_BYTE) & BIT_BYTE_MASK;
    cmdVerifyCRCHCI[CMD_ADDRESS_LBYTE_HWORD_OFFSET]  = (startAddress >> BIT_SHIFT_2_BYTE) & BIT_BYTE_MASK;
    cmdVerifyCRCHCI[CMD_ADDRESS_HBYTE_HWORD_OFFSET]  = (startAddress >> BIT_SHIFT_3_BYTE) & BIT_BYTE_MASK;

    cmdVerifyCRCHCI[CMD_SIZE_LBYTE_LWORD_OFFSET] = (size >> BIT_SHIFT_0_BYTE) & BIT_BYTE_MASK;
    cmdVerifyCRCHCI[CMD_SIZE_HBYTE_LWORD_OFFSET] = (size >> BIT_SHIFT_1_BYTE) & BIT_BYTE_MASK;
    cmdVerifyCRCHCI[CMD_SIZE_LBYTE_HWORD_OFFSET] = (size >> BIT_SHIFT_2_BYTE) & BIT_BYTE_MASK;
    cmdVerifyCRCHCI[CMD_SIZE_HBYTE_HWORD_OFFSET] = (size >> BIT_SHIFT_3_BYTE) & BIT_BYTE_MASK;

    /* Send command */
    send_command_generic(cmdVerifyCRCHCI, cmdLength);
}

boolean wait_event_generic(const uint8 expectedResponse[], Ifx_SizeT count)
{
    /* The response buffer is used as intermediate buffer for parsing the received data from
     * Fifo for further protocol processing */
    uint8 responseRecv[ASC_RX_BUFFER_SIZE];
    boolean retValue = FALSE;

    /* Enable remote side TX */
    IfxPort_setPinLow(ASC_HCI_PROTOCOL_RTS_PORT);

    /* Calculate ticks for timeout */
    Ifx_TickTime timeoutTicks = calulate_SysTicks(MS_PER_SECOND);

    /* Read response from HCI protocol UART */
    if (IfxStdIf_DPipe_read(&g_asclinPipeHCIProtocol, responseRecv, &count, timeoutTicks) == TRUE)
    {
        /* Success: Response received
         * Now check received response for validity
         */
        retValue = TRUE;

        /* Compare received response with expected response for correctness*/
        for (uint32 i = 0; i < count; i++)
        {
            if (responseRecv[i] != expectedResponse[i])
            {
                retValue = FALSE;
            }
        }
    }

    /* Disable remote side TX */
    IfxPort_setPinHigh(ASC_HCI_PROTOCOL_RTS_PORT);

    return retValue;
}

boolean wait_event_verify_crc(uint32 expectedCRC)
{
    /* Bit pattern of expected verifyCRC response */
    uint8 responseVerifyCRCHCI[] = {0x04, 0x0E, 0x08, 0x01, 0xCC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00};
    /* Size of expected response */
    Ifx_SizeT count = sizeof responseVerifyCRCHCI;

    /* Patch bit pattern with expected CRC */
    responseVerifyCRCHCI[RSP_CRC_LBYTE_LWORD_OFFSET] = (expectedCRC >> BIT_SHIFT_0_BYTE) & BIT_BYTE_MASK;
    responseVerifyCRCHCI[RSP_CRC_HBYTE_LWORD_OFFSET] = (expectedCRC >> BIT_SHIFT_1_BYTE) & BIT_BYTE_MASK;
    responseVerifyCRCHCI[RSP_CRC_LBYTE_HWORD_OFFSET] = (expectedCRC >> BIT_SHIFT_2_BYTE) & BIT_BYTE_MASK;
    responseVerifyCRCHCI[RSP_CRC_HBYTE_HWORD_OFFSET] = (expectedCRC >> BIT_SHIFT_3_BYTE) & BIT_BYTE_MASK;

    /* Wait until response bit pattern is received */
    return wait_event_generic(&responseVerifyCRCHCI[0], count);
}

boolean wait_event_hci_reset(void)
{
    /* Bit pattern of expected reset HCI response */
    const uint8 responseResetHCI[] = {0x04, 0x0e, 0x04, 0x01, 0x03, 0x0c, 0x00};
    /* Size of expected response */
    Ifx_SizeT count = sizeof responseResetHCI;

    /* Wait until response bit pattern is received */
    return wait_event_generic(responseResetHCI, count);
}

boolean wait_event_download_minidriver(void)
{
    /* Bit pattern of expected download minidriver response */
    const uint8 responseDownloadMinidriverHCI[] = {0x04, 0x0e, 0x04, 0x01, 0x2e, 0xfc, 0x00};
    /* Size of expected response */
    Ifx_SizeT count = sizeof responseDownloadMinidriverHCI;

    /* Wait until response bit pattern is received */
    return wait_event_generic(&responseDownloadMinidriverHCI[0], count);
}

boolean wait_event_write_ram(void)
{
    /* Bit pattern of expected write ACK response */
    const uint8 responseWriteAckHCI[] = {0x04, 0x0e, 0x04, 0x01, 0x4c, 0xfc, 0x00};
    /* Size of expected response */
    Ifx_SizeT count = sizeof responseWriteAckHCI;

    /* Wait until response bit pattern is received */
    return wait_event_generic(&responseWriteAckHCI[0], count);
}

boolean wait_event_launch_ram(void)
{
    /* Bit pattern of expected launch HCI response */
    const uint8 responseLaunchHCI[] = {0x04, 0x0e, 0x04, 0x01, 0x4e, 0xfc, 0x00};
    /* Size of expected response */
    Ifx_SizeT count = sizeof responseLaunchHCI;

    /* Wait until response bit pattern is received */
    return wait_event_generic(&responseLaunchHCI[0], count);
}

boolean wait_event_update_baudrate(void)
{
    /* Bit pattern of expected baud rate update response */
    const uint8 responseBaudrateUpdateHCI[] = {0x04, 0x0e, 0x04, 0x01, 0x18, 0xfc, 0x00};
    /* Size of expected response */
    Ifx_SizeT count = sizeof responseBaudrateUpdateHCI;

    /* Wait until response bit pattern is received */
    return wait_event_generic(&responseBaudrateUpdateHCI[0], count);
}

boolean wait_event_chip_erase(void)
{
    /* Bit pattern of expected chip erase response */
    const uint8 responseChipEraseHCI[] = {0x04, 0x0e, 0x04, 0x01, 0xce, 0xff, 0x00};
    /* Size of expected response */
    Ifx_SizeT count = sizeof responseChipEraseHCI;

    /* Wait until response bit pattern is received */
    return wait_event_generic(&responseChipEraseHCI[0], count);
}

boolean reset_hci(uint8 trials)
{
    boolean retValue = FALSE;

    /* Probe responsiveness of target by sending resets */
    do
    {
        /* Send reset request */
        send_request_reset_hci();

        /* Wait for reset response */
        retValue = wait_event_hci_reset();

        /* Decrement trial counter */
        trials--;

    /* Repeat until success or number of trials executed */
    }while( (trials > 0) && (retValue == FALSE) );

    return retValue;
}

boolean validate_binary(void)
{
    /* Request CRC calculation of application binary for FLASH_RANGE_1 */
    send_command_verify_crc(FLASH_RANGE_1_STARTADDRESS, FLASH_RANGE_1_SIZE);

    /* Check if received CRC matches expected CRC */
    if ( wait_event_verify_crc(FLASH_RANGE_1_CRC) == FALSE )
    {
        /* CRC of FLASH_RANGE_1 is incorrect */
        return FALSE;
    }

    /* Request CRC calculation of application binary for FLASH_RANGE_2 */
    send_command_verify_crc(FLASH_RANGE_2_STARTADDRESS, FLASH_RANGE_2_SIZE);

    /* Check if received CRC matches expected CRC */
    if (wait_event_verify_crc(FLASH_RANGE_2_CRC) == FALSE)
    {
        /* CRC of FLASH_RANGE_2 is incorrect */
        return FALSE;
    }

    /* Application binary CRCs are correct */
    return TRUE;
}

boolean download_binary(const uint8 binary[][BINARY_PACKET_MAX_SIZE], uint32 packetCount)
{
    /* Program each binary packets into CYW920189EVB-02 */
    for (uint32 packetIndex = 0; packetIndex < packetCount; packetIndex++)
    {
        /* Get destination address for the packet */
        uint32 address =  (((uint32)binary[packetIndex][BINARY_PAYLOAD_ADDRESS_HBYTE_HWORD_OFFSET]) << BIT_SHIFT_3_BYTE) |
                          (((uint32)binary[packetIndex][BINARY_PAYLOAD_ADDRESS_LBYTE_HWORD_OFFSET]) << BIT_SHIFT_2_BYTE) |
                          (((uint32)binary[packetIndex][BINARY_PAYLOAD_ADDRESS_HBYTE_LWORD_OFFSET]) << BIT_SHIFT_1_BYTE) |
                          (((uint32)binary[packetIndex][BINARY_PAYLOAD_ADDRESS_LBYTE_LWORD_OFFSET]) << BIT_SHIFT_0_BYTE);

        /* Get size of the packet */
        Ifx_SizeT size = binary[packetIndex][BINARY_PAYLOAD_SIZE_OFFSET];

        /* Write packet to CYW920189EVB-02 */
        send_command_write_ram(size,
                               address,
                               &(binary[packetIndex][BINARY_PAYLOAD_DATA_OFFSET])
                              );

        /* Wait until writing of data is acknowledged */
        if ( wait_event_write_ram() == FALSE)
        {
            return FALSE;
        }
    }

    return TRUE;
}
