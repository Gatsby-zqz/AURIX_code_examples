/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
 /*\title Bluetooth application firmware download and execution
 * \abstract Demonstrate the download of an application firmware to Infineon's CYW20819 device family by applying the AIROC(TM) HCI UART Control Protocol on AURIX(TM)
 * \description The example enables the extension of AURIX(TM) devices with the BLE (Bluetooth Low Energy) and classic
 *              bluetooth capability which is provided by Infineon's CYW20819 device. The application firmware binary
 *              which is distributed within this example implements a RFCOMM (Radio Frequency Communication) bluetooth
 *              classic profile for the CYW20819 device. This application binary is downloaded by AURIX(TM) to the
 *              CYW20819 device. During execution of the application binary, the data received/transmitted on the
 *              RFCOMM bluetooth interface by the CYW20819 device is bridged to a UART (Universal Asynchronous
 *              Receiver Transmitter), which is connected to AURIX(TM) and processed on AURIX(TM) within a shell. A shell
 *              is a user interface for parsing commands and accessing services. By this, a RFCOMM bluetooth
 *              application on a remote device (i.e. smartphone) can be used as a terminal application to communicate
 *              with AURIX(TM).
 *
 * \name iLLD_TC375_ADS_Bluetooth_RFCOMM
 * \version V1.0.0
 * \board AURIX TC375 lite Kit, KIT_A2G_TC375_LITE, TC37xTP_A-Step
 * \keywords Bluetooth, AIROC(TM) HCI, ASC, shell, RFCOMM, AURIX, UART, VCOM, serial communication
 * \documents See README.md
 * \lastUpdated 2023-02-06
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Includes-----------------------------------------------------*/
/*********************************************************************************************************************/
#include "BT_HCI_Protocol_Download.h"
#include "BT_Minidriver_Binary.h"
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "BT_RFCOMM_Binary.h"
#include "BT_Shell.h"
#include "Bsp.h"

/*********************************************************************************************************************/
/*-----------------------------------------------------Macros--------------------------------------------------------*/
/*********************************************************************************************************************/
#define HCI_RESET_RETRIALS    3
#define HCI_DELAY_RETRIALS_MS 100

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void wait_ms(uint32 ms)
{
    sint32 Fsys = IfxStm_getFrequency(&MODULE_STM0);
    Ifx_TickTime waitms = (Fsys / (1000 / ms));

    wait(waitms);
}

void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    /* Initialize the UART interface for HCI protocol communication */
    init_hci_protocol_UART();

    /* Reset HCI UART to confirm linkup (CYW920819EVB-02 is connected to AURIX) */
    if ( reset_hci(HCI_RESET_RETRIALS) == TRUE)
    {
        boolean linkUp = TRUE;

        /* Download of minidriver to RAM needed for flashing application binary */
        send_command_download_minidriver();
        linkUp = wait_event_download_minidriver();

        /* Download minidriver binary to RAM of CYW920819EVB-02*/
        if ( linkUp == TRUE )
        {
            linkUp = download_binary(g_minidriverBinary, MINIDRIVER_BINARY_PACKETCOUNT);
        }

        /*Launch minidriver binary inside RAM */
        if ( linkUp == TRUE )
        {
            send_command_launch_ram(MINIDRIVER_LAUNCH_ADDRESS);
            linkUp = wait_event_launch_ram();
        }

        /* Validate CRCs of application binary inside flash.
         * Only if CRC is invalid, flashing programming is needed */
        if ( validate_binary() == FALSE )
        {
            /* Start flash programing */

            /* Optional: Set an optimized baudrate to speed up download */
            if ( linkUp == TRUE )
            {
                send_command_update_baudrate( ASC_HCI_PROTOCOL_BAUDRATE );
                linkUp = wait_event_update_baudrate();
            }

            /* Erase flash before downloading new application binary */
            if ( linkUp == TRUE )
            {
                send_command_chip_erase();
                linkUp = wait_event_chip_erase();
            }

            /* Download of RFCOMM application binary to CYW920819EVB-02*/
            if ( linkUp == TRUE )
            {
                linkUp = download_binary(g_rfcommBinary, RFCOMM_BINARY_PACKETCOUNT);
            }

            /* Validate if application binary flashing succeeded */
            if ( validate_binary() == FALSE )
            {
                /* Unexpected unresponsiveness during firmware download.
                 * Check your physical connection and retry */
                while(1){};
            }
        }

        /* Launch application binary from flash */
        if ( linkUp == TRUE )
        {
            send_command_launch_ram(RFCOMM_LAUNCH_ADDRESS);
            linkUp = wait_event_launch_ram();
        }

        if (linkUp == FALSE)
        {
            /* Unexpected link-loss during firmware download.
             * Check your physical connection and retry */
            while(1){};
        }
    }
    else
    {
        /* Unexpected unresponsiveness of CYW920819EVB-02 to HCI_RESET commands after reset
         * Check physical connection and follow manual recovery procedure of
         * CYW920819EVB-02 Kit */
        while(1){};
    }

    /* Relax startup timing for CYW920819EVB-02 before starting shell.
     * Otherwise characters of the initial info screen might get lost. */
    wait_ms(150);

    /* Initialize the UART to run for shell interface on PUART of CYW920819EVB-02 */
    init_shell();

    while(1)
    {
        /* Run the application shell on on PUART of CYW920819EVB-02 */
        run_shell();
    }
}
