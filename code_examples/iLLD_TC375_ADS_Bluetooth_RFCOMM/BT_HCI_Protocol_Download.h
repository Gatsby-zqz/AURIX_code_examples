/**********************************************************************************************************************
 * \file BT_HCI_Protocol_Download.h
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#ifndef BT_HCI_PROTOCOL_DOWNLOAD_H_
#define BT_HCI_PROTOCOL_DOWNLOAD_H_

/*********************************************************************************************************************/
/*------------------------------------------------------Includes-----------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"

/*********************************************************************************************************************/
/*-----------------------------------------------------Macros--------------------------------------------------------*/
/*********************************************************************************************************************/
/* Communication parameters */
#define ASC_HCI_PROTOCOL_BAUDRATE  115200                      /* Define the UART baud rate            */
#define BINARY_PACKET_MAX_SIZE     245

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/**
 * @init_hci_protocol_UART
 * Initialize ASCLIN5 module for HCI protocol usage
 *
 * */
void init_hci_protocol_UART(void);

/**
 * @send_command_generic
 * Generic send HCI protocol request. Used by all other specific HCI protocol request functions.
 *
 * @input  :  - data       : pointer to command's bit pattern
 *            - noOfBytes  : number of bytes of command
 *
 * */
void send_command_generic(const uint8 data[], Ifx_SizeT noOfBytes);

/**
 * @send_command_hci_reset
 * Send HCI_RESET protocol command on the UART
 *
 * */
void send_command_hci_reset(void);

/**
 * @send_command_write_ram
 * Send WRITE_RAM protocol command on the UART
 * Note: The WRITE_RAM command is not limited to actual RAM address ranges. The same command can be used for
 * non-volatile-storage like serial flash.
 *
 * @input  :  - payloadSize        : Amount of data to be written
 *            - destinationAddress : Destination address of the data
 *            - payloadData        : Payload of data to be written
 *
 * */
void send_command_write_ram(Ifx_SizeT payloadSize, uint32 destinationAddress, const uint8 payloadData[]);

/**
 * @send_command_verify_crc
 * Send VERIFY_CRC protocol command on the UART
 *
 * */
void send_command_verify_crc(uint32 startAddress, uint32 size);

/**
 * @send_command_update_baudrate
 * Send UPDATE_BAUDRATE protocol command on the UART
 *
 * */
void send_command_update_baudrate(uint32 baudrate);

/**
 * @send_command_chip_erase
 * Send CHIP_ERASE protocol command on the UART
 *
 * */
void send_command_chip_erase(void);

/**
 * @send_command_download_minidriver
 * Send download minidriver protocol command on the UART
 *
 * */
void send_command_download_minidriver(void);

/**
 * @send_command_launch_ram
 * Send LAUNCH_RAM protocol command on the UART
 * Note: The LAUNCH_RAM command is not limited to actual RAM address ranges. The same command can be used for
 * non-volatile-storage like serial flash.
 *
 * @input  :  - launchAddress      : Address of the executable to start
 *
 * */
void send_command_launch_ram(uint32 launchAddress);

/**
 * @wait_event_generic NAME
 * Generic wait for HCI protocol events
 * Used by all other wait for specific HCI protocol event functions.
 *
 * @input  :  - expectedResponse   : Expected event bit pattern of the response
 *
 * @return :  - true               : Expected event bit pattern received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_generic(const uint8 expectedResponse[], Ifx_SizeT count);

/**
 * @wait_event_hci_reset
 * Wait for HCI_RESET protocol event on the UART
 *
 * @return :  - true               : HCI_RESET event bit pattern received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_hci_reset(void);

/**
 * @wait_event_write_ram
 * Wait for WRITE_RAM protocol event on the UART
 *
 * @return :  - true               : WRITE_RAM event bit pattern received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_write_ram(void);

/**
 * @wait_event_verify_crc
 * Wait for VERIFY_CRC protocol event on the UART
 *
 * @input  :  - expectedCRC        : Expected CRC within the event response
 *
 * @return :  - true               : VERIFY_CRC event bit pattern including correct expected CRC
 *                                   received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_verify_crc(uint32 expectedCRC);

/* Wait for UPDATE_BAUDRATE protocol event on the UART */
/**
 * @wait_event_update_baudrate
 * Wait for UPDATE_BAUDRATE protocol event on the UART
 *
 * @return :  - true               : UPDATE_BAUDRATE event bit pattern received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_update_baudrate(void);

/* Wait for CHIP_ERASE protocol event on the UART */
/**
 * @wait_event_chip_erase
 * Wait for CHIP_ERASE protocol event on the UART
 *
 * @return :  - true               : CHIP_ERASE event bit pattern received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_chip_erase(void);

/**
 * @wait_event_download_minidriver
 * Wait for DOWNLOAD_MINIDRIVER protocol event on the UART
 *
 * @return :  - true               : DOWNLOAD_MINIDRIVER event bit pattern received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_download_minidriver(void);

/**
 * @wait_event_launch_ram
 * Wait for LAUNCH_RAM protocol event on the UART
 *
 * @return :  - true               : DOWNLOAD_MINIDRIVER event bit pattern received within timeout
 *            - false              : Wrong bit pattern or no event response received
 *
 * */
boolean wait_event_launch_ram(void);

/**
 * @reset_hci
 * Check for linkup and responsiveness of the CYW920819EVB-01 evaluation kit
 * by sending HCI_RESET command and wait for HCI_RESET event response
 *
 * @input  :  - trials             : Number of trials sending the HCI_RESET
 *
 * @return :  - true               : HCI_RESET bit pattern received
 *            - false              : No HCI_RESET bit pattern received
 *
 * */
boolean reset_hci(uint8 trials);

/**
 * @validate_binary
 * Validate the RFCOMM-executable inside flash for correctness
 *
 * @return :  - true               : RFCOMM executable inside flash CRC checked ok
 *            - false              : RFCOMM executable inside flash CRC checked not ok
 *
 * */
boolean validate_binary(void);

/**
 * @download_binary
 * Validate the RFCOMM-executable inside flash for correctness
 *
 * @input  :  - binary[][PAYLOAD_PACKET_MAX_SIZE] : Array of binary download data
 *            - packetCount                        : Amount of packets inside array
 *
 * @return :  - true               : Download succeeded
 *            - false              : Download failed
 *
 * */
boolean download_binary(const uint8 binary[][BINARY_PACKET_MAX_SIZE], uint32 packetCount);

#endif /* BT_HCI_PROTOCOL_DOWNLOAD_H_ */
