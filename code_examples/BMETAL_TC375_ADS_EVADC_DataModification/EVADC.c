/**********************************************************************************************************************
 * \file EDSADC.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include "Ifx_Types.h"
#include "IfxPort_reg.h"
#include "IfxConverter_reg.h"
#include "IfxStm.h"

#include "EVADC.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ANALOG_FULL_SCALE   3.3     /* Analog full-scale voltage    (V_IN = V_AREF = 3.3V)           */
#define RAW_FULL_SCALE      4095    /* EVADC maximum digital code representing analog input = V_AREF */

/* DMM configuration options */
#define MODE_DMM_DISABLE    0x0
#define MODE_DMM_AVERAGE    0x1
#define MODE_DMM_FIR        0x2
#define MODE_DMM_IIR        0x3

/* DMM settings */
#define DMM_AVERAGE_NUM     0x3     /* Number of samples for the Standard Data Reduction Mode */
#define DMM_FIR_COEFF       0xC     /* FIR filtering coefficients */
#define DMM_IIR_COEFF       0xE     /* FIR filtering coefficients */


/* Possible values for FIR/IIR filter coefficients:
 * --------------------------------------------------------------------------------------------------------
 * |          Average filter          | * |          FIR filter         | * |         IIR filter          |
 * ------------------------------------ * ------------------------------- * -------------------------------
 * | DMM | DRCTR | Accumulated values | * | DMM | DRCTR | COEFFICIENTS  | * | DMM | DRCTR | COEFFICIENTS  |
 * ------------------------------------ * ------------------------------- * -------------------------------
 * | 0x0 |  0x0  | Disabled           | * | 0x1 |  0x0  | a=2, b=1, c=0 | * | 0x1 |  0xE  | a=2, b=2      |
 * | 0x0 |  0x1  | 2 results average  | * | 0x1 |  0x1  | a=1, b=2, c=0 | * | 0x1 |  0xF  | a=3, b=4      |
 * | 0x0 |  0x2  | 3 results average  | * | 0x1 |  0x2  | a=2, b=0, c=1 | * |     |       |               |
 * | 0x0 |  0x3  | 4 results average  | * | 0x1 |  0x3  | a=1, b=1, c=1 | * |     |       |               |
 * | 0x0 |  0x4  | 5 results average  | * | 0x1 |  0x4  | a=1, b=0, c=2 | * |     |       |               |
 * | 0x0 |  0x5  | 6 results average  | * | 0x1 |  0x5  | a=3, b=1, c=0 | * |     |       |               |
 * | 0x0 |  0x6  | 7 results average  | * | 0x1 |  0x6  | a=2, b=2, c=0 | * |     |       |               |
 * | 0x0 |  0x7  | 8 results average  | * | 0x1 |  0x7  | a=1, b=3, c=0 | * |     |       |               |
 * | 0x0 |  0x8  | 9 results average  | * | 0x1 |  0x8  | a=3, b=0, c=1 | * |     |       |               |
 * | 0x0 |  0x9  | 10 results average | * | 0x1 |  0x9  | a=2, b=1, c=1 | * |     |       |               |
 * | 0x0 |  0xA  | 11 results average | * | 0x1 |  0xA  | a=1, b=2, c=1 | * |     |       |               |
 * | 0x0 |  0xB  | 12 results average | * | 0x1 |  0xB  | a=2, b=0, c=2 | * |     |       |               |
 * | 0x0 |  0xC  | 13 results average | * | 0x1 |  0xC  | a=1, b=1, c=2 | * |     |       |               |
 * | 0x0 |  0xD  | 14 results average | * | 0x1 |  0xD  | a=1, b=0, c=3 | * |     |       |               |
 * | 0x0 |  0xE  | 15 results average | * |     |       |               | * |     |       |               |
 * | 0x0 |  0xF  | 16 results average | * |     |       |               | * |     |       |               |
 * --------------------------------------------------------------------------------------------------------
 *
 * When selecting different coefficients, make sure to set the correct DIV_FACTOR.
 */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* Variables to store the result */
volatile uint16  g_resultEVADC_G0 = 0;     /* Variable to store the raw ADC value */
volatile float32 g_resultVoltage = 0.0;    /* Variable to store the calculated voltage value */

/* Variables to configure DMM function */
volatile uint16 g_dmm_mode_cfg = MODE_DMM_DISABLE;  /* Configuration for DMM mode: average, FIR, IIR*/
volatile uint16 g_dmm_div_factor = 1;               /* Division factor for the average mode */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/* The following functions are implemented to maximize readability rather than performance */
static void init_CONVCTRL( void );

IFX_INTERRUPT(evadc_ch0_isr, 0, 0x1);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* This function initializes Convert Control module:
 * - Enable the CONVCTRL module
 * - Set up 40MHz clock
 */
static void init_CONVCTRL( )
{
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword ());
    CONVCTRL_CLC.U = 0x00000000;        /* Enable module CONVCTRL */
    IfxScuWdt_setCpuEndinit (IfxScuWdt_getCpuWatchdogPassword ());

    while(CONVCTRL_CLC.B.DISS == 0x1)   /* Wait until module clock is enabled   */
    {;}

    CONVCTRL_CCCTRL.U = 0xB0000000;     /* Unlock converter control registers   */
    CONVCTRL_PHSCFG.U = 0x00008003;     /* fADC=160MHz, fPHSYNC=160MHz/4=40MHz  */
    CONVCTRL_CCCTRL.U = 0x00000000;     /* Lock converter control registers     */
}
/* This function initializes the EVADC Group 0 Channel 0:
 * - Enable the module
 * - Set up internal clock to 40MHz
 * - Enable Normal operation mode
 * - Request calibration
 * - Set up Queue 0
 * - Set up external trigger GTM_trig_0
 * - Set up channel settings
 * - Set up DMM
 * - Set up Service Request
 */
void enable_EVADC_G0CH0( void )
{
    init_CONVCTRL();        /* Enable CONVCTRL module*/

    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    EVADC_CLC.U = 0x0;      /* Enable clock for the EVADC module*/

    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Wait until Module clock is enabled (DISS == 0) */
    while( EVADC_CLC.B.DISS == 0x1 );

    /* Setup Module clock
     * ANCFG - Analog Fct. Config. Register,
         * IPE[0]       - 0x0   --> Idle Precharge
         * BE[1]        - 0x0   --> Input Buffer
         * RPE[2]       - 0x0   --> Reference Precharge
         * RPC[3]       - 0x0   --> Reference Precharge Control
         * CALSTC[4:5]  - 0x0   --> Calibration Sample Time Control
         * DPCAL[6]     - 0x1   --> Disable Post-Calibration
         * ACSD[16:18]  - 0x00  --> Analog Clock Synchronization Delay
         * SSE[19]      - 0x0   --> Sample Synchronization
         * DIVA[20:24]  - 0x03  --> Divider Factor for the Analog Internal Clock (F_adci), 0x03 = 40MHz
         * DCMSB[25]    - 0x0   --> Double Clock for the MSB Conversion
     * */
    EVADC_G0ANCFG.B.IPE = 0;    /* Disable Idle Precharge */
    EVADC_G0ANCFG.B.BE  = 0;    /* Disable Input Buffer */
    EVADC_G0ANCFG.B.RPE = 0;    /* Reference Precharge */
    EVADC_G0ANCFG.B.DPCAL = 1;  /* Disable Post-Calibration */
    EVADC_G0ANCFG.B.DIVA = 0x3; /* Setup clock frequency fADC=160MHz/4=40MHz */

    EVADC_G0ANCFG.U = ( 0x1 << 6 ) | ( 0x3 << 20 );

    /* Enable Module Operation
    * GxARBCFG - Arbitration Config. Register
       * ANONC[0:1]     - 0x03 --> Analog Converter Control, 0x03 = Normal Operation
       * ANONs[16:17]   - rh --> Analog Converter Control Status
       * CHNR[20:24]    - rh --> Channel Number
       * SYNRUN[25]     - rh --> Synchronous Conversion Running
       * CAL[28]        - rh --> Start-Up Calibration Active Indication
       * BUSY[30]       - rh --> Converter Busy Flag
       * SAMPLE[31]     - rh --> Sample Phase Flag
    * */
    EVADC_G0ARBCFG.B.ANONC = 0x3;               /* Setup Normal Operation  */
    while(EVADC_G0ARBCFG.B.ANONS != 0x3);       /* Wait until analog part it switched on */

    /* Wait at least 5us to settle analog part */
    for(int i=0; i < 50000; i++)
    {;}

    /* Request startup calibration
    * EVADC_GLOBCFG - Global Configuration Register
        * USC[12]       - 0x0   --> Unsynchronized Clock Generation
        * SUPLEV[13:14] - 0x00  --> Supply Voltage Level, Automatic control
        * CPWC[15]      - 0x1   --> Write Control
        * SUCAL[31]     - 0x1   --> Start-Up Calibration
    * */
    EVADC_GLOBCFG.U |= (1 << 15) | (1 << 31 ); /* Enable startup calibration */

    /* Wait until calibration is done */
    while(EVADC_G0ARBCFG.B.CAL == 0x1);

    /* Enable arbitration slot 0
    * GxARBPR - Arbitration Priority Register i, i=0-2
        * PRIOi[4*i+1:4*i]  - 0x03  --> Priority of Request Source i
        * CSMi[4*i+3]       - 0x0   --> Conversion Start Mode of Request Source i
        * ASENi[i+24]       - 0x1   --> Arbitration Source Input i Enable
    * */
    EVADC_G0ARBPR.B.ASEN0 = 0x1;    /* Enable Arbitration Slot  0 */


    /* Add Channel 0 to Group 0 Queue Source and enable External Trigger */
    /* GxQINRi (i=0-2) - Queue i Input Register, Group x
        * REQCHNR[0:4]  - 0x00  --> Request Channel Number
        * RF[5]         - 0x01  --> Refill
        * ENSI[6]       - 0x00  --> Enable Source Interrupt
        * EXTR[7]       - 0x01  --> External Trigger
        * PDD[9]        - 0x00  --> Pull-Down Diagnostics Enable
        * MDPD[10]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable
        * MDPU[11]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable - MDPD,MDPU
        * CDEN[12]      - 0x00  --> Converter Diagnostics Enable
        * CDSEL[13:14]  - 0x00  --> Converter Diagnostics Pull-Devices Select
    * */
    EVADC_G0QINR0.U = ( 0x0 << 0 ) | ( 0x1 << 7 ) | ( 0x1 << 5 );


    /* Configure Source Control Trigger & Gate
    * GxQCTRLi (i=0-2;x=0-11) - Queue i Source Contr. Register, Group x
        * SRCRESREG[0:3]    - 0x00  --> Source-specific Result Register
        * TRSEL[7:6]        - 0x00  --> Trigger Source Selection
        * XTSEL[8:11]       - 0x08  --> External Trigger Input Selection
        * XTLVL[12]         - 0x02  --> External Trigger Level
        * XTMODE[13:14]     - 0x00  --> Trigger Operating Mode
        * XTWC[15]          - 0x00  --> Control for Trigger Configuration
        * GTSEL[16:19]      - 0x00  --> Gate Input Selection
        * GTLVL[20]         - 0x00  --> Gate Input Level
        * GTWC[23]          - 0x00  --> Write Control for Gate Configuration
        * TMEN[28]          - 0x00  --> Timer Mode Enable
        * TMWC[31]          - 0x00  --> Write Control for Timer Mode
    * */
    EVADC_G0QCTRL0.U = ( 0x0 )      |    /* Use GxCHCTRy.RESREG to select result register for channels in group*/
                      ( 0x8 << 8 )  |    /* Trigger on GTM_adcx_trig0 (see device appendix) */
                      ( 0x2 << 13 ) |    /* Trigger on rising edge*/
                      ( 0x1 << 15 ) |    /* Bitfields XTMODE, XTSEL, TRSEL can be written */
                      ( 0x0 << 16 ) |    /* Gate by GTM_adcx_trig0 */
                      ( 0x1 << 23 );     /* Bitfield GTSEL can be written */


    /* Enable Trigger & Gate for Request Source 0
    * GxQMRi (i=0-2;x=0-11) - Queue i Mode Register, Group x
        * ENGT[0:1]    - 0x01  --> Enable Gate
        * ENTR[2]      - 0x1   --> Enable External Trigger
        * CLRV[8]      - 0x0   --> Clear Valid Bit
        * TREV[9]      - 0x0   --> Trigger Event
        * FLUSH[10]    - 0x0   --> Flush Queue
        * CEV[11]      - 0x0   --> Clear Event Flag
        * PTDIS[16]    - 0x0   --> Repeat Disable
    * */
    EVADC_G0QMR0.B.ENGT = 0x1;  /* Enable Gate */
    EVADC_G0QMR0.B.ENTR = 0x1;  /* Enable External Trigger */

    /* Configure Channel Settings */

    /* Configure sample time of 425ns = 16 x F_adci(40MHz), 2 + (STCS - 15) × 16
    * GxICLASSi - Input Class Register i, (i=0-1)
        * STCS[0:4]     - 0x0F  --> Sample Time Control for Standard Conversions
        * AIPS[6:7]     - 0x00  --> Analog Input Precharge Control for Standard Conversions
        * CMS[8:9]      - 0x00  --> Conversion Mode for Standard Conversions
        * SESPS[10]     - 0x00  --> Spread Early Sample Point for Standard Conversions
        * STCE[16:20]   - 0x00  --> Sample Time Control for EMUX Conversions
        * AIPE[22:23]   - 0x00  --> Analog Input Precharge Control for EMUX Conversions
        * CME[24:25]    - 0x00  --> Conversion Mode for EMUX Conversions
        * SESPE[26]     - 0x00  --> Spread Early Sample Point for EMUX Conversions
    * */
    EVADC_G0ICLASS0.B.STCS  = 0x0F;

    /*
     * GxCHCTRy - Channel Control Register
        * ICLSEL [0:1]  - 0x00  --> Input Class Select
        * BNDSELL[4:5]  - 0x00  --> Lower Boundary Select
        * BNDSELU[6:7]  - 0x00  --> Upper Boundary Select
        * CHEVMODE[8:9] - 0x00  --> Channel Event Mode
        * SYNC[10]      - 0x00  --> Synchronization Request
        * REFSEL[11]    - 0x00  --> Reference Input Selection
        * BNDSELX[12:15]- 0x00  --> BoundaryExtensions
        * RESREG[16:19] - 0x00  --> Result Register
        * RESTGT[20]    - 0x00  --> Result Target
        * RESPOS[21]    - 0x00  --> Result Position
        * BWDCH[28:29]  - 0x00  --> Broken Wire Detection Channel
        * BWDEN[30]     - 0x00  --> Broken Wire Detection Enable
    * */
    EVADC_G0CHCTR0.B.RESREG = 0x0;  /* Store result from channel y to specified group result register */
    EVADC_G0CHCTR0.B.RESPOS = 0x0;  /* Store result right-aligned */

    /* Setup Data Reduction Mode
     * GxRCRy - Channel Control Register
       * DRCTR[16:19]   - 0x00  --> Data Reduction Control
       * DMM[20:21]     - 0x00  --> Data Modification Mode
       * WFR[24]        - 0x00  --> Wait-for-Read Mode Enable
       * FEN[25:26]     - 0x00  --> FIFO Mode Enable
       * SRGEN[31]      - 0x01  --> Service Request Generation Enable
    * */
    switch( g_dmm_mode_cfg )
    {
        case MODE_DMM_AVERAGE:

            EVADC_G0RCR0.B.DRCTR = DMM_AVERAGE_NUM;
            EVADC_G0RCR0.B.DMM = 0;     /* Standard data reduction */

            g_dmm_div_factor = DMM_AVERAGE_NUM + 1;
            break;

        case MODE_DMM_FIR:

            EVADC_G0RCR0.B.DRCTR = DMM_FIR_COEFF;
            EVADC_G0RCR0.B.DMM = 0x1;     /* FIR mode */

            g_dmm_div_factor = 1;
            break;

        case MODE_DMM_IIR:

            EVADC_G0RCR0.B.DRCTR = DMM_IIR_COEFF;
            EVADC_G0RCR0.B.DMM = 0x1;     /* IIR mode */

            g_dmm_div_factor = 1;
            break;

        default:

            EVADC_G0RCR0.B.DRCTR = 0;   /* Data Reduction disabled */
            EVADC_G0RCR0.B.DMM = 0;     /* Standard data reduction */

            g_dmm_div_factor = 1;
            break;
    }

    EVADC_G0RCR0.B.WFR = 0;     /* Wait-for-Read Mode disabled */
    EVADC_G0RCR0.B.FEN = 0;     /* FIFO Mode disabled */
    EVADC_G0RCR0.B.SRGEN = 1;   /* Enable Service Request Generation */

    /* Configure Service Request */
    /* Result Event Node Pointer Register 0, Group x (GxREVNP0) */
    EVADC_G0REVNP0.U = (0x0 << 0 );

    return;

}
/* This function implements EVADC service request handler:
 * - Read raw result from channel result register
 * - Convert raw result into voltage value
 * - Toggle P00.1 pin
 */
IFX_INTERRUPT(evadc_ch0_isr, 0, 0x1 )
{
    /* Check valid result in G0RES0 */
    if( EVADC_G0RES0.B.VF == 1 )
    {
        g_resultEVADC_G0 = EVADC_G0RES0.B.RESULT;

        /* Convert result */
        g_resultVoltage = ((float)g_resultEVADC_G0 * ANALOG_FULL_SCALE) / RAW_FULL_SCALE;
        g_resultVoltage /= g_dmm_div_factor;
    }

    /* Toggle pin for the debug purposes */
    IfxPort_togglePin( &MODULE_P00, 1 );
}
