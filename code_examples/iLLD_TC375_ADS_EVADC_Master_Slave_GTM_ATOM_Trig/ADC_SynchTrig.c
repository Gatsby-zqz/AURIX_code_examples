/**********************************************************************************************************************
 * \file ADC_SynchTrig.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "ADC_SynchTrig.h"
#include "IfxEvadc_Adc.h"
#include "IfxGtm_Atom_Pwm.h"
#include "IfxGtm_Trig.h"
#include "IfxPort.h"
#include "IfxPort_PinMap.h"
#include "IfxStm.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ADC_SYNCH_MASTER                    IfxEvadc_GroupId_0                         /* EVADC Master Group         */
#define ADC_SYNCH_SLAVE1                    IfxEvadc_GroupId_2                         /* EVADC Slave1 Group         */
#define ADC_SYNCH_SLAVE2                    IfxEvadc_GroupId_3                         /* EVADC Slave2 Group         */

#define ADC_SYNCH_NUM_GROUPS                3                                         /* Number of used groups       */
#define ADC_SYNCH_NUM_CHANNELS              3                                         /* Number of used channels     */
#define ADC_SYNCH_CH_U   IfxEvadc_ChannelId_0          /* Channel ID for pin AN0: AURIX LIte Kit: Pin Header X2:27   */
#define ADC_SYNCH_CH_V   IfxEvadc_ChannelId_0   /* Channel ID for pin AN16: AURIX LIte Kit: Shield2Go Connector 1:2  */
#define ADC_SYNCH_CH_W   IfxEvadc_ChannelId_0                   /* Channel ID for pin AN24: AURIX LIte Kit: X301: 5  */

#define ADC_SYNCH_REFILL_AND_WAIT_FOR_TRIG  (1 << IFX_EVADC_G_Q_QINR_RF_OFF) | \
                                              (1 << IFX_EVADC_G_Q_Q0R_EXTR_OFF)   /* Queue Refill & wait for trigger */

#define ADC_SYNCH_EVADC_RES_AVAILABLE_PRIO  10                                         /* Interrupt priority         */
#define ADC_SYNCH_PWM_TRIG_OUT_PIN          IfxGtm_ATOM0_3_TOUT3_P02_3_OUT /* Pin to watch GTM ATOM Trigger to ADC   */
#define ADC_SYNCH_INTERRUPT_OUT_PIN_U       IfxPort_P02_5             /* Pin to watch Result Interrupt from ADC CH U */
#define ADC_SYNCH_INTERRUPT_OUT_PIN_V       IfxPort_P02_6             /* Pin to watch Result Interrupt from ADC CH V */
#define ADC_SYNCH_INTERRUPT_OUT_PIN_W       IfxPort_P02_7             /* Pin to watch Result Interrupt from ADC CH W */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* EVADC handles */
IfxEvadc_Adc         g_evadc;                                                   /* EVADC module handle variable      */
IfxEvadc_Adc_Group   g_adcGroups[ADC_SYNCH_NUM_GROUPS];                         /* EVADC group handle array          */
IfxEvadc_Adc_Channel g_adcChannels[ADC_SYNCH_NUM_GROUPS];                       /* EVADC channels handle array       */

/* Global variable to view the results */
float32              g_results[ADC_SYNCH_NUM_GROUPS];                           /* Array of results                  */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/** \brief Function to initialize the EVADC module
 *
 */
IFX_STATIC void initEVADCModule(void);

/** \brief Function to initialize the EVADC Master Group.
 *
 */
IFX_STATIC void initEVADCGroupMaster(void);

/** \brief Function to initialize the EVADC Slave1 Group.
 *
 */
IFX_STATIC void initEVADCGroupSlave1(void);

/** \brief Function to initialize the EVADC Slave2 Group.
 *
 */
IFX_STATIC void initEVADCGroupSlave2(void);

/** \brief Function to initialize the EVADC channel U.
 *
 */
IFX_STATIC void initEVADCChannelU(void);

/** \brief Function to initialize the EVADC channel V.
 *
 */
IFX_STATIC void initEVADCChannelV(void);

/** \brief Function to initialize the EVADC channel W.
 *
 */
IFX_STATIC void initEVADCChannelW(void);

/** \brief Function to add each channel to the queue and start the same.
 *
 */
IFX_STATIC void initQueuesAndStart(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the EVADC with default parameters */
void initEVADC(void)
{
    initEVADCModule();                                                               /* Initialize the EVADC module  */
    initEVADCGroupMaster();                                                   /* Initialize the EVADC Master Group   */
    initEVADCGroupSlave1();                                                   /* Initialize the EVADC Slave1 Group   */
    initEVADCGroupSlave2();                                                   /* Initialize the EVADC Slave2 Group   */
    initEVADCChannelU();                                                      /* Initialize the channel U            */
    initEVADCChannelV();                                                      /* Initialize the channel V            */
    initEVADCChannelW();                                                      /* Initialize the channel W            */
    initQueuesAndStart();                                                     /* Fill the queue and configure        */

    /* Set port pins to watch the events */
    IfxPort_setPinLow(ADC_SYNCH_INTERRUPT_OUT_PIN_U.port, ADC_SYNCH_INTERRUPT_OUT_PIN_U.pinIndex);
    IfxPort_setPinLow(ADC_SYNCH_INTERRUPT_OUT_PIN_V.port, ADC_SYNCH_INTERRUPT_OUT_PIN_V.pinIndex);
    IfxPort_setPinLow(ADC_SYNCH_INTERRUPT_OUT_PIN_W.port, ADC_SYNCH_INTERRUPT_OUT_PIN_W.pinIndex);
    IfxPort_setPinModeOutput(ADC_SYNCH_INTERRUPT_OUT_PIN_U.port, ADC_SYNCH_INTERRUPT_OUT_PIN_U.pinIndex,
                                  IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(ADC_SYNCH_INTERRUPT_OUT_PIN_V.port, ADC_SYNCH_INTERRUPT_OUT_PIN_V.pinIndex,
                                  IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(ADC_SYNCH_INTERRUPT_OUT_PIN_W.port, ADC_SYNCH_INTERRUPT_OUT_PIN_W.pinIndex,
                                  IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
}

/* Function to initialize the EVADC module with default parameters */
IFX_STATIC void initEVADCModule(void)
{
    /* Create configuration */
    IfxEvadc_Adc_Config adcConfig;
    IfxEvadc_Adc_initModuleConfig(&adcConfig, &MODULE_EVADC);

    /* Initialize module */
    IfxEvadc_Adc_initModule(&g_evadc, &adcConfig);

    /* Initialize the OCDS control register to view OTGB signals.
       By configuring the OCDS register Trigger Set, the internal signals of EVADC are directed to MCDS trace.
       In this case the signals are input sample signals.
     */
    {
        Ifx_EVADC_OCS ocs= MODULE_EVADC.OCS;
        ocs.B.TG_P= 1;
        ocs.B.TGS= 1;                 /* Trigger Set 1, TS16_SSIGC, input sample signals of primary/secondary groups */
        MODULE_EVADC.OCS.U= ocs.U;
    }
}

/* Function to initialize the EVADC Master Group */
IFX_STATIC void initEVADCGroupMaster(void)
{
    /* Create and initialize group configuration with default values */
    IfxEvadc_Adc_GroupConfig adcGroupConfig;
    IfxEvadc_Adc_initGroupConfig(&adcGroupConfig, &g_evadc);

    /* Setting user configuration for Group A (Master) */
    adcGroupConfig.groupId = ADC_SYNCH_MASTER;
    adcGroupConfig.master = ADC_SYNCH_MASTER;
    adcGroupConfig.analogConverterMode= IfxEvadc_AnalogConverterMode_off;

    /* Enable queued source */
    adcGroupConfig.arbiter.requestSlotQueue0Enabled = TRUE;

    /* Enable all gates in "always" mode (no edge detection) */
    adcGroupConfig.queueRequest[0].requestSlotPrio= IfxEvadc_RequestSlotPriority_highest;
    adcGroupConfig.queueRequest[0].requestSlotStartMode= IfxEvadc_RequestSlotStartMode_cancelInjectRepeat;
    adcGroupConfig.queueRequest[0].triggerConfig.gatingMode = IfxEvadc_GatingMode_always;
    adcGroupConfig.queueRequest[0].triggerConfig.triggerMode = IfxEvadc_TriggerMode_uponFallingEdge;
    adcGroupConfig.queueRequest[0].triggerConfig.triggerSource= IfxEvadc_TriggerSource_11;      /* GTM ADC trigger 3 */

    /* Initialize the group */
    IfxEvadc_Adc_initGroup(&g_adcGroups[0], &adcGroupConfig);
}

/* Function to initialize the EVADC Slave1 Group */
IFX_STATIC void initEVADCGroupSlave1(void)
{
    /* Create and initialize group configuration with default values */
    IfxEvadc_Adc_GroupConfig adcGroupConfig;
    IfxEvadc_Adc_initGroupConfig(&adcGroupConfig, &g_evadc);

    /* Setting user configuration for Group B (Slave 1) */
    adcGroupConfig.groupId = ADC_SYNCH_SLAVE1;
    adcGroupConfig.master = ADC_SYNCH_MASTER;
    adcGroupConfig.analogConverterMode= IfxEvadc_AnalogConverterMode_off;

    /* Initialize the group */
    IfxEvadc_Adc_initGroup(&g_adcGroups[1], &adcGroupConfig);
}

/* Function to initialize the EVADC Slave2 Group */
IFX_STATIC void initEVADCGroupSlave2(void)
{
    /* Create and initialize group configuration with default values */
    IfxEvadc_Adc_GroupConfig adcGroupConfig;
    IfxEvadc_Adc_initGroupConfig(&adcGroupConfig, &g_evadc);

    /* Setting user configuration for Group B (Slave 2) */
    adcGroupConfig.groupId = ADC_SYNCH_SLAVE2;
    adcGroupConfig.master = ADC_SYNCH_MASTER;
    adcGroupConfig.analogConverterMode= IfxEvadc_AnalogConverterMode_off;

    /* Initialize the group */
    IfxEvadc_Adc_initGroup(&g_adcGroups[2], &adcGroupConfig);
}

/* Function to initialize the EVADC channel U */
IFX_STATIC void initEVADCChannelU(void)
{
    /* Create channel configuration */
    IfxEvadc_Adc_ChannelConfig adcChannelConfig;

    /* Initialize the configuration with default values */
    IfxEvadc_Adc_initChannelConfig(&adcChannelConfig, &g_adcGroups[0]);

    /* Select the channel ID and the respective result register */
    adcChannelConfig.channelId = ADC_SYNCH_CH_U;
    adcChannelConfig.resultRegister = ADC_SYNCH_CH_U;
    adcChannelConfig.rightAlignedStorage= FALSE;
    adcChannelConfig.resultServProvider= IfxSrc_Tos_cpu0;
    adcChannelConfig.resultPriority = ADC_SYNCH_EVADC_RES_AVAILABLE_PRIO;
    adcChannelConfig.resultSrcNr= IfxEvadc_SrcNr_group0;
    adcChannelConfig.synchonize= TRUE;

    /* Initialize the channel */
    IfxEvadc_Adc_initChannel(&g_adcChannels[0], &adcChannelConfig);
}

/* Function to initialize the EVADC channel V */
IFX_STATIC void initEVADCChannelV(void)
{
    /* Create channel configuration */
    IfxEvadc_Adc_ChannelConfig adcChannelConfig;

    /* Initialize the configuration with default values */
    IfxEvadc_Adc_initChannelConfig(&adcChannelConfig, &g_adcGroups[1]);

    /* Select the channel ID and the respective result register */
    adcChannelConfig.channelId = ADC_SYNCH_CH_V;
    adcChannelConfig.resultRegister = ADC_SYNCH_CH_V;
    adcChannelConfig.rightAlignedStorage= FALSE;
    adcChannelConfig.resultServProvider= IfxSrc_Tos_cpu1;
    adcChannelConfig.resultPriority = ADC_SYNCH_EVADC_RES_AVAILABLE_PRIO;
    adcChannelConfig.resultSrcNr= IfxEvadc_SrcNr_group0;

    /* Initialize the channel */
    IfxEvadc_Adc_initChannel(&g_adcChannels[1], &adcChannelConfig);
}

/* Function to initialize the EVADC channel W */
IFX_STATIC void initEVADCChannelW(void)
{
    /* Create channel configuration */
    IfxEvadc_Adc_ChannelConfig adcChannelConfig;

    /* Initialize the configuration with default values */
    IfxEvadc_Adc_initChannelConfig(&adcChannelConfig, &g_adcGroups[2]);

    /* Select the channel ID and the respective result register */
    adcChannelConfig.channelId = ADC_SYNCH_CH_W;
    adcChannelConfig.resultRegister = ADC_SYNCH_CH_W;
    adcChannelConfig.rightAlignedStorage= FALSE;
    adcChannelConfig.resultServProvider= IfxSrc_Tos_cpu2;
    adcChannelConfig.resultPriority = ADC_SYNCH_EVADC_RES_AVAILABLE_PRIO;
    adcChannelConfig.resultSrcNr= IfxEvadc_SrcNr_group0;

    /* Initialize the channel */
    IfxEvadc_Adc_initChannel(&g_adcChannels[2], &adcChannelConfig);
}

/* Function to add each channel to the queue and start the Adc */
IFX_STATIC void initQueuesAndStart(void)
{
    /* Add channel to queue with refill option enabled */
    IfxEvadc_Adc_addToQueue(&g_adcChannels[0], IfxEvadc_RequestSource_queue0, ADC_SYNCH_REFILL_AND_WAIT_FOR_TRIG);
    IfxEvadc_Adc_setAnalogConvertControl(&MODULE_EVADC, &g_adcGroups[0], IfxEvadc_AnalogConverterMode_normalOperation);

    /* Wait till the Analog part settles. Needs max 3uS : Ref: TC37x Data sheet */
    {
        IfxStm_waitTicks(&MODULE_STM0, (uint32)(3.0e-6f * IfxStm_getFrequency(&MODULE_STM0)));
    }
}

/* ISR Function that is triggered after the conversion to read the ADC results */
IFX_INTERRUPT(serviceAdcResultU, 0, ADC_SYNCH_EVADC_RES_AVAILABLE_PRIO)
{
    /* Set the watch pin to high */
    IfxPort_setPinHigh(ADC_SYNCH_INTERRUPT_OUT_PIN_U.port, ADC_SYNCH_INTERRUPT_OUT_PIN_U.pinIndex);

    /* Read the result of the selected channel */
    g_results[0] = IfxEvadc_Adc_getResult(&g_adcChannels[0]).B.RESULT * 3.3f / 0xFFF;

    /* Set the watch pin to low */
    IfxPort_setPinLow(ADC_SYNCH_INTERRUPT_OUT_PIN_U.port, ADC_SYNCH_INTERRUPT_OUT_PIN_U.pinIndex);
}

/* ISR Function that is triggered after the conversion to read the ADC results */
IFX_INTERRUPT(serviceAdcResultV, 1, ADC_SYNCH_EVADC_RES_AVAILABLE_PRIO)
{
    /* Set the watch pin to high */
    IfxPort_setPinHigh(ADC_SYNCH_INTERRUPT_OUT_PIN_V.port, ADC_SYNCH_INTERRUPT_OUT_PIN_V.pinIndex);

    /* Read the result of the selected channel */
    g_results[1] = IfxEvadc_Adc_getResult(&g_adcChannels[1]).B.RESULT * 3.3f / 0xFFF;

    /* Set the watch pin to low */
    IfxPort_setPinLow(ADC_SYNCH_INTERRUPT_OUT_PIN_V.port, ADC_SYNCH_INTERRUPT_OUT_PIN_V.pinIndex);
}

/* ISR Function that is triggered after the conversion to read the ADC results */
IFX_INTERRUPT(serviceAdcResultW, 2, ADC_SYNCH_EVADC_RES_AVAILABLE_PRIO)
{
    /* Set the watch pin to high */
    IfxPort_setPinHigh(ADC_SYNCH_INTERRUPT_OUT_PIN_W.port, ADC_SYNCH_INTERRUPT_OUT_PIN_W.pinIndex);

    /* Read the result of the selected channel */
    g_results[2] = IfxEvadc_Adc_getResult(&g_adcChannels[2]).B.RESULT * 3.3f / 0xFFF;

    /* Set the watch pin to low */
    IfxPort_setPinLow(ADC_SYNCH_INTERRUPT_OUT_PIN_W.port, ADC_SYNCH_INTERRUPT_OUT_PIN_W.pinIndex);
}

/* Function to initialize the GTM ATOM as PWM channel and configure that to trigger the EVADC */
void initGtmAtomTrig(void)
{
    IfxGtm_enable(&MODULE_GTM);                                                                   /* Enables the GTM */

    {
        /* enable GTM clock and its clocks */
        float32 frequency = IfxGtm_Cmu_getModuleFrequency(&MODULE_GTM);

        IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, frequency);            /* Set the global clock frequency to the max */
        IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, frequency);                    /* Set the CMU CLK0 */
        IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);    /* FXCLK: used by TOM and CLK0: used by ATOM */
    }

    /* Initialize ATOM Channel */
    IfxGtm_Atom_Pwm_Config atomConfig;
    IfxGtm_Atom_Pwm_Driver atomHandle;

    IfxGtm_Atom_Pwm_initConfig(&atomConfig, &MODULE_GTM);

    atomConfig.atom= ADC_SYNCH_PWM_TRIG_OUT_PIN.atom;
    atomConfig.atomChannel= ADC_SYNCH_PWM_TRIG_OUT_PIN.channel;
    atomConfig.period= (uint32)(100e6/20e3);
    atomConfig.dutyCycle= atomConfig.period / 2;
    atomConfig.synchronousUpdateEnabled = TRUE;
    atomConfig.interrupt.mode= IfxGtm_IrqMode_pulse;
    atomConfig.pin.outputPin = &ADC_SYNCH_PWM_TRIG_OUT_PIN;            /* Required only to watch this trigger signal */

    IfxGtm_Atom_Pwm_init(&atomHandle, &atomConfig);

    IfxGtm_Trig_toEVadc(&MODULE_GTM, IfxGtm_Trig_AdcGroup_0, IfxGtm_Trig_AdcTrig_3,
                            IfxGtm_Trig_AdcTrigSource_atom0,
                            IfxGtm_Trig_AdcTrigChannel_3);                      /* ADC G0 Triggered by GTM ATOM0 CH3 */
}
