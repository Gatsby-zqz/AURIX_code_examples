/**********************************************************************************************************************
 * \file functions.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "conversion_functions.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
uint32 g_numObjects = 0;
Objects g_objs[RADAR_NUM_OBJ_MAX];

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
float32 CalculateDistance(uint32 rIndx)
{
    /* r = idx * bin_res     , where: bin_res=range resolution of each bin  */
    /*   = idx * c/(2*bw)    , where: c=speed of light, bw=ramp bandwidth  */
    return rIndx * 299792458.0 / 2.0 / (float32)RADAR_FREQ_BW;
}

float32 CaclulateVelocity(uint32 dIndx, uint32 rIndx)
{
    /* The doppler axis is split in two parts: indices smaller than (RADAR_NUM_RAMPS/2) indicate positive velocities,
     * indices larger than RADAR_NUM_RAMPS/2 indicate negative velocities.
     */
    sint32 dIndx_modified;
    float32 f0 = RADAR_FREQ_START + (RADAR_FREQ_BW/RADAR_NUM_SAMPLES) * rIndx;
    if (dIndx < RADAR_NUM_RAMPS/2)
    {
        dIndx_modified = dIndx;
    }
    else
    {
        dIndx_modified = dIndx-RADAR_NUM_RAMPS;
    }
    float32 fd = (float32)dIndx_modified / ((float32)RADAR_NUM_RAMPS*RADAR_PRI);

    return ((299792458 * fd) / (2 * f0) * 3.6); /* in km/h */
}

void AnalyzeDetectionBitmaps(void)
{
    uint32 from_dmap = 0; /* bit from doppler lclmax detection map */
    uint32 from_rmap = 0; /* bit from range lclmax detection map */

    g_numObjects = 0;

    for(sint32 d=0; d<RADAR_NUM_DOPPLER_BINS; d++)
    {
        for(sint32 r=0; r<RADAR_NUM_RANGE_GATES; r++)
        {
            from_dmap = IS_BIT_SET(lclMaxVMap[r][d/32], d%32);
            from_rmap = IS_BIT_SET(lclMaxRMap[d][r/32], r%32);

            if(from_dmap && from_rmap) /* relevant bit in both detection maps is set -> valid target */
            {
                if(g_numObjects<RADAR_NUM_OBJ_MAX)
                {
                    g_objs[g_numObjects].nci      = rdMap_nci[r][d];
                    g_objs[g_numObjects].dIndx    = (uint16) d;
                    g_objs[g_numObjects].rIndx    = (uint16) r;
                    g_objs[g_numObjects].range    = CalculateDistance(r);
                    g_objs[g_numObjects].velocity = CaclulateVelocity(d, r);
                    g_numObjects++;
                }
                else
                {
                    /* reached max number of objects, ignore additional detections */
                    return;
                }
            }
        }
    }
}
