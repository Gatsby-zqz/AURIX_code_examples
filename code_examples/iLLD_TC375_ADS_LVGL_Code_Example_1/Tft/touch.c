/**********************************************************************************************************************
 * \file touch.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Configuration.h"
#include "touch.h"

/*********************************************************************************************************************/
/*-----------------------------------------------------Macros--------------------------------------------------------*/
/*********************************************************************************************************************/
#define TOUCH_BUFFER_SIZE 5

#define XMAX_TOUCH   3700.0f
#define XMIN_TOUCH   240.0f
#define YMIN_TOUCH   300.0f
#define YMAX_TOUCH   3740.0f

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct
{
    uint8 spiTxBuffer[TOUCH_BUFFER_SIZE];
    uint8 spiRxBuffer[TOUCH_BUFFER_SIZE];
} AppQspi_Touch_Buffer;

typedef struct
{
    AppQspi_Touch_Buffer qspiBuffer;
    struct
    {
        IfxQspi_SpiMaster         *spiMaster;
        IfxQspi_SpiMaster_Channel spiMasterChannel;
    } drivers;
} App_Qspi_Touch;

/*********************************************************************************************************************/
/*-----------------------------------------------------Macros--------------------------------------------------------*/
/*********************************************************************************************************************/
#if TOUCH_VAR_LOCATION == 0
#if defined(__GNUC__)
#pragma section ".bss_cpu0" awc0
#endif
#if defined(__TASKING__)
#pragma section farbss "bss_cpu0"
#pragma section fardata "data_cpu0"
#endif
#if defined(__DCC__)
#pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
#endif
#elif TOUCH_VAR_LOCATION == 1
#if defined(__GNUC__)
#pragma section ".bss_cpu1" awc1
#endif
#if defined(__TASKING__)
#pragma section farbss "bss_cpu1"
#pragma section fardata "data_cpu1"
#endif
#if defined(__DCC__)
#pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
#endif
#elif TOUCH_VAR_LOCATION == 2
#if defined(__GNUC__)
#pragma section ".bss_cpu2" awc2
#endif
#if defined(__TASKING__)
#pragma section farbss "bss_cpu2"
#pragma section fardata "data_cpu2"
#endif
#if defined(__DCC__)
#pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
#endif
#else
#error "Set TOUCH_VAR_LOCATION to a valid value!"
#endif

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
App_Qspi_Touch g_Qspi_Touch;
TTOUCH_DRIVER touch_driver;
TTOUCH_EVENT touch_event;

#if defined(__GNUC__)
#pragma section
#endif
#if defined(__TASKING__)
#pragma section farbss restore
#pragma section fardata restore
#endif
#if defined(__DCC__)
#pragma section DATA RW
#endif

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementation-----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize Qspix in master mode and to set the variables */
void touch_init (void)
{
    /* Disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    /* INT from TFT touch */
    IfxPort_setPinModeInput(TOUCH_USE_INT.port, TOUCH_USE_INT.pinIndex, IfxPort_Mode_inputPullUp);

    /* CS to TFTtouch */
    IfxPort_setPinModeInput(TOUCH_USE_CHIPSELECT.pin.port, TOUCH_USE_CHIPSELECT.pin.pinIndex, IfxPort_Mode_inputPullUp);

    g_Qspi_Touch.drivers.spiMaster = TOUCH_QSPI_INIT();
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    {
        /* Create channel config */
#if defined(__DCC__)
        /* Bug on DCC not all bits in mode are cleared */
        memset(&spiMasterChannelConfig, 0, sizeof(spiMasterChannelConfig));
#endif
        IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig,
            g_Qspi_Touch.drivers.spiMaster);

        /* Set the baudrate for this channel */
        spiMasterChannelConfig.base.baudrate = 2000000;

        /* Set the transfer data width */
        spiMasterChannelConfig.base.mode.dataWidth = 8;

        spiMasterChannelConfig.base.mode.csTrailDelay = 0;
        spiMasterChannelConfig.base.mode.csInactiveDelay = 0;
        spiMasterChannelConfig.base.mode.shiftClock = SpiIf_ShiftClock_shiftTransmitDataOnTrailingEdge;

        const IfxQspi_SpiMaster_Output slsOutput = {&TOUCH_USE_CHIPSELECT,
                                                    IfxPort_OutputMode_pushPull,
                                                    IfxPort_PadDriver_cmosAutomotiveSpeed1};

        spiMasterChannelConfig.sls.output.pin    = slsOutput.pin;
        spiMasterChannelConfig.sls.output.mode   = slsOutput.mode;
        spiMasterChannelConfig.sls.output.driver = slsOutput.driver;

        /* Initialize channel */
        IfxQspi_SpiMaster_initChannel(&g_Qspi_Touch.drivers.spiMasterChannel,
            &spiMasterChannelConfig);
    }

    /* Initialize buffer area */
    g_Qspi_Touch.qspiBuffer.spiTxBuffer[0] = 0;
    g_Qspi_Touch.qspiBuffer.spiRxBuffer[0] = 0;

    /* Enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);

    touch_event.status = TOUCH_UNINIT;

    touch_driver.status = TOUCH_UP;
    touch_driver.prev_status = TOUCH_UP;
    touch_driver.cnt = 0;

    touch_driver.xmax = XMAX_TOUCH;
    touch_driver.xmin = XMIN_TOUCH;
    touch_driver.ymax = YMIN_TOUCH;
    touch_driver.ymin = YMAX_TOUCH;

    touch_driver.touchmode = (1 << TOUCH_UNINIT);
    touch_driver.bounce_limit = 0;
    touch_driver.bounce_cnt = 0;
}

/* Function to calculate X and Y of touch event */
void touch_calcdisp (void)
{
    touch_event.xdisp =
        ((float) touch_event.x - touch_driver.xmin) / (touch_driver.xmax - touch_driver.xmin) * (float) TERMINAL_MAXX;

    if (touch_event.xdisp < 0)
    {
        touch_event.xdisp = 0;
    }
    if (touch_event.xdisp >= TERMINAL_MAXX)
    {
      touch_event.xdisp = TERMINAL_MAXX - 1;
    }

    touch_event.ydisp =
        ((float) touch_event.y - touch_driver.ymin) / (touch_driver.ymax - touch_driver.ymin) * (float) TERMINAL_MAXY;

    if (touch_event.ydisp < 0)
    {
        touch_event.ydisp = 0;
    }
    if (touch_event.ydisp >= TERMINAL_MAXY)
    {
        touch_event.ydisp = TERMINAL_MAXY - 1;
    }

    touch_driver.xdisp = touch_event.xdisp;
    touch_driver.ydisp = touch_event.ydisp;
}

/* Function called periodically e.g. to react to touch events */
void touch_periodic (void)
{
    IfxCpu_enableInterrupts();

    /* Debouncing */
    touch_driver.bounce_cnt += 1;
    if (touch_driver.bounce_cnt < touch_driver.bounce_limit)
    {
        return;
    }
    touch_driver.bounce_cnt = 0;

    touch_driver.touchmode = 0;
    {
        /* HW interrupt from TFT detected */
        if (IfxPort_getPinState(TOUCH_USE_INT.port, TOUCH_USE_INT.pinIndex) == FALSE)
        {
            touch_driver.xmax = XMAX_TOUCH;
            touch_driver.xmin = XMIN_TOUCH;
            touch_driver.ymax = YMIN_TOUCH;
            touch_driver.ymin = YMAX_TOUCH;

            /* Data */
            g_Qspi_Touch.qspiBuffer.spiTxBuffer[0] = 0x90;
            g_Qspi_Touch.qspiBuffer.spiTxBuffer[1] = 0x00;
            g_Qspi_Touch.qspiBuffer.spiTxBuffer[2] = 0xD0;
            g_Qspi_Touch.qspiBuffer.spiTxBuffer[3] = 0x00;
            g_Qspi_Touch.qspiBuffer.spiTxBuffer[4] = 0x00;

            /* Wait until SPI is no longer busy */
            while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Touch.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

            IfxQspi_SpiMaster_exchange(&g_Qspi_Touch.drivers.spiMasterChannel, &g_Qspi_Touch.qspiBuffer.spiTxBuffer[0],
                &g_Qspi_Touch.qspiBuffer.spiRxBuffer[0], TOUCH_BUFFER_SIZE);

            /* Wait until SPI is no longer busy */
            while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Touch.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

            touch_driver.prev_time = touch_driver.time;
            touch_driver.time = (__mfcr (0xFC04) & 0x7FFFFFFF) >> 8;
            touch_driver.prev_x = touch_driver.x;

            /* Touch position */
            touch_driver.x = ((g_Qspi_Touch.qspiBuffer.spiRxBuffer[1]<<8) | (g_Qspi_Touch.qspiBuffer.spiRxBuffer[2])) >> 3;
            touch_driver.prev_y = touch_driver.y;
            touch_driver.y = ((g_Qspi_Touch.qspiBuffer.spiRxBuffer[3]<<8) | (g_Qspi_Touch.qspiBuffer.spiRxBuffer[4])) >> 3;

            touch_driver.prev_status = touch_driver.status;
            touch_driver.status = TOUCH_DOWN;
        }
        else
        {
            touch_driver.prev_time = touch_driver.time;
            touch_driver.prev_y = touch_driver.y;
            touch_driver.y = -1;
            touch_driver.prev_x = touch_driver.x;
            touch_driver.x = -1;
            touch_driver.prev_status = touch_driver.status;
            touch_driver.status = TOUCH_UP;
        }
    }

    if ((touch_driver.status == TOUCH_DOWN) && (touch_driver.prev_status == TOUCH_UP))
    {
        /* DOWN */
        touch_event.time = touch_driver.time;
        touch_event.x = touch_driver.x;
        touch_event.y = touch_driver.y;
        touch_driver.prev_x_down = touch_driver.x;
        touch_driver.prev_y_down = touch_driver.y;
        touch_driver.prev_time_down = touch_driver.time;
        touch_event.dx = -1;
        touch_event.dy = -1;
        touch_event.dtime = -1;
        touch_driver.cnt = 0;
        touch_event.status = TOUCH_DOWN;
        touch_driver.touchmode |= (1 << touch_event.status);
        touch_calcdisp ();

        return;
    }
    if ((touch_driver.status == TOUCH_DOWN) && (touch_driver.prev_status == TOUCH_DOWN))
    {
        /* DOWN with previous down, means move */
        touch_event.time = touch_driver.time;
        touch_event.dtime = touch_driver.time - touch_driver.prev_time;
        touch_event.x = touch_driver.x;
        touch_event.y = touch_driver.y;
        touch_event.dx = touch_driver.x - touch_driver.prev_x;
        touch_event.dy = touch_driver.y - touch_driver.prev_y;
        touch_driver.cnt += 1;
        if (touch_driver.cnt < 100)
        {
            touch_event.status = TOUCH_MOVE;
        }
        else
        {
            if (touch_driver.cnt > 1000)
            {
                touch_event.status = TOUCH_DOWN10S;
            }
            else
            {
                touch_event.status = TOUCH_DOWN3S;
            }
        }
        touch_driver.touchmode |= (1 << touch_event.status);
        touch_driver.status = TOUCH_MOVE;
        touch_calcdisp ();

        return;
    }
    if ((touch_driver.status == TOUCH_DOWN) && (touch_driver.prev_status == TOUCH_MOVE))
    {
        /* Previous move with down, means move */
        touch_event.time = touch_driver.time;
        touch_event.dtime = touch_driver.time - touch_driver.prev_time;
        touch_event.x = touch_driver.x;
        touch_event.y = touch_driver.y;
        touch_event.dx = touch_driver.x - touch_driver.prev_x;
        touch_event.dy = touch_driver.y - touch_driver.prev_y;
        touch_driver.cnt += 1;
        if (touch_driver.cnt < 100)
        {
            touch_event.status = TOUCH_MOVE;
        }
        else
        {
            if (touch_driver.cnt > 1000)
            {
                touch_event.status = TOUCH_DOWN10S;
            }
            else
            {
                touch_event.status = TOUCH_DOWN3S;
            }
        }
        touch_driver.touchmode |= (1 << touch_event.status);
        touch_driver.status = TOUCH_MOVE;
        touch_calcdisp ();

        return;
    }
    if ((touch_driver.status == TOUCH_UP) && (touch_driver.prev_status == TOUCH_MOVE))
    {
        /* UP with previous move */
        touch_event.time = touch_driver.time;
        touch_event.dtime = touch_driver.prev_time - touch_driver.prev_time_down;
        touch_event.x = touch_driver.prev_x;
        touch_event.y = touch_driver.prev_y;
        touch_event.dx = touch_driver.prev_x - touch_driver.prev_x_down;
        touch_event.dy = touch_driver.prev_y - touch_driver.prev_y_down;
        touch_event.status = TOUCH_UP;
        touch_driver.touchmode |= (1 << touch_event.status);
        touch_driver.status = TOUCH_UP;
        touch_calcdisp ();

        return;
    }
    if ((touch_driver.status == TOUCH_UP) && (touch_driver.prev_status == TOUCH_DOWN))
    {
        /* UP without previous move */
        touch_event.time = touch_driver.time;
        touch_event.dtime = touch_driver.prev_time - touch_driver.prev_time_down;
        touch_event.x = touch_driver.prev_x;
        touch_event.y = touch_driver.prev_y;
        touch_event.dx = touch_driver.prev_x - touch_driver.prev_x_down;
        touch_event.dy = touch_driver.prev_y - touch_driver.prev_y_down;
        touch_event.status = TOUCH_UP;
        touch_driver.touchmode |= (1 << touch_event.status);
        touch_driver.status = TOUCH_UP;
        touch_calcdisp ();

        return;
    }
}
