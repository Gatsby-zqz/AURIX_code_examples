/**********************************************************************************************************************
 * \file tfthw.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "tfthw.h"
#include "Configuration.h"

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototype-------------------------------------------------*/
/*********************************************************************************************************************/
static void delay_us (uint32 time);
static void delay_ms (uint32 time);
static void tft_write_data_ili9486 (uint8 regaddr, uint16 *puiData, uint32 count);
static uint32 tft_terminate_endless_transfer (void);

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct
{
    struct
    {
        IfxQspi_SpiMaster         *spiMaster;
        IfxQspi_SpiMaster_Channel spiMasterChannel;
    } drivers;
} App_Qspi_Tft;

/*********************************************************************************************************************/
/*-----------------------------------------------------Macros--------------------------------------------------------*/
/*********************************************************************************************************************/
#if TFT_DISPLAY_VAR_LOCATION == 0
#if defined(__GNUC__)
#pragma section
#pragma section ".bss_cpu0" awc0
#endif
#if defined(__TASKING__)
#pragma section farbss "bss_cpu0"
#endif
#if defined(__DCC__)
#pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
#endif
#elif TFT_DISPLAY_VAR_LOCATION == 1
#if defined(__GNUC__)
#pragma section ".bss_cpu1" awc1
#endif
#if defined(__TASKING__)
#pragma section farbss "bss_cpu1"
#endif
#if defined(__DCC__)
#pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
#endif
#elif TFT_DISPLAY_VAR_LOCATION == 2
#if defined(__GNUC__)
#pragma section ".bss_cpu2" awc2
#endif
#if defined(__TASKING__)
#pragma section farbss "bss_cpu2"
#endif
#if defined(__DCC__)
#pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
#endif
#else
#error "Set TFT_DISPLAY_VAR_LOCATION to a valid value!"
#endif

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
volatile uint32 tft_status = 0;
volatile uint16 tft_id = 0;
volatile uint32 (*pCallbackFunction) (void) = (void *)0;
App_Qspi_Tft g_Qspi_Tft;

#if defined(__GNUC__)
#pragma section
#endif
#if defined(__TASKING__)
#pragma section farbss restore
#endif
#if defined(__DCC__)
#pragma section DATA RW
#endif

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementation-----------------------------------------------*/
/*********************************************************************************************************************/
/* Callback for TFT data transfer */
void tft_transmit_callback(void)
{
    /* Check that we are ready (no remaining bytes) in case that we are not using the DMA */
    if (g_Qspi_Tft.drivers.spiMaster->dma.useDma == 0)
    {
        if (g_Qspi_Tft.drivers.spiMasterChannel.base.tx.remaining)
        {
            return;
        }
    }

    /* If pCallbackFunction is valid then it is executed */
    if (pCallbackFunction != (void *)0)
    {
        pCallbackFunction();
    }
}

/* Function to init TFT */
void tft_init (void)
{
    /* Set the LCD backlight to output push-pull mode */
    IfxPort_setPinModeOutput(LCD_BACKLIGHT, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(LCD_BACKLIGHT);

    /* Set the LCD reset to output push-pull mode */
    IfxPort_setPinModeOutput(LCD_RESET, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(LCD_RESET);

    /* Set the LCD reset to output push-pull mode */
    IfxPort_setPinModeOutput(LCD_DC, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    // CS to TFT
    IfxPort_setPinModeInput(TFT_USE_CHIPSELECT.pin.port, TFT_USE_CHIPSELECT.pin.pinIndex, IfxPort_Mode_inputPullUp);

    g_Qspi_Tft.drivers.spiMaster = TFT_QSPI_INIT();
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    /* Create channel config */
#if defined(__DCC__)
    /* Bug on DCC not all bits in mode are cleared */
    memset(&spiMasterChannelConfig, 0, sizeof(spiMasterChannelConfig));
#endif
    IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, g_Qspi_Tft.drivers.spiMaster);

    /* Set the baudrate for this channel */
    spiMasterChannelConfig.base.baudrate = 20000000;

    /* Set the transfer data width */
    spiMasterChannelConfig.base.mode.dataWidth = 16;
    spiMasterChannelConfig.base.mode.csLeadDelay = SpiIf_SlsoTiming_1;
    spiMasterChannelConfig.base.mode.csTrailDelay = SpiIf_SlsoTiming_0;
    spiMasterChannelConfig.base.mode.csInactiveDelay = SpiIf_SlsoTiming_0;
    spiMasterChannelConfig.base.mode.shiftClock = SpiIf_ShiftClock_shiftTransmitDataOnTrailingEdge;

    const IfxQspi_SpiMaster_Output slsOutput = {&TFT_USE_CHIPSELECT,
                                                IfxPort_OutputMode_pushPull,
                                                IfxPort_PadDriver_cmosAutomotiveSpeed1};

    spiMasterChannelConfig.sls.output.pin    = slsOutput.pin;
    spiMasterChannelConfig.sls.output.mode   = slsOutput.mode;
    spiMasterChannelConfig.sls.output.driver = slsOutput.driver;

    /* Initialize channel */
    IfxQspi_SpiMaster_initChannel(&g_Qspi_Tft.drivers.spiMasterChannel,
        &spiMasterChannelConfig);

    /* Enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);

    /* Set TFT id */
    tft_id = 0x9486;

    pCallbackFunction = (void *)0;

    if (tft_id == 0x9486)
    {
        /* This is an ILI9486 controller:
           we will send max. 15 values + 1 value for last write */

        uint16 uwData[16];
        /* Start Initial Sequence:
           Setting from display supplier */
        uwData[0] = 0x0036;
        uwData[1] = 0x0004;
        uwData[2] = 0x0000;
        uwData[3] = 0x003C;
        uwData[4] = 0x000F;
        uwData[5] = 0x000F;
        uwData[6] = 0x00A4;
        uwData[7] = 0x0002;
        uwData[8] = 0x0000;
        tft_write_data_ili9486(0xF1, &uwData[0], 8);

        /* Setting from display supplier */
        uwData[0] = 0x0018;
        uwData[1] = 0x00A3;
        uwData[2] = 0x0012;
        uwData[3] = 0x0002;
        uwData[4] = 0x0032;
        uwData[5] = 0x0012;
        uwData[6] = 0x00FF;
        uwData[7] = 0x0032;
        uwData[8] = 0x0000;
        tft_write_data_ili9486(0xF2, &uwData[0], 6);

        /* Setting from display supplier */
        uwData[0] = 0x0040;
        uwData[1] = 0x0000;
        uwData[2] = 0x0008;
        uwData[3] = 0x0091;
        uwData[4] = 0x0004;
        uwData[5] = 0x0000;
        tft_write_data_ili9486(0xF4, &uwData[0], 6);

        /* Setting from display supplier */
        uwData[0] = 0x0021;
        uwData[1] = 0x0004;
        uwData[2] = 0x0000;
        tft_write_data_ili9486(0xF8, &uwData[0], 3);

        /* Power Control 1 */
        uwData[0] = 0x0019;
        uwData[1] = 0x001A;
        uwData[2] = 0x0000;
        tft_write_data_ili9486(0xC0, &uwData[0], 3);

        /* Power Control 2 */
        uwData[0] = 0x0045;
        uwData[1] = 0x0000;
        uwData[2] = 0x0000;
        tft_write_data_ili9486(0xC1, &uwData[0], 3);

        /* Power Control 3 (normal mode) */
        uwData[0] = 0x0033;
        uwData[1] = 0x0000;
        tft_write_data_ili9486(0xC2, &uwData[0], 2);

        /* VCOM Control */
        uwData[0] = 0x0000;
        uwData[1] = 0x0028;
        uwData[2] = 0x0000;
        tft_write_data_ili9486(0xC5, &uwData[0], 3);

        /* Memory Access Control */
        uwData[0] = 0x0068;
        uwData[1] = 0x0000;
        tft_write_data_ili9486(0x36, &uwData[0], 2);

        /* Interface Pixel Format Set */
        uwData[0] = 0x0055;
        uwData[1] = 0x0000;
        tft_write_data_ili9486(0x3A, &uwData[0], 2);

        /* Frame Rate Control (in Normal Mode) */
        uwData[0] = 0x00A0;
        uwData[1] = 0x0011;
        uwData[2] = 0x0000;
        tft_write_data_ili9486(0xB1, &uwData[0], 3);

        /* Display Function Control */
        uwData[0] = 0x0000;
        uwData[1] = 0x0042;
        uwData[2] = 0x003B;
        uwData[3] = 0x0000;
        tft_write_data_ili9486(0xB6, &uwData[0], 4);

        /* Interface Control */
        uwData[0] = 0x0001;
        uwData[1] = 0x0030;
        uwData[2] = 0x0000;
        tft_write_data_ili9486(0xF6, &uwData[0], 3);

        /* Gamma Function Disable */
        uwData[0] = 0x0000;
        uwData[1] = 0x0000;
        tft_write_data_ili9486(0xF2, &uwData[0], 2);

        /* Gamma curve selected */
        uwData[0] = 0x0001;
        uwData[1] = 0x0000;
        tft_write_data_ili9486(0x26, &uwData[0], 2);

        /* Positive Gamma Correction */
        uwData[0]  = 0x001F;
        uwData[1]  = 0x0025;
        uwData[2]  = 0x0022;
        uwData[3]  = 0x000B;
        uwData[4]  = 0x0006;
        uwData[5]  = 0x000A;
        uwData[6]  = 0x004E;
        uwData[7]  = 0x00C6;
        uwData[8]  = 0x0039;
        uwData[9]  = 0x0000;
        uwData[10] = 0x0000;
        uwData[11] = 0x0000;
        uwData[12] = 0x0000;
        uwData[13] = 0x0000;
        uwData[14] = 0x0000;
        uwData[15] = 0x0000;
        tft_write_data_ili9486(0xE0, &uwData[0], 16);

        /* Negative Gamma Correction */
        uwData[0]  = 0x001F;
        uwData[1]  = 0x003F;
        uwData[2]  = 0x003F;
        uwData[3]  = 0x000F;
        uwData[4]  = 0x001F;
        uwData[5]  = 0x000F;
        uwData[6]  = 0x0046;
        uwData[7]  = 0x0049;
        uwData[8]  = 0x0031;
        uwData[9]  = 0x0005;
        uwData[10] = 0x0009;
        uwData[11] = 0x0003;
        uwData[12] = 0x001C;
        uwData[13] = 0x001A;
        uwData[14] = 0x0000;
        uwData[15] = 0x0000;
        tft_write_data_ili9486(0xE1, &uwData[0], 16);

        /* Column Address Set */
        uwData[0] = 0x0000;
        uwData[1] = 0x0000;
        uwData[2] = ((TFT_XSIZE-1) & 0xFF00)>>8;
        uwData[3] = (TFT_XSIZE-1) & 0x00FF;
        uwData[4] = 0x0000;
        tft_write_data_ili9486(0x2A, &uwData[0], 5);

        /* Page Address set */
        uwData[0] = 0x0000;
        uwData[1] = 0x0000;
        uwData[2] = ((TFT_YSIZE-1) & 0xFF00)>>8;
        uwData[3] = (TFT_YSIZE-1) & 0x00FF;
        uwData[4] = 0x0000;
        tft_write_data_ili9486(0x2B, &uwData[0], 5);

        /* Sleep OUT */
        uwData[0] = 0x0000;
        tft_write_data_ili9486(0x11, &uwData[0], 1);

        // Driver delay 120ms */
        delay_ms (120);

        /* Display ON */
        uwData[0] = 0x0000;
        tft_write_data_ili9486(0x29, &uwData[0], 1);
    }
}

/* Function to set the pixel datapointer to x,y location */
void tft_display_setxy (uint32 x1, uint32 y1, uint32 x2, uint32 y2)
{
    if (tft_id == 0x9486)
    {
        uint16 uwData[5];

        uwData[0] = (uint16) (x1 >> 8);
        uwData[1] = (uint16) x1;
        uwData[2] = (uint16) (x2 >> 8);
        uwData[3] = (uint16) x2;
        uwData[4] = 0x0000;
        /* Column Address Set, we change only the start (2 Parameters) */
        tft_write_data_ili9486(0x2A, &uwData[0], 5);

        uwData[0] = (uint16) (y1 >> 8);
        uwData[1] = (uint16) y1;
        uwData[2] = (uint16) (y2 >> 8);
        uwData[3] = (uint16) y2;
        uwData[4] = 0x0000;
        /* Page Address Set, we change only the start (2 Parameters) */
        tft_write_data_ili9486(0x2B, &uwData[0], 5);

        uwData[0] = (uint16) (x1 >> 8);
        uwData[1] = (uint16) x1;
        uwData[2] = 0x0000;
        /* Column Address Set, we change only the start (2 Parameters) */
        tft_write_data_ili9486(0x2A, &uwData[0], 3);

        uwData[0] = (uint16) (y1 >> 8);
        uwData[1] = (uint16) y1;
        uwData[2] = 0x0000;
        /* Page Address Set, we change only the start (2 Parameters) */
        tft_write_data_ili9486(0x2B, &uwData[0], 3);
    }
}

/* Function to flush the actual row buff and callback pFunc if finished */
void tft_flush_row_buff( uint32 numberOfPixel, const void * buff)
{
    uint16 tx_data;

    /* TFT not busy */
    if (tft_status == 0)
    {
        if (tft_id == 0x9486){

            /* Set register address for ILI9486 */
            tx_data =  0x2C;
        }

        /* Wait until SPI is no longer busy (should not busy here) */
        while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Tft.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

        /* Command */
        IfxPort_setPinLow(LCD_DC);
        /* Send the address to the display */
        IfxQspi_SpiMaster_exchange(&g_Qspi_Tft.drivers.spiMasterChannel, &tx_data, 0, 1);
    }

    /* TFT busy */
    tft_status = 1;

    /* Wait until SPI is no longer busy (should not busy here) */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Tft.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

    /* Data */
    IfxPort_setPinHigh(LCD_DC);
    /* Send the values to the display */
    IfxQspi_SpiMaster_exchange(&g_Qspi_Tft.drivers.spiMasterChannel, buff, 0, (sint16)(numberOfPixel));

    tft_terminate_endless_transfer();
}

/* Delay (microseconds) */
static void delay_us (uint32 time)
{
    volatile sint32 test;
    uint32 i;
    test = 0;
    for (i = 0; i < time; i += 1)
    {
        test += 1;
    }
}

/* Delay (milliseconds) */
static void delay_ms (uint32 time)
{
    while (time--)
    {
        delay_us (1000);
    }
}

/* Function to send commands/data to TFT */
static void tft_write_data_ili9486 (uint8 regaddr, uint16 *puiData, uint32 count)
{
    uint16 tx_data;

    /* Wait until SPI is no longer busy (should not busy here) */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Tft.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

    tx_data = regaddr;

    /* Command */
    IfxPort_setPinLow(LCD_DC);
    /* Send the command to the display */
    IfxQspi_SpiMaster_exchange(&g_Qspi_Tft.drivers.spiMasterChannel, &tx_data, 0, 1);

    /* Wait until SPI is no longer busy */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Tft.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

    /* Data */
    IfxPort_setPinHigh(LCD_DC);
    /* Send the data to the display */
    IfxQspi_SpiMaster_exchange(&g_Qspi_Tft.drivers.spiMasterChannel, puiData, 0, (sint16)(count));

    /* Wait until Spi is no longer busy */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Tft.drivers.spiMasterChannel) == SpiIf_Status_busy) {};
}

/* Function to terminate TFT data transfer */
static uint32 tft_terminate_endless_transfer (void)
{
    uint16 tx_data;

    /* First we reset the callback function to 0 */
    pCallbackFunction = (void *)0;

    /* Wait until SPI is no longer busy (wait until receive is finished) */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Tft.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

    tx_data = 0;

    /* Command */
    IfxPort_setPinLow(LCD_DC);
    /* Send the command to the display */
    IfxQspi_SpiMaster_exchange(&g_Qspi_Tft.drivers.spiMasterChannel, &tx_data, 0, 1);

    /* Wait until SPI is no longer busy */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_Tft.drivers.spiMasterChannel) == SpiIf_Status_busy) {};

    /* TFT no longer busy */
    tft_status = 0;

    return 0;
}
