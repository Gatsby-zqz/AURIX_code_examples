
FreeRTOS_13K.elf:     file format elf32-kungfu32-little


Disassembly of section .start_tc0:

80000000 <_start>:
##@@@F_:_start():
80000000:	20 5c 00 00 	MOVL      R0, #0			;->0x0000
80000004:	40 5c 01 d0 	MOVH      R0, #53249			;->0xD001
##@@@P_:startup_Tc0.s:25
##@@@L0020_:	.align	2   
##@@@L0021_:	.type	_start, @function   
##@@@L0022_:_start:   
##@@@L0023_://++++++++++++++++++++++++++++sp   
##@@@L0024_:	MOV 	R0,	#__initial_sp   
##@@@L0025_:	MOV 	SP,	R0   
80000008:	c0 59       	MOV       SP, R0
##@@@P_:startup_Tc0.s:27
##@@@L0026_://++++++++++++++++++++++++++++one isr size   
##@@@L0027_:	MOV 	R0,	#0x20   
8000000a:	00 12       	MOV       R0, #32			;->0x0020
8000000c:	20 5c 00 e0 	MOVL      R0, #57344			;->0xE000
80000010:	40 5c 01 80 	MOVH      R0, #32769			;->0x8001
##@@@P_:startup_Tc0.s:30
##@@@L0028_:	   
##@@@L0029_://++++++++++++++++++++++++++++isr table enter   
##@@@L0030_:	MOV 	R0,	#LCF_INTVEC0_START   
80000014:	20 5c 1c 19 	MOVL      R0, #6428			;->0x191C
80000018:	40 5c 00 80 	MOVH      R0, #32768			;->0x8000
##@@@P_:startup_Tc0.s:34
##@@@L0031_:	   
##@@@L0032_://++++++++++++++++++++++++++++   
##@@@L0033_:	MOV 	R0, # __Core0_start   
##@@@L0034_:	LJMP 	R0   
8000001c:	00 5c       	LJMP      R0
##@@@P_:startup_Tc0.s:36
##@@@L0035_://++++++++++++++++++++++++++++   
##@@@L0036_:	SJMP $   
8000001e:	00 04       	SJMP      $+0                   ;->0x8000001e

Disassembly of section .traptab_tc0:

80000800 <_cpu0_trap_table>:
##@@@F_:_cpu0_trap_table():
##@@@P_:Trap_Debug_tc0.c:77
##@@@L0072_:// 2^5=32   
##@@@L0073_:#define KFX_WEAK_Trap0_Interrupt(name) 	__asm__(".align 2\n\t JMP  "#name);   
##@@@L0074_:
##@@@L0075_:__attribute__((section(".traptab_cpu0")))   
##@@@L0076_:void _cpu0_trap_table (void)   
##@@@L0077_:{   
80000800:	00 03 80 02 	JMP       $+640                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:78
##@@@L0078_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000804:	00 03 7e 02 	JMP       $+638                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:79
##@@@L0079_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000808:	00 03 7c 02 	JMP       $+636                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:80
##@@@L0080_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000080c:	00 03 7a 02 	JMP       $+634                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:81
##@@@L0081_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000810:	00 03 78 02 	JMP       $+632                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:82
##@@@L0082_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000814:	00 03 76 02 	JMP       $+630                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:83
##@@@L0083_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000818:	00 03 74 02 	JMP       $+628                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:84
##@@@L0084_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000081c:	00 03 72 02 	JMP       $+626                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:85
##@@@L0085_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000820:	00 03 70 02 	JMP       $+624                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:86
##@@@L0086_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000824:	00 03 6e 02 	JMP       $+622                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:87
##@@@L0087_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000828:	00 03 6c 02 	JMP       $+620                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:88
##@@@L0088_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000082c:	00 03 6a 02 	JMP       $+618                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:89
##@@@L0089_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000830:	00 03 68 02 	JMP       $+616                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:90
##@@@L0090_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000834:	00 03 66 02 	JMP       $+614                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:91
##@@@L0091_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000838:	00 03 64 02 	JMP       $+612                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:92
##@@@L0092_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000083c:	00 03 62 02 	JMP       $+610                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:93
##@@@L0093_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000840:	00 03 60 02 	JMP       $+608                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:94
##@@@L0094_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000844:	00 03 5e 02 	JMP       $+606                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:95
##@@@L0095_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000848:	00 03 5c 02 	JMP       $+604                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:96
##@@@L0096_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000084c:	00 03 5a 02 	JMP       $+602                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:97
##@@@L0097_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000850:	00 03 58 02 	JMP       $+600                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:99
##@@@L0098_:
##@@@L0099_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000854:	00 03 56 02 	JMP       $+598                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:100
##@@@L0100_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000858:	00 03 54 02 	JMP       $+596                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:101
##@@@L0101_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000085c:	00 03 52 02 	JMP       $+594                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:102
##@@@L0102_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000860:	00 03 50 02 	JMP       $+592                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:103
##@@@L0103_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000864:	00 03 4e 02 	JMP       $+590                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:104
##@@@L0104_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000868:	00 03 4c 02 	JMP       $+588                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:105
##@@@L0105_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000086c:	00 03 4a 02 	JMP       $+586                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:106
##@@@L0106_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000870:	00 03 48 02 	JMP       $+584                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:107
##@@@L0107_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000874:	00 03 46 02 	JMP       $+582                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:108
##@@@L0108_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000878:	00 03 44 02 	JMP       $+580                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:109
##@@@L0109_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000087c:	00 03 42 02 	JMP       $+578                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:110
##@@@L0110_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000880:	00 03 40 02 	JMP       $+576                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:111
##@@@L0111_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000884:	00 03 3e 02 	JMP       $+574                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:112
##@@@L0112_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000888:	00 03 3c 02 	JMP       $+572                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:113
##@@@L0113_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000088c:	00 03 3a 02 	JMP       $+570                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:114
##@@@L0114_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000890:	00 03 38 02 	JMP       $+568                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:115
##@@@L0115_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000894:	00 03 36 02 	JMP       $+566                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:116
##@@@L0116_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000898:	00 03 34 02 	JMP       $+564                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:117
##@@@L0117_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000089c:	00 03 32 02 	JMP       $+562                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:118
##@@@L0118_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008a0:	00 03 30 02 	JMP       $+560                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:120
##@@@L0119_:
##@@@L0120_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008a4:	00 03 2e 02 	JMP       $+558                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:121
##@@@L0121_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008a8:	00 03 2c 02 	JMP       $+556                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:122
##@@@L0122_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008ac:	00 03 2a 02 	JMP       $+554                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:123
##@@@L0123_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008b0:	00 03 28 02 	JMP       $+552                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:124
##@@@L0124_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008b4:	00 03 26 02 	JMP       $+550                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:125
##@@@L0125_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008b8:	00 03 24 02 	JMP       $+548                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:126
##@@@L0126_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008bc:	00 03 22 02 	JMP       $+546                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:127
##@@@L0127_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008c0:	00 03 20 02 	JMP       $+544                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:128
##@@@L0128_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008c4:	00 03 1e 02 	JMP       $+542                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:129
##@@@L0129_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008c8:	00 03 1c 02 	JMP       $+540                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:130
##@@@L0130_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008cc:	00 03 1a 02 	JMP       $+538                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:131
##@@@L0131_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008d0:	00 03 18 02 	JMP       $+536                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:132
##@@@L0132_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008d4:	00 03 16 02 	JMP       $+534                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:133
##@@@L0133_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008d8:	00 03 14 02 	JMP       $+532                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:134
##@@@L0134_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008dc:	00 03 12 02 	JMP       $+530                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:135
##@@@L0135_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008e0:	00 03 10 02 	JMP       $+528                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:136
##@@@L0136_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008e4:	00 03 0e 02 	JMP       $+526                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:137
##@@@L0137_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008e8:	00 03 0c 02 	JMP       $+524                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:138
##@@@L0138_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008ec:	00 03 0a 02 	JMP       $+522                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:139
##@@@L0139_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008f0:	00 03 08 02 	JMP       $+520                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:141
##@@@L0140_:
##@@@L0141_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008f4:	00 03 06 02 	JMP       $+518                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:142
##@@@L0142_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008f8:	00 03 04 02 	JMP       $+516                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:143
##@@@L0143_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
800008fc:	00 03 02 02 	JMP       $+514                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:144
##@@@L0144_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000900:	00 03 00 02 	JMP       $+512                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:145
##@@@L0145_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000904:	00 03 fe 01 	JMP       $+510                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:146
##@@@L0146_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000908:	00 03 fc 01 	JMP       $+508                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:147
##@@@L0147_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000090c:	00 03 fa 01 	JMP       $+506                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:148
##@@@L0148_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000910:	00 03 f8 01 	JMP       $+504                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:149
##@@@L0149_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000914:	00 03 f6 01 	JMP       $+502                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:150
##@@@L0150_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000918:	00 03 f4 01 	JMP       $+500                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:151
##@@@L0151_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000091c:	00 03 f2 01 	JMP       $+498                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:152
##@@@L0152_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000920:	00 03 f0 01 	JMP       $+496                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:153
##@@@L0153_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000924:	00 03 ee 01 	JMP       $+494                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:154
##@@@L0154_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000928:	00 03 ec 01 	JMP       $+492                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:155
##@@@L0155_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000092c:	00 03 ea 01 	JMP       $+490                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:156
##@@@L0156_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000930:	00 03 e8 01 	JMP       $+488                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:157
##@@@L0157_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000934:	00 03 e6 01 	JMP       $+486                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:158
##@@@L0158_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
80000938:	00 03 e4 01 	JMP       $+484                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:159
##@@@L0159_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
8000093c:	00 03 e2 01 	JMP       $+482                 ;->0x80000d00
##@@@P_:Trap_Debug_tc0.c:161
##@@@L0160_:	KFX_WEAK_Trap0_Interrupt( debugROM);   
##@@@L0161_:}   
80000940:	1d 5c       	JMP       LR
	...

80000d00 <debugROM>:
##@@@F_:debugROM():
80000d00:	00 00       	NOP      NOP      
	...

80000d04 <entry_loop>:
80000d04:	22 5c 00 81 	MOVL      R2, #33024			;->0x8100
80000d08:	42 5c 00 f9 	MOVH      R2, #63744			;->0xF900
80000d0c:	10 10       	MOV       R1, #0			;->0x0000
80000d0e:	21 85       	ST.W      [R2], R1
80000d10:	22 5c 00 84 	MOVL      R2, #33792			;->0x8400
80000d14:	42 5c 00 f9 	MOVH      R2, #63744			;->0xF900
80000d18:	12 80       	LD.B      R1, [R2]
80000d1a:	11 38       	CMP       R1, #1			;->0x01
80000d1c:	06 f0       	JZ        $+6                   ;->0x80000d28
80000d1e:	00 00       	NOP      NOP      
80000d20:	12 38       	CMP       R1, #2			;->0x02
80000d22:	0c f0       	JZ        $+12                  ;->0x80000d3a
80000d24:	f0 07       	SJMP      $-16                  ;->0x80000d04
	...

80000d28 <going>:
80000d28:	00 00       	NOP      NOP      
80000d2a:	10 10       	MOV       R1, #0			;->0x0000
80000d2c:	22 5c 08 81 	MOVL      R2, #33032			;->0x8108
80000d30:	42 5c 00 f9 	MOVH      R2, #63744			;->0xF900
80000d34:	21 85       	ST.W      [R2], R1
80000d36:	e7 07       	SJMP      $-25                  ;->0x80000d04
	...

80000d3a <_resume>:
80000d3a:	00 00       	NOP      NOP      
80000d3c:	00 00       	NOP      NOP      
80000d3e:	10 10       	MOV       R1, #0			;->0x0000
80000d40:	22 5c 10 81 	MOVL      R2, #33040			;->0x8110
80000d44:	42 5c 00 f9 	MOVH      R2, #63744			;->0xF900
80000d48:	21 85       	ST.W      [R2], R1
80000d4a:	00 00       	NOP      NOP      
80000d4c:	00 00       	NOP      NOP      
80000d4e:	0c 00       	MRET     MRET     
	...

80000d52 <_exception>:
80000d52:	d9 07       	SJMP      $-39                  ;->0x80000d04
	...

Disassembly of section .inttab_tc0_000:

8001e000 <__iVecEntry0_0>:
##@@@F_:__iVecEntry0_0():
##@@@P_:Cpu0_Main.c:43
##@@@L0038_:#else   
##@@@L0039_:extern void interruptSwGp0Sr0(void);   
##@@@L0040_:extern void interruptSystick(void);   
##@@@L0041_:#endif   
##@@@L0042_:KFX_INTERRUPT_INTERNAL(interruptSystick, 0, 1);   
##@@@L0043_:KFX_INTERRUPT_INTERNAL(interruptSwGp0Sr0, 0, 0);   
8001e000:	25 5d       	PUSH      R5
8001e002:	2d 5d       	PUSH      LR
8001e004:	25 5c 58 91 	MOVL      R5, #37208			;->0x9158
8001e008:	45 5c 00 80 	MOVH      R5, #32768			;->0x8000
8001e00c:	05 5c       	LJMP      R5
8001e00e:	0d 5d       	POP       LR
8001e010:	05 5d       	POP       R5
8001e012:	0c 00       	MRET     MRET     
8001e014:	1d 5c       	JMP       LR
8001e016:	00 00       	NOP      NOP      
##@@@P_:weak_interrupt_tc0.c:28
##@@@L0023_:**                      Includes                                              **   
##@@@L0024_:*******************************************************************************/   
##@@@L0025_:
##@@@L0026_:#include "Kfx_Ssw.h"   
##@@@L0027_:
##@@@L0028_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 0);   
8001e018:	00 04       	SJMP      $+0                   ;->0x8001e018
8001e01a:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_001:

8001e020 <__iVecEntry0_1>:
##@@@F_:__iVecEntry0_1():
##@@@P_:Cpu0_Main.c:42
##@@@L0037_:}   
##@@@L0038_:#else   
##@@@L0039_:extern void interruptSwGp0Sr0(void);   
##@@@L0040_:extern void interruptSystick(void);   
##@@@L0041_:#endif   
##@@@L0042_:KFX_INTERRUPT_INTERNAL(interruptSystick, 0, 1);   
8001e020:	25 5d       	PUSH      R5
8001e022:	2d 5d       	PUSH      LR
8001e024:	25 5c 70 90 	MOVL      R5, #36976			;->0x9070
8001e028:	45 5c 00 80 	MOVH      R5, #32768			;->0x8000
8001e02c:	05 5c       	LJMP      R5
8001e02e:	0d 5d       	POP       LR
8001e030:	05 5d       	POP       R5
8001e032:	0c 00       	MRET     MRET     
8001e034:	1d 5c       	JMP       LR
8001e036:	00 00       	NOP      NOP      
##@@@P_:weak_interrupt_tc0.c:29
##@@@L0029_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 1);   
8001e038:	00 04       	SJMP      $+0                   ;->0x8001e038
8001e03a:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_002:

8001e040 <__iVecEntry0_2>:
##@@@F_:__iVecEntry0_2():
##@@@P_:weak_interrupt_tc0.c:30
##@@@L0030_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 2);   
8001e040:	00 04       	SJMP      $+0                   ;->0x8001e040
8001e042:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_003:

8001e060 <__iVecEntry0_3>:
##@@@F_:__iVecEntry0_3():
##@@@P_:weak_interrupt_tc0.c:31
##@@@L0031_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 3);   
8001e060:	00 04       	SJMP      $+0                   ;->0x8001e060
8001e062:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_004:

8001e080 <__iVecEntry0_4>:
##@@@F_:__iVecEntry0_4():
##@@@P_:weak_interrupt_tc0.c:32
##@@@L0032_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 4);   
8001e080:	00 04       	SJMP      $+0                   ;->0x8001e080
8001e082:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_005:

8001e0a0 <__iVecEntry0_5>:
##@@@F_:__iVecEntry0_5():
##@@@P_:weak_interrupt_tc0.c:33
##@@@L0033_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 5);   
8001e0a0:	00 04       	SJMP      $+0                   ;->0x8001e0a0
8001e0a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_006:

8001e0c0 <__iVecEntry0_6>:
##@@@F_:__iVecEntry0_6():
##@@@P_:weak_interrupt_tc0.c:34
##@@@L0034_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 6);   
8001e0c0:	00 04       	SJMP      $+0                   ;->0x8001e0c0
8001e0c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_007:

8001e0e0 <__iVecEntry0_7>:
##@@@F_:__iVecEntry0_7():
##@@@P_:weak_interrupt_tc0.c:35
##@@@L0035_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 7);   
8001e0e0:	00 04       	SJMP      $+0                   ;->0x8001e0e0
8001e0e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_008:

8001e100 <__iVecEntry0_8>:
##@@@F_:__iVecEntry0_8():
##@@@P_:weak_interrupt_tc0.c:36
##@@@L0036_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 8);   
8001e100:	00 04       	SJMP      $+0                   ;->0x8001e100
8001e102:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_009:

8001e120 <__iVecEntry0_9>:
##@@@F_:__iVecEntry0_9():
##@@@P_:weak_interrupt_tc0.c:37
##@@@L0037_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 9);   
8001e120:	00 04       	SJMP      $+0                   ;->0x8001e120
8001e122:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_00A:

8001e140 <__iVecEntry0_10>:
##@@@F_:__iVecEntry0_10():
##@@@P_:weak_interrupt_tc0.c:38
##@@@L0038_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 10);   
8001e140:	00 04       	SJMP      $+0                   ;->0x8001e140
8001e142:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_00B:

8001e160 <__iVecEntry0_11>:
##@@@F_:__iVecEntry0_11():
##@@@P_:weak_interrupt_tc0.c:39
##@@@L0039_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 11);   
8001e160:	00 04       	SJMP      $+0                   ;->0x8001e160
8001e162:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_00C:

8001e180 <__iVecEntry0_12>:
##@@@F_:__iVecEntry0_12():
##@@@P_:weak_interrupt_tc0.c:40
##@@@L0040_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 12);   
8001e180:	00 04       	SJMP      $+0                   ;->0x8001e180
8001e182:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_00D:

8001e1a0 <__iVecEntry0_13>:
##@@@F_:__iVecEntry0_13():
##@@@P_:weak_interrupt_tc0.c:41
##@@@L0041_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 13);   
8001e1a0:	00 04       	SJMP      $+0                   ;->0x8001e1a0
8001e1a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_00E:

8001e1c0 <__iVecEntry0_14>:
##@@@F_:__iVecEntry0_14():
##@@@P_:weak_interrupt_tc0.c:42
##@@@L0042_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 14);   
8001e1c0:	00 04       	SJMP      $+0                   ;->0x8001e1c0
8001e1c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_00F:

8001e1e0 <__iVecEntry0_15>:
##@@@F_:__iVecEntry0_15():
##@@@P_:weak_interrupt_tc0.c:43
##@@@L0043_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 15);   
8001e1e0:	00 04       	SJMP      $+0                   ;->0x8001e1e0
8001e1e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_010:

8001e200 <__iVecEntry0_16>:
##@@@F_:__iVecEntry0_16():
##@@@P_:weak_interrupt_tc0.c:44
##@@@L0044_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 16);   
8001e200:	00 04       	SJMP      $+0                   ;->0x8001e200
8001e202:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_011:

8001e220 <__iVecEntry0_17>:
##@@@F_:__iVecEntry0_17():
##@@@P_:weak_interrupt_tc0.c:45
##@@@L0045_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 17);   
8001e220:	00 04       	SJMP      $+0                   ;->0x8001e220
8001e222:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_012:

8001e240 <__iVecEntry0_18>:
##@@@F_:__iVecEntry0_18():
##@@@P_:weak_interrupt_tc0.c:46
##@@@L0046_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 18);   
8001e240:	00 04       	SJMP      $+0                   ;->0x8001e240
8001e242:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_013:

8001e260 <__iVecEntry0_19>:
##@@@F_:__iVecEntry0_19():
##@@@P_:weak_interrupt_tc0.c:47
##@@@L0047_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 19);   
8001e260:	00 04       	SJMP      $+0                   ;->0x8001e260
8001e262:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_014:

8001e280 <__iVecEntry0_20>:
##@@@F_:__iVecEntry0_20():
##@@@P_:weak_interrupt_tc0.c:48
##@@@L0048_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 20);   
8001e280:	00 04       	SJMP      $+0                   ;->0x8001e280
8001e282:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_015:

8001e2a0 <__iVecEntry0_21>:
##@@@F_:__iVecEntry0_21():
##@@@P_:weak_interrupt_tc0.c:49
##@@@L0049_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 21);   
8001e2a0:	00 04       	SJMP      $+0                   ;->0x8001e2a0
8001e2a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_016:

8001e2c0 <__iVecEntry0_22>:
##@@@F_:__iVecEntry0_22():
##@@@P_:weak_interrupt_tc0.c:50
##@@@L0050_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 22);   
8001e2c0:	00 04       	SJMP      $+0                   ;->0x8001e2c0
8001e2c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_017:

8001e2e0 <__iVecEntry0_23>:
##@@@F_:__iVecEntry0_23():
##@@@P_:weak_interrupt_tc0.c:51
##@@@L0051_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 23);   
8001e2e0:	00 04       	SJMP      $+0                   ;->0x8001e2e0
8001e2e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_018:

8001e300 <__iVecEntry0_24>:
##@@@F_:__iVecEntry0_24():
##@@@P_:weak_interrupt_tc0.c:52
##@@@L0052_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 24);   
8001e300:	00 04       	SJMP      $+0                   ;->0x8001e300
8001e302:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_019:

8001e320 <__iVecEntry0_25>:
##@@@F_:__iVecEntry0_25():
##@@@P_:weak_interrupt_tc0.c:53
##@@@L0053_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 25);   
8001e320:	00 04       	SJMP      $+0                   ;->0x8001e320
8001e322:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_01A:

8001e340 <__iVecEntry0_26>:
##@@@F_:__iVecEntry0_26():
##@@@P_:weak_interrupt_tc0.c:54
##@@@L0054_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 26);   
8001e340:	00 04       	SJMP      $+0                   ;->0x8001e340
8001e342:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_01B:

8001e360 <__iVecEntry0_27>:
##@@@F_:__iVecEntry0_27():
##@@@P_:weak_interrupt_tc0.c:55
##@@@L0055_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 27);   
8001e360:	00 04       	SJMP      $+0                   ;->0x8001e360
8001e362:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_01C:

8001e380 <__iVecEntry0_28>:
##@@@F_:__iVecEntry0_28():
##@@@P_:weak_interrupt_tc0.c:56
##@@@L0056_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 28);   
8001e380:	00 04       	SJMP      $+0                   ;->0x8001e380
8001e382:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_01D:

8001e3a0 <__iVecEntry0_29>:
##@@@F_:__iVecEntry0_29():
##@@@P_:weak_interrupt_tc0.c:57
##@@@L0057_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 29);   
8001e3a0:	00 04       	SJMP      $+0                   ;->0x8001e3a0
8001e3a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_01E:

8001e3c0 <__iVecEntry0_30>:
##@@@F_:__iVecEntry0_30():
##@@@P_:weak_interrupt_tc0.c:58
##@@@L0058_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 30);   
8001e3c0:	00 04       	SJMP      $+0                   ;->0x8001e3c0
8001e3c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_01F:

8001e3e0 <__iVecEntry0_31>:
##@@@F_:__iVecEntry0_31():
##@@@P_:weak_interrupt_tc0.c:59
##@@@L0059_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 31);   
8001e3e0:	00 04       	SJMP      $+0                   ;->0x8001e3e0
8001e3e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_020:

8001e400 <__iVecEntry0_32>:
##@@@F_:__iVecEntry0_32():
##@@@P_:weak_interrupt_tc0.c:60
##@@@L0060_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 32);   
8001e400:	00 04       	SJMP      $+0                   ;->0x8001e400
8001e402:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_021:

8001e420 <__iVecEntry0_33>:
##@@@F_:__iVecEntry0_33():
##@@@P_:weak_interrupt_tc0.c:61
##@@@L0061_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 33);   
8001e420:	00 04       	SJMP      $+0                   ;->0x8001e420
8001e422:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_022:

8001e440 <__iVecEntry0_34>:
##@@@F_:__iVecEntry0_34():
##@@@P_:weak_interrupt_tc0.c:62
##@@@L0062_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 34);   
8001e440:	00 04       	SJMP      $+0                   ;->0x8001e440
8001e442:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_023:

8001e460 <__iVecEntry0_35>:
##@@@F_:__iVecEntry0_35():
##@@@P_:weak_interrupt_tc0.c:63
##@@@L0063_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 35);   
8001e460:	00 04       	SJMP      $+0                   ;->0x8001e460
8001e462:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_024:

8001e480 <__iVecEntry0_36>:
##@@@F_:__iVecEntry0_36():
##@@@P_:weak_interrupt_tc0.c:64
##@@@L0064_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 36);   
8001e480:	00 04       	SJMP      $+0                   ;->0x8001e480
8001e482:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_025:

8001e4a0 <__iVecEntry0_37>:
##@@@F_:__iVecEntry0_37():
##@@@P_:weak_interrupt_tc0.c:65
##@@@L0065_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 37);   
8001e4a0:	00 04       	SJMP      $+0                   ;->0x8001e4a0
8001e4a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_026:

8001e4c0 <__iVecEntry0_38>:
##@@@F_:__iVecEntry0_38():
##@@@P_:weak_interrupt_tc0.c:66
##@@@L0066_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 38);   
8001e4c0:	00 04       	SJMP      $+0                   ;->0x8001e4c0
8001e4c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_027:

8001e4e0 <__iVecEntry0_39>:
##@@@F_:__iVecEntry0_39():
##@@@P_:weak_interrupt_tc0.c:67
##@@@L0067_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 39);   
8001e4e0:	00 04       	SJMP      $+0                   ;->0x8001e4e0
8001e4e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_028:

8001e500 <__iVecEntry0_40>:
##@@@F_:__iVecEntry0_40():
##@@@P_:weak_interrupt_tc0.c:68
##@@@L0068_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 40);   
8001e500:	00 04       	SJMP      $+0                   ;->0x8001e500
8001e502:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_029:

8001e520 <__iVecEntry0_41>:
##@@@F_:__iVecEntry0_41():
##@@@P_:weak_interrupt_tc0.c:69
##@@@L0069_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 41);   
8001e520:	00 04       	SJMP      $+0                   ;->0x8001e520
8001e522:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_02A:

8001e540 <__iVecEntry0_42>:
##@@@F_:__iVecEntry0_42():
##@@@P_:weak_interrupt_tc0.c:70
##@@@L0070_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 42);   
8001e540:	00 04       	SJMP      $+0                   ;->0x8001e540
8001e542:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_02B:

8001e560 <__iVecEntry0_43>:
##@@@F_:__iVecEntry0_43():
##@@@P_:weak_interrupt_tc0.c:71
##@@@L0071_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 43);   
8001e560:	00 04       	SJMP      $+0                   ;->0x8001e560
8001e562:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_02C:

8001e580 <__iVecEntry0_44>:
##@@@F_:__iVecEntry0_44():
##@@@P_:weak_interrupt_tc0.c:72
##@@@L0072_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 44);   
8001e580:	00 04       	SJMP      $+0                   ;->0x8001e580
8001e582:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_02D:

8001e5a0 <__iVecEntry0_45>:
##@@@F_:__iVecEntry0_45():
##@@@P_:weak_interrupt_tc0.c:73
##@@@L0073_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 45);   
8001e5a0:	00 04       	SJMP      $+0                   ;->0x8001e5a0
8001e5a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_02E:

8001e5c0 <__iVecEntry0_46>:
##@@@F_:__iVecEntry0_46():
##@@@P_:weak_interrupt_tc0.c:74
##@@@L0074_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 46);   
8001e5c0:	00 04       	SJMP      $+0                   ;->0x8001e5c0
8001e5c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_02F:

8001e5e0 <__iVecEntry0_47>:
##@@@F_:__iVecEntry0_47():
##@@@P_:weak_interrupt_tc0.c:75
##@@@L0075_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 47);   
8001e5e0:	00 04       	SJMP      $+0                   ;->0x8001e5e0
8001e5e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_030:

8001e600 <__iVecEntry0_48>:
##@@@F_:__iVecEntry0_48():
##@@@P_:weak_interrupt_tc0.c:76
##@@@L0076_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 48);   
8001e600:	00 04       	SJMP      $+0                   ;->0x8001e600
8001e602:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_031:

8001e620 <__iVecEntry0_49>:
##@@@F_:__iVecEntry0_49():
##@@@P_:weak_interrupt_tc0.c:77
##@@@L0077_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 49);   
8001e620:	00 04       	SJMP      $+0                   ;->0x8001e620
8001e622:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_032:

8001e640 <__iVecEntry0_50>:
##@@@F_:__iVecEntry0_50():
##@@@P_:weak_interrupt_tc0.c:78
##@@@L0078_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 50);   
8001e640:	00 04       	SJMP      $+0                   ;->0x8001e640
8001e642:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_033:

8001e660 <__iVecEntry0_51>:
##@@@F_:__iVecEntry0_51():
##@@@P_:weak_interrupt_tc0.c:79
##@@@L0079_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 51);   
8001e660:	00 04       	SJMP      $+0                   ;->0x8001e660
8001e662:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_034:

8001e680 <__iVecEntry0_52>:
##@@@F_:__iVecEntry0_52():
##@@@P_:weak_interrupt_tc0.c:80
##@@@L0080_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 52);   
8001e680:	00 04       	SJMP      $+0                   ;->0x8001e680
8001e682:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_035:

8001e6a0 <__iVecEntry0_53>:
##@@@F_:__iVecEntry0_53():
##@@@P_:weak_interrupt_tc0.c:81
##@@@L0081_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 53);   
8001e6a0:	00 04       	SJMP      $+0                   ;->0x8001e6a0
8001e6a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_036:

8001e6c0 <__iVecEntry0_54>:
##@@@F_:__iVecEntry0_54():
##@@@P_:weak_interrupt_tc0.c:82
##@@@L0082_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 54);   
8001e6c0:	00 04       	SJMP      $+0                   ;->0x8001e6c0
8001e6c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_037:

8001e6e0 <__iVecEntry0_55>:
##@@@F_:__iVecEntry0_55():
##@@@P_:weak_interrupt_tc0.c:83
##@@@L0083_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 55);   
8001e6e0:	00 04       	SJMP      $+0                   ;->0x8001e6e0
8001e6e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_038:

8001e700 <__iVecEntry0_56>:
##@@@F_:__iVecEntry0_56():
##@@@P_:weak_interrupt_tc0.c:84
##@@@L0084_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 56);   
8001e700:	00 04       	SJMP      $+0                   ;->0x8001e700
8001e702:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_039:

8001e720 <__iVecEntry0_57>:
##@@@F_:__iVecEntry0_57():
##@@@P_:weak_interrupt_tc0.c:85
##@@@L0085_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 57);   
8001e720:	00 04       	SJMP      $+0                   ;->0x8001e720
8001e722:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_03A:

8001e740 <__iVecEntry0_58>:
##@@@F_:__iVecEntry0_58():
##@@@P_:weak_interrupt_tc0.c:86
##@@@L0086_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 58);   
8001e740:	00 04       	SJMP      $+0                   ;->0x8001e740
8001e742:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_03B:

8001e760 <__iVecEntry0_59>:
##@@@F_:__iVecEntry0_59():
##@@@P_:weak_interrupt_tc0.c:87
##@@@L0087_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 59);   
8001e760:	00 04       	SJMP      $+0                   ;->0x8001e760
8001e762:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_03C:

8001e780 <__iVecEntry0_60>:
##@@@F_:__iVecEntry0_60():
##@@@P_:weak_interrupt_tc0.c:88
##@@@L0088_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 60);   
8001e780:	00 04       	SJMP      $+0                   ;->0x8001e780
8001e782:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_03D:

8001e7a0 <__iVecEntry0_61>:
##@@@F_:__iVecEntry0_61():
##@@@P_:weak_interrupt_tc0.c:89
##@@@L0089_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 61);   
8001e7a0:	00 04       	SJMP      $+0                   ;->0x8001e7a0
8001e7a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_03E:

8001e7c0 <__iVecEntry0_62>:
##@@@F_:__iVecEntry0_62():
##@@@P_:weak_interrupt_tc0.c:90
##@@@L0090_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 62);   
8001e7c0:	00 04       	SJMP      $+0                   ;->0x8001e7c0
8001e7c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_03F:

8001e7e0 <__iVecEntry0_63>:
##@@@F_:__iVecEntry0_63():
##@@@P_:weak_interrupt_tc0.c:91
##@@@L0091_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 63);   
8001e7e0:	00 04       	SJMP      $+0                   ;->0x8001e7e0
8001e7e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_040:

8001e800 <__iVecEntry0_64>:
##@@@F_:__iVecEntry0_64():
##@@@P_:weak_interrupt_tc0.c:92
##@@@L0092_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 64);   
8001e800:	00 04       	SJMP      $+0                   ;->0x8001e800
8001e802:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_041:

8001e820 <__iVecEntry0_65>:
##@@@F_:__iVecEntry0_65():
##@@@P_:weak_interrupt_tc0.c:93
##@@@L0093_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 65);   
8001e820:	00 04       	SJMP      $+0                   ;->0x8001e820
8001e822:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_042:

8001e840 <__iVecEntry0_66>:
##@@@F_:__iVecEntry0_66():
##@@@P_:weak_interrupt_tc0.c:94
##@@@L0094_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 66);   
8001e840:	00 04       	SJMP      $+0                   ;->0x8001e840
8001e842:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_043:

8001e860 <__iVecEntry0_67>:
##@@@F_:__iVecEntry0_67():
##@@@P_:weak_interrupt_tc0.c:95
##@@@L0095_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 67);   
8001e860:	00 04       	SJMP      $+0                   ;->0x8001e860
8001e862:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_044:

8001e880 <__iVecEntry0_68>:
##@@@F_:__iVecEntry0_68():
##@@@P_:weak_interrupt_tc0.c:96
##@@@L0096_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 68);   
8001e880:	00 04       	SJMP      $+0                   ;->0x8001e880
8001e882:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_045:

8001e8a0 <__iVecEntry0_69>:
##@@@F_:__iVecEntry0_69():
##@@@P_:weak_interrupt_tc0.c:97
##@@@L0097_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 69);   
8001e8a0:	00 04       	SJMP      $+0                   ;->0x8001e8a0
8001e8a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_046:

8001e8c0 <__iVecEntry0_70>:
##@@@F_:__iVecEntry0_70():
##@@@P_:weak_interrupt_tc0.c:98
##@@@L0098_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 70);   
8001e8c0:	00 04       	SJMP      $+0                   ;->0x8001e8c0
8001e8c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_047:

8001e8e0 <__iVecEntry0_71>:
##@@@F_:__iVecEntry0_71():
##@@@P_:weak_interrupt_tc0.c:99
##@@@L0099_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 71);   
8001e8e0:	00 04       	SJMP      $+0                   ;->0x8001e8e0
8001e8e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_048:

8001e900 <__iVecEntry0_72>:
##@@@F_:__iVecEntry0_72():
##@@@P_:weak_interrupt_tc0.c:100
##@@@L0100_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 72);   
8001e900:	00 04       	SJMP      $+0                   ;->0x8001e900
8001e902:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_049:

8001e920 <__iVecEntry0_73>:
##@@@F_:__iVecEntry0_73():
##@@@P_:weak_interrupt_tc0.c:101
##@@@L0101_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 73);   
8001e920:	00 04       	SJMP      $+0                   ;->0x8001e920
8001e922:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_04A:

8001e940 <__iVecEntry0_74>:
##@@@F_:__iVecEntry0_74():
##@@@P_:weak_interrupt_tc0.c:102
##@@@L0102_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 74);   
8001e940:	00 04       	SJMP      $+0                   ;->0x8001e940
8001e942:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_04B:

8001e960 <__iVecEntry0_75>:
##@@@F_:__iVecEntry0_75():
##@@@P_:weak_interrupt_tc0.c:103
##@@@L0103_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 75);   
8001e960:	00 04       	SJMP      $+0                   ;->0x8001e960
8001e962:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_04C:

8001e980 <__iVecEntry0_76>:
##@@@F_:__iVecEntry0_76():
##@@@P_:weak_interrupt_tc0.c:104
##@@@L0104_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 76);   
8001e980:	00 04       	SJMP      $+0                   ;->0x8001e980
8001e982:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_04D:

8001e9a0 <__iVecEntry0_77>:
##@@@F_:__iVecEntry0_77():
##@@@P_:weak_interrupt_tc0.c:105
##@@@L0105_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 77);   
8001e9a0:	00 04       	SJMP      $+0                   ;->0x8001e9a0
8001e9a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_04E:

8001e9c0 <__iVecEntry0_78>:
##@@@F_:__iVecEntry0_78():
##@@@P_:weak_interrupt_tc0.c:106
##@@@L0106_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 78);   
8001e9c0:	00 04       	SJMP      $+0                   ;->0x8001e9c0
8001e9c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_04F:

8001e9e0 <__iVecEntry0_79>:
##@@@F_:__iVecEntry0_79():
##@@@P_:weak_interrupt_tc0.c:107
##@@@L0107_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 79);   
8001e9e0:	00 04       	SJMP      $+0                   ;->0x8001e9e0
8001e9e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_050:

8001ea00 <__iVecEntry0_80>:
##@@@F_:__iVecEntry0_80():
##@@@P_:weak_interrupt_tc0.c:108
##@@@L0108_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 80);   
8001ea00:	00 04       	SJMP      $+0                   ;->0x8001ea00
8001ea02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_051:

8001ea20 <__iVecEntry0_81>:
##@@@F_:__iVecEntry0_81():
##@@@P_:weak_interrupt_tc0.c:109
##@@@L0109_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 81);   
8001ea20:	00 04       	SJMP      $+0                   ;->0x8001ea20
8001ea22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_052:

8001ea40 <__iVecEntry0_82>:
##@@@F_:__iVecEntry0_82():
##@@@P_:weak_interrupt_tc0.c:110
##@@@L0110_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 82);   
8001ea40:	00 04       	SJMP      $+0                   ;->0x8001ea40
8001ea42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_053:

8001ea60 <__iVecEntry0_83>:
##@@@F_:__iVecEntry0_83():
##@@@P_:weak_interrupt_tc0.c:111
##@@@L0111_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 83);   
8001ea60:	00 04       	SJMP      $+0                   ;->0x8001ea60
8001ea62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_054:

8001ea80 <__iVecEntry0_84>:
##@@@F_:__iVecEntry0_84():
##@@@P_:weak_interrupt_tc0.c:112
##@@@L0112_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 84);   
8001ea80:	00 04       	SJMP      $+0                   ;->0x8001ea80
8001ea82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_055:

8001eaa0 <__iVecEntry0_85>:
##@@@F_:__iVecEntry0_85():
##@@@P_:weak_interrupt_tc0.c:113
##@@@L0113_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 85);   
8001eaa0:	00 04       	SJMP      $+0                   ;->0x8001eaa0
8001eaa2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_056:

8001eac0 <__iVecEntry0_86>:
##@@@F_:__iVecEntry0_86():
##@@@P_:weak_interrupt_tc0.c:114
##@@@L0114_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 86);   
8001eac0:	00 04       	SJMP      $+0                   ;->0x8001eac0
8001eac2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_057:

8001eae0 <__iVecEntry0_87>:
##@@@F_:__iVecEntry0_87():
##@@@P_:weak_interrupt_tc0.c:115
##@@@L0115_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 87);   
8001eae0:	00 04       	SJMP      $+0                   ;->0x8001eae0
8001eae2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_058:

8001eb00 <__iVecEntry0_88>:
##@@@F_:__iVecEntry0_88():
##@@@P_:weak_interrupt_tc0.c:116
##@@@L0116_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 88);   
8001eb00:	00 04       	SJMP      $+0                   ;->0x8001eb00
8001eb02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_059:

8001eb20 <__iVecEntry0_89>:
##@@@F_:__iVecEntry0_89():
##@@@P_:weak_interrupt_tc0.c:117
##@@@L0117_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 89);   
8001eb20:	00 04       	SJMP      $+0                   ;->0x8001eb20
8001eb22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_05A:

8001eb40 <__iVecEntry0_90>:
##@@@F_:__iVecEntry0_90():
##@@@P_:weak_interrupt_tc0.c:118
##@@@L0118_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 90);   
8001eb40:	00 04       	SJMP      $+0                   ;->0x8001eb40
8001eb42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_05B:

8001eb60 <__iVecEntry0_91>:
##@@@F_:__iVecEntry0_91():
##@@@P_:weak_interrupt_tc0.c:119
##@@@L0119_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 91);   
8001eb60:	00 04       	SJMP      $+0                   ;->0x8001eb60
8001eb62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_05C:

8001eb80 <__iVecEntry0_92>:
##@@@F_:__iVecEntry0_92():
##@@@P_:weak_interrupt_tc0.c:120
##@@@L0120_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 92);   
8001eb80:	00 04       	SJMP      $+0                   ;->0x8001eb80
8001eb82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_05D:

8001eba0 <__iVecEntry0_93>:
##@@@F_:__iVecEntry0_93():
##@@@P_:weak_interrupt_tc0.c:121
##@@@L0121_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 93);   
8001eba0:	00 04       	SJMP      $+0                   ;->0x8001eba0
8001eba2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_05E:

8001ebc0 <__iVecEntry0_94>:
##@@@F_:__iVecEntry0_94():
##@@@P_:weak_interrupt_tc0.c:122
##@@@L0122_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 94);   
8001ebc0:	00 04       	SJMP      $+0                   ;->0x8001ebc0
8001ebc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_05F:

8001ebe0 <__iVecEntry0_95>:
##@@@F_:__iVecEntry0_95():
##@@@P_:weak_interrupt_tc0.c:123
##@@@L0123_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 95);   
8001ebe0:	00 04       	SJMP      $+0                   ;->0x8001ebe0
8001ebe2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_060:

8001ec00 <__iVecEntry0_96>:
##@@@F_:__iVecEntry0_96():
##@@@P_:weak_interrupt_tc0.c:124
##@@@L0124_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 96);   
8001ec00:	00 04       	SJMP      $+0                   ;->0x8001ec00
8001ec02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_061:

8001ec20 <__iVecEntry0_97>:
##@@@F_:__iVecEntry0_97():
##@@@P_:weak_interrupt_tc0.c:125
##@@@L0125_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 97);   
8001ec20:	00 04       	SJMP      $+0                   ;->0x8001ec20
8001ec22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_062:

8001ec40 <__iVecEntry0_98>:
##@@@F_:__iVecEntry0_98():
##@@@P_:weak_interrupt_tc0.c:126
##@@@L0126_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 98);   
8001ec40:	00 04       	SJMP      $+0                   ;->0x8001ec40
8001ec42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_063:

8001ec60 <__iVecEntry0_99>:
##@@@F_:__iVecEntry0_99():
##@@@P_:weak_interrupt_tc0.c:127
##@@@L0127_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 99);   
8001ec60:	00 04       	SJMP      $+0                   ;->0x8001ec60
8001ec62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_064:

8001ec80 <__iVecEntry0_100>:
##@@@F_:__iVecEntry0_100():
##@@@P_:weak_interrupt_tc0.c:128
##@@@L0128_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 100);   
8001ec80:	00 04       	SJMP      $+0                   ;->0x8001ec80
8001ec82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_065:

8001eca0 <__iVecEntry0_101>:
##@@@F_:__iVecEntry0_101():
##@@@P_:weak_interrupt_tc0.c:129
##@@@L0129_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 101);   
8001eca0:	00 04       	SJMP      $+0                   ;->0x8001eca0
8001eca2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_066:

8001ecc0 <__iVecEntry0_102>:
##@@@F_:__iVecEntry0_102():
##@@@P_:weak_interrupt_tc0.c:130
##@@@L0130_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 102);   
8001ecc0:	00 04       	SJMP      $+0                   ;->0x8001ecc0
8001ecc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_067:

8001ece0 <__iVecEntry0_103>:
##@@@F_:__iVecEntry0_103():
##@@@P_:weak_interrupt_tc0.c:131
##@@@L0131_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 103);   
8001ece0:	00 04       	SJMP      $+0                   ;->0x8001ece0
8001ece2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_068:

8001ed00 <__iVecEntry0_104>:
##@@@F_:__iVecEntry0_104():
##@@@P_:weak_interrupt_tc0.c:132
##@@@L0132_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 104);   
8001ed00:	00 04       	SJMP      $+0                   ;->0x8001ed00
8001ed02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_069:

8001ed20 <__iVecEntry0_105>:
##@@@F_:__iVecEntry0_105():
##@@@P_:weak_interrupt_tc0.c:133
##@@@L0133_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 105);   
8001ed20:	00 04       	SJMP      $+0                   ;->0x8001ed20
8001ed22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_06A:

8001ed40 <__iVecEntry0_106>:
##@@@F_:__iVecEntry0_106():
##@@@P_:weak_interrupt_tc0.c:134
##@@@L0134_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 106);   
8001ed40:	00 04       	SJMP      $+0                   ;->0x8001ed40
8001ed42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_06B:

8001ed60 <__iVecEntry0_107>:
##@@@F_:__iVecEntry0_107():
##@@@P_:weak_interrupt_tc0.c:135
##@@@L0135_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 107);   
8001ed60:	00 04       	SJMP      $+0                   ;->0x8001ed60
8001ed62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_06C:

8001ed80 <__iVecEntry0_108>:
##@@@F_:__iVecEntry0_108():
##@@@P_:weak_interrupt_tc0.c:136
##@@@L0136_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 108);   
8001ed80:	00 04       	SJMP      $+0                   ;->0x8001ed80
8001ed82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_06D:

8001eda0 <__iVecEntry0_109>:
##@@@F_:__iVecEntry0_109():
##@@@P_:weak_interrupt_tc0.c:137
##@@@L0137_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 109);   
8001eda0:	00 04       	SJMP      $+0                   ;->0x8001eda0
8001eda2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_06E:

8001edc0 <__iVecEntry0_110>:
##@@@F_:__iVecEntry0_110():
##@@@P_:weak_interrupt_tc0.c:138
##@@@L0138_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 110);   
8001edc0:	00 04       	SJMP      $+0                   ;->0x8001edc0
8001edc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_06F:

8001ede0 <__iVecEntry0_111>:
##@@@F_:__iVecEntry0_111():
##@@@P_:weak_interrupt_tc0.c:139
##@@@L0139_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 111);   
8001ede0:	00 04       	SJMP      $+0                   ;->0x8001ede0
8001ede2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_070:

8001ee00 <__iVecEntry0_112>:
##@@@F_:__iVecEntry0_112():
##@@@P_:weak_interrupt_tc0.c:140
##@@@L0140_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 112);   
8001ee00:	00 04       	SJMP      $+0                   ;->0x8001ee00
8001ee02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_071:

8001ee20 <__iVecEntry0_113>:
##@@@F_:__iVecEntry0_113():
##@@@P_:weak_interrupt_tc0.c:141
##@@@L0141_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 113);   
8001ee20:	00 04       	SJMP      $+0                   ;->0x8001ee20
8001ee22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_072:

8001ee40 <__iVecEntry0_114>:
##@@@F_:__iVecEntry0_114():
##@@@P_:weak_interrupt_tc0.c:142
##@@@L0142_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 114);   
8001ee40:	00 04       	SJMP      $+0                   ;->0x8001ee40
8001ee42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_073:

8001ee60 <__iVecEntry0_115>:
##@@@F_:__iVecEntry0_115():
##@@@P_:weak_interrupt_tc0.c:143
##@@@L0143_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 115);   
8001ee60:	00 04       	SJMP      $+0                   ;->0x8001ee60
8001ee62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_074:

8001ee80 <__iVecEntry0_116>:
##@@@F_:__iVecEntry0_116():
##@@@P_:weak_interrupt_tc0.c:144
##@@@L0144_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 116);   
8001ee80:	00 04       	SJMP      $+0                   ;->0x8001ee80
8001ee82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_075:

8001eea0 <__iVecEntry0_117>:
##@@@F_:__iVecEntry0_117():
##@@@P_:weak_interrupt_tc0.c:145
##@@@L0145_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 117);   
8001eea0:	00 04       	SJMP      $+0                   ;->0x8001eea0
8001eea2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_076:

8001eec0 <__iVecEntry0_118>:
##@@@F_:__iVecEntry0_118():
##@@@P_:weak_interrupt_tc0.c:146
##@@@L0146_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 118);   
8001eec0:	00 04       	SJMP      $+0                   ;->0x8001eec0
8001eec2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_077:

8001eee0 <__iVecEntry0_119>:
##@@@F_:__iVecEntry0_119():
##@@@P_:weak_interrupt_tc0.c:147
##@@@L0147_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 119);   
8001eee0:	00 04       	SJMP      $+0                   ;->0x8001eee0
8001eee2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_078:

8001ef00 <__iVecEntry0_120>:
##@@@F_:__iVecEntry0_120():
##@@@P_:weak_interrupt_tc0.c:148
##@@@L0148_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 120);   
8001ef00:	00 04       	SJMP      $+0                   ;->0x8001ef00
8001ef02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_079:

8001ef20 <__iVecEntry0_121>:
##@@@F_:__iVecEntry0_121():
##@@@P_:weak_interrupt_tc0.c:149
##@@@L0149_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 121);   
8001ef20:	00 04       	SJMP      $+0                   ;->0x8001ef20
8001ef22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_07A:

8001ef40 <__iVecEntry0_122>:
##@@@F_:__iVecEntry0_122():
##@@@P_:weak_interrupt_tc0.c:150
##@@@L0150_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 122);   
8001ef40:	00 04       	SJMP      $+0                   ;->0x8001ef40
8001ef42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_07B:

8001ef60 <__iVecEntry0_123>:
##@@@F_:__iVecEntry0_123():
##@@@P_:weak_interrupt_tc0.c:151
##@@@L0151_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 123);   
8001ef60:	00 04       	SJMP      $+0                   ;->0x8001ef60
8001ef62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_07C:

8001ef80 <__iVecEntry0_124>:
##@@@F_:__iVecEntry0_124():
##@@@P_:weak_interrupt_tc0.c:152
##@@@L0152_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 124);   
8001ef80:	00 04       	SJMP      $+0                   ;->0x8001ef80
8001ef82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_07D:

8001efa0 <__iVecEntry0_125>:
##@@@F_:__iVecEntry0_125():
##@@@P_:weak_interrupt_tc0.c:153
##@@@L0153_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 125);   
8001efa0:	00 04       	SJMP      $+0                   ;->0x8001efa0
8001efa2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_07E:

8001efc0 <__iVecEntry0_126>:
##@@@F_:__iVecEntry0_126():
##@@@P_:weak_interrupt_tc0.c:154
##@@@L0154_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 126);   
8001efc0:	00 04       	SJMP      $+0                   ;->0x8001efc0
8001efc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_07F:

8001efe0 <__iVecEntry0_127>:
##@@@F_:__iVecEntry0_127():
##@@@P_:weak_interrupt_tc0.c:155
##@@@L0155_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 127);   
8001efe0:	00 04       	SJMP      $+0                   ;->0x8001efe0
8001efe2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_080:

8001f000 <__iVecEntry0_128>:
##@@@F_:__iVecEntry0_128():
##@@@P_:weak_interrupt_tc0.c:156
##@@@L0156_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 128);   
8001f000:	00 04       	SJMP      $+0                   ;->0x8001f000
8001f002:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_081:

8001f020 <__iVecEntry0_129>:
##@@@F_:__iVecEntry0_129():
##@@@P_:weak_interrupt_tc0.c:157
##@@@L0157_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 129);   
8001f020:	00 04       	SJMP      $+0                   ;->0x8001f020
8001f022:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_082:

8001f040 <__iVecEntry0_130>:
##@@@F_:__iVecEntry0_130():
##@@@P_:weak_interrupt_tc0.c:158
##@@@L0158_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 130);   
8001f040:	00 04       	SJMP      $+0                   ;->0x8001f040
8001f042:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_083:

8001f060 <__iVecEntry0_131>:
##@@@F_:__iVecEntry0_131():
##@@@P_:weak_interrupt_tc0.c:159
##@@@L0159_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 131);   
8001f060:	00 04       	SJMP      $+0                   ;->0x8001f060
8001f062:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_084:

8001f080 <__iVecEntry0_132>:
##@@@F_:__iVecEntry0_132():
##@@@P_:weak_interrupt_tc0.c:160
##@@@L0160_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 132);   
8001f080:	00 04       	SJMP      $+0                   ;->0x8001f080
8001f082:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_085:

8001f0a0 <__iVecEntry0_133>:
##@@@F_:__iVecEntry0_133():
##@@@P_:weak_interrupt_tc0.c:161
##@@@L0161_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 133);   
8001f0a0:	00 04       	SJMP      $+0                   ;->0x8001f0a0
8001f0a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_086:

8001f0c0 <__iVecEntry0_134>:
##@@@F_:__iVecEntry0_134():
##@@@P_:weak_interrupt_tc0.c:162
##@@@L0162_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 134);   
8001f0c0:	00 04       	SJMP      $+0                   ;->0x8001f0c0
8001f0c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_087:

8001f0e0 <__iVecEntry0_135>:
##@@@F_:__iVecEntry0_135():
##@@@P_:weak_interrupt_tc0.c:163
##@@@L0163_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 135);   
8001f0e0:	00 04       	SJMP      $+0                   ;->0x8001f0e0
8001f0e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_088:

8001f100 <__iVecEntry0_136>:
##@@@F_:__iVecEntry0_136():
##@@@P_:weak_interrupt_tc0.c:164
##@@@L0164_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 136);   
8001f100:	00 04       	SJMP      $+0                   ;->0x8001f100
8001f102:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_089:

8001f120 <__iVecEntry0_137>:
##@@@F_:__iVecEntry0_137():
##@@@P_:weak_interrupt_tc0.c:165
##@@@L0165_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 137);   
8001f120:	00 04       	SJMP      $+0                   ;->0x8001f120
8001f122:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_08A:

8001f140 <__iVecEntry0_138>:
##@@@F_:__iVecEntry0_138():
##@@@P_:weak_interrupt_tc0.c:166
##@@@L0166_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 138);   
8001f140:	00 04       	SJMP      $+0                   ;->0x8001f140
8001f142:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_08B:

8001f160 <__iVecEntry0_139>:
##@@@F_:__iVecEntry0_139():
##@@@P_:weak_interrupt_tc0.c:167
##@@@L0167_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 139);   
8001f160:	00 04       	SJMP      $+0                   ;->0x8001f160
8001f162:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_08C:

8001f180 <__iVecEntry0_140>:
##@@@F_:__iVecEntry0_140():
##@@@P_:weak_interrupt_tc0.c:168
##@@@L0168_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 140);   
8001f180:	00 04       	SJMP      $+0                   ;->0x8001f180
8001f182:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_08D:

8001f1a0 <__iVecEntry0_141>:
##@@@F_:__iVecEntry0_141():
##@@@P_:weak_interrupt_tc0.c:169
##@@@L0169_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 141);   
8001f1a0:	00 04       	SJMP      $+0                   ;->0x8001f1a0
8001f1a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_08E:

8001f1c0 <__iVecEntry0_142>:
##@@@F_:__iVecEntry0_142():
##@@@P_:weak_interrupt_tc0.c:170
##@@@L0170_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 142);   
8001f1c0:	00 04       	SJMP      $+0                   ;->0x8001f1c0
8001f1c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_08F:

8001f1e0 <__iVecEntry0_143>:
##@@@F_:__iVecEntry0_143():
##@@@P_:weak_interrupt_tc0.c:171
##@@@L0171_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 143);   
8001f1e0:	00 04       	SJMP      $+0                   ;->0x8001f1e0
8001f1e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_090:

8001f200 <__iVecEntry0_144>:
##@@@F_:__iVecEntry0_144():
##@@@P_:weak_interrupt_tc0.c:172
##@@@L0172_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 144);   
8001f200:	00 04       	SJMP      $+0                   ;->0x8001f200
8001f202:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_091:

8001f220 <__iVecEntry0_145>:
##@@@F_:__iVecEntry0_145():
##@@@P_:weak_interrupt_tc0.c:173
##@@@L0173_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 145);   
8001f220:	00 04       	SJMP      $+0                   ;->0x8001f220
8001f222:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_092:

8001f240 <__iVecEntry0_146>:
##@@@F_:__iVecEntry0_146():
##@@@P_:weak_interrupt_tc0.c:174
##@@@L0174_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 146);   
8001f240:	00 04       	SJMP      $+0                   ;->0x8001f240
8001f242:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_093:

8001f260 <__iVecEntry0_147>:
##@@@F_:__iVecEntry0_147():
##@@@P_:weak_interrupt_tc0.c:175
##@@@L0175_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 147);   
8001f260:	00 04       	SJMP      $+0                   ;->0x8001f260
8001f262:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_094:

8001f280 <__iVecEntry0_148>:
##@@@F_:__iVecEntry0_148():
##@@@P_:weak_interrupt_tc0.c:176
##@@@L0176_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 148);   
8001f280:	00 04       	SJMP      $+0                   ;->0x8001f280
8001f282:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_095:

8001f2a0 <__iVecEntry0_149>:
##@@@F_:__iVecEntry0_149():
##@@@P_:weak_interrupt_tc0.c:177
##@@@L0177_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 149);   
8001f2a0:	00 04       	SJMP      $+0                   ;->0x8001f2a0
8001f2a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_096:

8001f2c0 <__iVecEntry0_150>:
##@@@F_:__iVecEntry0_150():
##@@@P_:weak_interrupt_tc0.c:178
##@@@L0178_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 150);   
8001f2c0:	00 04       	SJMP      $+0                   ;->0x8001f2c0
8001f2c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_097:

8001f2e0 <__iVecEntry0_151>:
##@@@F_:__iVecEntry0_151():
##@@@P_:weak_interrupt_tc0.c:179
##@@@L0179_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 151);   
8001f2e0:	00 04       	SJMP      $+0                   ;->0x8001f2e0
8001f2e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_098:

8001f300 <__iVecEntry0_152>:
##@@@F_:__iVecEntry0_152():
##@@@P_:weak_interrupt_tc0.c:180
##@@@L0180_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 152);   
8001f300:	00 04       	SJMP      $+0                   ;->0x8001f300
8001f302:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_099:

8001f320 <__iVecEntry0_153>:
##@@@F_:__iVecEntry0_153():
##@@@P_:weak_interrupt_tc0.c:181
##@@@L0181_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 153);   
8001f320:	00 04       	SJMP      $+0                   ;->0x8001f320
8001f322:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_09A:

8001f340 <__iVecEntry0_154>:
##@@@F_:__iVecEntry0_154():
##@@@P_:weak_interrupt_tc0.c:182
##@@@L0182_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 154);   
8001f340:	00 04       	SJMP      $+0                   ;->0x8001f340
8001f342:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_09B:

8001f360 <__iVecEntry0_155>:
##@@@F_:__iVecEntry0_155():
##@@@P_:weak_interrupt_tc0.c:183
##@@@L0183_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 155);   
8001f360:	00 04       	SJMP      $+0                   ;->0x8001f360
8001f362:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_09C:

8001f380 <__iVecEntry0_156>:
##@@@F_:__iVecEntry0_156():
##@@@P_:weak_interrupt_tc0.c:184
##@@@L0184_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 156);   
8001f380:	00 04       	SJMP      $+0                   ;->0x8001f380
8001f382:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_09D:

8001f3a0 <__iVecEntry0_157>:
##@@@F_:__iVecEntry0_157():
##@@@P_:weak_interrupt_tc0.c:185
##@@@L0185_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 157);   
8001f3a0:	00 04       	SJMP      $+0                   ;->0x8001f3a0
8001f3a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_09E:

8001f3c0 <__iVecEntry0_158>:
##@@@F_:__iVecEntry0_158():
##@@@P_:weak_interrupt_tc0.c:186
##@@@L0186_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 158);   
8001f3c0:	00 04       	SJMP      $+0                   ;->0x8001f3c0
8001f3c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_09F:

8001f3e0 <__iVecEntry0_159>:
##@@@F_:__iVecEntry0_159():
##@@@P_:weak_interrupt_tc0.c:187
##@@@L0187_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 159);   
8001f3e0:	00 04       	SJMP      $+0                   ;->0x8001f3e0
8001f3e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A0:

8001f400 <__iVecEntry0_160>:
##@@@F_:__iVecEntry0_160():
##@@@P_:weak_interrupt_tc0.c:188
##@@@L0188_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 160);   
8001f400:	00 04       	SJMP      $+0                   ;->0x8001f400
8001f402:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A1:

8001f420 <__iVecEntry0_161>:
##@@@F_:__iVecEntry0_161():
##@@@P_:weak_interrupt_tc0.c:189
##@@@L0189_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 161);   
8001f420:	00 04       	SJMP      $+0                   ;->0x8001f420
8001f422:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A2:

8001f440 <__iVecEntry0_162>:
##@@@F_:__iVecEntry0_162():
##@@@P_:weak_interrupt_tc0.c:190
##@@@L0190_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 162);   
8001f440:	00 04       	SJMP      $+0                   ;->0x8001f440
8001f442:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A3:

8001f460 <__iVecEntry0_163>:
##@@@F_:__iVecEntry0_163():
##@@@P_:weak_interrupt_tc0.c:191
##@@@L0191_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 163);   
8001f460:	00 04       	SJMP      $+0                   ;->0x8001f460
8001f462:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A4:

8001f480 <__iVecEntry0_164>:
##@@@F_:__iVecEntry0_164():
##@@@P_:weak_interrupt_tc0.c:192
##@@@L0192_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 164);   
8001f480:	00 04       	SJMP      $+0                   ;->0x8001f480
8001f482:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A5:

8001f4a0 <__iVecEntry0_165>:
##@@@F_:__iVecEntry0_165():
##@@@P_:weak_interrupt_tc0.c:193
##@@@L0193_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 165);   
8001f4a0:	00 04       	SJMP      $+0                   ;->0x8001f4a0
8001f4a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A6:

8001f4c0 <__iVecEntry0_166>:
##@@@F_:__iVecEntry0_166():
##@@@P_:weak_interrupt_tc0.c:194
##@@@L0194_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 166);   
8001f4c0:	00 04       	SJMP      $+0                   ;->0x8001f4c0
8001f4c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A7:

8001f4e0 <__iVecEntry0_167>:
##@@@F_:__iVecEntry0_167():
##@@@P_:weak_interrupt_tc0.c:195
##@@@L0195_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 167);   
8001f4e0:	00 04       	SJMP      $+0                   ;->0x8001f4e0
8001f4e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A8:

8001f500 <__iVecEntry0_168>:
##@@@F_:__iVecEntry0_168():
##@@@P_:weak_interrupt_tc0.c:196
##@@@L0196_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 168);   
8001f500:	00 04       	SJMP      $+0                   ;->0x8001f500
8001f502:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0A9:

8001f520 <__iVecEntry0_169>:
##@@@F_:__iVecEntry0_169():
##@@@P_:weak_interrupt_tc0.c:197
##@@@L0197_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 169);   
8001f520:	00 04       	SJMP      $+0                   ;->0x8001f520
8001f522:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0AA:

8001f540 <__iVecEntry0_170>:
##@@@F_:__iVecEntry0_170():
##@@@P_:weak_interrupt_tc0.c:198
##@@@L0198_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 170);   
8001f540:	00 04       	SJMP      $+0                   ;->0x8001f540
8001f542:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0AB:

8001f560 <__iVecEntry0_171>:
##@@@F_:__iVecEntry0_171():
##@@@P_:weak_interrupt_tc0.c:199
##@@@L0199_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 171);   
8001f560:	00 04       	SJMP      $+0                   ;->0x8001f560
8001f562:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0AC:

8001f580 <__iVecEntry0_172>:
##@@@F_:__iVecEntry0_172():
##@@@P_:weak_interrupt_tc0.c:200
##@@@L0200_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 172);   
8001f580:	00 04       	SJMP      $+0                   ;->0x8001f580
8001f582:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0AD:

8001f5a0 <__iVecEntry0_173>:
##@@@F_:__iVecEntry0_173():
##@@@P_:weak_interrupt_tc0.c:201
##@@@L0201_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 173);   
8001f5a0:	00 04       	SJMP      $+0                   ;->0x8001f5a0
8001f5a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0AE:

8001f5c0 <__iVecEntry0_174>:
##@@@F_:__iVecEntry0_174():
##@@@P_:weak_interrupt_tc0.c:202
##@@@L0202_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 174);   
8001f5c0:	00 04       	SJMP      $+0                   ;->0x8001f5c0
8001f5c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0AF:

8001f5e0 <__iVecEntry0_175>:
##@@@F_:__iVecEntry0_175():
##@@@P_:weak_interrupt_tc0.c:203
##@@@L0203_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 175);   
8001f5e0:	00 04       	SJMP      $+0                   ;->0x8001f5e0
8001f5e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B0:

8001f600 <__iVecEntry0_176>:
##@@@F_:__iVecEntry0_176():
##@@@P_:weak_interrupt_tc0.c:204
##@@@L0204_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 176);   
8001f600:	00 04       	SJMP      $+0                   ;->0x8001f600
8001f602:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B1:

8001f620 <__iVecEntry0_177>:
##@@@F_:__iVecEntry0_177():
##@@@P_:weak_interrupt_tc0.c:205
##@@@L0205_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 177);   
8001f620:	00 04       	SJMP      $+0                   ;->0x8001f620
8001f622:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B2:

8001f640 <__iVecEntry0_178>:
##@@@F_:__iVecEntry0_178():
##@@@P_:weak_interrupt_tc0.c:206
##@@@L0206_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 178);   
8001f640:	00 04       	SJMP      $+0                   ;->0x8001f640
8001f642:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B3:

8001f660 <__iVecEntry0_179>:
##@@@F_:__iVecEntry0_179():
##@@@P_:weak_interrupt_tc0.c:207
##@@@L0207_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 179);   
8001f660:	00 04       	SJMP      $+0                   ;->0x8001f660
8001f662:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B4:

8001f680 <__iVecEntry0_180>:
##@@@F_:__iVecEntry0_180():
##@@@P_:weak_interrupt_tc0.c:208
##@@@L0208_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 180);   
8001f680:	00 04       	SJMP      $+0                   ;->0x8001f680
8001f682:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B5:

8001f6a0 <__iVecEntry0_181>:
##@@@F_:__iVecEntry0_181():
##@@@P_:weak_interrupt_tc0.c:209
##@@@L0209_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 181);   
8001f6a0:	00 04       	SJMP      $+0                   ;->0x8001f6a0
8001f6a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B6:

8001f6c0 <__iVecEntry0_182>:
##@@@F_:__iVecEntry0_182():
##@@@P_:weak_interrupt_tc0.c:210
##@@@L0210_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 182);   
8001f6c0:	00 04       	SJMP      $+0                   ;->0x8001f6c0
8001f6c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B7:

8001f6e0 <__iVecEntry0_183>:
##@@@F_:__iVecEntry0_183():
##@@@P_:weak_interrupt_tc0.c:211
##@@@L0211_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 183);   
8001f6e0:	00 04       	SJMP      $+0                   ;->0x8001f6e0
8001f6e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B8:

8001f700 <__iVecEntry0_184>:
##@@@F_:__iVecEntry0_184():
##@@@P_:weak_interrupt_tc0.c:212
##@@@L0212_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 184);   
8001f700:	00 04       	SJMP      $+0                   ;->0x8001f700
8001f702:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0B9:

8001f720 <__iVecEntry0_185>:
##@@@F_:__iVecEntry0_185():
##@@@P_:weak_interrupt_tc0.c:213
##@@@L0213_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 185);   
8001f720:	00 04       	SJMP      $+0                   ;->0x8001f720
8001f722:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0BA:

8001f740 <__iVecEntry0_186>:
##@@@F_:__iVecEntry0_186():
##@@@P_:weak_interrupt_tc0.c:214
##@@@L0214_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 186);   
8001f740:	00 04       	SJMP      $+0                   ;->0x8001f740
8001f742:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0BB:

8001f760 <__iVecEntry0_187>:
##@@@F_:__iVecEntry0_187():
##@@@P_:weak_interrupt_tc0.c:215
##@@@L0215_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 187);   
8001f760:	00 04       	SJMP      $+0                   ;->0x8001f760
8001f762:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0BC:

8001f780 <__iVecEntry0_188>:
##@@@F_:__iVecEntry0_188():
##@@@P_:weak_interrupt_tc0.c:216
##@@@L0216_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 188);   
8001f780:	00 04       	SJMP      $+0                   ;->0x8001f780
8001f782:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0BD:

8001f7a0 <__iVecEntry0_189>:
##@@@F_:__iVecEntry0_189():
##@@@P_:weak_interrupt_tc0.c:217
##@@@L0217_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 189);   
8001f7a0:	00 04       	SJMP      $+0                   ;->0x8001f7a0
8001f7a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0BE:

8001f7c0 <__iVecEntry0_190>:
##@@@F_:__iVecEntry0_190():
##@@@P_:weak_interrupt_tc0.c:218
##@@@L0218_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 190);   
8001f7c0:	00 04       	SJMP      $+0                   ;->0x8001f7c0
8001f7c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0BF:

8001f7e0 <__iVecEntry0_191>:
##@@@F_:__iVecEntry0_191():
##@@@P_:weak_interrupt_tc0.c:219
##@@@L0219_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 191);   
8001f7e0:	00 04       	SJMP      $+0                   ;->0x8001f7e0
8001f7e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C0:

8001f800 <__iVecEntry0_192>:
##@@@F_:__iVecEntry0_192():
##@@@P_:weak_interrupt_tc0.c:220
##@@@L0220_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 192);   
8001f800:	00 04       	SJMP      $+0                   ;->0x8001f800
8001f802:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C1:

8001f820 <__iVecEntry0_193>:
##@@@F_:__iVecEntry0_193():
##@@@P_:weak_interrupt_tc0.c:221
##@@@L0221_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 193);   
8001f820:	00 04       	SJMP      $+0                   ;->0x8001f820
8001f822:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C2:

8001f840 <__iVecEntry0_194>:
##@@@F_:__iVecEntry0_194():
##@@@P_:weak_interrupt_tc0.c:222
##@@@L0222_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 194);   
8001f840:	00 04       	SJMP      $+0                   ;->0x8001f840
8001f842:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C3:

8001f860 <__iVecEntry0_195>:
##@@@F_:__iVecEntry0_195():
##@@@P_:weak_interrupt_tc0.c:223
##@@@L0223_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 195);   
8001f860:	00 04       	SJMP      $+0                   ;->0x8001f860
8001f862:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C4:

8001f880 <__iVecEntry0_196>:
##@@@F_:__iVecEntry0_196():
##@@@P_:weak_interrupt_tc0.c:224
##@@@L0224_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 196);   
8001f880:	00 04       	SJMP      $+0                   ;->0x8001f880
8001f882:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C5:

8001f8a0 <__iVecEntry0_197>:
##@@@F_:__iVecEntry0_197():
##@@@P_:weak_interrupt_tc0.c:225
##@@@L0225_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 197);   
8001f8a0:	00 04       	SJMP      $+0                   ;->0x8001f8a0
8001f8a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C6:

8001f8c0 <__iVecEntry0_198>:
##@@@F_:__iVecEntry0_198():
##@@@P_:weak_interrupt_tc0.c:226
##@@@L0226_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 198);   
8001f8c0:	00 04       	SJMP      $+0                   ;->0x8001f8c0
8001f8c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C7:

8001f8e0 <__iVecEntry0_199>:
##@@@F_:__iVecEntry0_199():
##@@@P_:weak_interrupt_tc0.c:227
##@@@L0227_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 199);   
8001f8e0:	00 04       	SJMP      $+0                   ;->0x8001f8e0
8001f8e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C8:

8001f900 <__iVecEntry0_200>:
##@@@F_:__iVecEntry0_200():
##@@@P_:weak_interrupt_tc0.c:228
##@@@L0228_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 200);   
8001f900:	00 04       	SJMP      $+0                   ;->0x8001f900
8001f902:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0C9:

8001f920 <__iVecEntry0_201>:
##@@@F_:__iVecEntry0_201():
##@@@P_:weak_interrupt_tc0.c:229
##@@@L0229_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 201);   
8001f920:	00 04       	SJMP      $+0                   ;->0x8001f920
8001f922:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0CA:

8001f940 <__iVecEntry0_202>:
##@@@F_:__iVecEntry0_202():
##@@@P_:weak_interrupt_tc0.c:230
##@@@L0230_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 202);   
8001f940:	00 04       	SJMP      $+0                   ;->0x8001f940
8001f942:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0CB:

8001f960 <__iVecEntry0_203>:
##@@@F_:__iVecEntry0_203():
##@@@P_:weak_interrupt_tc0.c:231
##@@@L0231_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 203);   
8001f960:	00 04       	SJMP      $+0                   ;->0x8001f960
8001f962:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0CC:

8001f980 <__iVecEntry0_204>:
##@@@F_:__iVecEntry0_204():
##@@@P_:weak_interrupt_tc0.c:232
##@@@L0232_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 204);   
8001f980:	00 04       	SJMP      $+0                   ;->0x8001f980
8001f982:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0CD:

8001f9a0 <__iVecEntry0_205>:
##@@@F_:__iVecEntry0_205():
##@@@P_:weak_interrupt_tc0.c:233
##@@@L0233_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 205);   
8001f9a0:	00 04       	SJMP      $+0                   ;->0x8001f9a0
8001f9a2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0CE:

8001f9c0 <__iVecEntry0_206>:
##@@@F_:__iVecEntry0_206():
##@@@P_:weak_interrupt_tc0.c:234
##@@@L0234_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 206);   
8001f9c0:	00 04       	SJMP      $+0                   ;->0x8001f9c0
8001f9c2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0CF:

8001f9e0 <__iVecEntry0_207>:
##@@@F_:__iVecEntry0_207():
##@@@P_:weak_interrupt_tc0.c:235
##@@@L0235_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 207);   
8001f9e0:	00 04       	SJMP      $+0                   ;->0x8001f9e0
8001f9e2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D0:

8001fa00 <__iVecEntry0_208>:
##@@@F_:__iVecEntry0_208():
##@@@P_:weak_interrupt_tc0.c:236
##@@@L0236_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 208);   
8001fa00:	00 04       	SJMP      $+0                   ;->0x8001fa00
8001fa02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D1:

8001fa20 <__iVecEntry0_209>:
##@@@F_:__iVecEntry0_209():
##@@@P_:weak_interrupt_tc0.c:237
##@@@L0237_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 209);   
8001fa20:	00 04       	SJMP      $+0                   ;->0x8001fa20
8001fa22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D2:

8001fa40 <__iVecEntry0_210>:
##@@@F_:__iVecEntry0_210():
##@@@P_:weak_interrupt_tc0.c:238
##@@@L0238_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 210);   
8001fa40:	00 04       	SJMP      $+0                   ;->0x8001fa40
8001fa42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D3:

8001fa60 <__iVecEntry0_211>:
##@@@F_:__iVecEntry0_211():
##@@@P_:weak_interrupt_tc0.c:239
##@@@L0239_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 211);   
8001fa60:	00 04       	SJMP      $+0                   ;->0x8001fa60
8001fa62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D4:

8001fa80 <__iVecEntry0_212>:
##@@@F_:__iVecEntry0_212():
##@@@P_:weak_interrupt_tc0.c:240
##@@@L0240_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 212);   
8001fa80:	00 04       	SJMP      $+0                   ;->0x8001fa80
8001fa82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D5:

8001faa0 <__iVecEntry0_213>:
##@@@F_:__iVecEntry0_213():
##@@@P_:weak_interrupt_tc0.c:241
##@@@L0241_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 213);   
8001faa0:	00 04       	SJMP      $+0                   ;->0x8001faa0
8001faa2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D6:

8001fac0 <__iVecEntry0_214>:
##@@@F_:__iVecEntry0_214():
##@@@P_:weak_interrupt_tc0.c:242
##@@@L0242_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 214);   
8001fac0:	00 04       	SJMP      $+0                   ;->0x8001fac0
8001fac2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D7:

8001fae0 <__iVecEntry0_215>:
##@@@F_:__iVecEntry0_215():
##@@@P_:weak_interrupt_tc0.c:243
##@@@L0243_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 215);   
8001fae0:	00 04       	SJMP      $+0                   ;->0x8001fae0
8001fae2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D8:

8001fb00 <__iVecEntry0_216>:
##@@@F_:__iVecEntry0_216():
##@@@P_:weak_interrupt_tc0.c:244
##@@@L0244_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 216);   
8001fb00:	00 04       	SJMP      $+0                   ;->0x8001fb00
8001fb02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0D9:

8001fb20 <__iVecEntry0_217>:
##@@@F_:__iVecEntry0_217():
##@@@P_:weak_interrupt_tc0.c:245
##@@@L0245_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 217);   
8001fb20:	00 04       	SJMP      $+0                   ;->0x8001fb20
8001fb22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0DA:

8001fb40 <__iVecEntry0_218>:
##@@@F_:__iVecEntry0_218():
##@@@P_:weak_interrupt_tc0.c:246
##@@@L0246_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 218);   
8001fb40:	00 04       	SJMP      $+0                   ;->0x8001fb40
8001fb42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0DB:

8001fb60 <__iVecEntry0_219>:
##@@@F_:__iVecEntry0_219():
##@@@P_:weak_interrupt_tc0.c:247
##@@@L0247_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 219);   
8001fb60:	00 04       	SJMP      $+0                   ;->0x8001fb60
8001fb62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0DC:

8001fb80 <__iVecEntry0_220>:
##@@@F_:__iVecEntry0_220():
##@@@P_:weak_interrupt_tc0.c:248
##@@@L0248_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 220);   
8001fb80:	00 04       	SJMP      $+0                   ;->0x8001fb80
8001fb82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0DD:

8001fba0 <__iVecEntry0_221>:
##@@@F_:__iVecEntry0_221():
##@@@P_:weak_interrupt_tc0.c:249
##@@@L0249_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 221);   
8001fba0:	00 04       	SJMP      $+0                   ;->0x8001fba0
8001fba2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0DE:

8001fbc0 <__iVecEntry0_222>:
##@@@F_:__iVecEntry0_222():
##@@@P_:weak_interrupt_tc0.c:250
##@@@L0250_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 222);   
8001fbc0:	00 04       	SJMP      $+0                   ;->0x8001fbc0
8001fbc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0DF:

8001fbe0 <__iVecEntry0_223>:
##@@@F_:__iVecEntry0_223():
##@@@P_:weak_interrupt_tc0.c:251
##@@@L0251_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 223);   
8001fbe0:	00 04       	SJMP      $+0                   ;->0x8001fbe0
8001fbe2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E0:

8001fc00 <__iVecEntry0_224>:
##@@@F_:__iVecEntry0_224():
##@@@P_:weak_interrupt_tc0.c:252
##@@@L0252_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 224);   
8001fc00:	00 04       	SJMP      $+0                   ;->0x8001fc00
8001fc02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E1:

8001fc20 <__iVecEntry0_225>:
##@@@F_:__iVecEntry0_225():
##@@@P_:weak_interrupt_tc0.c:253
##@@@L0253_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 225);   
8001fc20:	00 04       	SJMP      $+0                   ;->0x8001fc20
8001fc22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E2:

8001fc40 <__iVecEntry0_226>:
##@@@F_:__iVecEntry0_226():
##@@@P_:weak_interrupt_tc0.c:254
##@@@L0254_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 226);   
8001fc40:	00 04       	SJMP      $+0                   ;->0x8001fc40
8001fc42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E3:

8001fc60 <__iVecEntry0_227>:
##@@@F_:__iVecEntry0_227():
##@@@P_:weak_interrupt_tc0.c:255
##@@@L0255_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 227);   
8001fc60:	00 04       	SJMP      $+0                   ;->0x8001fc60
8001fc62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E4:

8001fc80 <__iVecEntry0_228>:
##@@@F_:__iVecEntry0_228():
##@@@P_:weak_interrupt_tc0.c:256
##@@@L0256_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 228);   
8001fc80:	00 04       	SJMP      $+0                   ;->0x8001fc80
8001fc82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E5:

8001fca0 <__iVecEntry0_229>:
##@@@F_:__iVecEntry0_229():
##@@@P_:weak_interrupt_tc0.c:257
##@@@L0257_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 229);   
8001fca0:	00 04       	SJMP      $+0                   ;->0x8001fca0
8001fca2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E6:

8001fcc0 <__iVecEntry0_230>:
##@@@F_:__iVecEntry0_230():
##@@@P_:weak_interrupt_tc0.c:258
##@@@L0258_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 230);   
8001fcc0:	00 04       	SJMP      $+0                   ;->0x8001fcc0
8001fcc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E7:

8001fce0 <__iVecEntry0_231>:
##@@@F_:__iVecEntry0_231():
##@@@P_:weak_interrupt_tc0.c:259
##@@@L0259_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 231);   
8001fce0:	00 04       	SJMP      $+0                   ;->0x8001fce0
8001fce2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E8:

8001fd00 <__iVecEntry0_232>:
##@@@F_:__iVecEntry0_232():
##@@@P_:weak_interrupt_tc0.c:260
##@@@L0260_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 232);   
8001fd00:	00 04       	SJMP      $+0                   ;->0x8001fd00
8001fd02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0E9:

8001fd20 <__iVecEntry0_233>:
##@@@F_:__iVecEntry0_233():
##@@@P_:weak_interrupt_tc0.c:261
##@@@L0261_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 233);   
8001fd20:	00 04       	SJMP      $+0                   ;->0x8001fd20
8001fd22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0EA:

8001fd40 <__iVecEntry0_234>:
##@@@F_:__iVecEntry0_234():
##@@@P_:weak_interrupt_tc0.c:262
##@@@L0262_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 234);   
8001fd40:	00 04       	SJMP      $+0                   ;->0x8001fd40
8001fd42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0EB:

8001fd60 <__iVecEntry0_235>:
##@@@F_:__iVecEntry0_235():
##@@@P_:weak_interrupt_tc0.c:263
##@@@L0263_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 235);   
8001fd60:	00 04       	SJMP      $+0                   ;->0x8001fd60
8001fd62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0EC:

8001fd80 <__iVecEntry0_236>:
##@@@F_:__iVecEntry0_236():
##@@@P_:weak_interrupt_tc0.c:264
##@@@L0264_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 236);   
8001fd80:	00 04       	SJMP      $+0                   ;->0x8001fd80
8001fd82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0ED:

8001fda0 <__iVecEntry0_237>:
##@@@F_:__iVecEntry0_237():
##@@@P_:weak_interrupt_tc0.c:265
##@@@L0265_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 237);   
8001fda0:	00 04       	SJMP      $+0                   ;->0x8001fda0
8001fda2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0EE:

8001fdc0 <__iVecEntry0_238>:
##@@@F_:__iVecEntry0_238():
##@@@P_:weak_interrupt_tc0.c:266
##@@@L0266_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 238);   
8001fdc0:	00 04       	SJMP      $+0                   ;->0x8001fdc0
8001fdc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0EF:

8001fde0 <__iVecEntry0_239>:
##@@@F_:__iVecEntry0_239():
##@@@P_:weak_interrupt_tc0.c:267
##@@@L0267_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 239);   
8001fde0:	00 04       	SJMP      $+0                   ;->0x8001fde0
8001fde2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F0:

8001fe00 <__iVecEntry0_240>:
##@@@F_:__iVecEntry0_240():
##@@@P_:weak_interrupt_tc0.c:268
##@@@L0268_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 240);   
8001fe00:	00 04       	SJMP      $+0                   ;->0x8001fe00
8001fe02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F1:

8001fe20 <__iVecEntry0_241>:
##@@@F_:__iVecEntry0_241():
##@@@P_:weak_interrupt_tc0.c:269
##@@@L0269_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 241);   
8001fe20:	00 04       	SJMP      $+0                   ;->0x8001fe20
8001fe22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F2:

8001fe40 <__iVecEntry0_242>:
##@@@F_:__iVecEntry0_242():
##@@@P_:weak_interrupt_tc0.c:270
##@@@L0270_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 242);   
8001fe40:	00 04       	SJMP      $+0                   ;->0x8001fe40
8001fe42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F3:

8001fe60 <__iVecEntry0_243>:
##@@@F_:__iVecEntry0_243():
##@@@P_:weak_interrupt_tc0.c:271
##@@@L0271_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 243);   
8001fe60:	00 04       	SJMP      $+0                   ;->0x8001fe60
8001fe62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F4:

8001fe80 <__iVecEntry0_244>:
##@@@F_:__iVecEntry0_244():
##@@@P_:weak_interrupt_tc0.c:272
##@@@L0272_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 244);   
8001fe80:	00 04       	SJMP      $+0                   ;->0x8001fe80
8001fe82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F5:

8001fea0 <__iVecEntry0_245>:
##@@@F_:__iVecEntry0_245():
##@@@P_:weak_interrupt_tc0.c:273
##@@@L0273_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 245);   
8001fea0:	00 04       	SJMP      $+0                   ;->0x8001fea0
8001fea2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F6:

8001fec0 <__iVecEntry0_246>:
##@@@F_:__iVecEntry0_246():
##@@@P_:weak_interrupt_tc0.c:274
##@@@L0274_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 246);   
8001fec0:	00 04       	SJMP      $+0                   ;->0x8001fec0
8001fec2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F7:

8001fee0 <__iVecEntry0_247>:
##@@@F_:__iVecEntry0_247():
##@@@P_:weak_interrupt_tc0.c:275
##@@@L0275_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 247);   
8001fee0:	00 04       	SJMP      $+0                   ;->0x8001fee0
8001fee2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F8:

8001ff00 <__iVecEntry0_248>:
##@@@F_:__iVecEntry0_248():
##@@@P_:weak_interrupt_tc0.c:276
##@@@L0276_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 248);   
8001ff00:	00 04       	SJMP      $+0                   ;->0x8001ff00
8001ff02:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0F9:

8001ff20 <__iVecEntry0_249>:
##@@@F_:__iVecEntry0_249():
##@@@P_:weak_interrupt_tc0.c:277
##@@@L0277_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 249);   
8001ff20:	00 04       	SJMP      $+0                   ;->0x8001ff20
8001ff22:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0FA:

8001ff40 <__iVecEntry0_250>:
##@@@F_:__iVecEntry0_250():
##@@@P_:weak_interrupt_tc0.c:278
##@@@L0278_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 250);   
8001ff40:	00 04       	SJMP      $+0                   ;->0x8001ff40
8001ff42:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0FB:

8001ff60 <__iVecEntry0_251>:
##@@@F_:__iVecEntry0_251():
##@@@P_:weak_interrupt_tc0.c:279
##@@@L0279_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 251);   
8001ff60:	00 04       	SJMP      $+0                   ;->0x8001ff60
8001ff62:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0FC:

8001ff80 <__iVecEntry0_252>:
##@@@F_:__iVecEntry0_252():
##@@@P_:weak_interrupt_tc0.c:280
##@@@L0280_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 252);   
8001ff80:	00 04       	SJMP      $+0                   ;->0x8001ff80
8001ff82:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0FD:

8001ffa0 <__iVecEntry0_253>:
##@@@F_:__iVecEntry0_253():
##@@@P_:weak_interrupt_tc0.c:281
##@@@L0281_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 253);   
8001ffa0:	00 04       	SJMP      $+0                   ;->0x8001ffa0
8001ffa2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0FE:

8001ffc0 <__iVecEntry0_254>:
##@@@F_:__iVecEntry0_254():
##@@@P_:weak_interrupt_tc0.c:282
##@@@L0282_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 254);   
8001ffc0:	00 04       	SJMP      $+0                   ;->0x8001ffc0
8001ffc2:	1d 5c       	JMP       LR

Disassembly of section .inttab_tc0_0FF:

8001ffe0 <__iVecEntry0_255>:
##@@@F_:__iVecEntry0_255():
##@@@P_:weak_interrupt_tc0.c:283
##@@@L0283_:KFX_WEAK_INTERRUPT(default_core0_while, 0, 255);   
8001ffe0:	00 04       	SJMP      $+0                   ;->0x8001ffe0
8001ffe2:	1d 5c       	JMP       LR

Disassembly of section .CPU0.psram_text:

d000d7a8 <Clk_NopDelay>:
##@@@F_:Clk_NopDelay():
##@@@P_:kf32a13k_hw_clk.c:167
##@@@L0162_: * @attention 低频时延时时间不准确   
##@@@L0163_: * @retval void   
##@@@L0164_: */   
##@@@L0165_:#ifndef SIMULATION   
##@@@L0166_:__attribute__((noinline, section(".indata"), optnone)) static void Clk_NopDelay(uint32_t DelayCount)   
##@@@L0167_:{   
d000d7a8:	e8 30       	SUB       SP, #8			;->0x08
d000d7aa:	01 20       	ST.W      [SP + #1], R0
##@@@P_:kf32a13k_hw_clk.c:168
##@@@L0168_:    asm volatile("MOV R0, %0" ::"r"(DelayCount));   
d000d7ac:	01 0d       	LD.W      R5, [SP + #1]
d000d7ae:	05 58       	MOV       R0, R5
##@@@P_:kf32a13k_hw_clk.c:169
##@@@L0169_:    asm volatile("LSR R0, #3");   
d000d7b0:	03 7c       	LSR       R0, #3			;->0x03
##@@@P_:kf32a13k_hw_clk.c:170
##@@@L0170_:    asm volatile("SUB R0, R0, #1");   
d000d7b2:	40 cc       	SUB       R0, R0, #1
##@@@P_:kf32a13k_hw_clk.c:171
##@@@L0171_:    asm volatile("NOP");   
d000d7b4:	00 00       	NOP      NOP      
##@@@P_:kf32a13k_hw_clk.c:172
##@@@L0172_:    asm volatile("NOP");   
d000d7b6:	00 00       	NOP      NOP      
##@@@P_:kf32a13k_hw_clk.c:173
##@@@L0173_:    asm volatile("NOP");   
d000d7b8:	00 00       	NOP      NOP      
##@@@P_:kf32a13k_hw_clk.c:174
##@@@L0174_:    asm volatile("CMP R0, #0");   
d000d7ba:	00 38       	CMP       R0, #0			;->0x00
##@@@P_:kf32a13k_hw_clk.c:175
##@@@L0175_:    asm volatile("JNZ $-5");   
d000d7bc:	fb f1       	JNZ       $-5                   ;->0xd000d7b2
##@@@P_:kf32a13k_hw_clk.c:176
##@@@L0176_:}   
d000d7be:	e8 28       	ADD       SP, #8			;->0x08
d000d7c0:	1d 5c       	JMP       LR
	...

Disassembly of section .CPU0.text:

800017f8 <Kfx_Ssw_C_InitInline>:
##@@@F_:Kfx_Ssw_C_InitInline():
##@@@P_:Kfx_Ssw_Tc0.c:36
##@@@L0031_:#if defined(__GNUC__)   
##@@@L0032_:#pragma GCC optimize "O2"   
##@@@L0033_:#endif   
##@@@L0034_:
##@@@L0035_:void Kfx_Ssw_C_InitInline(void)   
##@@@L0036_:{   
800017f8:	0f 5f       	PUSH      {R6-R9}
800017fa:	e0 31       	SUB       SP, #16			;->0x10
##@@@P_:Kfx_Ssw_Tc0.c:45
##@@@L0040_:    /* clear table */   
##@@@L0041_:    pTable = (unsigned int *)&__clear_table;   
##@@@L0042_:
##@@@L0043_:    while (pTable)   
##@@@L0044_:    {   
##@@@L0045_:        pBlockDest.uiPtr = (unsigned int *)*pTable++;   
800017fc:	43 44       	LD        R4, [PC + #67]        ;->0x80001908  :=0x80001704
800017fe:	54 82       	LD.W      R5, [R4]
80001800:	03 25       	ST.W      [SP + #3], R5
##@@@P_:Kfx_Ssw_Tc0.c:46
##@@@L0046_:        uiLength         = *pTable++;   
80001802:	5c 98       	LD.W      R3, [R4 + #1]
##@@@P_:Kfx_Ssw_Tc0.c:49
##@@@L0047_:
##@@@L0048_:        /* we are finished when length == -1 */   
##@@@L0049_:        if (uiLength == 0xFFFFFFFF)   
80001804:	42 45       	LD        R5, [PC + #66]        ;->0x8000190c  :=0xffffffff
80001806:	01 25       	ST.W      [SP + #1], R5
80001808:	35 70       	CMP       R3, R5
8000180a:	31 f0       	JZ        $+49                  ;->0x8000186c
8000180c:	48 28       	ADD       R4, #8			;->0x08
8000180e:	84 10       	MOV       R8, #4			;->0x0004
80001810:	12 10       	MOV       R1, #2			;->0x0002
80001812:	01 10       	MOV       R0, #1			;->0x0001
80001814:	60 10       	MOV       R6, #0			;->0x0000
80001816:	08 04       	SJMP      $+8                   ;->0x80001826
##@@@P_:Kfx_Ssw_Tc0.c:45
##@@@L0040_:    /* clear table */   
##@@@L0041_:    pTable = (unsigned int *)&__clear_table;   
##@@@L0042_:
##@@@L0043_:    while (pTable)   
##@@@L0044_:    {   
##@@@L0045_:        pBlockDest.uiPtr = (unsigned int *)*pTable++;   
80001818:	54 82       	LD.W      R5, [R4]
8000181a:	03 25       	ST.W      [SP + #3], R5
##@@@P_:Kfx_Ssw_Tc0.c:46
##@@@L0046_:        uiLength         = *pTable++;   
8000181c:	5c 98       	LD.W      R3, [R4 + #1]
8000181e:	48 28       	ADD       R4, #8			;->0x08
##@@@P_:Kfx_Ssw_Tc0.c:49
##@@@L0047_:
##@@@L0048_:        /* we are finished when length == -1 */   
##@@@L0049_:        if (uiLength == 0xFFFFFFFF)   
80001820:	01 0d       	LD.W      R5, [SP + #1]
80001822:	35 70       	CMP       R3, R5
80001824:	24 f0       	JZ        $+36                  ;->0x8000186c
##@@@P_:Kfx_Ssw_Tc0.c:56
##@@@L0051_:            break;   
##@@@L0052_:        }   
##@@@L0053_:
##@@@L0054_:        uiCnt = uiLength / 8;   
##@@@L0055_:
##@@@L0056_:        while (uiCnt--)   
80001826:	38 38       	CMP       R3, #8			;->0x08
80001828:	0c f3       	JNC       $+12                  ;->0x80001840
##@@@P_:Kfx_Ssw_Tc0.c:54
##@@@L0049_:        if (uiLength == 0xFFFFFFFF)   
##@@@L0050_:        {   
##@@@L0051_:            break;   
##@@@L0052_:        }   
##@@@L0053_:
##@@@L0054_:        uiCnt = uiLength / 8;   
8000182a:	e3 58       	MOV       R7, R3
8000182c:	3b 7c       	LSR       R7, #3			;->0x03
##@@@P_:Kfx_Ssw_Tc0.c:58
##@@@L0055_:
##@@@L0056_:        while (uiCnt--)   
##@@@L0057_:        {   
##@@@L0058_:            *pBlockDest.ullPtr++ = 0;   
8000182e:	03 0a       	LD.W      R2, [SP + #3]
80001830:	a2 58       	MOV       R5, R2
80001832:	58 28       	ADD       R5, #8			;->0x08
80001834:	03 25       	ST.W      [SP + #3], R5
80001836:	56 a0       	ST.W      [R2 + #1], R6
##@@@P_:Kfx_Ssw_Tc0.c:56
##@@@L0051_:            break;   
##@@@L0052_:        }   
##@@@L0053_:
##@@@L0054_:        uiCnt = uiLength / 8;   
##@@@L0055_:
##@@@L0056_:        while (uiCnt--)   
80001838:	7f cc       	SUB       R7, R7, #1
8000183a:	70 38       	CMP       R7, #0			;->0x00
##@@@P_:Kfx_Ssw_Tc0.c:58
##@@@L0057_:        {   
##@@@L0058_:            *pBlockDest.ullPtr++ = 0;   
8000183c:	26 85       	ST.W      [R2], R6
8000183e:	f8 f1       	JNZ       $-8                   ;->0x8000182e
##@@@P_:Kfx_Ssw_Tc0.c:61
##@@@L0059_:        }   
##@@@L0060_:
##@@@L0061_:        if (uiLength & 0x4)   
80001840:	a3 58       	MOV       R5, R3
80001842:	58 69       	ANL       R5, R8
80001844:	50 38       	CMP       R5, #0			;->0x00
80001846:	05 f0       	JZ        $+5                   ;->0x80001850
##@@@P_:Kfx_Ssw_Tc0.c:63
##@@@L0062_:        {   
##@@@L0063_:            *pBlockDest.uiPtr++ = 0;   
80001848:	03 0d       	LD.W      R5, [SP + #3]
8000184a:	15 c1       	ADD       R2, R5, #4
8000184c:	03 22       	ST.W      [SP + #3], R2
8000184e:	56 85       	ST.W      [R5], R6
##@@@P_:Kfx_Ssw_Tc0.c:66
##@@@L0064_:        }   
##@@@L0065_:
##@@@L0066_:        if (uiLength & 0x2)   
80001850:	a3 58       	MOV       R5, R3
80001852:	51 69       	ANL       R5, R1
80001854:	50 38       	CMP       R5, #0			;->0x00
80001856:	05 f0       	JZ        $+5                   ;->0x80001860
##@@@P_:Kfx_Ssw_Tc0.c:68
##@@@L0067_:        {   
##@@@L0068_:            *pBlockDest.usPtr++ = 0;   
80001858:	03 0d       	LD.W      R5, [SP + #3]
8000185a:	95 c0       	ADD       R2, R5, #2
8000185c:	03 22       	ST.W      [SP + #3], R2
8000185e:	56 84       	ST.H      [R5], R6
##@@@P_:Kfx_Ssw_Tc0.c:71
##@@@L0069_:        }   
##@@@L0070_:
##@@@L0071_:        if (uiLength & 0x1)   
80001860:	30 69       	ANL       R3, R0
80001862:	30 38       	CMP       R3, #0			;->0x00
80001864:	da f0       	JZ        $-38                  ;->0x80001818
##@@@P_:Kfx_Ssw_Tc0.c:73
##@@@L0072_:        {   
##@@@L0073_:            *pBlockDest.ucPtr = 0;   
80001866:	03 0d       	LD.W      R5, [SP + #3]
80001868:	56 83       	ST.B      [R5], R6
8000186a:	d7 07       	SJMP      $-41                  ;->0x80001818
##@@@P_:Kfx_Ssw_Tc0.c:82
##@@@L0077_:    /* copy table */   
##@@@L0078_:    pTable = (unsigned int *)&__copy_table;   
##@@@L0079_:
##@@@L0080_:    while (pTable)   
##@@@L0081_:    {   
##@@@L0082_:        pBlockSrc.uiPtr  = (unsigned int *)*pTable++;   
8000186c:	29 44       	LD        R4, [PC + #41]        ;->0x80001910  :=0x8000175c
8000186e:	34 82       	LD.W      R3, [R4]
80001870:	02 23       	ST.W      [SP + #2], R3
##@@@P_:Kfx_Ssw_Tc0.c:83
##@@@L0083_:        pBlockDest.uiPtr = (unsigned int *)*pTable++;   
80001872:	5c 98       	LD.W      R3, [R4 + #1]
80001874:	03 23       	ST.W      [SP + #3], R3
##@@@P_:Kfx_Ssw_Tc0.c:84
##@@@L0084_:        uiLength         = *pTable++;   
80001876:	84 98       	LD.W      R0, [R4 + #2]
##@@@P_:Kfx_Ssw_Tc0.c:87
##@@@L0085_:
##@@@L0086_:        /* we are finished when length == -1 */   
##@@@L0087_:        if (uiLength == 0xFFFFFFFF)   
80001878:	01 0d       	LD.W      R5, [SP + #1]
8000187a:	05 70       	CMP       R0, R5
8000187c:	02 f1       	JNZ       $+2                   ;->0x80001880
8000187e:	42 04       	SJMP      $+66                  ;->0x80001902
80001880:	4c 28       	ADD       R4, #12			;->0x0C
80001882:	84 10       	MOV       R8, #4			;->0x0004
80001884:	92 10       	MOV       R9, #2			;->0x0002
80001886:	11 10       	MOV       R1, #1			;->0x0001
80001888:	0a 04       	SJMP      $+10                  ;->0x8000189c
##@@@P_:Kfx_Ssw_Tc0.c:82
##@@@L0077_:    /* copy table */   
##@@@L0078_:    pTable = (unsigned int *)&__copy_table;   
##@@@L0079_:
##@@@L0080_:    while (pTable)   
##@@@L0081_:    {   
##@@@L0082_:        pBlockSrc.uiPtr  = (unsigned int *)*pTable++;   
8000188a:	54 82       	LD.W      R5, [R4]
8000188c:	02 25       	ST.W      [SP + #2], R5
##@@@P_:Kfx_Ssw_Tc0.c:83
##@@@L0083_:        pBlockDest.uiPtr = (unsigned int *)*pTable++;   
8000188e:	6c 98       	LD.W      R5, [R4 + #1]
80001890:	03 25       	ST.W      [SP + #3], R5
##@@@P_:Kfx_Ssw_Tc0.c:84
##@@@L0084_:        uiLength         = *pTable++;   
80001892:	84 98       	LD.W      R0, [R4 + #2]
80001894:	4c 28       	ADD       R4, #12			;->0x0C
##@@@P_:Kfx_Ssw_Tc0.c:87
##@@@L0085_:
##@@@L0086_:        /* we are finished when length == -1 */   
##@@@L0087_:        if (uiLength == 0xFFFFFFFF)   
80001896:	01 0d       	LD.W      R5, [SP + #1]
80001898:	05 70       	CMP       R0, R5
8000189a:	34 f0       	JZ        $+52                  ;->0x80001902
##@@@P_:Kfx_Ssw_Tc0.c:94
##@@@L0089_:            break;   
##@@@L0090_:        }   
##@@@L0091_:
##@@@L0092_:        uiCnt = uiLength / 8;   
##@@@L0093_:
##@@@L0094_:        while (uiCnt--)   
8000189c:	08 38       	CMP       R0, #8			;->0x08
8000189e:	12 f3       	JNC       $+18                  ;->0x800018c2
##@@@P_:Kfx_Ssw_Tc0.c:92
##@@@L0087_:        if (uiLength == 0xFFFFFFFF)   
##@@@L0088_:        {   
##@@@L0089_:            break;   
##@@@L0090_:        }   
##@@@L0091_:
##@@@L0092_:        uiCnt = uiLength / 8;   
800018a0:	c0 58       	MOV       R6, R0
800018a2:	33 7c       	LSR       R6, #3			;->0x03
##@@@P_:Kfx_Ssw_Tc0.c:96
##@@@L0093_:
##@@@L0094_:        while (uiCnt--)   
##@@@L0095_:        {   
##@@@L0096_:            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;   
800018a4:	02 0d       	LD.W      R5, [SP + #2]
800018a6:	e5 58       	MOV       R7, R5
800018a8:	78 28       	ADD       R7, #8			;->0x08
800018aa:	02 27       	ST.W      [SP + #2], R7
800018ac:	75 82       	LD.W      R7, [R5]
800018ae:	6d 98       	LD.W      R5, [R5 + #1]
800018b0:	03 0a       	LD.W      R2, [SP + #3]
800018b2:	62 58       	MOV       R3, R2
800018b4:	38 28       	ADD       R3, #8			;->0x08
800018b6:	03 23       	ST.W      [SP + #3], R3
800018b8:	55 a0       	ST.W      [R2 + #1], R5
##@@@P_:Kfx_Ssw_Tc0.c:94
##@@@L0089_:            break;   
##@@@L0090_:        }   
##@@@L0091_:
##@@@L0092_:        uiCnt = uiLength / 8;   
##@@@L0093_:
##@@@L0094_:        while (uiCnt--)   
800018ba:	76 cc       	SUB       R6, R6, #1
800018bc:	60 38       	CMP       R6, #0			;->0x00
##@@@P_:Kfx_Ssw_Tc0.c:96
##@@@L0095_:        {   
##@@@L0096_:            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;   
800018be:	27 85       	ST.W      [R2], R7
##@@@P_:Kfx_Ssw_Tc0.c:94
##@@@L0089_:            break;   
##@@@L0090_:        }   
##@@@L0091_:
##@@@L0092_:        uiCnt = uiLength / 8;   
##@@@L0093_:
##@@@L0094_:        while (uiCnt--)   
800018c0:	f2 f1       	JNZ       $-14                  ;->0x800018a4
##@@@P_:Kfx_Ssw_Tc0.c:99
##@@@L0095_:        {   
##@@@L0096_:            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;   
##@@@L0097_:        }   
##@@@L0098_:
##@@@L0099_:        if (uiLength & 0x4)   
800018c2:	a0 58       	MOV       R5, R0
800018c4:	58 69       	ANL       R5, R8
800018c6:	50 38       	CMP       R5, #0			;->0x00
800018c8:	09 f0       	JZ        $+9                   ;->0x800018da
##@@@P_:Kfx_Ssw_Tc0.c:101
##@@@L0100_:        {   
##@@@L0101_:            *pBlockDest.uiPtr++ = *pBlockSrc.uiPtr++;   
800018ca:	02 0d       	LD.W      R5, [SP + #2]
800018cc:	1d c1       	ADD       R3, R5, #4
800018ce:	02 23       	ST.W      [SP + #2], R3
800018d0:	55 82       	LD.W      R5, [R5]
800018d2:	03 0b       	LD.W      R3, [SP + #3]
800018d4:	13 c1       	ADD       R2, R3, #4
800018d6:	03 22       	ST.W      [SP + #3], R2
800018d8:	35 85       	ST.W      [R3], R5
##@@@P_:Kfx_Ssw_Tc0.c:104
##@@@L0102_:        }   
##@@@L0103_:
##@@@L0104_:        if (uiLength & 0x2)   
800018da:	a0 58       	MOV       R5, R0
800018dc:	59 69       	ANL       R5, R9
800018de:	50 38       	CMP       R5, #0			;->0x00
800018e0:	09 f0       	JZ        $+9                   ;->0x800018f2
##@@@P_:Kfx_Ssw_Tc0.c:106
##@@@L0105_:        {   
##@@@L0106_:            *pBlockDest.usPtr++ = *pBlockSrc.usPtr++;   
800018e2:	02 0d       	LD.W      R5, [SP + #2]
800018e4:	9d c0       	ADD       R3, R5, #2
800018e6:	02 23       	ST.W      [SP + #2], R3
800018e8:	55 81       	LD.H      R5, [R5]
800018ea:	03 0b       	LD.W      R3, [SP + #3]
800018ec:	93 c0       	ADD       R2, R3, #2
800018ee:	03 22       	ST.W      [SP + #3], R2
800018f0:	35 84       	ST.H      [R3], R5
##@@@P_:Kfx_Ssw_Tc0.c:109
##@@@L0107_:        }   
##@@@L0108_:
##@@@L0109_:        if (uiLength & 0x1)   
800018f2:	01 69       	ANL       R0, R1
800018f4:	00 38       	CMP       R0, #0			;->0x00
800018f6:	ca f0       	JZ        $-54                  ;->0x8000188a
##@@@P_:Kfx_Ssw_Tc0.c:111
##@@@L0110_:        {   
##@@@L0111_:            *pBlockDest.ucPtr = *pBlockSrc.ucPtr;   
800018f8:	02 0d       	LD.W      R5, [SP + #2]
800018fa:	55 80       	LD.B      R5, [R5]
800018fc:	03 0b       	LD.W      R3, [SP + #3]
800018fe:	35 83       	ST.B      [R3], R5
80001900:	c5 07       	SJMP      $-59                  ;->0x8000188a
##@@@P_:Kfx_Ssw_Tc0.c:114
##@@@L0112_:        }   
##@@@L0113_:    }   
##@@@L0114_:}   
80001902:	e0 29       	ADD       SP, #16			;->0x10
80001904:	0f 5e       	POP       {R6-R9}
80001906:	1d 5c       	JMP       LR
80001908:	04 17 00 80 	.long     0x80001704 ->-2147477756  [!!!@2@:MOV       R0, #116	@@: LD.B      R0, [R0]
8000190c:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80001910:	5c 17 00 80 	.long     0x8000175c ->-2147477668  [!!!@2@:MOV       R5, #124	@@: LD.B      R0, [R0]

80001914 <hardware_init_hook>:
##@@@F_:hardware_init_hook():
##@@@P_:Kfx_Ssw_Tc0.c:132
##@@@L0127_:
##@@@L0128_:void __Core0_start(void);   
##@@@L0129_:/*********************************************************************************   
##@@@L0130_: * - startup code   
##@@@L0131_: *********************************************************************************/   
##@@@L0132_:_WEAK void hardware_init_hook(void) {}   
80001914:	1d 5c       	JMP       LR
	...

80001918 <software_init_hook>:
##@@@F_:software_init_hook():
##@@@P_:Kfx_Ssw_Tc0.c:134
##@@@L0133_:
##@@@L0134_:_WEAK void software_init_hook(void) {}   
80001918:	1d 5c       	JMP       LR
	...

8000191c <__Core0_start>:
##@@@F_:__Core0_start():
##@@@P_:Kfx_Ssw_Tc0.c:154
##@@@L0149_:extern unsigned int __USTACK0[];      /**< user stack end */   
##@@@L0150_:extern unsigned int __ISTACK0[];      /**< interrupt stack end */   
##@@@L0151_:extern unsigned int __INTTAB_CPU0[];  /**< interrupt vector table */   
##@@@L0152_:extern unsigned int __TRAPTAB_CPU0[]; /**< trap vector table */   
##@@@L0153_:void                __Core0_start(void)   
##@@@L0154_:{   
8000191c:	2d 5d       	PUSH      LR
8000191e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:Kfx_Ssw_Tc0.c:157
##@@@L0155_:
##@@@L0156_:    /* Hook functions to initialize application specific HW extensions */   
##@@@L0157_:    hardware_init_hook();   
80001920:	09 45       	LD        R5, [PC + #9]         ;->0x80001944  :=0x80001914
80001922:	05 5c       	LJMP      R5
##@@@P_:Kfx_Ssw_Tc0.c:160
##@@@L0158_:
##@@@L0159_:    /* Hook functions to initialize application specific SW extensions */   
##@@@L0160_:    software_init_hook();   
80001924:	09 45       	LD        R5, [PC + #9]         ;->0x80001948  :=0x80001918
80001926:	05 5c       	LJMP      R5
##@@@P_:Kfx_Ssw_Tc0.c:163
##@@@L0161_:
##@@@L0162_:    /* Initialization of C runtime variables and CPP constructors and destructors */   
##@@@L0163_:    Kfx_Ssw_C_InitInline();   
80001928:	09 45       	LD        R5, [PC + #9]         ;->0x8000194c  :=0x800017f8
8000192a:	05 5c       	LJMP      R5
##@@@P_:Kfx_Ssw_Tc0.c:164
##@@@L0164_:    __asm__ volatile("PUSH R0" ::: "memory");   
8000192c:	20 5d       	PUSH      R0
##@@@P_:Kfx_Ssw_Tc0.c:181
##@@@L0176_://    __asm__ volatile("SYNC");   
##@@@L0177_:    /* SP */   
##@@@L0178_://    __asm__ volatile("MOV SP, %0" ::"r"((unsigned int)__USTACK0) : "R0");   
##@@@L0179_://    __asm__ volatile("SYNC");   
##@@@L0180_:
##@@@L0181_:    __asm__ volatile("POP R0" ::: "memory");   
8000192e:	00 5d       	POP       R0
##@@@F_:__jump_and_link():
##@@@P_:Cpu_Intrinsics.h:61
##@@@L0056_: */   
##@@@L0057_:_KF_INLINE void __jump_and_link(void (*fun)(void))   
##@@@L0058_:{   
##@@@L0059_:    __asm__ volatile("PUSH      R5" ::: "memory");   
##@@@L0060_:    /** @attention "MOV  R5, %0" : : "r"(fun)操作在O0优化下编译器行为不可预测 */   
##@@@L0061_:    __asm__ volatile("MOV  R5, %0" : : "r"(fun) : "R5");   
80001930:	08 44       	LD        R4, [PC + #8]         ;->0x80001950  :=0x80001954
##@@@P_:Cpu_Intrinsics.h:59
##@@@L0054_:
##@@@L0055_:/** Jump and link   
##@@@L0056_: */   
##@@@L0057_:_KF_INLINE void __jump_and_link(void (*fun)(void))   
##@@@L0058_:{   
##@@@L0059_:    __asm__ volatile("PUSH      R5" ::: "memory");   
80001932:	25 5d       	PUSH      R5
##@@@P_:Cpu_Intrinsics.h:61
##@@@L0060_:    /** @attention "MOV  R5, %0" : : "r"(fun)操作在O0优化下编译器行为不可预测 */   
##@@@L0061_:    __asm__ volatile("MOV  R5, %0" : : "r"(fun) : "R5");   
80001934:	a4 58       	MOV       R5, R4
##@@@P_:Cpu_Intrinsics.h:63
##@@@L0062_:    // __asm__ volatile("MOV R5, R0");   
##@@@L0063_:    __asm__ volatile("LJMP       R5");   
80001936:	05 5c       	LJMP      R5
##@@@P_:Cpu_Intrinsics.h:64
##@@@L0064_:    __asm__ volatile("POP       R5" ::: "memory");   
80001938:	05 5d       	POP       R5
##@@@F_:__Loop():
##@@@P_:Cpu_Intrinsics.h:91
##@@@L0086_:}   
##@@@L0087_:
##@@@L0088_:/******************************************************************************/   
##@@@L0089_:_KF_INLINE void __Loop(void)   
##@@@L0090_:{   
##@@@L0091_:    __asm__ volatile("sjmp $+0");   
8000193a:	00 04       	SJMP      $+0                   ;->0x8000193a
##@@@F_:__Core0_start():
##@@@P_:Kfx_Ssw_Tc0.c:188
##@@@L0183_:    extern void core0_main(void);   
##@@@L0184_:    __jumpToFunctionWithLink(core0_main); /* Jump to main function of CPU0 */   
##@@@L0185_:
##@@@L0186_:    /* Go into infinite loop, normally the code shall not reach here */   
##@@@L0187_:    __Loop();   
##@@@L0188_:}   
8000193c:	e4 28       	ADD       SP, #4			;->0x04
8000193e:	0d 5d       	POP       LR
80001940:	1d 5c       	JMP       LR
80001942:	00 00       	NOP      NOP      
80001944:	14 19 00 80 	.long     0x80001914 ->-2147477228  [!!!@2@:MOV       R1, #148	@@: LD.B      R0, [R0]
80001948:	18 19 00 80 	.long     0x80001918 ->-2147477224  [!!!@2@:MOV       R1, #152	@@: LD.B      R0, [R0]
8000194c:	f8 17 00 80 	.long     0x800017f8 ->-2147477512  [!!!@2@:MOV       PC, #120	@@: LD.B      R0, [R0]
80001950:	54 19 00 80 	.long     0x80001954 ->-2147477164  [!!!@2@:MOV       R5, #148	@@: LD.B      R0, [R0]

80001954 <core0_main>:
##@@@F_:core0_main():
##@@@P_:Cpu0_Main.c:46
##@@@L0043_:KFX_INTERRUPT_INTERNAL(interruptSwGp0Sr0, 0, 0);   
##@@@L0044_:
##@@@L0045_:void core0_main(void)   
##@@@L0046_:{   
80001954:	e8 30       	SUB       SP, #8			;->0x08
80001956:	53 10       	MOV       R5, #3			;->0x0003
##@@@P_:Cpu0_Main.c:48
##@@@L0047_:#if 1   
##@@@L0048_:	volatile int a=3;   
80001958:	01 25       	ST.W      [SP + #1], R5
##@@@P_:Cpu0_Main.c:50
##@@@L0049_:
##@@@L0050_:	a++;   
8000195a:	01 0d       	LD.W      R5, [SP + #1]
8000195c:	6d c0       	ADD       R5, R5, #1
8000195e:	01 25       	ST.W      [SP + #1], R5
##@@@P_:Cpu0_Main.c:53
##@@@L0051_:	while(1)   
##@@@L0052_:	{   
##@@@L0053_:		a++;   
80001960:	01 0d       	LD.W      R5, [SP + #1]
80001962:	6d c0       	ADD       R5, R5, #1
80001964:	01 25       	ST.W      [SP + #1], R5
##@@@P_:Cpu0_Main.c:51
##@@@L0046_:{   
##@@@L0047_:#if 1   
##@@@L0048_:	volatile int a=3;   
##@@@L0049_:
##@@@L0050_:	a++;   
##@@@L0051_:	while(1)   
80001966:	fd 07       	SJMP      $-3                   ;->0x80001960

Disassembly of section .text:

80001984 <os_sleep>:
##@@@F_:os_sleep():
##@@@P_:app_task.c:50
##@@@L0045_: * @brief 系统延时   
##@@@L0046_: *   
##@@@L0047_: * @param  msec-延时时间，单位毫秒   
##@@@L0048_: */   
##@@@L0049_:void os_sleep(int msec)   
##@@@L0050_:{   
80001984:	2d 5d       	PUSH      LR
80001986:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:app_task.c:54
##@@@L0051_:    TickType_t ticks = msec / portTICK_PERIOD_MS;   
##@@@L0052_:
##@@@L0053_:    /* Minimum delay = 1 tick */   
##@@@L0054_:    vTaskDelay(ticks ? ticks : 1);   
80001988:	00 38       	CMP       R0, #0			;->0x00
8000198a:	02 f1       	JNZ       $+2                   ;->0x8000198e
8000198c:	01 10       	MOV       R0, #1			;->0x0001
8000198e:	03 45       	LD        R5, [PC + #3]         ;->0x80001998  :=0x80005c80
80001990:	05 5c       	LJMP      R5
##@@@P_:app_task.c:55
##@@@L0055_:}   
80001992:	e4 28       	ADD       SP, #4			;->0x04
80001994:	0d 5d       	POP       LR
80001996:	1d 5c       	JMP       LR
80001998:	80 5c 00 80 	.long     0x80005c80 ->-2147459968  [!!!@4@:LJMP      $+32768               ;->0x80011998

8000199c <main_task>:
##@@@F_:main_task():
##@@@P_:app_task.c:65
##@@@L0060_: * @param pvParameters-函数入参   
##@@@L0061_: *   
##@@@L0062_: * @return None   
##@@@L0063_: */   
##@@@L0064_:void main_task(void *pvParameters)   
##@@@L0065_:{   
8000199c:	81 5f       	PUSH      {R6,LR}
8000199e:	e4 30       	SUB       SP, #4			;->0x04
800019a0:	61 10       	MOV       R6, #1			;->0x0001
##@@@F_:os_sleep():
##@@@P_:app_task.c:54
##@@@L0049_:void os_sleep(int msec)   
##@@@L0050_:{   
##@@@L0051_:    TickType_t ticks = msec / portTICK_PERIOD_MS;   
##@@@L0052_:
##@@@L0053_:    /* Minimum delay = 1 tick */   
##@@@L0054_:    vTaskDelay(ticks ? ticks : 1);   
800019a2:	06 58       	MOV       R0, R6
800019a4:	02 45       	LD        R5, [PC + #2]         ;->0x800019ac  :=0x80005c80
800019a6:	05 5c       	LJMP      R5
##@@@F_:main_task():
##@@@P_:app_task.c:68
##@@@L0063_: */   
##@@@L0064_:void main_task(void *pvParameters)   
##@@@L0065_:{   
##@@@L0066_:    uint32_t device_run_num = 0;   
##@@@L0067_:
##@@@L0068_:    while (1)   
800019a8:	fd 07       	SJMP      $-3                   ;->0x800019a2
800019aa:	00 00       	NOP      NOP      
800019ac:	80 5c 00 80 	.long     0x80005c80 ->-2147459968  [!!!@4@:LJMP      $+32768               ;->0x800119ac

800019b0 <xEventGroupCreateStatic>:
##@@@F_:xEventGroupCreateStatic():
##@@@P_:event_groups.c:81
##@@@L0076_:/*-----------------------------------------------------------*/   
##@@@L0077_:
##@@@L0078_:#if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L0079_:
##@@@L0080_:    EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer )   
##@@@L0081_:    {   
800019b0:	81 5f       	PUSH      {R6,LR}
800019b2:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:event_groups.c:87
##@@@L0082_:        EventGroup_t * pxEventBits;   
##@@@L0083_:
##@@@L0084_:        traceENTER_xEventGroupCreateStatic( pxEventGroupBuffer );   
##@@@L0085_:
##@@@L0086_:        /* A StaticEventGroup_t object must be provided. */   
##@@@L0087_:        configASSERT( pxEventGroupBuffer );   
800019b4:	00 38       	CMP       R0, #0			;->0x00
800019b6:	15 f0       	JZ        $+21                  ;->0x800019e0
800019b8:	50 12       	MOV       R5, #32			;->0x0020
##@@@P_:event_groups.c:94
##@@@L0089_:        #if ( configASSERT_DEFINED == 1 )   
##@@@L0090_:        {   
##@@@L0091_:            /* Sanity check that the size of the structure used to declare a   
##@@@L0092_:             * variable of type StaticEventGroup_t equals the size of the real   
##@@@L0093_:             * event group structure. */   
##@@@L0094_:            volatile size_t xSize = sizeof( StaticEventGroup_t );   
800019ba:	01 25       	ST.W      [SP + #1], R5
##@@@P_:event_groups.c:95
##@@@L0095_:            configASSERT( xSize == sizeof( EventGroup_t ) );   
800019bc:	01 0d       	LD.W      R5, [SP + #1]
800019be:	50 3a       	CMP       R5, #32			;->0x20
800019c0:	33 f1       	JNZ       $+51                  ;->0x80001a26
800019c2:	c0 58       	MOV       R6, R0
800019c4:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:event_groups.c:107
##@@@L0102_:        /* coverity[misra_c_2012_rule_11_3_violation] */   
##@@@L0103_:        pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer;   
##@@@L0104_:
##@@@L0105_:        if( pxEventBits != NULL )   
##@@@L0106_:        {   
##@@@L0107_:            pxEventBits->uxEventBits = 0;   
800019c6:	05 85       	ST.W      [R0], R5
##@@@P_:event_groups.c:108
##@@@L0108_:            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );   
800019c8:	00 c1       	ADD       R0, R0, #4
800019ca:	05 45       	LD        R5, [PC + #5]         ;->0x800019dc  :=0x80002224
800019cc:	05 5c       	LJMP      R5
800019ce:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:event_groups.c:115
##@@@L0110_:            #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )   
##@@@L0111_:            {   
##@@@L0112_:                /* Both static and dynamic allocation can be used, so note that   
##@@@L0113_:                 * this event group was created statically in case the event group   
##@@@L0114_:                 * is later deleted. */   
##@@@L0115_:                pxEventBits->ucStaticallyAllocated = pdTRUE;   
800019d0:	35 97       	ST.B      [R6 + #28], R5
##@@@P_:event_groups.c:131
##@@@L0126_:            traceEVENT_GROUP_CREATE_FAILED();   
##@@@L0127_:        }   
##@@@L0128_:
##@@@L0129_:        traceRETURN_xEventGroupCreateStatic( pxEventBits );   
##@@@L0130_:
##@@@L0131_:        return pxEventBits;   
800019d2:	06 58       	MOV       R0, R6
800019d4:	e8 28       	ADD       SP, #8			;->0x08
800019d6:	06 5d       	POP       R6
800019d8:	0d 5d       	POP       LR
800019da:	1d 5c       	JMP       LR
800019dc:	24 22 00 80 	.long     0x80002224 ->-2147474908  [!!!@2@:ST.W      [SP + #36], R2	@@: LD.B      R0, [R0]
##@@@P_:event_groups.c:87
##@@@L0082_:        EventGroup_t * pxEventBits;   
##@@@L0083_:
##@@@L0084_:        traceENTER_xEventGroupCreateStatic( pxEventGroupBuffer );   
##@@@L0085_:
##@@@L0086_:        /* A StaticEventGroup_t object must be provided. */   
##@@@L0087_:        configASSERT( pxEventGroupBuffer );   
800019e0:	20 5d       	PUSH      R0
800019e2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800019e6:	08 00       	SYNC     SYNC     
800019e8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800019ec:	08 00       	SYNC     SYNC     
800019ee:	00 5d       	POP       R0
800019f0:	20 5d       	PUSH      R0
800019f2:	21 5d       	PUSH      R1
800019f4:	1e 45       	LD        R5, [PC + #30]        ;->0x80001a6c  :=0x1ff
800019f6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800019fa:	25 58       	MOV       R1, R5
800019fc:	11 68       	NOT       R1, R1
800019fe:	01 69       	ANL       R0, R1
80001a00:	5f 11       	MOV       R5, #31			;->0x001F
80001a02:	25 58       	MOV       R1, R5
80001a04:	01 6a       	ORL       R0, R1
80001a06:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001a0a:	08 00       	SYNC     SYNC     
80001a0c:	01 5d       	POP       R1
80001a0e:	00 5d       	POP       R0
80001a10:	20 5d       	PUSH      R0
80001a12:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001a16:	08 00       	SYNC     SYNC     
80001a18:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001a1c:	08 00       	SYNC     SYNC     
80001a1e:	00 5d       	POP       R0
80001a20:	07 00       	BREAK    BREAK    
80001a22:	14 45       	LD        R5, [PC + #20]        ;->0x80001a70  :=0x8000911c
80001a24:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:95
##@@@L0090_:        {   
##@@@L0091_:            /* Sanity check that the size of the structure used to declare a   
##@@@L0092_:             * variable of type StaticEventGroup_t equals the size of the real   
##@@@L0093_:             * event group structure. */   
##@@@L0094_:            volatile size_t xSize = sizeof( StaticEventGroup_t );   
##@@@L0095_:            configASSERT( xSize == sizeof( EventGroup_t ) );   
80001a26:	20 5d       	PUSH      R0
80001a28:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001a2c:	08 00       	SYNC     SYNC     
80001a2e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001a32:	08 00       	SYNC     SYNC     
80001a34:	00 5d       	POP       R0
80001a36:	20 5d       	PUSH      R0
80001a38:	21 5d       	PUSH      R1
80001a3a:	0d 45       	LD        R5, [PC + #13]        ;->0x80001a6c  :=0x1ff
80001a3c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001a40:	25 58       	MOV       R1, R5
80001a42:	11 68       	NOT       R1, R1
80001a44:	01 69       	ANL       R0, R1
80001a46:	5f 11       	MOV       R5, #31			;->0x001F
80001a48:	25 58       	MOV       R1, R5
80001a4a:	01 6a       	ORL       R0, R1
80001a4c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001a50:	08 00       	SYNC     SYNC     
80001a52:	01 5d       	POP       R1
80001a54:	00 5d       	POP       R0
80001a56:	20 5d       	PUSH      R0
80001a58:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001a5c:	08 00       	SYNC     SYNC     
80001a5e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001a62:	08 00       	SYNC     SYNC     
80001a64:	00 5d       	POP       R0
80001a66:	07 00       	BREAK    BREAK    
80001a68:	02 45       	LD        R5, [PC + #2]         ;->0x80001a70  :=0x8000911c
80001a6a:	05 5c       	LJMP      R5
80001a6c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80001a70:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80001a74 <xEventGroupCreate>:
##@@@F_:xEventGroupCreate():
##@@@P_:event_groups.c:140
##@@@L0135_:/*-----------------------------------------------------------*/   
##@@@L0136_:
##@@@L0137_:#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )   
##@@@L0138_:
##@@@L0139_:    EventGroupHandle_t xEventGroupCreate( void )   
##@@@L0140_:    {   
80001a74:	83 5f       	PUSH      {R6-R7,LR}
80001a76:	e4 30       	SUB       SP, #4			;->0x04
80001a78:	00 12       	MOV       R0, #32			;->0x0020
##@@@P_:event_groups.c:148
##@@@L0143_:        traceENTER_xEventGroupCreate();   
##@@@L0144_:
##@@@L0145_:        /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L0146_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0147_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0148_:        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );   
80001a7a:	09 45       	LD        R5, [PC + #9]         ;->0x80001a9c  :=0x80008960
80001a7c:	05 5c       	LJMP      R5
80001a7e:	c0 58       	MOV       R6, R0
##@@@P_:event_groups.c:150
##@@@L0149_:
##@@@L0150_:        if( pxEventBits != NULL )   
80001a80:	00 38       	CMP       R0, #0			;->0x00
80001a82:	07 f0       	JZ        $+7                   ;->0x80001a90
80001a84:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:event_groups.c:152
##@@@L0151_:        {   
##@@@L0152_:            pxEventBits->uxEventBits = 0;   
80001a86:	67 85       	ST.W      [R6], R7
##@@@P_:event_groups.c:153
##@@@L0153_:            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );   
80001a88:	06 c1       	ADD       R0, R6, #4
80001a8a:	06 45       	LD        R5, [PC + #6]         ;->0x80001aa0  :=0x80002224
80001a8c:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:160
##@@@L0155_:            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L0156_:            {   
##@@@L0157_:                /* Both static and dynamic allocation can be used, so note this   
##@@@L0158_:                 * event group was allocated statically in case the event group is   
##@@@L0159_:                 * later deleted. */   
##@@@L0160_:                pxEventBits->ucStaticallyAllocated = pdFALSE;   
80001a8e:	37 97       	ST.B      [R6 + #28], R7
##@@@P_:event_groups.c:173
##@@@L0168_:            traceEVENT_GROUP_CREATE_FAILED();   
##@@@L0169_:        }   
##@@@L0170_:
##@@@L0171_:        traceRETURN_xEventGroupCreate( pxEventBits );   
##@@@L0172_:
##@@@L0173_:        return pxEventBits;   
80001a90:	06 58       	MOV       R0, R6
80001a92:	e4 28       	ADD       SP, #4			;->0x04
80001a94:	03 5e       	POP       {R6-R7}
80001a96:	0d 5d       	POP       LR
80001a98:	1d 5c       	JMP       LR
80001a9a:	00 00       	NOP      NOP      
80001a9c:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
80001aa0:	24 22 00 80 	.long     0x80002224 ->-2147474908  [!!!@2@:ST.W      [SP + #36], R2	@@: LD.B      R0, [R0]

80001aa4 <xEventGroupSync>:
##@@@F_:xEventGroupSync():
##@@@P_:event_groups.c:183
##@@@L0178_:
##@@@L0179_:EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,   
##@@@L0180_:                             const EventBits_t uxBitsToSet,   
##@@@L0181_:                             const EventBits_t uxBitsToWaitFor,   
##@@@L0182_:                             TickType_t xTicksToWait )   
##@@@L0183_:{   
80001aa4:	9f 5f       	PUSH      {R6-R10,LR}
80001aa6:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:event_groups.c:191
##@@@L0186_:    BaseType_t xAlreadyYielded;   
##@@@L0187_:    BaseType_t xTimeoutOccurred = pdFALSE;   
##@@@L0188_:
##@@@L0189_:    traceENTER_xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );   
##@@@L0190_:
##@@@L0191_:    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001aa8:	25 45       	LD        R5, [PC + #37]        ;->0x80001b3c  :=0x1000000
80001aaa:	25 70       	CMP       R2, R5
80001aac:	60 f2       	JC        $+96                  ;->0x80001b6c
80001aae:	e2 58       	MOV       R7, R2
##@@@P_:event_groups.c:192
##@@@L0192_:    configASSERT( uxBitsToWaitFor != 0 );   
80001ab0:	20 38       	CMP       R2, #0			;->0x00
80001ab2:	02 f1       	JNZ       $+2                   ;->0x80001ab6
80001ab4:	7f 04       	SJMP      $+127                 ;->0x80001bb2
80001ab6:	23 59       	MOV       R9, R3
80001ab8:	41 59       	MOV       R10, R1
80001aba:	c0 58       	MOV       R6, R0
##@@@P_:event_groups.c:199
##@@@L0194_:    {   
##@@@L0195_:        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );   
##@@@L0196_:    }   
##@@@L0197_:    #endif   
##@@@L0198_:
##@@@L0199_:    vTaskSuspendAll();   
80001abc:	21 45       	LD        R5, [PC + #33]        ;->0x80001b40  :=0x800059b0
80001abe:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:201
##@@@L0200_:    {   
##@@@L0201_:        uxOriginalBitValue = pxEventBits->uxEventBits;   
80001ac0:	86 82       	LD.W      R8, [R6]
##@@@P_:event_groups.c:203
##@@@L0202_:
##@@@L0203_:        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );   
80001ac2:	06 58       	MOV       R0, R6
80001ac4:	2a 58       	MOV       R1, R10
80001ac6:	20 45       	LD        R5, [PC + #32]        ;->0x80001b44  :=0x80001c00
80001ac8:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:205
##@@@L0204_:
##@@@L0205_:        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )   
80001aca:	8a 6a       	ORL       R8, R10
80001acc:	a8 58       	MOV       R5, R8
80001ace:	57 69       	ANL       R5, R7
80001ad0:	57 70       	CMP       R5, R7
80001ad2:	06 f1       	JNZ       $+6                   ;->0x80001ade
##@@@P_:event_groups.c:212
##@@@L0207_:            /* All the rendezvous bits are now set - no need to block. */   
##@@@L0208_:            uxReturn = ( uxOriginalBitValue | uxBitsToSet );   
##@@@L0209_:
##@@@L0210_:            /* Rendezvous always clear the bits.  They will have been cleared   
##@@@L0211_:             * already unless this is the only task in the rendezvous. */   
##@@@L0212_:            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;   
80001ad4:	56 82       	LD.W      R5, [R6]
80001ad6:	47 68       	NOT       R4, R7
80001ad8:	54 69       	ANL       R5, R4
80001ada:	65 85       	ST.W      [R6], R5
80001adc:	29 04       	SJMP      $+41                  ;->0x80001b2e
##@@@P_:event_groups.c:218
##@@@L0213_:
##@@@L0214_:            xTicksToWait = 0;   
##@@@L0215_:        }   
##@@@L0216_:        else   
##@@@L0217_:        {   
##@@@L0218_:            if( xTicksToWait != ( TickType_t ) 0 )   
80001ade:	90 38       	CMP       R9, #0			;->0x00
80001ae0:	26 f0       	JZ        $+38                  ;->0x80001b2c
80001ae2:	1a 45       	LD        R5, [PC + #26]        ;->0x80001b48  :=0x5000000
##@@@P_:event_groups.c:225
##@@@L0220_:                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );   
##@@@L0221_:
##@@@L0222_:                /* Store the bits that the calling task is waiting for in the   
##@@@L0223_:                 * task's event list item so the kernel knows when a match is   
##@@@L0224_:                 * found.  Then enter the blocked state. */   
##@@@L0225_:                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );   
80001ae4:	27 58       	MOV       R1, R7
80001ae6:	15 6a       	ORL       R1, R5
80001ae8:	06 c1       	ADD       R0, R6, #4
80001aea:	49 58       	MOV       R2, R9
80001aec:	18 45       	LD        R5, [PC + #24]        ;->0x80001b4c  :=0x80006f0c
80001aee:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:242
##@@@L0237_:                uxReturn = pxEventBits->uxEventBits;   
##@@@L0238_:                xTimeoutOccurred = pdTRUE;   
##@@@L0239_:            }   
##@@@L0240_:        }   
##@@@L0241_:    }   
##@@@L0242_:    xAlreadyYielded = xTaskResumeAll();   
80001af0:	18 45       	LD        R5, [PC + #24]        ;->0x80001b50  :=0x80005a70
80001af2:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:246
##@@@L0243_:
##@@@L0244_:    if( xTicksToWait != ( TickType_t ) 0 )   
##@@@L0245_:    {   
##@@@L0246_:        if( xAlreadyYielded == pdFALSE )   
80001af4:	00 38       	CMP       R0, #0			;->0x00
80001af6:	03 f1       	JNZ       $+3                   ;->0x80001afc
##@@@P_:event_groups.c:248
##@@@L0247_:        {   
##@@@L0248_:            taskYIELD_WITHIN_API();   
80001af8:	17 45       	LD        R5, [PC + #23]        ;->0x80001b54  :=0x80008f64
80001afa:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:259
##@@@L0254_:
##@@@L0255_:        /* The task blocked to wait for its required bits to be set - at this   
##@@@L0256_:         * point either the required bits were set or the block time expired.  If   
##@@@L0257_:         * the required bits were set they will have been stored in the task's   
##@@@L0258_:         * event list item, and they should now be retrieved then cleared. */   
##@@@L0259_:        uxReturn = uxTaskResetEventItemValue();   
80001afc:	17 45       	LD        R5, [PC + #23]        ;->0x80001b58  :=0x80007b6c
80001afe:	05 5c       	LJMP      R5
80001b00:	17 45       	LD        R5, [PC + #23]        ;->0x80001b5c  :=0x2000000
80001b02:	00 59       	MOV       R8, R0
##@@@P_:event_groups.c:261
##@@@L0260_:
##@@@L0261_:        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )   
80001b04:	80 58       	MOV       R4, R0
80001b06:	45 69       	ANL       R4, R5
80001b08:	40 38       	CMP       R4, #0			;->0x00
80001b0a:	0e f1       	JNZ       $+14                  ;->0x80001b26
##@@@P_:event_groups.c:264
##@@@L0262_:        {   
##@@@L0263_:            /* The task timed out, just return the current event bit value. */   
##@@@L0264_:            taskENTER_CRITICAL();   
80001b0c:	15 45       	LD        R5, [PC + #21]        ;->0x80001b60  :=0x800056cc
80001b0e:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:266
##@@@L0265_:            {   
##@@@L0266_:                uxReturn = pxEventBits->uxEventBits;   
80001b10:	86 82       	LD.W      R8, [R6]
##@@@P_:event_groups.c:272
##@@@L0267_:
##@@@L0268_:                /* Although the task got here because it timed out before the   
##@@@L0269_:                 * bits it was waiting for were set, it is possible that since it   
##@@@L0270_:                 * unblocked another task has set the bits.  If this is the case   
##@@@L0271_:                 * then it needs to clear the bits before exiting. */   
##@@@L0272_:                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )   
80001b12:	a8 58       	MOV       R5, R8
80001b14:	57 69       	ANL       R5, R7
80001b16:	57 70       	CMP       R5, R7
80001b18:	05 f1       	JNZ       $+5                   ;->0x80001b22
##@@@P_:event_groups.c:274
##@@@L0273_:                {   
##@@@L0274_:                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;   
80001b1a:	57 68       	NOT       R5, R7
80001b1c:	88 58       	MOV       R4, R8
80001b1e:	45 69       	ANL       R4, R5
80001b20:	64 85       	ST.W      [R6], R4
##@@@P_:event_groups.c:281
##@@@L0276_:                else   
##@@@L0277_:                {   
##@@@L0278_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L0279_:                }   
##@@@L0280_:            }   
##@@@L0281_:            taskEXIT_CRITICAL();   
80001b22:	11 45       	LD        R5, [PC + #17]        ;->0x80001b64  :=0x80005730
80001b24:	05 5c       	LJMP      R5
80001b26:	11 45       	LD        R5, [PC + #17]        ;->0x80001b68  :=0xffffff
##@@@P_:event_groups.c:292
##@@@L0287_:            /* The task unblocked because the bits were set. */   
##@@@L0288_:        }   
##@@@L0289_:
##@@@L0290_:        /* Control bits might be set as the task had blocked should not be   
##@@@L0291_:         * returned. */   
##@@@L0292_:        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;   
80001b28:	85 69       	ANL       R8, R5
80001b2a:	04 04       	SJMP      $+4                   ;->0x80001b32
##@@@P_:event_groups.c:237
##@@@L0232_:            }   
##@@@L0233_:            else   
##@@@L0234_:            {   
##@@@L0235_:                /* The rendezvous bits were not set, but no block time was   
##@@@L0236_:                 * specified - just return the current event bit value. */   
##@@@L0237_:                uxReturn = pxEventBits->uxEventBits;   
80001b2c:	86 82       	LD.W      R8, [R6]
##@@@P_:event_groups.c:242
##@@@L0238_:                xTimeoutOccurred = pdTRUE;   
##@@@L0239_:            }   
##@@@L0240_:        }   
##@@@L0241_:    }   
##@@@L0242_:    xAlreadyYielded = xTaskResumeAll();   
80001b2e:	09 45       	LD        R5, [PC + #9]         ;->0x80001b50  :=0x80005a70
80001b30:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:302
##@@@L0297_:    /* Prevent compiler warnings when trace macros are not used. */   
##@@@L0298_:    ( void ) xTimeoutOccurred;   
##@@@L0299_:
##@@@L0300_:    traceRETURN_xEventGroupSync( uxReturn );   
##@@@L0301_:
##@@@L0302_:    return uxReturn;   
80001b32:	08 58       	MOV       R0, R8
80001b34:	e4 28       	ADD       SP, #4			;->0x04
80001b36:	1f 5e       	POP       {R6-R10}
80001b38:	0d 5d       	POP       LR
80001b3a:	1d 5c       	JMP       LR
80001b3c:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
80001b40:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80001b44:	00 1c 00 80 	.long     0x80001c00 ->-2147476480  [!!!@2@:MOV       R0, #192	@@: LD.B      R0, [R0]
80001b48:	00 00 00 05 	.long     0x05000000 ->083886080  [!!!@2@:NOP      	@@: SJMP      $+256                 ;->0x80001d48
80001b4c:	0c 6f 00 80 	.long     0x80006f0c ->-2147455220  [!!!@2@:ROR       R0, R12	@@: LD.B      R0, [R0]
80001b50:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80001b54:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80001b58:	6c 7b 00 80 	.long     0x80007b6c ->-2147452052  [!!!@2@:LSL       LR, #20	@@: LD.B      R0, [R0]
80001b5c:	00 00 00 02 	.long     0x02000000 ->033554432 
80001b60:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80001b60
80001b64:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80001b64
80001b68:	ff ff ff 00 	.long     0x00ffffff ->016777215 
##@@@P_:event_groups.c:191
##@@@L0186_:    BaseType_t xAlreadyYielded;   
##@@@L0187_:    BaseType_t xTimeoutOccurred = pdFALSE;   
##@@@L0188_:
##@@@L0189_:    traceENTER_xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );   
##@@@L0190_:
##@@@L0191_:    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001b6c:	20 5d       	PUSH      R0
80001b6e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001b72:	08 00       	SYNC     SYNC     
80001b74:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001b78:	08 00       	SYNC     SYNC     
80001b7a:	00 5d       	POP       R0
80001b7c:	20 5d       	PUSH      R0
80001b7e:	21 5d       	PUSH      R1
80001b80:	1e 45       	LD        R5, [PC + #30]        ;->0x80001bf8  :=0x1ff
80001b82:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001b86:	25 58       	MOV       R1, R5
80001b88:	11 68       	NOT       R1, R1
80001b8a:	01 69       	ANL       R0, R1
80001b8c:	5f 11       	MOV       R5, #31			;->0x001F
80001b8e:	25 58       	MOV       R1, R5
80001b90:	01 6a       	ORL       R0, R1
80001b92:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001b96:	08 00       	SYNC     SYNC     
80001b98:	01 5d       	POP       R1
80001b9a:	00 5d       	POP       R0
80001b9c:	20 5d       	PUSH      R0
80001b9e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001ba2:	08 00       	SYNC     SYNC     
80001ba4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001ba8:	08 00       	SYNC     SYNC     
80001baa:	00 5d       	POP       R0
80001bac:	07 00       	BREAK    BREAK    
80001bae:	14 45       	LD        R5, [PC + #20]        ;->0x80001bfc  :=0x8000911c
80001bb0:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:192
##@@@L0192_:    configASSERT( uxBitsToWaitFor != 0 );   
80001bb2:	20 5d       	PUSH      R0
80001bb4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001bb8:	08 00       	SYNC     SYNC     
80001bba:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001bbe:	08 00       	SYNC     SYNC     
80001bc0:	00 5d       	POP       R0
80001bc2:	20 5d       	PUSH      R0
80001bc4:	21 5d       	PUSH      R1
80001bc6:	0d 45       	LD        R5, [PC + #13]        ;->0x80001bf8  :=0x1ff
80001bc8:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001bcc:	25 58       	MOV       R1, R5
80001bce:	11 68       	NOT       R1, R1
80001bd0:	01 69       	ANL       R0, R1
80001bd2:	5f 11       	MOV       R5, #31			;->0x001F
80001bd4:	25 58       	MOV       R1, R5
80001bd6:	01 6a       	ORL       R0, R1
80001bd8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001bdc:	08 00       	SYNC     SYNC     
80001bde:	01 5d       	POP       R1
80001be0:	00 5d       	POP       R0
80001be2:	20 5d       	PUSH      R0
80001be4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001be8:	08 00       	SYNC     SYNC     
80001bea:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001bee:	08 00       	SYNC     SYNC     
80001bf0:	00 5d       	POP       R0
80001bf2:	07 00       	BREAK    BREAK    
80001bf4:	02 45       	LD        R5, [PC + #2]         ;->0x80001bfc  :=0x8000911c
80001bf6:	05 5c       	LJMP      R5
80001bf8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80001bfc:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80001c00 <xEventGroupSetBits>:
##@@@F_:xEventGroupSetBits():
##@@@P_:event_groups.c:540
##@@@L0535_:}   
##@@@L0536_:/*-----------------------------------------------------------*/   
##@@@L0537_:
##@@@L0538_:EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,   
##@@@L0539_:                                const EventBits_t uxBitsToSet )   
##@@@L0540_:{   
80001c00:	8f 5f       	PUSH      {R6-R9,LR}
80001c02:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:event_groups.c:553
##@@@L0548_:
##@@@L0549_:    traceENTER_xEventGroupSetBits( xEventGroup, uxBitsToSet );   
##@@@L0550_:
##@@@L0551_:    /* Check the user is not attempting to set the bits used by the kernel   
##@@@L0552_:     * itself. */   
##@@@L0553_:    configASSERT( xEventGroup );   
80001c04:	00 38       	CMP       R0, #0			;->0x00
80001c06:	02 f1       	JNZ       $+2                   ;->0x80001c0a
80001c08:	56 04       	SJMP      $+86                  ;->0x80001cb4
80001c0a:	e1 58       	MOV       R7, R1
80001c0c:	01 20       	ST.W      [SP + #1], R0
##@@@P_:event_groups.c:554
##@@@L0554_:    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001c0e:	23 45       	LD        R5, [PC + #35]        ;->0x80001c98  :=0x1000000
80001c10:	15 70       	CMP       R1, R5
80001c12:	02 f3       	JNC       $+2                   ;->0x80001c16
80001c14:	73 04       	SJMP      $+115                 ;->0x80001cfa
##@@@P_:event_groups.c:558
##@@@L0555_:
##@@@L0556_:    pxList = &( pxEventBits->xTasksWaitingForBits );   
##@@@L0557_:    pxListEnd = listGET_END_MARKER( pxList );   
##@@@L0558_:    vTaskSuspendAll();   
80001c16:	22 45       	LD        R5, [PC + #34]        ;->0x80001c9c  :=0x800059b0
80001c18:	05 5c       	LJMP      R5
80001c1a:	01 0b       	LD.W      R3, [SP + #1]
##@@@P_:event_groups.c:565
##@@@L0560_:        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );   
##@@@L0561_:
##@@@L0562_:        pxListItem = listGET_HEAD_ENTRY( pxList );   
##@@@L0563_:
##@@@L0564_:        /* Set the bits. */   
##@@@L0565_:        pxEventBits->uxEventBits |= uxBitsToSet;   
80001c1c:	53 82       	LD.W      R5, [R3]
80001c1e:	57 6a       	ORL       R5, R7
80001c20:	35 85       	ST.W      [R3], R5
##@@@P_:event_groups.c:557
##@@@L0552_:     * itself. */   
##@@@L0553_:    configASSERT( xEventGroup );   
##@@@L0554_:    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
##@@@L0555_:
##@@@L0556_:    pxList = &( pxEventBits->xTasksWaitingForBits );   
##@@@L0557_:    pxListEnd = listGET_END_MARKER( pxList );   
80001c22:	83 58       	MOV       R4, R3
##@@@P_:event_groups.c:562
##@@@L0558_:    vTaskSuspendAll();   
##@@@L0559_:    {   
##@@@L0560_:        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );   
##@@@L0561_:
##@@@L0562_:        pxListItem = listGET_HEAD_ENTRY( pxList );   
80001c24:	33 99       	LD.W      R6, [R3 + #4]
##@@@P_:event_groups.c:557
##@@@L0552_:     * itself. */   
##@@@L0553_:    configASSERT( xEventGroup );   
##@@@L0554_:    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
##@@@L0555_:
##@@@L0556_:    pxList = &( pxEventBits->xTasksWaitingForBits );   
##@@@L0557_:    pxListEnd = listGET_END_MARKER( pxList );   
80001c26:	4c 28       	ADD       R4, #12			;->0x0C
80001c28:	04 24       	ST.W      [SP + #4], R4
##@@@P_:event_groups.c:568
##@@@L0563_:
##@@@L0564_:        /* Set the bits. */   
##@@@L0565_:        pxEventBits->uxEventBits |= uxBitsToSet;   
##@@@L0566_:
##@@@L0567_:        /* See if the new bit value should unblock any tasks. */   
##@@@L0568_:        while( pxListItem != pxListEnd )   
80001c2a:	64 70       	CMP       R6, R4
80001c2c:	29 f0       	JZ        $+41                  ;->0x80001c7e
80001c2e:	1d 45       	LD        R5, [PC + #29]        ;->0x80001ca0  :=0x4000000
80001c30:	03 25       	ST.W      [SP + #3], R5
80001c32:	1d 45       	LD        R5, [PC + #29]        ;->0x80001ca4  :=0xffffff
80001c34:	02 25       	ST.W      [SP + #2], R5
80001c36:	70 10       	MOV       R7, #0			;->0x0000
80001c38:	10 04       	SJMP      $+16                  ;->0x80001c58
##@@@P_:event_groups.c:600
##@@@L0595_:            else   
##@@@L0596_:            {   
##@@@L0597_:                /* Need all bits to be set, but not all the bits were set. */   
##@@@L0598_:            }   
##@@@L0599_:
##@@@L0600_:            if( xMatchFound != pdFALSE )   
80001c3a:	50 38       	CMP       R5, #0			;->0x00
80001c3c:	0b f0       	JZ        $+11                  ;->0x80001c52
80001c3e:	1b 45       	LD        R5, [PC + #27]        ;->0x80001ca8  :=0x2000000
##@@@P_:event_groups.c:617
##@@@L0612_:                /* Store the actual event flag value in the task's event list   
##@@@L0613_:                 * item before removing the task from the event list.  The   
##@@@L0614_:                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows   
##@@@L0615_:                 * that is was unblocked due to its required bits matching, rather   
##@@@L0616_:                 * than because it timed out. */   
##@@@L0617_:                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );   
80001c40:	15 6a       	ORL       R1, R5
80001c42:	1b 45       	LD        R5, [PC + #27]        ;->0x80001cac  :=0x80007120
80001c44:	05 5c       	LJMP      R5
80001c46:	01 0b       	LD.W      R3, [SP + #1]
##@@@P_:event_groups.c:603
##@@@L0598_:            }   
##@@@L0599_:
##@@@L0600_:            if( xMatchFound != pdFALSE )   
##@@@L0601_:            {   
##@@@L0602_:                /* The bits match.  Should the bits be cleared on exit? */   
##@@@L0603_:                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )   
80001c48:	47 7a       	LSL       R8, #7			;->0x07
80001c4a:	c7 79       	ASR       R8, #31			;->0x1F
80001c4c:	89 69       	ANL       R8, R9
80001c4e:	87 6a       	ORL       R8, R7
80001c50:	e8 58       	MOV       R7, R8
##@@@P_:event_groups.c:568
##@@@L0563_:
##@@@L0564_:        /* Set the bits. */   
##@@@L0565_:        pxEventBits->uxEventBits |= uxBitsToSet;   
##@@@L0566_:
##@@@L0567_:        /* See if the new bit value should unblock any tasks. */   
##@@@L0568_:        while( pxListItem != pxListEnd )   
80001c52:	04 0d       	LD.W      R5, [SP + #4]
80001c54:	65 70       	CMP       R6, R5
80001c56:	12 f0       	JZ        $+18                  ;->0x80001c7a
80001c58:	06 58       	MOV       R0, R6
##@@@P_:event_groups.c:571
##@@@L0569_:        {   
##@@@L0570_:            pxNext = listGET_NEXT( pxListItem );   
##@@@L0571_:            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );   
80001c5a:	86 82       	LD.W      R8, [R6]
##@@@P_:event_groups.c:578
##@@@L0573_:
##@@@L0574_:            /* Split the bits waited for from the control bits. */   
##@@@L0575_:            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;   
##@@@L0576_:            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;   
##@@@L0577_:
##@@@L0578_:            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )   
80001c5c:	88 58       	MOV       R4, R8
80001c5e:	03 0d       	LD.W      R5, [SP + #3]
80001c60:	45 69       	ANL       R4, R5
##@@@P_:event_groups.c:576
##@@@L0571_:            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );   
##@@@L0572_:            xMatchFound = pdFALSE;   
##@@@L0573_:
##@@@L0574_:            /* Split the bits waited for from the control bits. */   
##@@@L0575_:            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;   
##@@@L0576_:            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;   
80001c62:	28 59       	MOV       R9, R8
80001c64:	13 82       	LD.W      R1, [R3]
80001c66:	02 0d       	LD.W      R5, [SP + #2]
80001c68:	95 69       	ANL       R9, R5
##@@@P_:event_groups.c:570
##@@@L0565_:        pxEventBits->uxEventBits |= uxBitsToSet;   
##@@@L0566_:
##@@@L0567_:        /* See if the new bit value should unblock any tasks. */   
##@@@L0568_:        while( pxListItem != pxListEnd )   
##@@@L0569_:        {   
##@@@L0570_:            pxNext = listGET_NEXT( pxListItem );   
80001c6a:	76 98       	LD.W      R6, [R6 + #1]
80001c6c:	a1 58       	MOV       R5, R1
80001c6e:	59 69       	ANL       R5, R9
##@@@P_:event_groups.c:578
##@@@L0573_:
##@@@L0574_:            /* Split the bits waited for from the control bits. */   
##@@@L0575_:            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;   
##@@@L0576_:            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;   
##@@@L0577_:
##@@@L0578_:            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )   
80001c70:	40 38       	CMP       R4, #0			;->0x00
80001c72:	e4 f0       	JZ        $-28                  ;->0x80001c3a
##@@@P_:event_groups.c:600
##@@@L0595_:            else   
##@@@L0596_:            {   
##@@@L0597_:                /* Need all bits to be set, but not all the bits were set. */   
##@@@L0598_:            }   
##@@@L0599_:
##@@@L0600_:            if( xMatchFound != pdFALSE )   
80001c74:	59 70       	CMP       R5, R9
80001c76:	e4 f0       	JZ        $-28                  ;->0x80001c3e
80001c78:	ed 07       	SJMP      $-19                  ;->0x80001c52
##@@@P_:event_groups.c:628
##@@@L0623_:            pxListItem = pxNext;   
##@@@L0624_:        }   
##@@@L0625_:
##@@@L0626_:        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT   
##@@@L0627_:         * bit was set in the control word. */   
##@@@L0628_:        pxEventBits->uxEventBits &= ~uxBitsToClear;   
80001c7a:	53 82       	LD.W      R5, [R3]
80001c7c:	02 04       	SJMP      $+2                   ;->0x80001c80
80001c7e:	70 10       	MOV       R7, #0			;->0x0000
80001c80:	47 68       	NOT       R4, R7
80001c82:	54 69       	ANL       R5, R4
80001c84:	35 85       	ST.W      [R3], R5
80001c86:	c3 58       	MOV       R6, R3
##@@@P_:event_groups.c:630
##@@@L0629_:    }   
##@@@L0630_:    ( void ) xTaskResumeAll();   
80001c88:	0a 45       	LD        R5, [PC + #10]        ;->0x80001cb0  :=0x80005a70
80001c8a:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:634
##@@@L0631_:
##@@@L0632_:    traceRETURN_xEventGroupSetBits( pxEventBits->uxEventBits );   
##@@@L0633_:
##@@@L0634_:    return pxEventBits->uxEventBits;   
80001c8c:	06 82       	LD.W      R0, [R6]
80001c8e:	e4 29       	ADD       SP, #20			;->0x14
80001c90:	0f 5e       	POP       {R6-R9}
80001c92:	0d 5d       	POP       LR
80001c94:	1d 5c       	JMP       LR
80001c96:	00 00       	NOP      NOP      
80001c98:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
80001c9c:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80001ca0:	00 00 00 04 	.long     0x04000000 ->067108864  [!!!@2@:NOP      	@@: SJMP      $+0                   ;->0x80001ca0
80001ca4:	ff ff ff 00 	.long     0x00ffffff ->016777215 
80001ca8:	00 00 00 02 	.long     0x02000000 ->033554432 
80001cac:	20 71 00 80 	.long     0x80007120 ->-2147454688  [!!!@2@:TST       R2, R0	@@: LD.B      R0, [R0]
80001cb0:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
##@@@P_:event_groups.c:553
##@@@L0548_:
##@@@L0549_:    traceENTER_xEventGroupSetBits( xEventGroup, uxBitsToSet );   
##@@@L0550_:
##@@@L0551_:    /* Check the user is not attempting to set the bits used by the kernel   
##@@@L0552_:     * itself. */   
##@@@L0553_:    configASSERT( xEventGroup );   
80001cb4:	20 5d       	PUSH      R0
80001cb6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001cba:	08 00       	SYNC     SYNC     
80001cbc:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001cc0:	08 00       	SYNC     SYNC     
80001cc2:	00 5d       	POP       R0
80001cc4:	20 5d       	PUSH      R0
80001cc6:	21 5d       	PUSH      R1
80001cc8:	1e 45       	LD        R5, [PC + #30]        ;->0x80001d40  :=0x1ff
80001cca:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001cce:	25 58       	MOV       R1, R5
80001cd0:	11 68       	NOT       R1, R1
80001cd2:	01 69       	ANL       R0, R1
80001cd4:	5f 11       	MOV       R5, #31			;->0x001F
80001cd6:	25 58       	MOV       R1, R5
80001cd8:	01 6a       	ORL       R0, R1
80001cda:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001cde:	08 00       	SYNC     SYNC     
80001ce0:	01 5d       	POP       R1
80001ce2:	00 5d       	POP       R0
80001ce4:	20 5d       	PUSH      R0
80001ce6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001cea:	08 00       	SYNC     SYNC     
80001cec:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001cf0:	08 00       	SYNC     SYNC     
80001cf2:	00 5d       	POP       R0
80001cf4:	07 00       	BREAK    BREAK    
80001cf6:	14 45       	LD        R5, [PC + #20]        ;->0x80001d44  :=0x8000911c
80001cf8:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:554
##@@@L0554_:    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001cfa:	20 5d       	PUSH      R0
80001cfc:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001d00:	08 00       	SYNC     SYNC     
80001d02:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001d06:	08 00       	SYNC     SYNC     
80001d08:	00 5d       	POP       R0
80001d0a:	20 5d       	PUSH      R0
80001d0c:	21 5d       	PUSH      R1
80001d0e:	0d 45       	LD        R5, [PC + #13]        ;->0x80001d40  :=0x1ff
80001d10:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001d14:	25 58       	MOV       R1, R5
80001d16:	11 68       	NOT       R1, R1
80001d18:	01 69       	ANL       R0, R1
80001d1a:	5f 11       	MOV       R5, #31			;->0x001F
80001d1c:	25 58       	MOV       R1, R5
80001d1e:	01 6a       	ORL       R0, R1
80001d20:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001d24:	08 00       	SYNC     SYNC     
80001d26:	01 5d       	POP       R1
80001d28:	00 5d       	POP       R0
80001d2a:	20 5d       	PUSH      R0
80001d2c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001d30:	08 00       	SYNC     SYNC     
80001d32:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001d36:	08 00       	SYNC     SYNC     
80001d38:	00 5d       	POP       R0
80001d3a:	07 00       	BREAK    BREAK    
80001d3c:	02 45       	LD        R5, [PC + #2]         ;->0x80001d44  :=0x8000911c
80001d3e:	05 5c       	LJMP      R5
80001d40:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80001d44:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80001d48 <xEventGroupWaitBits>:
##@@@F_:xEventGroupWaitBits():
##@@@P_:event_groups.c:311
##@@@L0306_:EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,   
##@@@L0307_:                                 const EventBits_t uxBitsToWaitFor,   
##@@@L0308_:                                 const BaseType_t xClearOnExit,   
##@@@L0309_:                                 const BaseType_t xWaitForAllBits,   
##@@@L0310_:                                 TickType_t xTicksToWait )   
##@@@L0311_:{   
80001d48:	bf 5f       	PUSH      {R6-R11,LR}
80001d4a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:event_groups.c:321
##@@@L0316_:
##@@@L0317_:    traceENTER_xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );   
##@@@L0318_:
##@@@L0319_:    /* Check the user is not attempting to wait on the bits used by the kernel   
##@@@L0320_:     * itself, and that at least one bit is being requested. */   
##@@@L0321_:    configASSERT( xEventGroup );   
80001d4c:	00 38       	CMP       R0, #0			;->0x00
80001d4e:	02 f1       	JNZ       $+2                   ;->0x80001d52
80001d50:	94 04       	SJMP      $+148                 ;->0x80001e78
80001d52:	e1 58       	MOV       R7, R1
##@@@P_:event_groups.c:322
##@@@L0322_:    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001d54:	3e 45       	LD        R5, [PC + #62]        ;->0x80001e4c  :=0x1000000
80001d56:	15 70       	CMP       R1, R5
80001d58:	02 f3       	JNC       $+2                   ;->0x80001d5c
80001d5a:	b2 04       	SJMP      $+178                 ;->0x80001ebe
##@@@P_:event_groups.c:323
##@@@L0323_:    configASSERT( uxBitsToWaitFor != 0 );   
80001d5c:	70 38       	CMP       R7, #0			;->0x00
80001d5e:	02 f1       	JNZ       $+2                   ;->0x80001d62
80001d60:	d2 04       	SJMP      $+210                 ;->0x80001f04
80001d62:	c0 58       	MOV       R6, R0
80001d64:	64 59       	MOV       R11, R4
80001d66:	23 59       	MOV       R9, R3
80001d68:	02 59       	MOV       R8, R2
##@@@P_:event_groups.c:330
##@@@L0325_:    {   
##@@@L0326_:        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );   
##@@@L0327_:    }   
##@@@L0328_:    #endif   
##@@@L0329_:
##@@@L0330_:    vTaskSuspendAll();   
80001d6a:	3a 45       	LD        R5, [PC + #58]        ;->0x80001e50  :=0x800059b0
80001d6c:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:332
##@@@L0331_:    {   
##@@@L0332_:        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;   
80001d6e:	a6 82       	LD.W      R10, [R6]
##@@@F_:prvTestWaitCondition():
##@@@P_:event_groups.c:772
##@@@L0767_:                                        const EventBits_t uxBitsToWaitFor,   
##@@@L0768_:                                        const BaseType_t xWaitForAllBits )   
##@@@L0769_:{   
##@@@L0770_:    BaseType_t xWaitConditionMet = pdFALSE;   
##@@@L0771_:
##@@@L0772_:    if( xWaitForAllBits == pdFALSE )   
80001d70:	4a 58       	MOV       R2, R10
80001d72:	27 69       	ANL       R2, R7
80001d74:	51 10       	MOV       R5, #1			;->0x0001
80001d76:	10 10       	MOV       R1, #0			;->0x0000
80001d78:	85 58       	MOV       R4, R5
80001d7a:	27 70       	CMP       R2, R7
80001d7c:	14 f1       	JNZ       $+20                  ;->0x80001da4
80001d7e:	81 58       	MOV       R4, R1
80001d80:	65 58       	MOV       R3, R5
80001d82:	20 38       	CMP       R2, #0			;->0x00
80001d84:	13 f1       	JNZ       $+19                  ;->0x80001daa
80001d86:	90 38       	CMP       R9, #0			;->0x00
80001d88:	02 f0       	JZ        $+2                   ;->0x80001d8c
##@@@F_:xEventGroupWaitBits():
80001d8a:	64 58       	MOV       R3, R4
##@@@P_:event_groups.c:337
##@@@L0332_:        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;   
##@@@L0333_:
##@@@L0334_:        /* Check to see if the wait condition is already met or not. */   
##@@@L0335_:        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );   
##@@@L0336_:
##@@@L0337_:        if( xWaitConditionMet != pdFALSE )   
80001d8c:	35 69       	ANL       R3, R5
80001d8e:	30 38       	CMP       R3, #0			;->0x00
80001d90:	11 f0       	JZ        $+17                  ;->0x80001db2
##@@@P_:event_groups.c:354
##@@@L0349_:            else   
##@@@L0350_:            {   
##@@@L0351_:                mtCOVERAGE_TEST_MARKER();   
##@@@L0352_:            }   
##@@@L0353_:        }   
##@@@L0354_:        else if( xTicksToWait == ( TickType_t ) 0 )   
80001d92:	b0 38       	CMP       R11, #0			;->0x00
80001d94:	15 f0       	JZ        $+21                  ;->0x80001dbe
##@@@P_:event_groups.c:367
##@@@L0362_:        {   
##@@@L0363_:            /* The task is going to block to wait for its required bits to be   
##@@@L0364_:             * set.  uxControlBits are used to remember the specified behaviour of   
##@@@L0365_:             * this call to xEventGroupWaitBits() - for use when the event bits   
##@@@L0366_:             * unblock the task. */   
##@@@L0367_:            if( xClearOnExit != pdFALSE )   
80001d96:	80 38       	CMP       R8, #0			;->0x00
80001d98:	16 f1       	JNZ       $+22                  ;->0x80001dc4
80001d9a:	10 10       	MOV       R1, #0			;->0x0000
80001d9c:	88 7b       	LSL       R1, #24			;->0x18
##@@@P_:event_groups.c:376
##@@@L0371_:            else   
##@@@L0372_:            {   
##@@@L0373_:                mtCOVERAGE_TEST_MARKER();   
##@@@L0374_:            }   
##@@@L0375_:
##@@@L0376_:            if( xWaitForAllBits != pdFALSE )   
80001d9e:	90 38       	CMP       R9, #0			;->0x00
80001da0:	16 f1       	JNZ       $+22                  ;->0x80001dcc
80001da2:	17 04       	SJMP      $+23                  ;->0x80001dd0
80001da4:	65 58       	MOV       R3, R5
##@@@F_:prvTestWaitCondition():
##@@@P_:event_groups.c:772
##@@@L0767_:                                        const EventBits_t uxBitsToWaitFor,   
##@@@L0768_:                                        const BaseType_t xWaitForAllBits )   
##@@@L0769_:{   
##@@@L0770_:    BaseType_t xWaitConditionMet = pdFALSE;   
##@@@L0771_:
##@@@L0772_:    if( xWaitForAllBits == pdFALSE )   
80001da6:	20 38       	CMP       R2, #0			;->0x00
80001da8:	ef f0       	JZ        $-17                  ;->0x80001d86
80001daa:	61 58       	MOV       R3, R1
80001dac:	90 38       	CMP       R9, #0			;->0x00
80001dae:	ee f1       	JNZ       $-18                  ;->0x80001d8a
80001db0:	ee 07       	SJMP      $-18                  ;->0x80001d8c
##@@@F_:xEventGroupWaitBits():
##@@@P_:event_groups.c:345
##@@@L0340_:             * block. */   
##@@@L0341_:            uxReturn = uxCurrentEventBits;   
##@@@L0342_:            xTicksToWait = ( TickType_t ) 0;   
##@@@L0343_:
##@@@L0344_:            /* Clear the wait bits if requested to do so. */   
##@@@L0345_:            if( xClearOnExit != pdFALSE )   
80001db2:	80 38       	CMP       R8, #0			;->0x00
80001db4:	05 f0       	JZ        $+5                   ;->0x80001dbe
##@@@P_:event_groups.c:347
##@@@L0346_:            {   
##@@@L0347_:                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;   
80001db6:	57 68       	NOT       R5, R7
80001db8:	8a 58       	MOV       R4, R10
80001dba:	45 69       	ANL       R4, R5
80001dbc:	64 85       	ST.W      [R6], R4
##@@@P_:event_groups.c:398
##@@@L0393_:            uxReturn = 0;   
##@@@L0394_:
##@@@L0395_:            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );   
##@@@L0396_:        }   
##@@@L0397_:    }   
##@@@L0398_:    xAlreadyYielded = xTaskResumeAll();   
80001dbe:	26 45       	LD        R5, [PC + #38]        ;->0x80001e54  :=0x80005a70
80001dc0:	05 5c       	LJMP      R5
80001dc2:	40 04       	SJMP      $+64                  ;->0x80001e42
80001dc4:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:event_groups.c:367
##@@@L0362_:        {   
##@@@L0363_:            /* The task is going to block to wait for its required bits to be   
##@@@L0364_:             * set.  uxControlBits are used to remember the specified behaviour of   
##@@@L0365_:             * this call to xEventGroupWaitBits() - for use when the event bits   
##@@@L0366_:             * unblock the task. */   
##@@@L0367_:            if( xClearOnExit != pdFALSE )   
80001dc6:	88 7b       	LSL       R1, #24			;->0x18
##@@@P_:event_groups.c:376
##@@@L0371_:            else   
##@@@L0372_:            {   
##@@@L0373_:                mtCOVERAGE_TEST_MARKER();   
##@@@L0374_:            }   
##@@@L0375_:
##@@@L0376_:            if( xWaitForAllBits != pdFALSE )   
80001dc8:	90 38       	CMP       R9, #0			;->0x00
80001dca:	03 f0       	JZ        $+3                   ;->0x80001dd0
80001dcc:	23 45       	LD        R5, [PC + #35]        ;->0x80001e58  :=0x4000000
80001dce:	15 6a       	ORL       R1, R5
##@@@P_:event_groups.c:388
##@@@L0383_:            }   
##@@@L0384_:
##@@@L0385_:            /* Store the bits that the calling task is waiting for in the   
##@@@L0386_:             * task's event list item so the kernel knows when a match is   
##@@@L0387_:             * found.  Then enter the blocked state. */   
##@@@L0388_:            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );   
80001dd0:	17 6a       	ORL       R1, R7
80001dd2:	06 c1       	ADD       R0, R6, #4
80001dd4:	4b 58       	MOV       R2, R11
80001dd6:	22 45       	LD        R5, [PC + #34]        ;->0x80001e5c  :=0x80006f0c
80001dd8:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:398
##@@@L0393_:            uxReturn = 0;   
##@@@L0394_:
##@@@L0395_:            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );   
##@@@L0396_:        }   
##@@@L0397_:    }   
##@@@L0398_:    xAlreadyYielded = xTaskResumeAll();   
80001dda:	1f 45       	LD        R5, [PC + #31]        ;->0x80001e54  :=0x80005a70
80001ddc:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:402
##@@@L0399_:
##@@@L0400_:    if( xTicksToWait != ( TickType_t ) 0 )   
##@@@L0401_:    {   
##@@@L0402_:        if( xAlreadyYielded == pdFALSE )   
80001dde:	00 38       	CMP       R0, #0			;->0x00
80001de0:	03 f1       	JNZ       $+3                   ;->0x80001de6
##@@@P_:event_groups.c:404
##@@@L0403_:        {   
##@@@L0404_:            taskYIELD_WITHIN_API();   
80001de2:	20 45       	LD        R5, [PC + #32]        ;->0x80001e60  :=0x80008f64
80001de4:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:415
##@@@L0410_:
##@@@L0411_:        /* The task blocked to wait for its required bits to be set - at this   
##@@@L0412_:         * point either the required bits were set or the block time expired.  If   
##@@@L0413_:         * the required bits were set they will have been stored in the task's   
##@@@L0414_:         * event list item, and they should now be retrieved then cleared. */   
##@@@L0415_:        uxReturn = uxTaskResetEventItemValue();   
80001de6:	20 45       	LD        R5, [PC + #32]        ;->0x80001e64  :=0x80007b6c
80001de8:	05 5c       	LJMP      R5
80001dea:	20 45       	LD        R5, [PC + #32]        ;->0x80001e68  :=0x2000000
80001dec:	40 59       	MOV       R10, R0
##@@@P_:event_groups.c:417
##@@@L0416_:
##@@@L0417_:        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )   
80001dee:	80 58       	MOV       R4, R0
80001df0:	45 69       	ANL       R4, R5
80001df2:	40 38       	CMP       R4, #0			;->0x00
80001df4:	25 f1       	JNZ       $+37                  ;->0x80001e3e
##@@@P_:event_groups.c:419
##@@@L0418_:        {   
##@@@L0419_:            taskENTER_CRITICAL();   
80001df6:	1e 45       	LD        R5, [PC + #30]        ;->0x80001e6c  :=0x800056cc
80001df8:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:422
##@@@L0420_:            {   
##@@@L0421_:                /* The task timed out, just return the current event bit value. */   
##@@@L0422_:                uxReturn = pxEventBits->uxEventBits;   
80001dfa:	a6 82       	LD.W      R10, [R6]
##@@@F_:prvTestWaitCondition():
##@@@P_:event_groups.c:772
##@@@L0767_:                                        const EventBits_t uxBitsToWaitFor,   
##@@@L0768_:                                        const BaseType_t xWaitForAllBits )   
##@@@L0769_:{   
##@@@L0770_:    BaseType_t xWaitConditionMet = pdFALSE;   
##@@@L0771_:
##@@@L0772_:    if( xWaitForAllBits == pdFALSE )   
80001dfc:	6a 58       	MOV       R3, R10
80001dfe:	37 69       	ANL       R3, R7
80001e00:	51 10       	MOV       R5, #1			;->0x0001
80001e02:	20 10       	MOV       R2, #0			;->0x0000
80001e04:	85 58       	MOV       R4, R5
80001e06:	37 70       	CMP       R3, R7
80001e08:	0a f0       	JZ        $+10                  ;->0x80001e1c
80001e0a:	82 58       	MOV       R4, R2
80001e0c:	30 38       	CMP       R3, #0			;->0x00
80001e0e:	09 f0       	JZ        $+9                   ;->0x80001e20
80001e10:	90 38       	CMP       R9, #0			;->0x00
80001e12:	0a f0       	JZ        $+10                  ;->0x80001e26
##@@@F_:xEventGroupWaitBits():
80001e14:	a4 58       	MOV       R5, R4
##@@@P_:event_groups.c:426
##@@@L0421_:                /* The task timed out, just return the current event bit value. */   
##@@@L0422_:                uxReturn = pxEventBits->uxEventBits;   
##@@@L0423_:
##@@@L0424_:                /* It is possible that the event bits were updated between this   
##@@@L0425_:                 * task leaving the Blocked state and running again. */   
##@@@L0426_:                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )   
80001e16:	80 38       	CMP       R8, #0			;->0x00
80001e18:	09 f1       	JNZ       $+9                   ;->0x80001e2a
80001e1a:	10 04       	SJMP      $+16                  ;->0x80001e3a
##@@@F_:prvTestWaitCondition():
##@@@P_:event_groups.c:772
##@@@L0767_:                                        const EventBits_t uxBitsToWaitFor,   
##@@@L0768_:                                        const BaseType_t xWaitForAllBits )   
##@@@L0769_:{   
##@@@L0770_:    BaseType_t xWaitConditionMet = pdFALSE;   
##@@@L0771_:
##@@@L0772_:    if( xWaitForAllBits == pdFALSE )   
80001e1c:	30 38       	CMP       R3, #0			;->0x00
80001e1e:	f9 f1       	JNZ       $-7                   ;->0x80001e10
80001e20:	a2 58       	MOV       R5, R2
80001e22:	90 38       	CMP       R9, #0			;->0x00
80001e24:	f8 f1       	JNZ       $-8                   ;->0x80001e14
##@@@F_:xEventGroupWaitBits():
##@@@P_:event_groups.c:426
##@@@L0421_:                /* The task timed out, just return the current event bit value. */   
##@@@L0422_:                uxReturn = pxEventBits->uxEventBits;   
##@@@L0423_:
##@@@L0424_:                /* It is possible that the event bits were updated between this   
##@@@L0425_:                 * task leaving the Blocked state and running again. */   
##@@@L0426_:                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )   
80001e26:	80 38       	CMP       R8, #0			;->0x00
80001e28:	09 f0       	JZ        $+9                   ;->0x80001e3a
80001e2a:	41 10       	MOV       R4, #1			;->0x0001
80001e2c:	54 69       	ANL       R5, R4
80001e2e:	50 38       	CMP       R5, #0			;->0x00
80001e30:	05 f0       	JZ        $+5                   ;->0x80001e3a
##@@@P_:event_groups.c:430
##@@@L0427_:                {   
##@@@L0428_:                    if( xClearOnExit != pdFALSE )   
##@@@L0429_:                    {   
##@@@L0430_:                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;   
80001e32:	57 68       	NOT       R5, R7
80001e34:	8a 58       	MOV       R4, R10
80001e36:	45 69       	ANL       R4, R5
80001e38:	64 85       	ST.W      [R6], R4
##@@@P_:event_groups.c:444
##@@@L0439_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L0440_:                }   
##@@@L0441_:
##@@@L0442_:                xTimeoutOccurred = pdTRUE;   
##@@@L0443_:            }   
##@@@L0444_:            taskEXIT_CRITICAL();   
80001e3a:	0e 45       	LD        R5, [PC + #14]        ;->0x80001e70  :=0x80005730
80001e3c:	05 5c       	LJMP      R5
80001e3e:	0e 45       	LD        R5, [PC + #14]        ;->0x80001e74  :=0xffffff
##@@@P_:event_groups.c:452
##@@@L0447_:        {   
##@@@L0448_:            /* The task unblocked because the bits were set. */   
##@@@L0449_:        }   
##@@@L0450_:
##@@@L0451_:        /* The task blocked so control bits may have been set. */   
##@@@L0452_:        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;   
80001e40:	a5 69       	ANL       R10, R5
##@@@P_:event_groups.c:462
##@@@L0457_:    /* Prevent compiler warnings when trace macros are not used. */   
##@@@L0458_:    ( void ) xTimeoutOccurred;   
##@@@L0459_:
##@@@L0460_:    traceRETURN_xEventGroupWaitBits( uxReturn );   
##@@@L0461_:
##@@@L0462_:    return uxReturn;   
80001e42:	0a 58       	MOV       R0, R10
80001e44:	e4 28       	ADD       SP, #4			;->0x04
80001e46:	3f 5e       	POP       {R6-R11}
80001e48:	0d 5d       	POP       LR
80001e4a:	1d 5c       	JMP       LR
80001e4c:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
80001e50:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80001e54:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80001e58:	00 00 00 04 	.long     0x04000000 ->067108864  [!!!@2@:NOP      	@@: SJMP      $+0                   ;->0x80001e58
80001e5c:	0c 6f 00 80 	.long     0x80006f0c ->-2147455220  [!!!@2@:ROR       R0, R12	@@: LD.B      R0, [R0]
80001e60:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80001e64:	6c 7b 00 80 	.long     0x80007b6c ->-2147452052  [!!!@2@:LSL       LR, #20	@@: LD.B      R0, [R0]
80001e68:	00 00 00 02 	.long     0x02000000 ->033554432 
80001e6c:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80001e6c
80001e70:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80001e70
80001e74:	ff ff ff 00 	.long     0x00ffffff ->016777215 
##@@@P_:event_groups.c:321
##@@@L0316_:
##@@@L0317_:    traceENTER_xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );   
##@@@L0318_:
##@@@L0319_:    /* Check the user is not attempting to wait on the bits used by the kernel   
##@@@L0320_:     * itself, and that at least one bit is being requested. */   
##@@@L0321_:    configASSERT( xEventGroup );   
80001e78:	20 5d       	PUSH      R0
80001e7a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001e7e:	08 00       	SYNC     SYNC     
80001e80:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001e84:	08 00       	SYNC     SYNC     
80001e86:	00 5d       	POP       R0
80001e88:	20 5d       	PUSH      R0
80001e8a:	21 5d       	PUSH      R1
80001e8c:	30 45       	LD        R5, [PC + #48]        ;->0x80001f4c  :=0x1ff
80001e8e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001e92:	25 58       	MOV       R1, R5
80001e94:	11 68       	NOT       R1, R1
80001e96:	01 69       	ANL       R0, R1
80001e98:	5f 11       	MOV       R5, #31			;->0x001F
80001e9a:	25 58       	MOV       R1, R5
80001e9c:	01 6a       	ORL       R0, R1
80001e9e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001ea2:	08 00       	SYNC     SYNC     
80001ea4:	01 5d       	POP       R1
80001ea6:	00 5d       	POP       R0
80001ea8:	20 5d       	PUSH      R0
80001eaa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001eae:	08 00       	SYNC     SYNC     
80001eb0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001eb4:	08 00       	SYNC     SYNC     
80001eb6:	00 5d       	POP       R0
80001eb8:	07 00       	BREAK    BREAK    
80001eba:	26 45       	LD        R5, [PC + #38]        ;->0x80001f50  :=0x8000911c
80001ebc:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:322
##@@@L0322_:    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001ebe:	20 5d       	PUSH      R0
80001ec0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001ec4:	08 00       	SYNC     SYNC     
80001ec6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001eca:	08 00       	SYNC     SYNC     
80001ecc:	00 5d       	POP       R0
80001ece:	20 5d       	PUSH      R0
80001ed0:	21 5d       	PUSH      R1
80001ed2:	1f 45       	LD        R5, [PC + #31]        ;->0x80001f4c  :=0x1ff
80001ed4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001ed8:	25 58       	MOV       R1, R5
80001eda:	11 68       	NOT       R1, R1
80001edc:	01 69       	ANL       R0, R1
80001ede:	5f 11       	MOV       R5, #31			;->0x001F
80001ee0:	25 58       	MOV       R1, R5
80001ee2:	01 6a       	ORL       R0, R1
80001ee4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001ee8:	08 00       	SYNC     SYNC     
80001eea:	01 5d       	POP       R1
80001eec:	00 5d       	POP       R0
80001eee:	20 5d       	PUSH      R0
80001ef0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001ef4:	08 00       	SYNC     SYNC     
80001ef6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001efa:	08 00       	SYNC     SYNC     
80001efc:	00 5d       	POP       R0
80001efe:	07 00       	BREAK    BREAK    
80001f00:	14 45       	LD        R5, [PC + #20]        ;->0x80001f50  :=0x8000911c
80001f02:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:323
##@@@L0323_:    configASSERT( uxBitsToWaitFor != 0 );   
80001f04:	20 5d       	PUSH      R0
80001f06:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001f0a:	08 00       	SYNC     SYNC     
80001f0c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001f10:	08 00       	SYNC     SYNC     
80001f12:	00 5d       	POP       R0
80001f14:	20 5d       	PUSH      R0
80001f16:	21 5d       	PUSH      R1
80001f18:	0d 45       	LD        R5, [PC + #13]        ;->0x80001f4c  :=0x1ff
80001f1a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001f1e:	25 58       	MOV       R1, R5
80001f20:	11 68       	NOT       R1, R1
80001f22:	01 69       	ANL       R0, R1
80001f24:	5f 11       	MOV       R5, #31			;->0x001F
80001f26:	25 58       	MOV       R1, R5
80001f28:	01 6a       	ORL       R0, R1
80001f2a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001f2e:	08 00       	SYNC     SYNC     
80001f30:	01 5d       	POP       R1
80001f32:	00 5d       	POP       R0
80001f34:	20 5d       	PUSH      R0
80001f36:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001f3a:	08 00       	SYNC     SYNC     
80001f3c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001f40:	08 00       	SYNC     SYNC     
80001f42:	00 5d       	POP       R0
80001f44:	07 00       	BREAK    BREAK    
80001f46:	03 45       	LD        R5, [PC + #3]         ;->0x80001f50  :=0x8000911c
80001f48:	05 5c       	LJMP      R5
80001f4a:	00 00       	NOP      NOP      
80001f4c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80001f50:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80001f54 <xEventGroupClearBits>:
##@@@F_:xEventGroupClearBits():
##@@@P_:event_groups.c:468
##@@@L0463_:}   
##@@@L0464_:/*-----------------------------------------------------------*/   
##@@@L0465_:
##@@@L0466_:EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,   
##@@@L0467_:                                  const EventBits_t uxBitsToClear )   
##@@@L0468_:{   
80001f54:	87 5f       	PUSH      {R6-R8,LR}
80001f56:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:event_groups.c:476
##@@@L0471_:
##@@@L0472_:    traceENTER_xEventGroupClearBits( xEventGroup, uxBitsToClear );   
##@@@L0473_:
##@@@L0474_:    /* Check the user is not attempting to clear the bits used by the kernel   
##@@@L0475_:     * itself. */   
##@@@L0476_:    configASSERT( xEventGroup );   
80001f58:	00 38       	CMP       R0, #0			;->0x00
80001f5a:	1b f0       	JZ        $+27                  ;->0x80001f90
80001f5c:	e1 58       	MOV       R7, R1
##@@@P_:event_groups.c:477
##@@@L0477_:    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001f5e:	0a 45       	LD        R5, [PC + #10]        ;->0x80001f84  :=0x1000000
80001f60:	15 70       	CMP       R1, R5
80001f62:	3a f2       	JC        $+58                  ;->0x80001fd6
80001f64:	c0 58       	MOV       R6, R0
##@@@P_:event_groups.c:479
##@@@L0478_:
##@@@L0479_:    taskENTER_CRITICAL();   
80001f66:	09 45       	LD        R5, [PC + #9]         ;->0x80001f88  :=0x800056cc
80001f68:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:485
##@@@L0480_:    {   
##@@@L0481_:        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );   
##@@@L0482_:
##@@@L0483_:        /* The value returned is the event group value prior to the bits being   
##@@@L0484_:         * cleared. */   
##@@@L0485_:        uxReturn = pxEventBits->uxEventBits;   
80001f6a:	86 82       	LD.W      R8, [R6]
##@@@P_:event_groups.c:488
##@@@L0486_:
##@@@L0487_:        /* Clear the bits. */   
##@@@L0488_:        pxEventBits->uxEventBits &= ~uxBitsToClear;   
80001f6c:	57 68       	NOT       R5, R7
80001f6e:	88 58       	MOV       R4, R8
80001f70:	45 69       	ANL       R4, R5
80001f72:	64 85       	ST.W      [R6], R4
##@@@P_:event_groups.c:490
##@@@L0489_:    }   
##@@@L0490_:    taskEXIT_CRITICAL();   
80001f74:	06 45       	LD        R5, [PC + #6]         ;->0x80001f8c  :=0x80005730
80001f76:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:494
##@@@L0491_:
##@@@L0492_:    traceRETURN_xEventGroupClearBits( uxReturn );   
##@@@L0493_:
##@@@L0494_:    return uxReturn;   
80001f78:	08 58       	MOV       R0, R8
80001f7a:	e4 28       	ADD       SP, #4			;->0x04
80001f7c:	07 5e       	POP       {R6-R8}
80001f7e:	0d 5d       	POP       LR
80001f80:	1d 5c       	JMP       LR
80001f82:	00 00       	NOP      NOP      
80001f84:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
80001f88:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80001f88
80001f8c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80001f8c
##@@@P_:event_groups.c:476
##@@@L0471_:
##@@@L0472_:    traceENTER_xEventGroupClearBits( xEventGroup, uxBitsToClear );   
##@@@L0473_:
##@@@L0474_:    /* Check the user is not attempting to clear the bits used by the kernel   
##@@@L0475_:     * itself. */   
##@@@L0476_:    configASSERT( xEventGroup );   
80001f90:	20 5d       	PUSH      R0
80001f92:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001f96:	08 00       	SYNC     SYNC     
80001f98:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001f9c:	08 00       	SYNC     SYNC     
80001f9e:	00 5d       	POP       R0
80001fa0:	20 5d       	PUSH      R0
80001fa2:	21 5d       	PUSH      R1
80001fa4:	1e 45       	LD        R5, [PC + #30]        ;->0x8000201c  :=0x1ff
80001fa6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001faa:	25 58       	MOV       R1, R5
80001fac:	11 68       	NOT       R1, R1
80001fae:	01 69       	ANL       R0, R1
80001fb0:	5f 11       	MOV       R5, #31			;->0x001F
80001fb2:	25 58       	MOV       R1, R5
80001fb4:	01 6a       	ORL       R0, R1
80001fb6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80001fba:	08 00       	SYNC     SYNC     
80001fbc:	01 5d       	POP       R1
80001fbe:	00 5d       	POP       R0
80001fc0:	20 5d       	PUSH      R0
80001fc2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001fc6:	08 00       	SYNC     SYNC     
80001fc8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80001fcc:	08 00       	SYNC     SYNC     
80001fce:	00 5d       	POP       R0
80001fd0:	07 00       	BREAK    BREAK    
80001fd2:	14 45       	LD        R5, [PC + #20]        ;->0x80002020  :=0x8000911c
80001fd4:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:477
##@@@L0477_:    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );   
80001fd6:	20 5d       	PUSH      R0
80001fd8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80001fdc:	08 00       	SYNC     SYNC     
80001fde:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80001fe2:	08 00       	SYNC     SYNC     
80001fe4:	00 5d       	POP       R0
80001fe6:	20 5d       	PUSH      R0
80001fe8:	21 5d       	PUSH      R1
80001fea:	0d 45       	LD        R5, [PC + #13]        ;->0x8000201c  :=0x1ff
80001fec:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80001ff0:	25 58       	MOV       R1, R5
80001ff2:	11 68       	NOT       R1, R1
80001ff4:	01 69       	ANL       R0, R1
80001ff6:	5f 11       	MOV       R5, #31			;->0x001F
80001ff8:	25 58       	MOV       R1, R5
80001ffa:	01 6a       	ORL       R0, R1
80001ffc:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002000:	08 00       	SYNC     SYNC     
80002002:	01 5d       	POP       R1
80002004:	00 5d       	POP       R0
80002006:	20 5d       	PUSH      R0
80002008:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000200c:	08 00       	SYNC     SYNC     
8000200e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002012:	08 00       	SYNC     SYNC     
80002014:	00 5d       	POP       R0
80002016:	07 00       	BREAK    BREAK    
80002018:	02 45       	LD        R5, [PC + #2]         ;->0x80002020  :=0x8000911c
8000201a:	05 5c       	LJMP      R5
8000201c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002020:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002024 <xEventGroupGetBitsFromISR>:
##@@@F_:xEventGroupGetBitsFromISR():
##@@@P_:event_groups.c:519
##@@@L0514_:
##@@@L0515_:#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */   
##@@@L0516_:/*-----------------------------------------------------------*/   
##@@@L0517_:
##@@@L0518_:EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )   
##@@@L0519_:{   
80002024:	81 5f       	PUSH      {R6,LR}
80002026:	e4 30       	SUB       SP, #4			;->0x04
80002028:	c0 58       	MOV       R6, R0
##@@@P_:event_groups.c:526
##@@@L0521_:    EventGroup_t const * const pxEventBits = xEventGroup;   
##@@@L0522_:    EventBits_t uxReturn;   
##@@@L0523_:
##@@@L0524_:    traceENTER_xEventGroupGetBitsFromISR( xEventGroup );   
##@@@L0525_:
##@@@L0526_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
8000202a:	06 45       	LD        R5, [PC + #6]         ;->0x80002040  :=0x80008ff0
8000202c:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:528
##@@@L0527_:    {   
##@@@L0528_:        uxReturn = pxEventBits->uxEventBits;   
8000202e:	66 82       	LD.W      R6, [R6]
##@@@P_:event_groups.c:530
##@@@L0529_:    }   
##@@@L0530_:    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80002030:	05 45       	LD        R5, [PC + #5]         ;->0x80002044  :=0x80009034
80002032:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:534
##@@@L0531_:
##@@@L0532_:    traceRETURN_xEventGroupGetBitsFromISR( uxReturn );   
##@@@L0533_:
##@@@L0534_:    return uxReturn;   
80002034:	06 58       	MOV       R0, R6
80002036:	e4 28       	ADD       SP, #4			;->0x04
80002038:	06 5d       	POP       R6
8000203a:	0d 5d       	POP       LR
8000203c:	1d 5c       	JMP       LR
8000203e:	00 00       	NOP      NOP      
80002040:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
80002044:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]

80002048 <vEventGroupDelete>:
##@@@F_:vEventGroupDelete():
##@@@P_:event_groups.c:639
##@@@L0634_:    return pxEventBits->uxEventBits;   
##@@@L0635_:}   
##@@@L0636_:/*-----------------------------------------------------------*/   
##@@@L0637_:
##@@@L0638_:void vEventGroupDelete( EventGroupHandle_t xEventGroup )   
##@@@L0639_:{   
80002048:	83 5f       	PUSH      {R6-R7,LR}
8000204a:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:event_groups.c:645
##@@@L0640_:    EventGroup_t * pxEventBits = xEventGroup;   
##@@@L0641_:    const List_t * pxTasksWaitingForBits;   
##@@@L0642_:
##@@@L0643_:    traceENTER_vEventGroupDelete( xEventGroup );   
##@@@L0644_:
##@@@L0645_:    configASSERT( pxEventBits );   
8000204c:	00 38       	CMP       R0, #0			;->0x00
8000204e:	4e f0       	JZ        $+78                  ;->0x800020ea
80002050:	c0 58       	MOV       R6, R0
##@@@P_:event_groups.c:649
##@@@L0646_:
##@@@L0647_:    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );   
##@@@L0648_:
##@@@L0649_:    vTaskSuspendAll();   
80002052:	10 45       	LD        R5, [PC + #16]        ;->0x80002090  :=0x800059b0
80002054:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:653
##@@@L0650_:    {   
##@@@L0651_:        traceEVENT_GROUP_DELETE( xEventGroup );   
##@@@L0652_:
##@@@L0653_:        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )   
80002056:	6e 98       	LD.W      R5, [R6 + #1]
80002058:	50 38       	CMP       R5, #0			;->0x00
8000205a:	0e f0       	JZ        $+14                  ;->0x80002076
8000205c:	e6 58       	MOV       R7, R6
8000205e:	0e 45       	LD        R5, [PC + #14]        ;->0x80002094  :=0x2000000
80002060:	01 25       	ST.W      [SP + #1], R5
80002062:	7c 28       	ADD       R7, #12			;->0x0C
##@@@P_:event_groups.c:657
##@@@L0654_:        {   
##@@@L0655_:            /* Unblock the task, returning 0 as the event list is being deleted   
##@@@L0656_:             * and cannot therefore have any bits set. */   
##@@@L0657_:            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );   
80002064:	06 99       	LD.W      R0, [R6 + #4]
80002066:	07 70       	CMP       R0, R7
80002068:	1e f0       	JZ        $+30                  ;->0x800020a4
##@@@P_:event_groups.c:658
##@@@L0658_:            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );   
8000206a:	01 09       	LD.W      R1, [SP + #1]
8000206c:	0b 45       	LD        R5, [PC + #11]        ;->0x80002098  :=0x80007120
8000206e:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:653
##@@@L0648_:
##@@@L0649_:    vTaskSuspendAll();   
##@@@L0650_:    {   
##@@@L0651_:        traceEVENT_GROUP_DELETE( xEventGroup );   
##@@@L0652_:
##@@@L0653_:        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )   
80002070:	6e 98       	LD.W      R5, [R6 + #1]
80002072:	50 38       	CMP       R5, #0			;->0x00
80002074:	f8 f1       	JNZ       $-8                   ;->0x80002064
##@@@P_:event_groups.c:661
##@@@L0656_:             * and cannot therefore have any bits set. */   
##@@@L0657_:            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );   
##@@@L0658_:            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );   
##@@@L0659_:        }   
##@@@L0660_:    }   
##@@@L0661_:    ( void ) xTaskResumeAll();   
80002076:	0a 45       	LD        R5, [PC + #10]        ;->0x8000209c  :=0x80005a70
80002078:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:673
##@@@L0668_:    }   
##@@@L0669_:    #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )   
##@@@L0670_:    {   
##@@@L0671_:        /* The event group could have been allocated statically or   
##@@@L0672_:         * dynamically, so check before attempting to free the memory. */   
##@@@L0673_:        if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )   
8000207a:	2e 8f       	LD.B      R5, [R6 + #28]
8000207c:	50 38       	CMP       R5, #0			;->0x00
8000207e:	04 f1       	JNZ       $+4                   ;->0x80002086
##@@@P_:event_groups.c:675
##@@@L0674_:        {   
##@@@L0675_:            vPortFree( pxEventBits );   
80002080:	06 58       	MOV       R0, R6
80002082:	08 45       	LD        R5, [PC + #8]         ;->0x800020a0  :=0x80008b9c
80002084:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:685
##@@@L0680_:        }   
##@@@L0681_:    }   
##@@@L0682_:    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */   
##@@@L0683_:
##@@@L0684_:    traceRETURN_vEventGroupDelete();   
##@@@L0685_:}   
80002086:	e8 28       	ADD       SP, #8			;->0x08
80002088:	03 5e       	POP       {R6-R7}
8000208a:	0d 5d       	POP       LR
8000208c:	1d 5c       	JMP       LR
8000208e:	00 00       	NOP      NOP      
80002090:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80002094:	00 00 00 02 	.long     0x02000000 ->033554432 
80002098:	20 71 00 80 	.long     0x80007120 ->-2147454688  [!!!@2@:TST       R2, R0	@@: LD.B      R0, [R0]
8000209c:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
800020a0:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]
##@@@P_:event_groups.c:657
##@@@L0652_:
##@@@L0653_:        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )   
##@@@L0654_:        {   
##@@@L0655_:            /* Unblock the task, returning 0 as the event list is being deleted   
##@@@L0656_:             * and cannot therefore have any bits set. */   
##@@@L0657_:            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );   
800020a4:	20 5d       	PUSH      R0
800020a6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800020aa:	08 00       	SYNC     SYNC     
800020ac:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800020b0:	08 00       	SYNC     SYNC     
800020b2:	00 5d       	POP       R0
800020b4:	20 5d       	PUSH      R0
800020b6:	21 5d       	PUSH      R1
800020b8:	1e 45       	LD        R5, [PC + #30]        ;->0x80002130  :=0x1ff
800020ba:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800020be:	25 58       	MOV       R1, R5
800020c0:	11 68       	NOT       R1, R1
800020c2:	01 69       	ANL       R0, R1
800020c4:	5f 11       	MOV       R5, #31			;->0x001F
800020c6:	25 58       	MOV       R1, R5
800020c8:	01 6a       	ORL       R0, R1
800020ca:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800020ce:	08 00       	SYNC     SYNC     
800020d0:	01 5d       	POP       R1
800020d2:	00 5d       	POP       R0
800020d4:	20 5d       	PUSH      R0
800020d6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800020da:	08 00       	SYNC     SYNC     
800020dc:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800020e0:	08 00       	SYNC     SYNC     
800020e2:	00 5d       	POP       R0
800020e4:	07 00       	BREAK    BREAK    
800020e6:	14 45       	LD        R5, [PC + #20]        ;->0x80002134  :=0x8000911c
800020e8:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:645
##@@@L0640_:    EventGroup_t * pxEventBits = xEventGroup;   
##@@@L0641_:    const List_t * pxTasksWaitingForBits;   
##@@@L0642_:
##@@@L0643_:    traceENTER_vEventGroupDelete( xEventGroup );   
##@@@L0644_:
##@@@L0645_:    configASSERT( pxEventBits );   
800020ea:	20 5d       	PUSH      R0
800020ec:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800020f0:	08 00       	SYNC     SYNC     
800020f2:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800020f6:	08 00       	SYNC     SYNC     
800020f8:	00 5d       	POP       R0
800020fa:	20 5d       	PUSH      R0
800020fc:	21 5d       	PUSH      R1
800020fe:	0d 45       	LD        R5, [PC + #13]        ;->0x80002130  :=0x1ff
80002100:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002104:	25 58       	MOV       R1, R5
80002106:	11 68       	NOT       R1, R1
80002108:	01 69       	ANL       R0, R1
8000210a:	5f 11       	MOV       R5, #31			;->0x001F
8000210c:	25 58       	MOV       R1, R5
8000210e:	01 6a       	ORL       R0, R1
80002110:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002114:	08 00       	SYNC     SYNC     
80002116:	01 5d       	POP       R1
80002118:	00 5d       	POP       R0
8000211a:	20 5d       	PUSH      R0
8000211c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002120:	08 00       	SYNC     SYNC     
80002122:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002126:	08 00       	SYNC     SYNC     
80002128:	00 5d       	POP       R0
8000212a:	07 00       	BREAK    BREAK    
8000212c:	02 45       	LD        R5, [PC + #2]         ;->0x80002134  :=0x8000911c
8000212e:	05 5c       	LJMP      R5
80002130:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002134:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002138 <xEventGroupGetStaticBuffer>:
##@@@F_:xEventGroupGetStaticBuffer():
##@@@P_:event_groups.c:691
##@@@L0686_:/*-----------------------------------------------------------*/   
##@@@L0687_:
##@@@L0688_:#if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L0689_:    BaseType_t xEventGroupGetStaticBuffer( EventGroupHandle_t xEventGroup,   
##@@@L0690_:                                           StaticEventGroup_t ** ppxEventGroupBuffer )   
##@@@L0691_:    {   
80002138:	2d 5d       	PUSH      LR
8000213a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:event_groups.c:697
##@@@L0692_:        BaseType_t xReturn;   
##@@@L0693_:        EventGroup_t * pxEventBits = xEventGroup;   
##@@@L0694_:
##@@@L0695_:        traceENTER_xEventGroupGetStaticBuffer( xEventGroup, ppxEventGroupBuffer );   
##@@@L0696_:
##@@@L0697_:        configASSERT( pxEventBits );   
8000213c:	00 38       	CMP       R0, #0			;->0x00
8000213e:	0d f0       	JZ        $+13                  ;->0x80002158
##@@@P_:event_groups.c:698
##@@@L0698_:        configASSERT( ppxEventGroupBuffer );   
80002140:	10 38       	CMP       R1, #0			;->0x00
80002142:	2e f0       	JZ        $+46                  ;->0x8000219e
##@@@P_:event_groups.c:703
##@@@L0699_:
##@@@L0700_:        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )   
##@@@L0701_:        {   
##@@@L0702_:            /* Check if the event group was statically allocated. */   
##@@@L0703_:            if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdTRUE )   
80002144:	28 8f       	LD.B      R5, [R0 + #28]
80002146:	51 38       	CMP       R5, #1			;->0x01
80002148:	04 f1       	JNZ       $+4                   ;->0x80002150
##@@@P_:event_groups.c:708
##@@@L0704_:            {   
##@@@L0705_:                /* MISRA Ref 11.3.1 [Misaligned access] */   
##@@@L0706_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-113 */   
##@@@L0707_:                /* coverity[misra_c_2012_rule_11_3_violation] */   
##@@@L0708_:                *ppxEventGroupBuffer = ( StaticEventGroup_t * ) pxEventBits;   
8000214a:	10 85       	ST.W      [R1], R0
8000214c:	01 10       	MOV       R0, #1			;->0x0001
8000214e:	02 04       	SJMP      $+2                   ;->0x80002152
80002150:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:event_groups.c:729
##@@@L0724_:        }   
##@@@L0725_:        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */   
##@@@L0726_:
##@@@L0727_:        traceRETURN_xEventGroupGetStaticBuffer( xReturn );   
##@@@L0728_:
##@@@L0729_:        return xReturn;   
80002152:	e4 28       	ADD       SP, #4			;->0x04
80002154:	0d 5d       	POP       LR
80002156:	1d 5c       	JMP       LR
##@@@P_:event_groups.c:697
##@@@L0692_:        BaseType_t xReturn;   
##@@@L0693_:        EventGroup_t * pxEventBits = xEventGroup;   
##@@@L0694_:
##@@@L0695_:        traceENTER_xEventGroupGetStaticBuffer( xEventGroup, ppxEventGroupBuffer );   
##@@@L0696_:
##@@@L0697_:        configASSERT( pxEventBits );   
80002158:	20 5d       	PUSH      R0
8000215a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000215e:	08 00       	SYNC     SYNC     
80002160:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002164:	08 00       	SYNC     SYNC     
80002166:	00 5d       	POP       R0
80002168:	20 5d       	PUSH      R0
8000216a:	21 5d       	PUSH      R1
8000216c:	1e 45       	LD        R5, [PC + #30]        ;->0x800021e4  :=0x1ff
8000216e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002172:	25 58       	MOV       R1, R5
80002174:	11 68       	NOT       R1, R1
80002176:	01 69       	ANL       R0, R1
80002178:	5f 11       	MOV       R5, #31			;->0x001F
8000217a:	25 58       	MOV       R1, R5
8000217c:	01 6a       	ORL       R0, R1
8000217e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002182:	08 00       	SYNC     SYNC     
80002184:	01 5d       	POP       R1
80002186:	00 5d       	POP       R0
80002188:	20 5d       	PUSH      R0
8000218a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000218e:	08 00       	SYNC     SYNC     
80002190:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002194:	08 00       	SYNC     SYNC     
80002196:	00 5d       	POP       R0
80002198:	07 00       	BREAK    BREAK    
8000219a:	14 45       	LD        R5, [PC + #20]        ;->0x800021e8  :=0x8000911c
8000219c:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:698
##@@@L0698_:        configASSERT( ppxEventGroupBuffer );   
8000219e:	20 5d       	PUSH      R0
800021a0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800021a4:	08 00       	SYNC     SYNC     
800021a6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800021aa:	08 00       	SYNC     SYNC     
800021ac:	00 5d       	POP       R0
800021ae:	20 5d       	PUSH      R0
800021b0:	21 5d       	PUSH      R1
800021b2:	0d 45       	LD        R5, [PC + #13]        ;->0x800021e4  :=0x1ff
800021b4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800021b8:	25 58       	MOV       R1, R5
800021ba:	11 68       	NOT       R1, R1
800021bc:	01 69       	ANL       R0, R1
800021be:	5f 11       	MOV       R5, #31			;->0x001F
800021c0:	25 58       	MOV       R1, R5
800021c2:	01 6a       	ORL       R0, R1
800021c4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800021c8:	08 00       	SYNC     SYNC     
800021ca:	01 5d       	POP       R1
800021cc:	00 5d       	POP       R0
800021ce:	20 5d       	PUSH      R0
800021d0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800021d4:	08 00       	SYNC     SYNC     
800021d6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800021da:	08 00       	SYNC     SYNC     
800021dc:	00 5d       	POP       R0
800021de:	07 00       	BREAK    BREAK    
800021e0:	02 45       	LD        R5, [PC + #2]         ;->0x800021e8  :=0x8000911c
800021e2:	05 5c       	LJMP      R5
800021e4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800021e8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800021ec <vEventGroupSetBitsCallback>:
##@@@F_:vEventGroupSetBitsCallback():
##@@@P_:event_groups.c:738
##@@@L0733_:
##@@@L0734_:/* For internal use only - execute a 'set bits' command that was pended from   
##@@@L0735_: * an interrupt. */   
##@@@L0736_:void vEventGroupSetBitsCallback( void * pvEventGroup,   
##@@@L0737_:                                 uint32_t ulBitsToSet )   
##@@@L0738_:{   
800021ec:	2d 5d       	PUSH      LR
800021ee:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:event_groups.c:744
##@@@L0739_:    traceENTER_vEventGroupSetBitsCallback( pvEventGroup, ulBitsToSet );   
##@@@L0740_:
##@@@L0741_:    /* MISRA Ref 11.5.4 [Callback function parameter] */   
##@@@L0742_:    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0743_:    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0744_:    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );   
800021f0:	03 45       	LD        R5, [PC + #3]         ;->0x800021fc  :=0x80001c00
800021f2:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:747
##@@@L0745_:
##@@@L0746_:    traceRETURN_vEventGroupSetBitsCallback();   
##@@@L0747_:}   
800021f4:	e4 28       	ADD       SP, #4			;->0x04
800021f6:	0d 5d       	POP       LR
800021f8:	1d 5c       	JMP       LR
800021fa:	00 00       	NOP      NOP      
800021fc:	00 1c 00 80 	.long     0x80001c00 ->-2147476480  [!!!@2@:MOV       R0, #192	@@: LD.B      R0, [R0]

80002200 <vEventGroupClearBitsCallback>:
##@@@F_:vEventGroupClearBitsCallback():
##@@@P_:event_groups.c:754
##@@@L0749_:
##@@@L0750_:/* For internal use only - execute a 'clear bits' command that was pended from   
##@@@L0751_: * an interrupt. */   
##@@@L0752_:void vEventGroupClearBitsCallback( void * pvEventGroup,   
##@@@L0753_:                                   uint32_t ulBitsToClear )   
##@@@L0754_:{   
80002200:	2d 5d       	PUSH      LR
80002202:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:event_groups.c:760
##@@@L0755_:    traceENTER_vEventGroupClearBitsCallback( pvEventGroup, ulBitsToClear );   
##@@@L0756_:
##@@@L0757_:    /* MISRA Ref 11.5.4 [Callback function parameter] */   
##@@@L0758_:    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0759_:    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0760_:    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );   
80002204:	03 45       	LD        R5, [PC + #3]         ;->0x80002210  :=0x80001f54
80002206:	05 5c       	LJMP      R5
##@@@P_:event_groups.c:763
##@@@L0761_:
##@@@L0762_:    traceRETURN_vEventGroupClearBitsCallback();   
##@@@L0763_:}   
80002208:	e4 28       	ADD       SP, #4			;->0x04
8000220a:	0d 5d       	POP       LR
8000220c:	1d 5c       	JMP       LR
8000220e:	00 00       	NOP      NOP      
80002210:	54 1f 00 80 	.long     0x80001f54 ->-2147475628  [!!!@2@:MOV       R5, #244	@@: LD.B      R0, [R0]

80002214 <uxEventGroupGetNumber>:
##@@@F_:uxEventGroupGetNumber():
##@@@P_:event_groups.c:837
##@@@L0832_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0833_:        EventGroup_t const * pxEventBits = ( EventGroup_t * ) xEventGroup;   
##@@@L0834_:
##@@@L0835_:        traceENTER_uxEventGroupGetNumber( xEventGroup );   
##@@@L0836_:
##@@@L0837_:        if( xEventGroup == NULL )   
80002214:	00 38       	CMP       R0, #0			;->0x00
80002216:	03 f0       	JZ        $+3                   ;->0x8000221c
##@@@P_:event_groups.c:843
##@@@L0838_:        {   
##@@@L0839_:            xReturn = 0;   
##@@@L0840_:        }   
##@@@L0841_:        else   
##@@@L0842_:        {   
##@@@L0843_:            xReturn = pxEventBits->uxEventGroupNumber;   
80002218:	80 99       	LD.W      R0, [R0 + #6]
##@@@P_:event_groups.c:848
##@@@L0844_:        }   
##@@@L0845_:
##@@@L0846_:        traceRETURN_uxEventGroupGetNumber( xReturn );   
##@@@L0847_:
##@@@L0848_:        return xReturn;   
8000221a:	1d 5c       	JMP       LR
8000221c:	00 10       	MOV       R0, #0			;->0x0000
8000221e:	1d 5c       	JMP       LR

80002220 <vEventGroupSetNumber>:
##@@@F_:vEventGroupSetNumber():
##@@@P_:event_groups.c:864
##@@@L0859_:        traceENTER_vEventGroupSetNumber( xEventGroup, uxEventGroupNumber );   
##@@@L0860_:
##@@@L0861_:        /* MISRA Ref 11.5.2 [Opaque pointer] */   
##@@@L0862_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0863_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0864_:        ( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber;   
80002220:	81 a1       	ST.W      [R0 + #6], R1
##@@@P_:event_groups.c:867
##@@@L0865_:
##@@@L0866_:        traceRETURN_vEventGroupSetNumber();   
##@@@L0867_:    }   
80002222:	1d 5c       	JMP       LR

80002224 <vListInitialise>:
##@@@F_:vListInitialise():
##@@@P_:list.c:50
##@@@L0045_:/*-----------------------------------------------------------   
##@@@L0046_:* PUBLIC LIST API documented in list.h   
##@@@L0047_:*----------------------------------------------------------*/   
##@@@L0048_:
##@@@L0049_:void vListInitialise( List_t * const pxList )   
##@@@L0050_:{   
80002224:	05 45       	LD        R5, [PC + #5]         ;->0x80002238  :=0xffffffff
##@@@P_:list.c:62
##@@@L0057_:
##@@@L0058_:    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );   
##@@@L0059_:
##@@@L0060_:    /* The list end value is the highest possible value in the list to   
##@@@L0061_:     * ensure it remains at the end of the list. */   
##@@@L0062_:    pxList->xListEnd.xItemValue = portMAX_DELAY;   
80002226:	85 a0       	ST.W      [R0 + #2], R5
80002228:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:list.c:78
##@@@L0073_:        pxList->xListEnd.pxContainer = NULL;   
##@@@L0074_:        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );   
##@@@L0075_:    }   
##@@@L0076_:    #endif   
##@@@L0077_:
##@@@L0078_:    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;   
8000222a:	05 85       	ST.W      [R0], R5
##@@@P_:list.c:56
##@@@L0051_:    traceENTER_vListInitialise( pxList );   
##@@@L0052_:
##@@@L0053_:    /* The list structure contains a list item which is used to mark the   
##@@@L0054_:     * end of the list.  To initialise the list the list end is inserted   
##@@@L0055_:     * as the only list entry. */   
##@@@L0056_:    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );   
8000222c:	a0 58       	MOV       R5, R0
8000222e:	58 28       	ADD       R5, #8			;->0x08
##@@@P_:list.c:67
##@@@L0062_:    pxList->xListEnd.xItemValue = portMAX_DELAY;   
##@@@L0063_:
##@@@L0064_:    /* The list end next and previous pointers point to itself so we know   
##@@@L0065_:     * when the list is empty. */   
##@@@L0066_:    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );   
##@@@L0067_:    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );   
80002230:	05 a1       	ST.W      [R0 + #4], R5
##@@@P_:list.c:66
##@@@L0061_:     * ensure it remains at the end of the list. */   
##@@@L0062_:    pxList->xListEnd.xItemValue = portMAX_DELAY;   
##@@@L0063_:
##@@@L0064_:    /* The list end next and previous pointers point to itself so we know   
##@@@L0065_:     * when the list is empty. */   
##@@@L0066_:    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );   
80002232:	c5 a0       	ST.W      [R0 + #3], R5
##@@@P_:list.c:56
##@@@L0051_:    traceENTER_vListInitialise( pxList );   
##@@@L0052_:
##@@@L0053_:    /* The list structure contains a list item which is used to mark the   
##@@@L0054_:     * end of the list.  To initialise the list the list end is inserted   
##@@@L0055_:     * as the only list entry. */   
##@@@L0056_:    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );   
80002234:	45 a0       	ST.W      [R0 + #1], R5
##@@@P_:list.c:86
##@@@L0081_:     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */   
##@@@L0082_:    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );   
##@@@L0083_:    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );   
##@@@L0084_:
##@@@L0085_:    traceRETURN_vListInitialise();   
##@@@L0086_:}   
80002236:	1d 5c       	JMP       LR
80002238:	ff ff ff ff 	.long     0xffffffff ->-00000001 

8000223c <vListInitialiseItem>:
##@@@F_:vListInitialiseItem():
##@@@P_:list.c:90
##@@@L0087_:/*-----------------------------------------------------------*/   
##@@@L0088_:
##@@@L0089_:void vListInitialiseItem( ListItem_t * const pxItem )   
##@@@L0090_:{   
8000223c:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:list.c:94
##@@@L0091_:    traceENTER_vListInitialiseItem( pxItem );   
##@@@L0092_:
##@@@L0093_:    /* Make sure the list item is not recorded as being on a list. */   
##@@@L0094_:    pxItem->pxContainer = NULL;   
8000223e:	05 a1       	ST.W      [R0 + #4], R5
##@@@P_:list.c:102
##@@@L0097_:     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */   
##@@@L0098_:    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );   
##@@@L0099_:    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );   
##@@@L0100_:
##@@@L0101_:    traceRETURN_vListInitialiseItem();   
##@@@L0102_:}   
80002240:	1d 5c       	JMP       LR
	...

80002244 <vListInsertEnd>:
##@@@F_:vListInsertEnd():
##@@@P_:list.c:108
##@@@L0103_:/*-----------------------------------------------------------*/   
##@@@L0104_:
##@@@L0105_:void vListInsertEnd( List_t * const pxList,   
##@@@L0106_:                     ListItem_t * const pxNewListItem )   
##@@@L0107_:{   
##@@@L0108_:    ListItem_t * const pxIndex = pxList->pxIndex;   
80002244:	68 98       	LD.W      R5, [R0 + #1]
##@@@P_:list.c:121
##@@@L0116_:    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );   
##@@@L0117_:
##@@@L0118_:    /* Insert a new list item into pxList, but rather than sort the list,   
##@@@L0119_:     * makes the new list item the last item to be removed by a call to   
##@@@L0120_:     * listGET_OWNER_OF_NEXT_ENTRY(). */   
##@@@L0121_:    pxNewListItem->pxNext = pxIndex;   
80002246:	4d a0       	ST.W      [R1 + #1], R5
##@@@P_:list.c:122
##@@@L0122_:    pxNewListItem->pxPrevious = pxIndex->pxPrevious;   
80002248:	a5 98       	LD.W      R4, [R5 + #2]
8000224a:	8c a0       	ST.W      [R1 + #2], R4
##@@@P_:list.c:127
##@@@L0123_:
##@@@L0124_:    /* Only used during decision coverage testing. */   
##@@@L0125_:    mtCOVERAGE_TEST_DELAY();   
##@@@L0126_:
##@@@L0127_:    pxIndex->pxPrevious->pxNext = pxNewListItem;   
8000224c:	a5 98       	LD.W      R4, [R5 + #2]
8000224e:	61 a0       	ST.W      [R4 + #1], R1
##@@@P_:list.c:128
##@@@L0128_:    pxIndex->pxPrevious = pxNewListItem;   
80002250:	a9 a0       	ST.W      [R5 + #2], R1
##@@@P_:list.c:131
##@@@L0129_:
##@@@L0130_:    /* Remember which list the item is in. */   
##@@@L0131_:    pxNewListItem->pxContainer = pxList;   
80002252:	08 a1       	ST.W      [R1 + #4], R0
##@@@P_:list.c:133
##@@@L0132_:
##@@@L0133_:    ( pxList->uxNumberOfItems )++;   
80002254:	50 82       	LD.W      R5, [R0]
80002256:	6d c0       	ADD       R5, R5, #1
80002258:	05 85       	ST.W      [R0], R5
##@@@P_:list.c:136
##@@@L0134_:
##@@@L0135_:    traceRETURN_vListInsertEnd();   
##@@@L0136_:}   
8000225a:	1d 5c       	JMP       LR

8000225c <vListInsert>:
##@@@F_:vListInsert():
##@@@P_:list.c:143
##@@@L0138_:
##@@@L0139_:void vListInsert( List_t * const pxList,   
##@@@L0140_:                  ListItem_t * const pxNewListItem )   
##@@@L0141_:{   
##@@@L0142_:    ListItem_t * pxIterator;   
##@@@L0143_:    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;   
8000225c:	31 82       	LD.W      R3, [R1]
##@@@P_:list.c:161
##@@@L0156_:     * new list item should be placed after it.  This ensures that TCBs which are   
##@@@L0157_:     * stored in ready lists (all of which have the same xItemValue value) get a   
##@@@L0158_:     * share of the CPU.  However, if the xItemValue is the same as the back marker   
##@@@L0159_:     * the iteration loop below will not end.  Therefore the value is checked   
##@@@L0160_:     * first, and the algorithm slightly modified if necessary. */   
##@@@L0161_:    if( xValueOfInsertion == portMAX_DELAY )   
8000225e:	0c 45       	LD        R5, [PC + #12]        ;->0x8000228c  :=0xffffffff
80002260:	35 70       	CMP       R3, R5
80002262:	09 f0       	JZ        $+9                   ;->0x80002274
##@@@P_:list.c:192
##@@@L0187_:        *   5) If the FreeRTOS port supports interrupt nesting then ensure that   
##@@@L0188_:        *      the priority of the tick interrupt is at or below   
##@@@L0189_:        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.   
##@@@L0190_:        **********************************************************************/   
##@@@L0191_:
##@@@L0192_:        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )   
80002264:	a0 58       	MOV       R5, R0
80002266:	58 28       	ADD       R5, #8			;->0x08
80002268:	85 58       	MOV       R4, R5
8000226a:	6d 98       	LD.W      R5, [R5 + #1]
8000226c:	25 82       	LD.W      R2, [R5]
8000226e:	23 70       	CMP       R2, R3
80002270:	fc f9       	JLS       $-4                   ;->0x80002268
80002272:	03 04       	SJMP      $+3                   ;->0x80002278
##@@@P_:list.c:163
##@@@L0158_:     * share of the CPU.  However, if the xItemValue is the same as the back marker   
##@@@L0159_:     * the iteration loop below will not end.  Therefore the value is checked   
##@@@L0160_:     * first, and the algorithm slightly modified if necessary. */   
##@@@L0161_:    if( xValueOfInsertion == portMAX_DELAY )   
##@@@L0162_:    {   
##@@@L0163_:        pxIterator = pxList->xListEnd.pxPrevious;   
80002274:	20 99       	LD.W      R4, [R0 + #4]
##@@@P_:list.c:199
##@@@L0194_:            /* There is nothing to do here, just iterating to the wanted   
##@@@L0195_:             * insertion position. */   
##@@@L0196_:        }   
##@@@L0197_:    }   
##@@@L0198_:
##@@@L0199_:    pxNewListItem->pxNext = pxIterator->pxNext;   
80002276:	6c 98       	LD.W      R5, [R4 + #1]
80002278:	4d a0       	ST.W      [R1 + #1], R5
##@@@P_:list.c:200
##@@@L0200_:    pxNewListItem->pxNext->pxPrevious = pxNewListItem;   
8000227a:	a9 a0       	ST.W      [R5 + #2], R1
##@@@P_:list.c:201
##@@@L0201_:    pxNewListItem->pxPrevious = pxIterator;   
8000227c:	8c a0       	ST.W      [R1 + #2], R4
##@@@P_:list.c:202
##@@@L0202_:    pxIterator->pxNext = pxNewListItem;   
8000227e:	61 a0       	ST.W      [R4 + #1], R1
##@@@P_:list.c:206
##@@@L0203_:
##@@@L0204_:    /* Remember which list the item is in.  This allows fast removal of the   
##@@@L0205_:     * item later. */   
##@@@L0206_:    pxNewListItem->pxContainer = pxList;   
80002280:	08 a1       	ST.W      [R1 + #4], R0
##@@@P_:list.c:208
##@@@L0207_:
##@@@L0208_:    ( pxList->uxNumberOfItems )++;   
80002282:	50 82       	LD.W      R5, [R0]
80002284:	6d c0       	ADD       R5, R5, #1
80002286:	05 85       	ST.W      [R0], R5
##@@@P_:list.c:211
##@@@L0209_:
##@@@L0210_:    traceRETURN_vListInsert();   
##@@@L0211_:}   
80002288:	1d 5c       	JMP       LR
8000228a:	00 00       	NOP      NOP      
8000228c:	ff ff ff ff 	.long     0xffffffff ->-00000001 

80002290 <uxListRemove>:
##@@@F_:uxListRemove():
##@@@P_:list.c:224
##@@@L0219_:
##@@@L0220_:    traceENTER_uxListRemove( pxItemToRemove );   
##@@@L0221_:
##@@@L0222_:
##@@@L0223_:
##@@@L0224_:    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;   
80002290:	58 98       	LD.W      R3, [R0 + #1]
80002292:	a0 98       	LD.W      R4, [R0 + #2]
##@@@P_:list.c:218
##@@@L0213_:
##@@@L0214_:UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )   
##@@@L0215_:{   
##@@@L0216_:    /* The list item knows which list it is in.  Obtain the list from the list   
##@@@L0217_:     * item. */   
##@@@L0218_:    List_t * const pxList = pxItemToRemove->pxContainer;   
80002294:	28 99       	LD.W      R5, [R0 + #4]
##@@@P_:list.c:224
##@@@L0219_:
##@@@L0220_:    traceENTER_uxListRemove( pxItemToRemove );   
##@@@L0221_:
##@@@L0222_:
##@@@L0223_:
##@@@L0224_:    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;   
80002296:	9c a0       	ST.W      [R3 + #2], R4
##@@@P_:list.c:225
##@@@L0225_:    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;   
80002298:	a0 98       	LD.W      R4, [R0 + #2]
8000229a:	63 a0       	ST.W      [R4 + #1], R3
##@@@P_:list.c:231
##@@@L0226_:
##@@@L0227_:    /* Only used during decision coverage testing. */   
##@@@L0228_:    mtCOVERAGE_TEST_DELAY();   
##@@@L0229_:
##@@@L0230_:    /* Make sure the index is left pointing to a valid item. */   
##@@@L0231_:    if( pxList->pxIndex == pxItemToRemove )   
8000229c:	5d 98       	LD.W      R3, [R5 + #1]
8000229e:	30 70       	CMP       R3, R0
800022a0:	02 f1       	JNZ       $+2                   ;->0x800022a4
##@@@P_:list.c:233
##@@@L0232_:    {   
##@@@L0233_:        pxList->pxIndex = pxItemToRemove->pxPrevious;   
800022a2:	6c a0       	ST.W      [R5 + #1], R4
800022a4:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:list.c:240
##@@@L0235_:    else   
##@@@L0236_:    {   
##@@@L0237_:        mtCOVERAGE_TEST_MARKER();   
##@@@L0238_:    }   
##@@@L0239_:
##@@@L0240_:    pxItemToRemove->pxContainer = NULL;   
800022a6:	04 a1       	ST.W      [R0 + #4], R4
##@@@P_:list.c:241
##@@@L0241_:    ( pxList->uxNumberOfItems )--;   
800022a8:	45 82       	LD.W      R4, [R5]
800022aa:	64 cc       	SUB       R4, R4, #1
800022ac:	54 85       	ST.W      [R5], R4
##@@@P_:list.c:245
##@@@L0242_:
##@@@L0243_:    traceRETURN_uxListRemove( pxList->uxNumberOfItems );   
##@@@L0244_:
##@@@L0245_:    return pxList->uxNumberOfItems;   
800022ae:	05 82       	LD.W      R0, [R5]
800022b0:	1d 5c       	JMP       LR
	...

800022b4 <xQueueGenericReset>:
##@@@F_:xQueueGenericReset():
##@@@P_:queue.c:305
##@@@L0300_:    } while( 0 )   
##@@@L0301_:/*-----------------------------------------------------------*/   
##@@@L0302_:
##@@@L0303_:BaseType_t xQueueGenericReset( QueueHandle_t xQueue,   
##@@@L0304_:                               BaseType_t xNewQueue )   
##@@@L0305_:{   
800022b4:	87 5f       	PUSH      {R6-R8,LR}
800022b6:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:311
##@@@L0306_:    BaseType_t xReturn = pdPASS;   
##@@@L0307_:    Queue_t * const pxQueue = xQueue;   
##@@@L0308_:
##@@@L0309_:    traceENTER_xQueueGenericReset( xQueue, xNewQueue );   
##@@@L0310_:
##@@@L0311_:    configASSERT( pxQueue );   
800022b8:	00 38       	CMP       R0, #0			;->0x00
800022ba:	70 f0       	JZ        $+112                 ;->0x8000239a
800022bc:	c0 58       	MOV       R6, R0
##@@@P_:queue.c:314
##@@@L0312_:
##@@@L0313_:    if( ( pxQueue != NULL ) &&   
##@@@L0314_:        ( pxQueue->uxLength >= 1U ) &&   
800022be:	c0 9b       	LD.W      R0, [R0 + #15]
800022c0:	00 38       	CMP       R0, #0			;->0x00
800022c2:	49 f0       	JZ        $+73                  ;->0x80002354
800022c4:	e1 58       	MOV       R7, R1
##@@@P_:queue.c:316
##@@@L0315_:        /* Check for multiplication overflow. */   
##@@@L0316_:        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )   
800022c6:	16 9c       	LD.W      R2, [R6 + #16]
800022c8:	80 10       	MOV       R8, #0			;->0x0000
800022ca:	28 58       	MOV       R1, R8
800022cc:	68 58       	MOV       R3, R8
800022ce:	19 45       	LD        R5, [PC + #25]        ;->0x80002330  :=0x8000d990
800022d0:	05 5c       	LJMP      R5
800022d2:	51 10       	MOV       R5, #1			;->0x0001
800022d4:	85 58       	MOV       R4, R5
800022d6:	10 38       	CMP       R1, #0			;->0x00
800022d8:	02 f1       	JNZ       $+2                   ;->0x800022dc
800022da:	88 58       	MOV       R4, R8
##@@@P_:queue.c:313
##@@@L0308_:
##@@@L0309_:    traceENTER_xQueueGenericReset( xQueue, xNewQueue );   
##@@@L0310_:
##@@@L0311_:    configASSERT( pxQueue );   
##@@@L0312_:
##@@@L0313_:    if( ( pxQueue != NULL ) &&   
800022dc:	45 69       	ANL       R4, R5
800022de:	40 38       	CMP       R4, #0			;->0x00
800022e0:	3a f1       	JNZ       $+58                  ;->0x80002354
##@@@P_:queue.c:318
##@@@L0314_:        ( pxQueue->uxLength >= 1U ) &&   
##@@@L0315_:        /* Check for multiplication overflow. */   
##@@@L0316_:        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )   
##@@@L0317_:    {   
##@@@L0318_:        taskENTER_CRITICAL();   
800022e2:	15 45       	LD        R5, [PC + #21]        ;->0x80002334  :=0x800056cc
800022e4:	05 5c       	LJMP      R5
800022e6:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:queue.c:321
##@@@L0319_:        {   
##@@@L0320_:            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );   
##@@@L0321_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;   
800022e8:	b5 a3       	ST.W      [R6 + #14], R5
##@@@P_:queue.c:320
##@@@L0315_:        /* Check for multiplication overflow. */   
##@@@L0316_:        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )   
##@@@L0317_:    {   
##@@@L0318_:        taskENTER_CRITICAL();   
##@@@L0319_:        {   
##@@@L0320_:            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );   
800022ea:	56 82       	LD.W      R5, [R6]
800022ec:	e6 9b       	LD.W      R4, [R6 + #15]
800022ee:	1e 9c       	LD.W      R3, [R6 + #16]
##@@@P_:queue.c:323
##@@@L0321_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;   
##@@@L0322_:            pxQueue->pcWriteTo = pxQueue->pcHead;   
##@@@L0323_:            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );   
800022f0:	54 cc       	SUB       R2, R4, #1
800022f2:	25 58       	MOV       R1, R5
800022f4:	19 00 43 04 	MADD32    R1, R2, R3
##@@@P_:queue.c:322
##@@@L0317_:    {   
##@@@L0318_:        taskENTER_CRITICAL();   
##@@@L0319_:        {   
##@@@L0320_:            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );   
##@@@L0321_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;   
##@@@L0322_:            pxQueue->pcWriteTo = pxQueue->pcHead;   
800022f8:	75 a0       	ST.W      [R6 + #1], R5
800022fa:	19 00 64 14 	MADD32    R5, R3, R4
##@@@P_:queue.c:320
##@@@L0315_:        /* Check for multiplication overflow. */   
##@@@L0316_:        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )   
##@@@L0317_:    {   
##@@@L0318_:        taskENTER_CRITICAL();   
##@@@L0319_:        {   
##@@@L0320_:            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );   
800022fe:	b5 a0       	ST.W      [R6 + #2], R5
80002300:	5f 1f       	MOV       R5, #255			;->0x00FF
80002302:	79 00 c5 10 	ST.B      [R6 + #68], R5			;->0x44
##@@@P_:queue.c:324
##@@@L0321_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;   
##@@@L0322_:            pxQueue->pcWriteTo = pxQueue->pcHead;   
##@@@L0323_:            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );   
##@@@L0324_:            pxQueue->cRxLock = queueUNLOCKED;   
80002306:	79 00 c5 14 	ST.B      [R6 + #69], R5			;->0x45
##@@@P_:queue.c:325
##@@@L0325_:            pxQueue->cTxLock = queueUNLOCKED;   
8000230a:	06 58       	MOV       R0, R6
8000230c:	00 29       	ADD       R0, #16			;->0x10
##@@@P_:queue.c:327
##@@@L0326_:
##@@@L0327_:            if( xNewQueue == pdFALSE )   
8000230e:	70 38       	CMP       R7, #0			;->0x00
##@@@P_:queue.c:323
##@@@L0318_:        taskENTER_CRITICAL();   
##@@@L0319_:        {   
##@@@L0320_:            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );   
##@@@L0321_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;   
##@@@L0322_:            pxQueue->pcWriteTo = pxQueue->pcHead;   
##@@@L0323_:            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );   
80002310:	f1 a0       	ST.W      [R6 + #3], R1
##@@@P_:queue.c:327
##@@@L0324_:            pxQueue->cRxLock = queueUNLOCKED;   
##@@@L0325_:            pxQueue->cTxLock = queueUNLOCKED;   
##@@@L0326_:
##@@@L0327_:            if( xNewQueue == pdFALSE )   
80002312:	17 f0       	JZ        $+23                  ;->0x80002340
##@@@P_:queue.c:353
##@@@L0348_:                }   
##@@@L0349_:            }   
##@@@L0350_:            else   
##@@@L0351_:            {   
##@@@L0352_:                /* Ensure the event queues start in the correct state. */   
##@@@L0353_:                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );   
80002314:	09 45       	LD        R5, [PC + #9]         ;->0x80002338  :=0x80002224
80002316:	05 5c       	LJMP      R5
##@@@P_:queue.c:354
##@@@L0354_:                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );   
80002318:	64 2a       	ADD       R6, #36			;->0x24
8000231a:	06 58       	MOV       R0, R6
8000231c:	07 45       	LD        R5, [PC + #7]         ;->0x80002338  :=0x80002224
8000231e:	05 5c       	LJMP      R5
##@@@P_:queue.c:357
##@@@L0355_:            }   
##@@@L0356_:        }   
##@@@L0357_:        taskEXIT_CRITICAL();   
80002320:	07 45       	LD        R5, [PC + #7]         ;->0x8000233c  :=0x80005730
80002322:	05 5c       	LJMP      R5
80002324:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:queue.c:370
##@@@L0365_:
##@@@L0366_:    /* A value is returned for calling semantic consistency with previous   
##@@@L0367_:     * versions. */   
##@@@L0368_:    traceRETURN_xQueueGenericReset( xReturn );   
##@@@L0369_:
##@@@L0370_:    return xReturn;   
80002326:	e4 28       	ADD       SP, #4			;->0x04
80002328:	07 5e       	POP       {R6-R8}
8000232a:	0d 5d       	POP       LR
8000232c:	1d 5c       	JMP       LR
8000232e:	00 00       	NOP      NOP      
80002330:	90 d9 00 80 	.long     0x8000d990 ->-2147427952  [!!!@2@:XRL       R2, R0, R6	@@: LD.B      R0, [R0]
80002334:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80002334
80002338:	24 22 00 80 	.long     0x80002224 ->-2147474908  [!!!@2@:ST.W      [SP + #36], R2	@@: LD.B      R0, [R0]
8000233c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x8000233c
##@@@P_:queue.c:334
##@@@L0329_:                /* If there are tasks blocked waiting to read from the queue, then   
##@@@L0330_:                 * the tasks will remain blocked as after this function exits the queue   
##@@@L0331_:                 * will still be empty.  If there are tasks blocked waiting to write to   
##@@@L0332_:                 * the queue, then one should be unblocked as after this function exits   
##@@@L0333_:                 * it will be possible to write to it. */   
##@@@L0334_:                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )   
80002340:	50 82       	LD.W      R5, [R0]
80002342:	50 38       	CMP       R5, #0			;->0x00
80002344:	ee f0       	JZ        $-18                  ;->0x80002320
##@@@P_:queue.c:336
##@@@L0335_:                {   
##@@@L0336_:                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )   
80002346:	27 45       	LD        R5, [PC + #39]        ;->0x800023e0  :=0x80006ffc
80002348:	05 5c       	LJMP      R5
8000234a:	00 38       	CMP       R0, #0			;->0x00
8000234c:	ea f0       	JZ        $-22                  ;->0x80002320
##@@@P_:queue.c:338
##@@@L0337_:                    {   
##@@@L0338_:                        queueYIELD_IF_USING_PREEMPTION();   
8000234e:	26 45       	LD        R5, [PC + #38]        ;->0x800023e4  :=0x80008f64
80002350:	05 5c       	LJMP      R5
80002352:	e7 07       	SJMP      $-25                  ;->0x80002320
##@@@P_:queue.c:364
##@@@L0359_:    else   
##@@@L0360_:    {   
##@@@L0361_:        xReturn = pdFAIL;   
##@@@L0362_:    }   
##@@@L0363_:
##@@@L0364_:    configASSERT( xReturn != pdFAIL );   
80002354:	20 5d       	PUSH      R0
80002356:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000235a:	08 00       	SYNC     SYNC     
8000235c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002360:	08 00       	SYNC     SYNC     
80002362:	00 5d       	POP       R0
80002364:	20 5d       	PUSH      R0
80002366:	21 5d       	PUSH      R1
80002368:	20 45       	LD        R5, [PC + #32]        ;->0x800023e8  :=0x1ff
8000236a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000236e:	25 58       	MOV       R1, R5
80002370:	11 68       	NOT       R1, R1
80002372:	01 69       	ANL       R0, R1
80002374:	5f 11       	MOV       R5, #31			;->0x001F
80002376:	25 58       	MOV       R1, R5
80002378:	01 6a       	ORL       R0, R1
8000237a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000237e:	08 00       	SYNC     SYNC     
80002380:	01 5d       	POP       R1
80002382:	00 5d       	POP       R0
80002384:	20 5d       	PUSH      R0
80002386:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000238a:	08 00       	SYNC     SYNC     
8000238c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002390:	08 00       	SYNC     SYNC     
80002392:	00 5d       	POP       R0
80002394:	07 00       	BREAK    BREAK    
80002396:	16 45       	LD        R5, [PC + #22]        ;->0x800023ec  :=0x8000911c
80002398:	05 5c       	LJMP      R5
##@@@P_:queue.c:311
##@@@L0306_:    BaseType_t xReturn = pdPASS;   
##@@@L0307_:    Queue_t * const pxQueue = xQueue;   
##@@@L0308_:
##@@@L0309_:    traceENTER_xQueueGenericReset( xQueue, xNewQueue );   
##@@@L0310_:
##@@@L0311_:    configASSERT( pxQueue );   
8000239a:	20 5d       	PUSH      R0
8000239c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800023a0:	08 00       	SYNC     SYNC     
800023a2:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800023a6:	08 00       	SYNC     SYNC     
800023a8:	00 5d       	POP       R0
800023aa:	20 5d       	PUSH      R0
800023ac:	21 5d       	PUSH      R1
800023ae:	0f 45       	LD        R5, [PC + #15]        ;->0x800023e8  :=0x1ff
800023b0:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800023b4:	25 58       	MOV       R1, R5
800023b6:	11 68       	NOT       R1, R1
800023b8:	01 69       	ANL       R0, R1
800023ba:	5f 11       	MOV       R5, #31			;->0x001F
800023bc:	25 58       	MOV       R1, R5
800023be:	01 6a       	ORL       R0, R1
800023c0:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800023c4:	08 00       	SYNC     SYNC     
800023c6:	01 5d       	POP       R1
800023c8:	00 5d       	POP       R0
800023ca:	20 5d       	PUSH      R0
800023cc:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800023d0:	08 00       	SYNC     SYNC     
800023d2:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800023d6:	08 00       	SYNC     SYNC     
800023d8:	00 5d       	POP       R0
800023da:	07 00       	BREAK    BREAK    
800023dc:	04 45       	LD        R5, [PC + #4]         ;->0x800023ec  :=0x8000911c
800023de:	05 5c       	LJMP      R5
800023e0:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
800023e4:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
800023e8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800023ec:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800023f0 <xQueueGenericCreateStatic>:
##@@@F_:xQueueGenericCreateStatic():
##@@@P_:queue.c:381
##@@@L0376_:    QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,   
##@@@L0377_:                                             const UBaseType_t uxItemSize,   
##@@@L0378_:                                             uint8_t * pucQueueStorage,   
##@@@L0379_:                                             StaticQueue_t * pxStaticQueue,   
##@@@L0380_:                                             const uint8_t ucQueueType )   
##@@@L0381_:    {   
800023f0:	83 5f       	PUSH      {R6-R7,LR}
800023f2:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:queue.c:388
##@@@L0383_:
##@@@L0384_:        traceENTER_xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );   
##@@@L0385_:
##@@@L0386_:        /* The StaticQueue_t structure and the queue storage area must be   
##@@@L0387_:         * supplied. */   
##@@@L0388_:        configASSERT( pxStaticQueue );   
800023f4:	30 38       	CMP       R3, #0			;->0x00
800023f6:	4e f0       	JZ        $+78                  ;->0x80002492
##@@@P_:queue.c:390
##@@@L0389_:
##@@@L0390_:        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&   
800023f8:	00 38       	CMP       R0, #0			;->0x00
800023fa:	29 f0       	JZ        $+41                  ;->0x8000244c
800023fc:	c3 58       	MOV       R6, R3
800023fe:	e4 58       	MOV       R7, R4
##@@@P_:queue.c:395
##@@@L0391_:            ( pxStaticQueue != NULL ) &&   
##@@@L0392_:
##@@@L0393_:            /* A queue storage area should be provided if the item size is not 0, and   
##@@@L0394_:             * should not be provided if the item size is 0. */   
##@@@L0395_:            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0U ) ) ) &&   
80002400:	10 38       	CMP       R1, #0			;->0x00
80002402:	03 f1       	JNZ       $+3                   ;->0x80002408
80002404:	20 38       	CMP       R2, #0			;->0x00
80002406:	23 f1       	JNZ       $+35                  ;->0x8000244c
##@@@P_:queue.c:396
##@@@L0396_:            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0U ) ) ) )   
80002408:	10 38       	CMP       R1, #0			;->0x00
8000240a:	03 f0       	JZ        $+3                   ;->0x80002410
8000240c:	20 38       	CMP       R2, #0			;->0x00
8000240e:	1f f0       	JZ        $+31                  ;->0x8000244c
80002410:	50 15       	MOV       R5, #80			;->0x0050
##@@@P_:queue.c:403
##@@@L0398_:            #if ( configASSERT_DEFINED == 1 )   
##@@@L0399_:            {   
##@@@L0400_:                /* Sanity check that the size of the structure used to declare a   
##@@@L0401_:                 * variable of type StaticQueue_t or StaticSemaphore_t equals the size of   
##@@@L0402_:                 * the real queue and semaphore structures. */   
##@@@L0403_:                volatile size_t xSize = sizeof( StaticQueue_t );   
80002412:	01 25       	ST.W      [SP + #1], R5
##@@@P_:queue.c:406
##@@@L0404_:
##@@@L0405_:                /* This assertion cannot be branch covered in unit tests */   
##@@@L0406_:                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */   
80002414:	01 0d       	LD.W      R5, [SP + #1]
80002416:	50 3d       	CMP       R5, #80			;->0x50
80002418:	60 f1       	JNZ       $+96                  ;->0x800024d8
##@@@P_:queue.c:407
##@@@L0407_:                ( void ) xSize;                             /* Prevent unused variable warning when configASSERT() is not defined. */   
8000241a:	01 0d       	LD.W      R5, [SP + #1]
8000241c:	51 10       	MOV       R5, #1			;->0x0001
##@@@F_:prvInitialiseNewQueue():
##@@@P_:queue.c:576
##@@@L0571_:{   
##@@@L0572_:    /* Remove compiler warnings about unused parameters should   
##@@@L0573_:     * configUSE_TRACE_FACILITY not be set to 1. */   
##@@@L0574_:    ( void ) ucQueueType;   
##@@@L0575_:
##@@@L0576_:    if( uxItemSize == ( UBaseType_t ) 0 )   
8000241e:	10 38       	CMP       R1, #0			;->0x00
##@@@F_:xQueueGenericCreateStatic():
80002420:	79 00 c5 18 	ST.B      [R6 + #70], R5			;->0x46
##@@@F_:prvInitialiseNewQueue():
80002424:	03 f0       	JZ        $+3                   ;->0x8000242a
##@@@P_:queue.c:587
##@@@L0582_:        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;   
##@@@L0583_:    }   
##@@@L0584_:    else   
##@@@L0585_:    {   
##@@@L0586_:        /* Set the head to the start of the queue storage area. */   
##@@@L0587_:        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;   
80002426:	62 85       	ST.W      [R6], R2
80002428:	02 04       	SJMP      $+2                   ;->0x8000242c
##@@@P_:queue.c:582
##@@@L0577_:    {   
##@@@L0578_:        /* No RAM was allocated for the queue storage area, but PC head cannot   
##@@@L0579_:         * be set to NULL because NULL is used as a key to say the queue is used as   
##@@@L0580_:         * a mutex.  Therefore just set pcHead to point to the queue as a benign   
##@@@L0581_:         * value that is known to be within the memory map. */   
##@@@L0582_:        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;   
8000242a:	66 85       	ST.W      [R6], R6
##@@@P_:queue.c:593
##@@@L0588_:    }   
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
8000242c:	31 a4       	ST.W      [R6 + #16], R1
##@@@P_:queue.c:592
##@@@L0587_:        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;   
##@@@L0588_:    }   
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
8000242e:	f0 a3       	ST.W      [R6 + #15], R0
80002430:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:queue.c:594
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
##@@@L0594_:    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );   
80002432:	06 58       	MOV       R0, R6
80002434:	05 45       	LD        R5, [PC + #5]         ;->0x80002448  :=0x800022b4
80002436:	05 5c       	LJMP      R5
80002438:	79 00 c7 30 	ST.B      [R6 + #76], R7			;->0x4C
##@@@F_:xQueueGenericCreateStatic():
##@@@P_:queue.c:438
##@@@L0433_:            mtCOVERAGE_TEST_MARKER();   
##@@@L0434_:        }   
##@@@L0435_:
##@@@L0436_:        traceRETURN_xQueueGenericCreateStatic( pxNewQueue );   
##@@@L0437_:
##@@@L0438_:        return pxNewQueue;   
8000243c:	06 58       	MOV       R0, R6
8000243e:	e8 28       	ADD       SP, #8			;->0x08
80002440:	03 5e       	POP       {R6-R7}
80002442:	0d 5d       	POP       LR
80002444:	1d 5c       	JMP       LR
80002446:	00 00       	NOP      NOP      
80002448:	b4 22 00 80 	.long     0x800022b4 ->-2147474764  [!!!@2@:ST.W      [SP + #180], R2	@@: LD.B      R0, [R0]
##@@@P_:queue.c:432
##@@@L0427_:
##@@@L0428_:            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );   
##@@@L0429_:        }   
##@@@L0430_:        else   
##@@@L0431_:        {   
##@@@L0432_:            configASSERT( pxNewQueue );   
8000244c:	20 5d       	PUSH      R0
8000244e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002452:	08 00       	SYNC     SYNC     
80002454:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002458:	08 00       	SYNC     SYNC     
8000245a:	00 5d       	POP       R0
8000245c:	20 5d       	PUSH      R0
8000245e:	21 5d       	PUSH      R1
80002460:	30 45       	LD        R5, [PC + #48]        ;->0x80002520  :=0x1ff
80002462:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002466:	25 58       	MOV       R1, R5
80002468:	11 68       	NOT       R1, R1
8000246a:	01 69       	ANL       R0, R1
8000246c:	5f 11       	MOV       R5, #31			;->0x001F
8000246e:	25 58       	MOV       R1, R5
80002470:	01 6a       	ORL       R0, R1
80002472:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002476:	08 00       	SYNC     SYNC     
80002478:	01 5d       	POP       R1
8000247a:	00 5d       	POP       R0
8000247c:	20 5d       	PUSH      R0
8000247e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002482:	08 00       	SYNC     SYNC     
80002484:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002488:	08 00       	SYNC     SYNC     
8000248a:	00 5d       	POP       R0
8000248c:	07 00       	BREAK    BREAK    
8000248e:	26 45       	LD        R5, [PC + #38]        ;->0x80002524  :=0x8000911c
80002490:	05 5c       	LJMP      R5
##@@@P_:queue.c:388
##@@@L0383_:
##@@@L0384_:        traceENTER_xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );   
##@@@L0385_:
##@@@L0386_:        /* The StaticQueue_t structure and the queue storage area must be   
##@@@L0387_:         * supplied. */   
##@@@L0388_:        configASSERT( pxStaticQueue );   
80002492:	20 5d       	PUSH      R0
80002494:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002498:	08 00       	SYNC     SYNC     
8000249a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000249e:	08 00       	SYNC     SYNC     
800024a0:	00 5d       	POP       R0
800024a2:	20 5d       	PUSH      R0
800024a4:	21 5d       	PUSH      R1
800024a6:	1f 45       	LD        R5, [PC + #31]        ;->0x80002520  :=0x1ff
800024a8:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800024ac:	25 58       	MOV       R1, R5
800024ae:	11 68       	NOT       R1, R1
800024b0:	01 69       	ANL       R0, R1
800024b2:	5f 11       	MOV       R5, #31			;->0x001F
800024b4:	25 58       	MOV       R1, R5
800024b6:	01 6a       	ORL       R0, R1
800024b8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800024bc:	08 00       	SYNC     SYNC     
800024be:	01 5d       	POP       R1
800024c0:	00 5d       	POP       R0
800024c2:	20 5d       	PUSH      R0
800024c4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800024c8:	08 00       	SYNC     SYNC     
800024ca:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800024ce:	08 00       	SYNC     SYNC     
800024d0:	00 5d       	POP       R0
800024d2:	07 00       	BREAK    BREAK    
800024d4:	14 45       	LD        R5, [PC + #20]        ;->0x80002524  :=0x8000911c
800024d6:	05 5c       	LJMP      R5
##@@@P_:queue.c:406
##@@@L0401_:                 * variable of type StaticQueue_t or StaticSemaphore_t equals the size of   
##@@@L0402_:                 * the real queue and semaphore structures. */   
##@@@L0403_:                volatile size_t xSize = sizeof( StaticQueue_t );   
##@@@L0404_:
##@@@L0405_:                /* This assertion cannot be branch covered in unit tests */   
##@@@L0406_:                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */   
800024d8:	20 5d       	PUSH      R0
800024da:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800024de:	08 00       	SYNC     SYNC     
800024e0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800024e4:	08 00       	SYNC     SYNC     
800024e6:	00 5d       	POP       R0
800024e8:	20 5d       	PUSH      R0
800024ea:	21 5d       	PUSH      R1
800024ec:	0d 45       	LD        R5, [PC + #13]        ;->0x80002520  :=0x1ff
800024ee:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800024f2:	25 58       	MOV       R1, R5
800024f4:	11 68       	NOT       R1, R1
800024f6:	01 69       	ANL       R0, R1
800024f8:	5f 11       	MOV       R5, #31			;->0x001F
800024fa:	25 58       	MOV       R1, R5
800024fc:	01 6a       	ORL       R0, R1
800024fe:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002502:	08 00       	SYNC     SYNC     
80002504:	01 5d       	POP       R1
80002506:	00 5d       	POP       R0
80002508:	20 5d       	PUSH      R0
8000250a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000250e:	08 00       	SYNC     SYNC     
80002510:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002514:	08 00       	SYNC     SYNC     
80002516:	00 5d       	POP       R0
80002518:	07 00       	BREAK    BREAK    
8000251a:	03 45       	LD        R5, [PC + #3]         ;->0x80002524  :=0x8000911c
8000251c:	05 5c       	LJMP      R5
8000251e:	00 00       	NOP      NOP      
80002520:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002524:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002528 <xQueueGenericGetStaticBuffers>:
##@@@F_:xQueueGenericGetStaticBuffers():
##@@@P_:queue.c:449
##@@@L0444_:#if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L0445_:
##@@@L0446_:    BaseType_t xQueueGenericGetStaticBuffers( QueueHandle_t xQueue,   
##@@@L0447_:                                              uint8_t ** ppucQueueStorage,   
##@@@L0448_:                                              StaticQueue_t ** ppxStaticQueue )   
##@@@L0449_:    {   
80002528:	2d 5d       	PUSH      LR
8000252a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:455
##@@@L0450_:        BaseType_t xReturn;   
##@@@L0451_:        Queue_t * const pxQueue = xQueue;   
##@@@L0452_:
##@@@L0453_:        traceENTER_xQueueGenericGetStaticBuffers( xQueue, ppucQueueStorage, ppxStaticQueue );   
##@@@L0454_:
##@@@L0455_:        configASSERT( pxQueue );   
8000252c:	00 38       	CMP       R0, #0			;->0x00
8000252e:	12 f0       	JZ        $+18                  ;->0x80002552
##@@@P_:queue.c:456
##@@@L0456_:        configASSERT( ppxStaticQueue );   
80002530:	20 38       	CMP       R2, #0			;->0x00
80002532:	33 f0       	JZ        $+51                  ;->0x80002598
80002534:	51 00 05 18 	LD.B      R5, [R0 + #70]			;->0x46
##@@@P_:queue.c:461
##@@@L0457_:
##@@@L0458_:        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )   
##@@@L0459_:        {   
##@@@L0460_:            /* Check if the queue was statically allocated. */   
##@@@L0461_:            if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdTRUE )   
80002538:	51 38       	CMP       R5, #1			;->0x01
8000253a:	08 f1       	JNZ       $+8                   ;->0x8000254a
##@@@P_:queue.c:463
##@@@L0462_:            {   
##@@@L0463_:                if( ppucQueueStorage != NULL )   
8000253c:	10 38       	CMP       R1, #0			;->0x00
8000253e:	03 f0       	JZ        $+3                   ;->0x80002544
##@@@P_:queue.c:465
##@@@L0464_:                {   
##@@@L0465_:                    *ppucQueueStorage = ( uint8_t * ) pxQueue->pcHead;   
80002540:	50 82       	LD.W      R5, [R0]
80002542:	15 85       	ST.W      [R1], R5
##@@@P_:queue.c:471
##@@@L0466_:                }   
##@@@L0467_:
##@@@L0468_:                /* MISRA Ref 11.3.1 [Misaligned access] */   
##@@@L0469_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-113 */   
##@@@L0470_:                /* coverity[misra_c_2012_rule_11_3_violation] */   
##@@@L0471_:                *ppxStaticQueue = ( StaticQueue_t * ) pxQueue;   
80002544:	20 85       	ST.W      [R2], R0
80002546:	01 10       	MOV       R0, #1			;->0x0001
80002548:	02 04       	SJMP      $+2                   ;->0x8000254c
8000254a:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:queue.c:494
##@@@L0489_:        }   
##@@@L0490_:        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */   
##@@@L0491_:
##@@@L0492_:        traceRETURN_xQueueGenericGetStaticBuffers( xReturn );   
##@@@L0493_:
##@@@L0494_:        return xReturn;   
8000254c:	e4 28       	ADD       SP, #4			;->0x04
8000254e:	0d 5d       	POP       LR
80002550:	1d 5c       	JMP       LR
##@@@P_:queue.c:455
##@@@L0450_:        BaseType_t xReturn;   
##@@@L0451_:        Queue_t * const pxQueue = xQueue;   
##@@@L0452_:
##@@@L0453_:        traceENTER_xQueueGenericGetStaticBuffers( xQueue, ppucQueueStorage, ppxStaticQueue );   
##@@@L0454_:
##@@@L0455_:        configASSERT( pxQueue );   
80002552:	20 5d       	PUSH      R0
80002554:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002558:	08 00       	SYNC     SYNC     
8000255a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000255e:	08 00       	SYNC     SYNC     
80002560:	00 5d       	POP       R0
80002562:	20 5d       	PUSH      R0
80002564:	21 5d       	PUSH      R1
80002566:	1f 45       	LD        R5, [PC + #31]        ;->0x800025e0  :=0x1ff
80002568:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000256c:	25 58       	MOV       R1, R5
8000256e:	11 68       	NOT       R1, R1
80002570:	01 69       	ANL       R0, R1
80002572:	5f 11       	MOV       R5, #31			;->0x001F
80002574:	25 58       	MOV       R1, R5
80002576:	01 6a       	ORL       R0, R1
80002578:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000257c:	08 00       	SYNC     SYNC     
8000257e:	01 5d       	POP       R1
80002580:	00 5d       	POP       R0
80002582:	20 5d       	PUSH      R0
80002584:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002588:	08 00       	SYNC     SYNC     
8000258a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000258e:	08 00       	SYNC     SYNC     
80002590:	00 5d       	POP       R0
80002592:	07 00       	BREAK    BREAK    
80002594:	14 45       	LD        R5, [PC + #20]        ;->0x800025e4  :=0x8000911c
80002596:	05 5c       	LJMP      R5
##@@@P_:queue.c:456
##@@@L0456_:        configASSERT( ppxStaticQueue );   
80002598:	20 5d       	PUSH      R0
8000259a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000259e:	08 00       	SYNC     SYNC     
800025a0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800025a4:	08 00       	SYNC     SYNC     
800025a6:	00 5d       	POP       R0
800025a8:	20 5d       	PUSH      R0
800025aa:	21 5d       	PUSH      R1
800025ac:	0d 45       	LD        R5, [PC + #13]        ;->0x800025e0  :=0x1ff
800025ae:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800025b2:	25 58       	MOV       R1, R5
800025b4:	11 68       	NOT       R1, R1
800025b6:	01 69       	ANL       R0, R1
800025b8:	5f 11       	MOV       R5, #31			;->0x001F
800025ba:	25 58       	MOV       R1, R5
800025bc:	01 6a       	ORL       R0, R1
800025be:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800025c2:	08 00       	SYNC     SYNC     
800025c4:	01 5d       	POP       R1
800025c6:	00 5d       	POP       R0
800025c8:	20 5d       	PUSH      R0
800025ca:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800025ce:	08 00       	SYNC     SYNC     
800025d0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800025d4:	08 00       	SYNC     SYNC     
800025d6:	00 5d       	POP       R0
800025d8:	07 00       	BREAK    BREAK    
800025da:	03 45       	LD        R5, [PC + #3]         ;->0x800025e4  :=0x8000911c
800025dc:	05 5c       	LJMP      R5
800025de:	00 00       	NOP      NOP      
800025e0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800025e4:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800025e8 <xQueueGenericCreate>:
##@@@F_:xQueueGenericCreate():
##@@@P_:queue.c:505
##@@@L0500_:#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )   
##@@@L0501_:
##@@@L0502_:    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,   
##@@@L0503_:                                       const UBaseType_t uxItemSize,   
##@@@L0504_:                                       const uint8_t ucQueueType )   
##@@@L0505_:    {   
800025e8:	87 5f       	PUSH      {R6-R8,LR}
800025ea:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:queue.c:512
##@@@L0507_:        size_t xQueueSizeInBytes;   
##@@@L0508_:        uint8_t * pucQueueStorage;   
##@@@L0509_:
##@@@L0510_:        traceENTER_xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );   
##@@@L0511_:
##@@@L0512_:        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&   
800025ec:	00 38       	CMP       R0, #0			;->0x00
800025ee:	3f f0       	JZ        $+63                  ;->0x8000266c
800025f0:	c0 58       	MOV       R6, R0
800025f2:	02 59       	MOV       R8, R2
800025f4:	a1 58       	MOV       R5, R1
800025f6:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:queue.c:514
##@@@L0513_:            /* Check for multiplication overflow. */   
##@@@L0514_:            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&   
800025f8:	27 58       	MOV       R1, R7
800025fa:	01 25       	ST.W      [SP + #1], R5
800025fc:	45 58       	MOV       R2, R5
800025fe:	67 58       	MOV       R3, R7
80002600:	17 45       	LD        R5, [PC + #23]        ;->0x8000265c  :=0x8000d990
80002602:	05 5c       	LJMP      R5
80002604:	51 10       	MOV       R5, #1			;->0x0001
80002606:	85 58       	MOV       R4, R5
80002608:	10 38       	CMP       R1, #0			;->0x00
8000260a:	02 f1       	JNZ       $+2                   ;->0x8000260e
8000260c:	87 58       	MOV       R4, R7
8000260e:	45 69       	ANL       R4, R5
80002610:	40 38       	CMP       R4, #0			;->0x00
80002612:	01 0c       	LD.W      R4, [SP + #1]
80002614:	2c f1       	JNZ       $+44                  ;->0x8000266c
##@@@P_:queue.c:512
##@@@L0507_:        size_t xQueueSizeInBytes;   
##@@@L0508_:        uint8_t * pucQueueStorage;   
##@@@L0509_:
##@@@L0510_:        traceENTER_xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );   
##@@@L0511_:
##@@@L0512_:        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&   
80002616:	13 45       	LD        R5, [PC + #19]        ;->0x80002660  :=0xffffffaf
##@@@P_:queue.c:516
##@@@L0513_:            /* Check for multiplication overflow. */   
##@@@L0514_:            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&   
##@@@L0515_:            /* Check for addition overflow. */   
##@@@L0516_:            ( ( UBaseType_t ) ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )   
80002618:	84 cb       	MULS      R0, R4, R6
##@@@P_:queue.c:512
##@@@L0507_:        size_t xQueueSizeInBytes;   
##@@@L0508_:        uint8_t * pucQueueStorage;   
##@@@L0509_:
##@@@L0510_:        traceENTER_xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );   
##@@@L0511_:
##@@@L0512_:        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&   
8000261a:	05 70       	CMP       R0, R5
8000261c:	28 f8       	JHI       $+40                  ;->0x8000266c
##@@@P_:queue.c:526
##@@@L0521_:            xQueueSizeInBytes = ( size_t ) ( ( size_t ) uxQueueLength * ( size_t ) uxItemSize );   
##@@@L0522_:
##@@@L0523_:            /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L0524_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0525_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0526_:            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );   
8000261e:	00 2d       	ADD       R0, #80			;->0x50
80002620:	11 45       	LD        R5, [PC + #17]        ;->0x80002664  :=0x80008960
80002622:	05 5c       	LJMP      R5
80002624:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:queue.c:528
##@@@L0527_:
##@@@L0528_:            if( pxNewQueue != NULL )   
80002626:	00 38       	CMP       R0, #0			;->0x00
80002628:	14 f0       	JZ        $+20                  ;->0x80002650
8000262a:	e0 58       	MOV       R7, R0
##@@@F_:prvInitialiseNewQueue():
##@@@P_:queue.c:592
##@@@L0587_:        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;   
##@@@L0588_:    }   
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
8000262c:	c6 a3       	ST.W      [R0 + #15], R6
8000262e:	01 0b       	LD.W      R3, [SP + #1]
##@@@P_:queue.c:593
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
80002630:	03 a4       	ST.W      [R0 + #16], R3
80002632:	85 58       	MOV       R4, R5
##@@@P_:queue.c:576
##@@@L0571_:{   
##@@@L0572_:    /* Remove compiler warnings about unused parameters should   
##@@@L0573_:     * configUSE_TRACE_FACILITY not be set to 1. */   
##@@@L0574_:    ( void ) ucQueueType;   
##@@@L0575_:
##@@@L0576_:    if( uxItemSize == ( UBaseType_t ) 0 )   
80002634:	30 38       	CMP       R3, #0			;->0x00
80002636:	02 f0       	JZ        $+2                   ;->0x8000263a
##@@@F_:xQueueGenericCreate():
80002638:	40 15       	MOV       R4, #80			;->0x0050
8000263a:	79 00 e5 18 	ST.B      [R7 + #70], R5			;->0x46
##@@@F_:prvInitialiseNewQueue():
8000263e:	2f c3       	ADD       R5, R7, R4
80002640:	75 85       	ST.W      [R7], R5
80002642:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:queue.c:594
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
##@@@L0594_:    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );   
80002644:	07 58       	MOV       R0, R7
80002646:	09 45       	LD        R5, [PC + #9]         ;->0x80002668  :=0x800022b4
80002648:	05 5c       	LJMP      R5
8000264a:	79 00 e8 30 	ST.B      [R7 + #76], R8			;->0x4C
##@@@P_:queue.c:598
##@@@L0595_:
##@@@L0596_:    #if ( configUSE_TRACE_FACILITY == 1 )   
##@@@L0597_:    {   
##@@@L0598_:        pxNewQueue->ucQueueType = ucQueueType;   
8000264e:	02 04       	SJMP      $+2                   ;->0x80002652
##@@@F_:xQueueGenericCreate():
80002650:	e5 58       	MOV       R7, R5
##@@@P_:queue.c:560
##@@@L0555_:            mtCOVERAGE_TEST_MARKER();   
##@@@L0556_:        }   
##@@@L0557_:
##@@@L0558_:        traceRETURN_xQueueGenericCreate( pxNewQueue );   
##@@@L0559_:
##@@@L0560_:        return pxNewQueue;   
80002652:	07 58       	MOV       R0, R7
80002654:	e8 28       	ADD       SP, #8			;->0x08
80002656:	07 5e       	POP       {R6-R8}
80002658:	0d 5d       	POP       LR
8000265a:	1d 5c       	JMP       LR
8000265c:	90 d9 00 80 	.long     0x8000d990 ->-2147427952  [!!!@2@:XRL       R2, R0, R6	@@: LD.B      R0, [R0]
80002660:	af ff ff ff 	.long     0xffffffaf ->-00000081 
80002664:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
80002668:	b4 22 00 80 	.long     0x800022b4 ->-2147474764  [!!!@2@:ST.W      [SP + #180], R2	@@: LD.B      R0, [R0]
##@@@P_:queue.c:554
##@@@L0549_:                mtCOVERAGE_TEST_MARKER();   
##@@@L0550_:            }   
##@@@L0551_:        }   
##@@@L0552_:        else   
##@@@L0553_:        {   
##@@@L0554_:            configASSERT( pxNewQueue );   
8000266c:	20 5d       	PUSH      R0
8000266e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002672:	08 00       	SYNC     SYNC     
80002674:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002678:	08 00       	SYNC     SYNC     
8000267a:	00 5d       	POP       R0
8000267c:	20 5d       	PUSH      R0
8000267e:	21 5d       	PUSH      R1
80002680:	0d 45       	LD        R5, [PC + #13]        ;->0x800026b4  :=0x1ff
80002682:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002686:	25 58       	MOV       R1, R5
80002688:	11 68       	NOT       R1, R1
8000268a:	01 69       	ANL       R0, R1
8000268c:	5f 11       	MOV       R5, #31			;->0x001F
8000268e:	25 58       	MOV       R1, R5
80002690:	01 6a       	ORL       R0, R1
80002692:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002696:	08 00       	SYNC     SYNC     
80002698:	01 5d       	POP       R1
8000269a:	00 5d       	POP       R0
8000269c:	20 5d       	PUSH      R0
8000269e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800026a2:	08 00       	SYNC     SYNC     
800026a4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800026a8:	08 00       	SYNC     SYNC     
800026aa:	00 5d       	POP       R0
800026ac:	07 00       	BREAK    BREAK    
800026ae:	03 45       	LD        R5, [PC + #3]         ;->0x800026b8  :=0x8000911c
800026b0:	05 5c       	LJMP      R5
800026b2:	00 00       	NOP      NOP      
800026b4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800026b8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800026bc <xQueueCreateMutex>:
##@@@F_:xQueueCreateMutex():
##@@@P_:queue.c:645
##@@@L0640_:/*-----------------------------------------------------------*/   
##@@@L0641_:
##@@@L0642_:#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )   
##@@@L0643_:
##@@@L0644_:    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )   
##@@@L0645_:    {   
800026bc:	87 5f       	PUSH      {R6-R8,LR}
800026be:	e4 30       	SUB       SP, #4			;->0x04
800026c0:	00 59       	MOV       R8, R0
800026c2:	00 15       	MOV       R0, #80			;->0x0050
##@@@F_:xQueueGenericCreate():
##@@@P_:queue.c:526
##@@@L0521_:            xQueueSizeInBytes = ( size_t ) ( ( size_t ) uxQueueLength * ( size_t ) uxItemSize );   
##@@@L0522_:
##@@@L0523_:            /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L0524_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0525_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0526_:            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );   
800026c4:	10 45       	LD        R5, [PC + #16]        ;->0x80002704  :=0x80008960
800026c6:	05 5c       	LJMP      R5
800026c8:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:queue.c:528
##@@@L0527_:
##@@@L0528_:            if( pxNewQueue != NULL )   
800026ca:	00 38       	CMP       R0, #0			;->0x00
800026cc:	16 f0       	JZ        $+22                  ;->0x800026f8
##@@@F_:xQueueCreateMutex():
800026ce:	e0 58       	MOV       R7, R0
##@@@F_:prvInitialiseNewQueue():
##@@@P_:queue.c:593
##@@@L0588_:    }   
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
800026d0:	06 a4       	ST.W      [R0 + #16], R6
800026d2:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:queue.c:592
##@@@L0587_:        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;   
##@@@L0588_:    }   
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
800026d4:	c1 a3       	ST.W      [R0 + #15], R1
##@@@F_:xQueueGenericCreate():
800026d6:	79 00 06 18 	ST.B      [R0 + #70], R6			;->0x46
##@@@F_:prvInitialiseNewQueue():
##@@@P_:queue.c:540
##@@@L0535_:                #if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L0536_:                {   
##@@@L0537_:                    /* Queues can be created either statically or dynamically, so   
##@@@L0538_:                     * note this task was created dynamically in case it is later   
##@@@L0539_:                     * deleted. */   
##@@@L0540_:                    pxNewQueue->ucStaticallyAllocated = pdFALSE;   
800026da:	00 85       	ST.W      [R0], R0
##@@@P_:queue.c:594
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
##@@@L0594_:    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );   
800026dc:	0b 45       	LD        R5, [PC + #11]        ;->0x80002708  :=0x800022b4
800026de:	05 5c       	LJMP      R5
800026e0:	79 00 e8 30 	ST.B      [R7 + #76], R8			;->0x4C
##@@@F_:prvInitialiseMutex():
##@@@P_:queue.c:622
##@@@L0617_:        {   
##@@@L0618_:            /* The queue create function will set all the queue structure members   
##@@@L0619_:            * correctly for a generic queue, but this function is creating a   
##@@@L0620_:            * mutex.  Overwrite those members that need to be set differently -   
##@@@L0621_:            * in particular the information required for priority inheritance. */   
##@@@L0622_:            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;   
800026e4:	be a0       	ST.W      [R7 + #2], R6
##@@@P_:queue.c:626
##@@@L0623_:            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;   
##@@@L0624_:
##@@@L0625_:            /* In case this is a recursive mutex. */   
##@@@L0626_:            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;   
800026e6:	fe a0       	ST.W      [R7 + #3], R6
##@@@P_:queue.c:623
##@@@L0618_:            /* The queue create function will set all the queue structure members   
##@@@L0619_:            * correctly for a generic queue, but this function is creating a   
##@@@L0620_:            * mutex.  Overwrite those members that need to be set differently -   
##@@@L0621_:            * in particular the information required for priority inheritance. */   
##@@@L0622_:            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;   
##@@@L0623_:            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;   
800026e8:	76 85       	ST.W      [R7], R6
##@@@P_:queue.c:631
##@@@L0626_:            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;   
##@@@L0627_:
##@@@L0628_:            traceCREATE_MUTEX( pxNewQueue );   
##@@@L0629_:
##@@@L0630_:            /* Start with the semaphore in the expected state. */   
##@@@L0631_:            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );   
800026ea:	07 58       	MOV       R0, R7
800026ec:	26 58       	MOV       R1, R6
800026ee:	46 58       	MOV       R2, R6
800026f0:	66 58       	MOV       R3, R6
800026f2:	07 45       	LD        R5, [PC + #7]         ;->0x8000270c  :=0x800027e0
800026f4:	05 5c       	LJMP      R5
800026f6:	c7 58       	MOV       R6, R7
##@@@F_:xQueueCreateMutex():
##@@@P_:queue.c:656
##@@@L0651_:        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );   
##@@@L0652_:        prvInitialiseMutex( ( Queue_t * ) xNewQueue );   
##@@@L0653_:
##@@@L0654_:        traceRETURN_xQueueCreateMutex( xNewQueue );   
##@@@L0655_:
##@@@L0656_:        return xNewQueue;   
800026f8:	06 58       	MOV       R0, R6
800026fa:	e4 28       	ADD       SP, #4			;->0x04
800026fc:	07 5e       	POP       {R6-R8}
800026fe:	0d 5d       	POP       LR
80002700:	1d 5c       	JMP       LR
80002702:	00 00       	NOP      NOP      
80002704:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
80002708:	b4 22 00 80 	.long     0x800022b4 ->-2147474764  [!!!@2@:ST.W      [SP + #180], R2	@@: LD.B      R0, [R0]
8000270c:	e0 27 00 80 	.long     0x800027e0 ->-2147473440  [!!!@2@:ST.W      [SP + #224], R7	@@: LD.B      R0, [R0]

80002710 <xQueueCreateMutexStatic>:
##@@@F_:xQueueCreateMutexStatic():
##@@@P_:queue.c:666
##@@@L0661_:
##@@@L0662_:#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )   
##@@@L0663_:
##@@@L0664_:    QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,   
##@@@L0665_:                                           StaticQueue_t * pxStaticQueue )   
##@@@L0666_:    {   
80002710:	83 5f       	PUSH      {R6-R7,LR}
80002712:	e4 30       	SUB       SP, #4			;->0x04
80002714:	61 58       	MOV       R3, R1
80002716:	80 58       	MOV       R4, R0
80002718:	01 10       	MOV       R0, #1			;->0x0001
8000271a:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:queue.c:676
##@@@L0671_:
##@@@L0672_:        /* Prevent compiler warnings about unused parameters if   
##@@@L0673_:         * configUSE_TRACE_FACILITY does not equal 1. */   
##@@@L0674_:        ( void ) ucQueueType;   
##@@@L0675_:
##@@@L0676_:        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );   
8000271c:	26 58       	MOV       R1, R6
8000271e:	46 58       	MOV       R2, R6
80002720:	0a 45       	LD        R5, [PC + #10]        ;->0x80002748  :=0x800023f0
80002722:	05 5c       	LJMP      R5
80002724:	e0 58       	MOV       R7, R0
##@@@F_:prvInitialiseMutex():
##@@@P_:queue.c:616
##@@@L0611_:
##@@@L0612_:#if ( configUSE_MUTEXES == 1 )   
##@@@L0613_:
##@@@L0614_:    static void prvInitialiseMutex( Queue_t * pxNewQueue )   
##@@@L0615_:    {   
##@@@L0616_:        if( pxNewQueue != NULL )   
80002726:	00 38       	CMP       R0, #0			;->0x00
80002728:	0a f0       	JZ        $+10                  ;->0x8000273c
##@@@P_:queue.c:626
##@@@L0621_:            * in particular the information required for priority inheritance. */   
##@@@L0622_:            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;   
##@@@L0623_:            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;   
##@@@L0624_:
##@@@L0625_:            /* In case this is a recursive mutex. */   
##@@@L0626_:            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;   
8000272a:	fe a0       	ST.W      [R7 + #3], R6
##@@@P_:queue.c:623
##@@@L0618_:            /* The queue create function will set all the queue structure members   
##@@@L0619_:            * correctly for a generic queue, but this function is creating a   
##@@@L0620_:            * mutex.  Overwrite those members that need to be set differently -   
##@@@L0621_:            * in particular the information required for priority inheritance. */   
##@@@L0622_:            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;   
##@@@L0623_:            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;   
8000272c:	76 85       	ST.W      [R7], R6
##@@@P_:queue.c:622
##@@@L0617_:        {   
##@@@L0618_:            /* The queue create function will set all the queue structure members   
##@@@L0619_:            * correctly for a generic queue, but this function is creating a   
##@@@L0620_:            * mutex.  Overwrite those members that need to be set differently -   
##@@@L0621_:            * in particular the information required for priority inheritance. */   
##@@@L0622_:            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;   
8000272e:	be a0       	ST.W      [R7 + #2], R6
##@@@P_:queue.c:631
##@@@L0626_:            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;   
##@@@L0627_:
##@@@L0628_:            traceCREATE_MUTEX( pxNewQueue );   
##@@@L0629_:
##@@@L0630_:            /* Start with the semaphore in the expected state. */   
##@@@L0631_:            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );   
80002730:	07 58       	MOV       R0, R7
80002732:	26 58       	MOV       R1, R6
80002734:	46 58       	MOV       R2, R6
80002736:	66 58       	MOV       R3, R6
80002738:	05 45       	LD        R5, [PC + #5]         ;->0x8000274c  :=0x800027e0
8000273a:	05 5c       	LJMP      R5
##@@@F_:xQueueCreateMutexStatic():
##@@@P_:queue.c:681
##@@@L0676_:        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );   
##@@@L0677_:        prvInitialiseMutex( ( Queue_t * ) xNewQueue );   
##@@@L0678_:
##@@@L0679_:        traceRETURN_xQueueCreateMutexStatic( xNewQueue );   
##@@@L0680_:
##@@@L0681_:        return xNewQueue;   
8000273c:	07 58       	MOV       R0, R7
8000273e:	e4 28       	ADD       SP, #4			;->0x04
80002740:	03 5e       	POP       {R6-R7}
80002742:	0d 5d       	POP       LR
80002744:	1d 5c       	JMP       LR
80002746:	00 00       	NOP      NOP      
80002748:	f0 23 00 80 	.long     0x800023f0 ->-2147474448  [!!!@2@:ST.W      [SP + #240], R3	@@: LD.B      R0, [R0]
8000274c:	e0 27 00 80 	.long     0x800027e0 ->-2147473440  [!!!@2@:ST.W      [SP + #224], R7	@@: LD.B      R0, [R0]

80002750 <xQueueGiveMutexRecursive>:
##@@@F_:xQueueGiveMutexRecursive():
##@@@P_:queue.c:757
##@@@L0752_:/*-----------------------------------------------------------*/   
##@@@L0753_:
##@@@L0754_:#if ( configUSE_RECURSIVE_MUTEXES == 1 )   
##@@@L0755_:
##@@@L0756_:    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )   
##@@@L0757_:    {   
80002750:	83 5f       	PUSH      {R6-R7,LR}
80002752:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:763
##@@@L0758_:        BaseType_t xReturn;   
##@@@L0759_:        Queue_t * const pxMutex = ( Queue_t * ) xMutex;   
##@@@L0760_:
##@@@L0761_:        traceENTER_xQueueGiveMutexRecursive( xMutex );   
##@@@L0762_:
##@@@L0763_:        configASSERT( pxMutex );   
80002754:	00 38       	CMP       R0, #0			;->0x00
80002756:	1d f0       	JZ        $+29                  ;->0x80002790
80002758:	c0 58       	MOV       R6, R0
##@@@P_:queue.c:771
##@@@L0766_:         * change outside of this task.  If this task does not hold the mutex then   
##@@@L0767_:         * pxMutexHolder can never coincidentally equal the tasks handle, and as   
##@@@L0768_:         * this is the only condition we are interested in it does not matter if   
##@@@L0769_:         * pxMutexHolder is accessed simultaneously by another task.  Therefore no   
##@@@L0770_:         * mutual exclusion is required to test the pxMutexHolder variable. */   
##@@@L0771_:        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )   
8000275a:	b8 98       	LD.W      R7, [R0 + #2]
8000275c:	0b 45       	LD        R5, [PC + #11]        ;->0x80002788  :=0x80007610
8000275e:	05 5c       	LJMP      R5
80002760:	70 70       	CMP       R7, R0
80002762:	03 f0       	JZ        $+3                   ;->0x80002768
80002764:	00 10       	MOV       R0, #0			;->0x0000
80002766:	0d 04       	SJMP      $+13                  ;->0x80002780
##@@@P_:queue.c:780
##@@@L0775_:            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to   
##@@@L0776_:             * the task handle, therefore no underflow check is required.  Also,   
##@@@L0777_:             * uxRecursiveCallCount is only modified by the mutex holder, and as   
##@@@L0778_:             * there can only be one, no mutual exclusion is required to modify the   
##@@@L0779_:             * uxRecursiveCallCount member. */   
##@@@L0780_:            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;   
80002768:	ee 98       	LD.W      R5, [R6 + #3]
8000276a:	6d cc       	SUB       R5, R5, #1
##@@@P_:queue.c:783
##@@@L0781_:
##@@@L0782_:            /* Has the recursive call count unwound to 0? */   
##@@@L0783_:            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )   
8000276c:	50 38       	CMP       R5, #0			;->0x00
##@@@P_:queue.c:780
##@@@L0775_:            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to   
##@@@L0776_:             * the task handle, therefore no underflow check is required.  Also,   
##@@@L0777_:             * uxRecursiveCallCount is only modified by the mutex holder, and as   
##@@@L0778_:             * there can only be one, no mutual exclusion is required to modify the   
##@@@L0779_:             * uxRecursiveCallCount member. */   
##@@@L0780_:            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;   
8000276e:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:queue.c:783
##@@@L0781_:
##@@@L0782_:            /* Has the recursive call count unwound to 0? */   
##@@@L0783_:            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )   
80002770:	07 f1       	JNZ       $+7                   ;->0x8000277e
80002772:	10 10       	MOV       R1, #0			;->0x0000
##@@@P_:queue.c:787
##@@@L0784_:            {   
##@@@L0785_:                /* Return the mutex.  This will automatically unblock any other   
##@@@L0786_:                 * task that might be waiting to access the mutex. */   
##@@@L0787_:                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );   
80002774:	06 58       	MOV       R0, R6
80002776:	41 58       	MOV       R2, R1
80002778:	61 58       	MOV       R3, R1
8000277a:	05 45       	LD        R5, [PC + #5]         ;->0x8000278c  :=0x800027e0
8000277c:	05 5c       	LJMP      R5
8000277e:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:queue.c:807
##@@@L0802_:            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );   
##@@@L0803_:        }   
##@@@L0804_:
##@@@L0805_:        traceRETURN_xQueueGiveMutexRecursive( xReturn );   
##@@@L0806_:
##@@@L0807_:        return xReturn;   
80002780:	e4 28       	ADD       SP, #4			;->0x04
80002782:	03 5e       	POP       {R6-R7}
80002784:	0d 5d       	POP       LR
80002786:	1d 5c       	JMP       LR
80002788:	10 76 00 80 	.long     0x80007610 ->-2147453424  [!!!@2@:LD.B      R1, [R0++]	@@: LD.B      R0, [R0]
8000278c:	e0 27 00 80 	.long     0x800027e0 ->-2147473440  [!!!@2@:ST.W      [SP + #224], R7	@@: LD.B      R0, [R0]
##@@@P_:queue.c:763
##@@@L0758_:        BaseType_t xReturn;   
##@@@L0759_:        Queue_t * const pxMutex = ( Queue_t * ) xMutex;   
##@@@L0760_:
##@@@L0761_:        traceENTER_xQueueGiveMutexRecursive( xMutex );   
##@@@L0762_:
##@@@L0763_:        configASSERT( pxMutex );   
80002790:	20 5d       	PUSH      R0
80002792:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002796:	08 00       	SYNC     SYNC     
80002798:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000279c:	08 00       	SYNC     SYNC     
8000279e:	00 5d       	POP       R0
800027a0:	20 5d       	PUSH      R0
800027a2:	21 5d       	PUSH      R1
800027a4:	0d 45       	LD        R5, [PC + #13]        ;->0x800027d8  :=0x1ff
800027a6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800027aa:	25 58       	MOV       R1, R5
800027ac:	11 68       	NOT       R1, R1
800027ae:	01 69       	ANL       R0, R1
800027b0:	5f 11       	MOV       R5, #31			;->0x001F
800027b2:	25 58       	MOV       R1, R5
800027b4:	01 6a       	ORL       R0, R1
800027b6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800027ba:	08 00       	SYNC     SYNC     
800027bc:	01 5d       	POP       R1
800027be:	00 5d       	POP       R0
800027c0:	20 5d       	PUSH      R0
800027c2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800027c6:	08 00       	SYNC     SYNC     
800027c8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800027cc:	08 00       	SYNC     SYNC     
800027ce:	00 5d       	POP       R0
800027d0:	07 00       	BREAK    BREAK    
800027d2:	03 45       	LD        R5, [PC + #3]         ;->0x800027dc  :=0x8000911c
800027d4:	05 5c       	LJMP      R5
800027d6:	00 00       	NOP      NOP      
800027d8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800027dc:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800027e0 <xQueueGenericSend>:
##@@@F_:xQueueGenericSend():
##@@@P_:queue.c:943
##@@@L0938_:
##@@@L0939_:BaseType_t xQueueGenericSend( QueueHandle_t xQueue,   
##@@@L0940_:                              const void * const pvItemToQueue,   
##@@@L0941_:                              TickType_t xTicksToWait,   
##@@@L0942_:                              const BaseType_t xCopyPosition )   
##@@@L0943_:{   
800027e0:	ff 5f       	PUSH      {R6-R12,LR}
800027e2:	e8 31       	SUB       SP, #24			;->0x18
##@@@P_:queue.c:950
##@@@L0945_:    TimeOut_t xTimeOut;   
##@@@L0946_:    Queue_t * const pxQueue = xQueue;   
##@@@L0947_:
##@@@L0948_:    traceENTER_xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );   
##@@@L0949_:
##@@@L0950_:    configASSERT( pxQueue );   
800027e4:	00 38       	CMP       R0, #0			;->0x00
800027e6:	05 22       	ST.W      [SP + #5], R2
800027e8:	02 f1       	JNZ       $+2                   ;->0x800027ec
800027ea:	e1 04       	SJMP      $+225                 ;->0x800029ac
800027ec:	23 59       	MOV       R9, R3
800027ee:	01 59       	MOV       R8, R1
800027f0:	c0 58       	MOV       R6, R0
##@@@P_:queue.c:951
##@@@L0951_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
800027f2:	10 38       	CMP       R1, #0			;->0x00
800027f4:	05 f1       	JNZ       $+5                   ;->0x800027fe
800027f6:	2e 9c       	LD.W      R5, [R6 + #16]
800027f8:	50 38       	CMP       R5, #0			;->0x00
800027fa:	02 f0       	JZ        $+2                   ;->0x800027fe
800027fc:	1e 05       	SJMP      $+286                 ;->0x80002a38
##@@@P_:queue.c:952
##@@@L0952_:    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );   
800027fe:	92 38       	CMP       R9, #2			;->0x02
80002800:	05 f1       	JNZ       $+5                   ;->0x8000280a
80002802:	ee 9b       	LD.W      R5, [R6 + #15]
80002804:	51 38       	CMP       R5, #1			;->0x01
80002806:	02 f0       	JZ        $+2                   ;->0x8000280a
80002808:	f5 04       	SJMP      $+245                 ;->0x800029f2
##@@@P_:queue.c:961
##@@@L0956_:    }   
##@@@L0957_:    #endif   
##@@@L0958_:
##@@@L0959_:    for( ; ; )   
##@@@L0960_:    {   
##@@@L0961_:        taskENTER_CRITICAL();   
8000280a:	5b 45       	LD        R5, [PC + #91]        ;->0x80002974  :=0x800056cc
8000280c:	05 5c       	LJMP      R5
##@@@P_:queue.c:967
##@@@L0962_:        {   
##@@@L0963_:            /* Is there room on the queue now?  The running task must be the   
##@@@L0964_:             * highest priority task wanting to access the queue.  If the head item   
##@@@L0965_:             * in the queue is to be overwritten then it does not matter if the   
##@@@L0966_:             * queue is full. */   
##@@@L0967_:            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )   
8000280e:	ee 9b       	LD.W      R5, [R6 + #15]
80002810:	a6 9b       	LD.W      R4, [R6 + #14]
80002812:	92 38       	CMP       R9, #2			;->0x02
80002814:	02 f1       	JNZ       $+2                   ;->0x80002818
80002816:	57 04       	SJMP      $+87                  ;->0x800028c4
80002818:	45 70       	CMP       R4, R5
8000281a:	02 f2       	JC        $+2                   ;->0x8000281e
8000281c:	54 04       	SJMP      $+84                  ;->0x800028c4
8000281e:	a1 10       	MOV       R10, #1			;->0x0001
80002820:	a6 58       	MOV       R5, R6
80002822:	50 29       	ADD       R5, #16			;->0x10
80002824:	01 25       	ST.W      [SP + #1], R5
80002826:	bf 1f       	MOV       R11, #255			;->0x00FF
80002828:	c0 10       	MOV       R12, #0			;->0x0000
8000282a:	aa 58       	MOV       R5, R10
8000282c:	0d 04       	SJMP      $+13                  ;->0x80002846
##@@@P_:queue.c:1138
##@@@L1133_:                }   
##@@@L1134_:            }   
##@@@L1135_:            else   
##@@@L1136_:            {   
##@@@L1137_:                /* Try again. */   
##@@@L1138_:                prvUnlockQueue( pxQueue );   
8000282e:	06 58       	MOV       R0, R6
80002830:	52 45       	LD        R5, [PC + #82]        ;->0x80002978  :=0x80002e64
80002832:	05 5c       	LJMP      R5
##@@@P_:queue.c:1139
##@@@L1139_:                ( void ) xTaskResumeAll();   
80002834:	52 45       	LD        R5, [PC + #82]        ;->0x8000297c  :=0x80005a70
80002836:	05 5c       	LJMP      R5
##@@@P_:queue.c:961
##@@@L0956_:    }   
##@@@L0957_:    #endif   
##@@@L0958_:
##@@@L0959_:    for( ; ; )   
##@@@L0960_:    {   
##@@@L0961_:        taskENTER_CRITICAL();   
80002838:	4f 45       	LD        R5, [PC + #79]        ;->0x80002974  :=0x800056cc
8000283a:	05 5c       	LJMP      R5
##@@@P_:queue.c:967
##@@@L0962_:        {   
##@@@L0963_:            /* Is there room on the queue now?  The running task must be the   
##@@@L0964_:             * highest priority task wanting to access the queue.  If the head item   
##@@@L0965_:             * in the queue is to be overwritten then it does not matter if the   
##@@@L0966_:             * queue is full. */   
##@@@L0967_:            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )   
8000283c:	ae 9b       	LD.W      R5, [R6 + #14]
8000283e:	e6 9b       	LD.W      R4, [R6 + #15]
80002840:	54 70       	CMP       R5, R4
80002842:	ac 58       	MOV       R5, R12
80002844:	40 f3       	JNC       $+64                  ;->0x800028c4
##@@@P_:queue.c:1075
##@@@L1070_:
##@@@L1071_:                return pdPASS;   
##@@@L1072_:            }   
##@@@L1073_:            else   
##@@@L1074_:            {   
##@@@L1075_:                if( xTicksToWait == ( TickType_t ) 0 )   
80002846:	05 0c       	LD.W      R4, [SP + #5]
80002848:	40 38       	CMP       R4, #0			;->0x00
8000284a:	02 f1       	JNZ       $+2                   ;->0x8000284e
8000284c:	68 04       	SJMP      $+104                 ;->0x8000291c
##@@@P_:queue.c:1088
##@@@L1083_:                    traceQUEUE_SEND_FAILED( pxQueue );   
##@@@L1084_:                    traceRETURN_xQueueGenericSend( errQUEUE_FULL );   
##@@@L1085_:
##@@@L1086_:                    return errQUEUE_FULL;   
##@@@L1087_:                }   
##@@@L1088_:                else if( xEntryTimeSet == pdFALSE )   
8000284e:	5a 69       	ANL       R5, R10
80002850:	50 38       	CMP       R5, #0			;->0x00
80002852:	05 f0       	JZ        $+5                   ;->0x8000285c
80002854:	4b 40       	LD        R0, [PC + #75]        ;->0x80002980  :=0xc
80002856:	0e 64       	ADD       R0, SP
##@@@P_:queue.c:1092
##@@@L1089_:                {   
##@@@L1090_:                    /* The queue was full and a block time was specified so   
##@@@L1091_:                     * configure the timeout structure. */   
##@@@L1092_:                    vTaskInternalSetTimeOutState( &xTimeOut );   
80002858:	4b 45       	LD        R5, [PC + #75]        ;->0x80002984  :=0x80007304
8000285a:	05 5c       	LJMP      R5
##@@@P_:queue.c:1102
##@@@L1097_:                    /* Entry time was already set. */   
##@@@L1098_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L1099_:                }   
##@@@L1100_:            }   
##@@@L1101_:        }   
##@@@L1102_:        taskEXIT_CRITICAL();   
8000285c:	4b 45       	LD        R5, [PC + #75]        ;->0x80002988  :=0x80005730
8000285e:	05 5c       	LJMP      R5
##@@@P_:queue.c:1107
##@@@L1103_:
##@@@L1104_:        /* Interrupts and other tasks can send to and receive from the queue   
##@@@L1105_:         * now the critical section has been exited. */   
##@@@L1106_:
##@@@L1107_:        vTaskSuspendAll();   
80002860:	4b 45       	LD        R5, [PC + #75]        ;->0x8000298c  :=0x800059b0
80002862:	05 5c       	LJMP      R5
##@@@P_:queue.c:1108
##@@@L1108_:        prvLockQueue( pxQueue );   
80002864:	44 45       	LD        R5, [PC + #68]        ;->0x80002974  :=0x800056cc
80002866:	05 5c       	LJMP      R5
80002868:	51 00 c5 10 	LD.B      R5, [R6 + #68]			;->0x44
8000286c:	5b 70       	CMP       R5, R11
8000286e:	03 f1       	JNZ       $+3                   ;->0x80002874
80002870:	79 00 cc 10 	ST.B      [R6 + #68], R12			;->0x44
80002874:	51 00 c5 14 	LD.B      R5, [R6 + #69]			;->0x45
80002878:	5b 70       	CMP       R5, R11
8000287a:	03 f1       	JNZ       $+3                   ;->0x80002880
8000287c:	79 00 cc 14 	ST.B      [R6 + #69], R12			;->0x45
80002880:	42 45       	LD        R5, [PC + #66]        ;->0x80002988  :=0x80005730
80002882:	05 5c       	LJMP      R5
80002884:	3f 40       	LD        R0, [PC + #63]        ;->0x80002980  :=0xc
80002886:	0e 64       	ADD       R0, SP
80002888:	42 41       	LD        R1, [PC + #66]        ;->0x80002990  :=0x14
8000288a:	1e 64       	ADD       R1, SP
##@@@P_:queue.c:1111
##@@@L1109_:
##@@@L1110_:        /* Update the timeout state to see if it has expired yet. */   
##@@@L1111_:        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )   
8000288c:	42 45       	LD        R5, [PC + #66]        ;->0x80002994  :=0x8000731c
8000288e:	05 5c       	LJMP      R5
80002890:	00 38       	CMP       R0, #0			;->0x00
80002892:	48 f1       	JNZ       $+72                  ;->0x80002922
##@@@F_:prvIsQueueFull():
##@@@P_:queue.c:2651
##@@@L2646_:
##@@@L2647_:static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )   
##@@@L2648_:{   
##@@@L2649_:    BaseType_t xReturn;   
##@@@L2650_:
##@@@L2651_:    taskENTER_CRITICAL();   
80002894:	38 45       	LD        R5, [PC + #56]        ;->0x80002974  :=0x800056cc
80002896:	05 5c       	LJMP      R5
##@@@P_:queue.c:2653
##@@@L2652_:    {   
##@@@L2653_:        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )   
80002898:	ee 9b       	LD.W      R5, [R6 + #15]
8000289a:	02 25       	ST.W      [SP + #2], R5
8000289c:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2662
##@@@L2657_:        else   
##@@@L2658_:        {   
##@@@L2659_:            xReturn = pdFALSE;   
##@@@L2660_:        }   
##@@@L2661_:    }   
##@@@L2662_:    taskEXIT_CRITICAL();   
8000289e:	3b 45       	LD        R5, [PC + #59]        ;->0x80002988  :=0x80005730
800028a0:	05 5c       	LJMP      R5
##@@@F_:xQueueGenericSend():
##@@@P_:queue.c:1113
##@@@L1108_:        prvLockQueue( pxQueue );   
##@@@L1109_:
##@@@L1110_:        /* Update the timeout state to see if it has expired yet. */   
##@@@L1111_:        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )   
##@@@L1112_:        {   
##@@@L1113_:            if( prvIsQueueFull( pxQueue ) != pdFALSE )   
800028a2:	02 0d       	LD.W      R5, [SP + #2]
800028a4:	75 70       	CMP       R7, R5
800028a6:	c4 f1       	JNZ       $-60                  ;->0x8000282e
##@@@P_:queue.c:1116
##@@@L1114_:            {   
##@@@L1115_:                traceBLOCKING_ON_QUEUE_SEND( pxQueue );   
##@@@L1116_:                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );   
800028a8:	05 09       	LD.W      R1, [SP + #5]
800028aa:	01 08       	LD.W      R0, [SP + #1]
800028ac:	3b 45       	LD        R5, [PC + #59]        ;->0x80002998  :=0x80006e8c
800028ae:	05 5c       	LJMP      R5
##@@@P_:queue.c:1123
##@@@L1118_:                /* Unlocking the queue means queue events can effect the   
##@@@L1119_:                 * event list. It is possible that interrupts occurring now   
##@@@L1120_:                 * remove this task from the event list again - but as the   
##@@@L1121_:                 * scheduler is suspended the task will go onto the pending   
##@@@L1122_:                 * ready list instead of the actual ready list. */   
##@@@L1123_:                prvUnlockQueue( pxQueue );   
800028b0:	06 58       	MOV       R0, R6
800028b2:	32 45       	LD        R5, [PC + #50]        ;->0x80002978  :=0x80002e64
800028b4:	05 5c       	LJMP      R5
##@@@P_:queue.c:1130
##@@@L1125_:                /* Resuming the scheduler will move tasks from the pending   
##@@@L1126_:                 * ready list into the ready list - so it is feasible that this   
##@@@L1127_:                 * task is already in the ready list before it yields - in which   
##@@@L1128_:                 * case the yield will not cause a context switch unless there   
##@@@L1129_:                 * is also a higher priority task in the pending ready list. */   
##@@@L1130_:                if( xTaskResumeAll() == pdFALSE )   
800028b6:	32 45       	LD        R5, [PC + #50]        ;->0x8000297c  :=0x80005a70
800028b8:	05 5c       	LJMP      R5
800028ba:	00 38       	CMP       R0, #0			;->0x00
800028bc:	be f1       	JNZ       $-66                  ;->0x80002838
##@@@P_:queue.c:1132
##@@@L1131_:                {   
##@@@L1132_:                    taskYIELD_WITHIN_API();   
800028be:	38 45       	LD        R5, [PC + #56]        ;->0x8000299c  :=0x80008f64
800028c0:	05 5c       	LJMP      R5
800028c2:	bb 07       	SJMP      $-69                  ;->0x80002838
##@@@F_:prvCopyDataToQueue():
##@@@P_:queue.c:2387
##@@@L2382_:    BaseType_t xReturn = pdFALSE;   
##@@@L2383_:    UBaseType_t uxMessagesWaiting;   
##@@@L2384_:
##@@@L2385_:    /* This function is called from a critical section. */   
##@@@L2386_:
##@@@L2387_:    uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
800028c4:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2389
##@@@L2388_:
##@@@L2389_:    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )   
800028c6:	16 9c       	LD.W      R2, [R6 + #16]
800028c8:	20 38       	CMP       R2, #0			;->0x00
800028ca:	1e f0       	JZ        $+30                  ;->0x80002906
##@@@P_:queue.c:2406
##@@@L2401_:                mtCOVERAGE_TEST_MARKER();   
##@@@L2402_:            }   
##@@@L2403_:        }   
##@@@L2404_:        #endif /* configUSE_MUTEXES */   
##@@@L2405_:    }   
##@@@L2406_:    else if( xPosition == queueSEND_TO_BACK )   
800028cc:	90 38       	CMP       R9, #0			;->0x00
800028ce:	31 f0       	JZ        $+49                  ;->0x80002930
##@@@P_:queue.c:2422
##@@@L2417_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2418_:        }   
##@@@L2419_:    }   
##@@@L2420_:    else   
##@@@L2421_:    {   
##@@@L2422_:        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );   
800028d0:	c6 98       	LD.W      R0, [R6 + #3]
800028d2:	28 58       	MOV       R1, R8
800028d4:	33 45       	LD        R5, [PC + #51]        ;->0x800029a0  :=0x8000d9ec
800028d6:	05 5c       	LJMP      R5
##@@@P_:queue.c:2423
##@@@L2423_:        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;   
800028d8:	2e 9c       	LD.W      R5, [R6 + #16]
800028da:	e6 98       	LD.W      R4, [R6 + #3]
800028dc:	64 c7       	SUB       R4, R4, R5
800028de:	f4 a0       	ST.W      [R6 + #3], R4
##@@@P_:queue.c:2425
##@@@L2424_:
##@@@L2425_:        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead )   
800028e0:	36 82       	LD.W      R3, [R6]
800028e2:	00 10       	MOV       R0, #0			;->0x0000
800028e4:	43 70       	CMP       R4, R3
800028e6:	05 f2       	JC        $+5                   ;->0x800028f0
##@@@P_:queue.c:2427
##@@@L2426_:        {   
##@@@L2427_:            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );   
800028e8:	a6 98       	LD.W      R4, [R6 + #2]
800028ea:	68 c7       	SUB       R5, R0, R5
800028ec:	6c c3       	ADD       R5, R4, R5
800028ee:	f5 a0       	ST.W      [R6 + #3], R5
##@@@F_:xQueueGenericSend():
800028f0:	41 10       	MOV       R4, #1			;->0x0001
800028f2:	a4 58       	MOV       R5, R4
##@@@P_:queue.c:952
##@@@L0947_:
##@@@L0948_:    traceENTER_xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );   
##@@@L0949_:
##@@@L0950_:    configASSERT( pxQueue );   
##@@@L0951_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
##@@@L0952_:    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );   
800028f4:	92 38       	CMP       R9, #2			;->0x02
800028f6:	02 f0       	JZ        $+2                   ;->0x800028fa
800028f8:	a0 58       	MOV       R5, R0
800028fa:	70 38       	CMP       R7, #0			;->0x00
800028fc:	02 f1       	JNZ       $+2                   ;->0x80002900
800028fe:	80 58       	MOV       R4, R0
##@@@F_:prvCopyDataToQueue():
##@@@P_:queue.c:2434
##@@@L2429_:        else   
##@@@L2430_:        {   
##@@@L2431_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2432_:        }   
##@@@L2433_:
##@@@L2434_:        if( xPosition == queueOVERWRITE )   
80002900:	54 69       	ANL       R5, R4
80002902:	7f c7       	SUB       R7, R7, R5
80002904:	24 04       	SJMP      $+36                  ;->0x8000294c
##@@@P_:queue.c:2393
##@@@L2388_:
##@@@L2389_:    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )   
##@@@L2390_:    {   
##@@@L2391_:        #if ( configUSE_MUTEXES == 1 )   
##@@@L2392_:        {   
##@@@L2393_:            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )   
80002906:	56 82       	LD.W      R5, [R6]
80002908:	00 10       	MOV       R0, #0			;->0x0000
8000290a:	50 38       	CMP       R5, #0			;->0x00
8000290c:	20 f1       	JNZ       $+32                  ;->0x8000294c
8000290e:	02 20       	ST.W      [SP + #2], R0
##@@@P_:queue.c:2396
##@@@L2394_:            {   
##@@@L2395_:                /* The mutex is no longer being held. */   
##@@@L2396_:                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );   
80002910:	86 98       	LD.W      R0, [R6 + #2]
80002912:	25 45       	LD        R5, [PC + #37]        ;->0x800029a4  :=0x800076c4
80002914:	05 5c       	LJMP      R5
##@@@P_:queue.c:2397
##@@@L2397_:                pxQueue->u.xSemaphore.xMutexHolder = NULL;   
80002916:	02 0d       	LD.W      R5, [SP + #2]
80002918:	b5 a0       	ST.W      [R6 + #2], R5
8000291a:	19 04       	SJMP      $+25                  ;->0x8000294c
##@@@F_:xQueueGenericSend():
##@@@P_:queue.c:1079
##@@@L1074_:            {   
##@@@L1075_:                if( xTicksToWait == ( TickType_t ) 0 )   
##@@@L1076_:                {   
##@@@L1077_:                    /* The queue was full and no block time is specified (or   
##@@@L1078_:                     * the block time has expired) so leave now. */   
##@@@L1079_:                    taskEXIT_CRITICAL();   
8000291c:	1b 45       	LD        R5, [PC + #27]        ;->0x80002988  :=0x80005730
8000291e:	05 5c       	LJMP      R5
80002920:	06 04       	SJMP      $+6                   ;->0x8000292c
##@@@P_:queue.c:1145
##@@@L1140_:            }   
##@@@L1141_:        }   
##@@@L1142_:        else   
##@@@L1143_:        {   
##@@@L1144_:            /* The timeout has expired. */   
##@@@L1145_:            prvUnlockQueue( pxQueue );   
80002922:	06 58       	MOV       R0, R6
80002924:	15 45       	LD        R5, [PC + #21]        ;->0x80002978  :=0x80002e64
80002926:	05 5c       	LJMP      R5
##@@@P_:queue.c:1146
##@@@L1146_:            ( void ) xTaskResumeAll();   
80002928:	15 45       	LD        R5, [PC + #21]        ;->0x8000297c  :=0x80005a70
8000292a:	05 5c       	LJMP      R5
8000292c:	00 10       	MOV       R0, #0			;->0x0000
8000292e:	1f 04       	SJMP      $+31                  ;->0x8000296c
##@@@F_:prvCopyDataToQueue():
##@@@P_:queue.c:2408
##@@@L2403_:        }   
##@@@L2404_:        #endif /* configUSE_MUTEXES */   
##@@@L2405_:    }   
##@@@L2406_:    else if( xPosition == queueSEND_TO_BACK )   
##@@@L2407_:    {   
##@@@L2408_:        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );   
80002930:	46 98       	LD.W      R0, [R6 + #1]
80002932:	28 58       	MOV       R1, R8
80002934:	1b 45       	LD        R5, [PC + #27]        ;->0x800029a0  :=0x8000d9ec
80002936:	05 5c       	LJMP      R5
##@@@P_:queue.c:2409
##@@@L2409_:        pxQueue->pcWriteTo += pxQueue->uxItemSize;   
80002938:	2e 9c       	LD.W      R5, [R6 + #16]
8000293a:	66 98       	LD.W      R4, [R6 + #1]
8000293c:	6c c3       	ADD       R5, R4, R5
8000293e:	75 a0       	ST.W      [R6 + #1], R5
##@@@P_:queue.c:2411
##@@@L2410_:
##@@@L2411_:        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )   
80002940:	a6 98       	LD.W      R4, [R6 + #2]
80002942:	54 70       	CMP       R5, R4
80002944:	03 f3       	JNC       $+3                   ;->0x8000294a
##@@@P_:queue.c:2413
##@@@L2412_:        {   
##@@@L2413_:            pxQueue->pcWriteTo = pxQueue->pcHead;   
80002946:	56 82       	LD.W      R5, [R6]
80002948:	75 a0       	ST.W      [R6 + #1], R5
8000294a:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:queue.c:2455
##@@@L2450_:        {   
##@@@L2451_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2452_:        }   
##@@@L2453_:    }   
##@@@L2454_:
##@@@L2455_:    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );   
8000294c:	6f c0       	ADD       R5, R7, #1
8000294e:	b5 a3       	ST.W      [R6 + #14], R5
##@@@F_:xQueueGenericSend():
##@@@P_:queue.c:1037
##@@@L1032_:                {   
##@@@L1033_:                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );   
##@@@L1034_:
##@@@L1035_:                    /* If there was a task waiting for data to arrive on the   
##@@@L1036_:                     * queue then unblock it now. */   
##@@@L1037_:                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )   
80002950:	6e 9a       	LD.W      R5, [R6 + #9]
80002952:	50 38       	CMP       R5, #0			;->0x00
80002954:	05 f0       	JZ        $+5                   ;->0x8000295e
80002956:	64 2a       	ADD       R6, #36			;->0x24
##@@@P_:queue.c:1039
##@@@L1038_:                    {   
##@@@L1039_:                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )   
80002958:	06 58       	MOV       R0, R6
8000295a:	14 45       	LD        R5, [PC + #20]        ;->0x800029a8  :=0x80006ffc
8000295c:	05 5c       	LJMP      R5
8000295e:	00 38       	CMP       R0, #0			;->0x00
80002960:	03 f0       	JZ        $+3                   ;->0x80002966
80002962:	0f 45       	LD        R5, [PC + #15]        ;->0x8000299c  :=0x80008f64
80002964:	05 5c       	LJMP      R5
##@@@P_:queue.c:1067
##@@@L1062_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L1063_:                    }   
##@@@L1064_:                }   
##@@@L1065_:                #endif /* configUSE_QUEUE_SETS */   
##@@@L1066_:
##@@@L1067_:                taskEXIT_CRITICAL();   
80002966:	09 45       	LD        R5, [PC + #9]         ;->0x80002988  :=0x80005730
80002968:	05 5c       	LJMP      R5
8000296a:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:queue.c:1154
##@@@L1149_:            traceRETURN_xQueueGenericSend( errQUEUE_FULL );   
##@@@L1150_:
##@@@L1151_:            return errQUEUE_FULL;   
##@@@L1152_:        }   
##@@@L1153_:    }   
##@@@L1154_:}   
8000296c:	e8 29       	ADD       SP, #24			;->0x18
8000296e:	7f 5e       	POP       {R6-R12}
80002970:	0d 5d       	POP       LR
80002972:	1d 5c       	JMP       LR
80002974:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80002974
80002978:	64 2e 00 80 	.long     0x80002e64 ->-2147471772  [!!!@2@:ADD       R6, #100	@@: LD.B      R0, [R0]
8000297c:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80002980:	0c 00 00 00 	.long     0x0000000c ->000000012  [!!!@2@:MRET     	@@: NOP      
80002984:	04 73 00 80 	.long     0x80007304 ->-2147454204  [!!!@2@:ST.W      [R0++], R4	@@: LD.B      R0, [R0]
80002988:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80002988
8000298c:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80002990:	14 00 00 00 	.long     0x00000014 ->000000020  [!!!@4@:DMSC16LL  ACC0, ACC0, R0, R0
80002994:	1c 73 00 80 	.long     0x8000731c ->-2147454180  [!!!@2@:ST.W      [R1++], R12	@@: LD.B      R0, [R0]
80002998:	8c 6e 00 80 	.long     0x80006e8c ->-2147455348  [!!!@2@:ASR       R8, R12	@@: LD.B      R0, [R0]
8000299c:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
800029a0:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
800029a4:	c4 76 00 80 	.long     0x800076c4 ->-2147453244  [!!!@2@:LD.B      R12, [R4++]	@@: LD.B      R0, [R0]
800029a8:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
##@@@P_:queue.c:950
##@@@L0945_:    TimeOut_t xTimeOut;   
##@@@L0946_:    Queue_t * const pxQueue = xQueue;   
##@@@L0947_:
##@@@L0948_:    traceENTER_xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );   
##@@@L0949_:
##@@@L0950_:    configASSERT( pxQueue );   
800029ac:	20 5d       	PUSH      R0
800029ae:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800029b2:	08 00       	SYNC     SYNC     
800029b4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800029b8:	08 00       	SYNC     SYNC     
800029ba:	00 5d       	POP       R0
800029bc:	20 5d       	PUSH      R0
800029be:	21 5d       	PUSH      R1
800029c0:	30 45       	LD        R5, [PC + #48]        ;->0x80002a80  :=0x1ff
800029c2:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800029c6:	25 58       	MOV       R1, R5
800029c8:	11 68       	NOT       R1, R1
800029ca:	01 69       	ANL       R0, R1
800029cc:	5f 11       	MOV       R5, #31			;->0x001F
800029ce:	25 58       	MOV       R1, R5
800029d0:	01 6a       	ORL       R0, R1
800029d2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800029d6:	08 00       	SYNC     SYNC     
800029d8:	01 5d       	POP       R1
800029da:	00 5d       	POP       R0
800029dc:	20 5d       	PUSH      R0
800029de:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800029e2:	08 00       	SYNC     SYNC     
800029e4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800029e8:	08 00       	SYNC     SYNC     
800029ea:	00 5d       	POP       R0
800029ec:	07 00       	BREAK    BREAK    
800029ee:	26 45       	LD        R5, [PC + #38]        ;->0x80002a84  :=0x8000911c
800029f0:	05 5c       	LJMP      R5
##@@@P_:queue.c:952
##@@@L0951_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
##@@@L0952_:    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );   
800029f2:	20 5d       	PUSH      R0
800029f4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800029f8:	08 00       	SYNC     SYNC     
800029fa:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800029fe:	08 00       	SYNC     SYNC     
80002a00:	00 5d       	POP       R0
80002a02:	20 5d       	PUSH      R0
80002a04:	21 5d       	PUSH      R1
80002a06:	1f 45       	LD        R5, [PC + #31]        ;->0x80002a80  :=0x1ff
80002a08:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002a0c:	25 58       	MOV       R1, R5
80002a0e:	11 68       	NOT       R1, R1
80002a10:	01 69       	ANL       R0, R1
80002a12:	5f 11       	MOV       R5, #31			;->0x001F
80002a14:	25 58       	MOV       R1, R5
80002a16:	01 6a       	ORL       R0, R1
80002a18:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002a1c:	08 00       	SYNC     SYNC     
80002a1e:	01 5d       	POP       R1
80002a20:	00 5d       	POP       R0
80002a22:	20 5d       	PUSH      R0
80002a24:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002a28:	08 00       	SYNC     SYNC     
80002a2a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002a2e:	08 00       	SYNC     SYNC     
80002a30:	00 5d       	POP       R0
80002a32:	07 00       	BREAK    BREAK    
80002a34:	14 45       	LD        R5, [PC + #20]        ;->0x80002a84  :=0x8000911c
80002a36:	05 5c       	LJMP      R5
##@@@P_:queue.c:951
##@@@L0946_:    Queue_t * const pxQueue = xQueue;   
##@@@L0947_:
##@@@L0948_:    traceENTER_xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );   
##@@@L0949_:
##@@@L0950_:    configASSERT( pxQueue );   
##@@@L0951_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
80002a38:	20 5d       	PUSH      R0
80002a3a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002a3e:	08 00       	SYNC     SYNC     
80002a40:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002a44:	08 00       	SYNC     SYNC     
80002a46:	00 5d       	POP       R0
80002a48:	20 5d       	PUSH      R0
80002a4a:	21 5d       	PUSH      R1
80002a4c:	0d 45       	LD        R5, [PC + #13]        ;->0x80002a80  :=0x1ff
80002a4e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002a52:	25 58       	MOV       R1, R5
80002a54:	11 68       	NOT       R1, R1
80002a56:	01 69       	ANL       R0, R1
80002a58:	5f 11       	MOV       R5, #31			;->0x001F
80002a5a:	25 58       	MOV       R1, R5
80002a5c:	01 6a       	ORL       R0, R1
80002a5e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002a62:	08 00       	SYNC     SYNC     
80002a64:	01 5d       	POP       R1
80002a66:	00 5d       	POP       R0
80002a68:	20 5d       	PUSH      R0
80002a6a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002a6e:	08 00       	SYNC     SYNC     
80002a70:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002a74:	08 00       	SYNC     SYNC     
80002a76:	00 5d       	POP       R0
80002a78:	07 00       	BREAK    BREAK    
80002a7a:	03 45       	LD        R5, [PC + #3]         ;->0x80002a84  :=0x8000911c
80002a7c:	05 5c       	LJMP      R5
80002a7e:	00 00       	NOP      NOP      
80002a80:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002a84:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002a88 <xQueueTakeMutexRecursive>:
##@@@F_:xQueueTakeMutexRecursive():
##@@@P_:queue.c:817
##@@@L0812_:
##@@@L0813_:#if ( configUSE_RECURSIVE_MUTEXES == 1 )   
##@@@L0814_:
##@@@L0815_:    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,   
##@@@L0816_:                                         TickType_t xTicksToWait )   
##@@@L0817_:    {   
80002a88:	87 5f       	PUSH      {R6-R8,LR}
80002a8a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:823
##@@@L0818_:        BaseType_t xReturn;   
##@@@L0819_:        Queue_t * const pxMutex = ( Queue_t * ) xMutex;   
##@@@L0820_:
##@@@L0821_:        traceENTER_xQueueTakeMutexRecursive( xMutex, xTicksToWait );   
##@@@L0822_:
##@@@L0823_:        configASSERT( pxMutex );   
80002a8c:	00 38       	CMP       R0, #0			;->0x00
80002a8e:	1d f0       	JZ        $+29                  ;->0x80002ac8
80002a90:	c0 58       	MOV       R6, R0
80002a92:	01 59       	MOV       R8, R1
##@@@P_:queue.c:830
##@@@L0825_:        /* Comments regarding mutual exclusion as per those within   
##@@@L0826_:         * xQueueGiveMutexRecursive(). */   
##@@@L0827_:
##@@@L0828_:        traceTAKE_MUTEX_RECURSIVE( pxMutex );   
##@@@L0829_:
##@@@L0830_:        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )   
80002a94:	b8 98       	LD.W      R7, [R0 + #2]
80002a96:	0b 45       	LD        R5, [PC + #11]        ;->0x80002ac0  :=0x80007610
80002a98:	05 5c       	LJMP      R5
80002a9a:	70 70       	CMP       R7, R0
80002a9c:	09 f0       	JZ        $+9                   ;->0x80002aae
##@@@P_:queue.c:837
##@@@L0832_:            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;   
##@@@L0833_:            xReturn = pdPASS;   
##@@@L0834_:        }   
##@@@L0835_:        else   
##@@@L0836_:        {   
##@@@L0837_:            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );   
80002a9e:	06 58       	MOV       R0, R6
80002aa0:	28 58       	MOV       R1, R8
80002aa2:	09 45       	LD        R5, [PC + #9]         ;->0x80002ac4  :=0x80002b18
80002aa4:	05 5c       	LJMP      R5
##@@@P_:queue.c:842
##@@@L0838_:
##@@@L0839_:            /* pdPASS will only be returned if the mutex was successfully   
##@@@L0840_:             * obtained.  The calling task may have entered the Blocked state   
##@@@L0841_:             * before reaching here. */   
##@@@L0842_:            if( xReturn != pdFAIL )   
80002aa6:	00 38       	CMP       R0, #0			;->0x00
80002aa8:	04 f1       	JNZ       $+4                   ;->0x80002ab0
80002aaa:	00 10       	MOV       R0, #0			;->0x0000
80002aac:	05 04       	SJMP      $+5                   ;->0x80002ab6
80002aae:	01 10       	MOV       R0, #1			;->0x0001
80002ab0:	ee 98       	LD.W      R5, [R6 + #3]
80002ab2:	6d c0       	ADD       R5, R5, #1
80002ab4:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:queue.c:854
##@@@L0849_:            }   
##@@@L0850_:        }   
##@@@L0851_:
##@@@L0852_:        traceRETURN_xQueueTakeMutexRecursive( xReturn );   
##@@@L0853_:
##@@@L0854_:        return xReturn;   
80002ab6:	e4 28       	ADD       SP, #4			;->0x04
80002ab8:	07 5e       	POP       {R6-R8}
80002aba:	0d 5d       	POP       LR
80002abc:	1d 5c       	JMP       LR
80002abe:	00 00       	NOP      NOP      
80002ac0:	10 76 00 80 	.long     0x80007610 ->-2147453424  [!!!@2@:LD.B      R1, [R0++]	@@: LD.B      R0, [R0]
80002ac4:	18 2b 00 80 	.long     0x80002b18 ->-2147472616  [!!!@2@:ADD       R1, #56	@@: LD.B      R0, [R0]
##@@@P_:queue.c:823
##@@@L0818_:        BaseType_t xReturn;   
##@@@L0819_:        Queue_t * const pxMutex = ( Queue_t * ) xMutex;   
##@@@L0820_:
##@@@L0821_:        traceENTER_xQueueTakeMutexRecursive( xMutex, xTicksToWait );   
##@@@L0822_:
##@@@L0823_:        configASSERT( pxMutex );   
80002ac8:	20 5d       	PUSH      R0
80002aca:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002ace:	08 00       	SYNC     SYNC     
80002ad0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002ad4:	08 00       	SYNC     SYNC     
80002ad6:	00 5d       	POP       R0
80002ad8:	20 5d       	PUSH      R0
80002ada:	21 5d       	PUSH      R1
80002adc:	0d 45       	LD        R5, [PC + #13]        ;->0x80002b10  :=0x1ff
80002ade:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002ae2:	25 58       	MOV       R1, R5
80002ae4:	11 68       	NOT       R1, R1
80002ae6:	01 69       	ANL       R0, R1
80002ae8:	5f 11       	MOV       R5, #31			;->0x001F
80002aea:	25 58       	MOV       R1, R5
80002aec:	01 6a       	ORL       R0, R1
80002aee:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002af2:	08 00       	SYNC     SYNC     
80002af4:	01 5d       	POP       R1
80002af6:	00 5d       	POP       R0
80002af8:	20 5d       	PUSH      R0
80002afa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002afe:	08 00       	SYNC     SYNC     
80002b00:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002b04:	08 00       	SYNC     SYNC     
80002b06:	00 5d       	POP       R0
80002b08:	07 00       	BREAK    BREAK    
80002b0a:	03 45       	LD        R5, [PC + #3]         ;->0x80002b14  :=0x8000911c
80002b0c:	05 5c       	LJMP      R5
80002b0e:	00 00       	NOP      NOP      
80002b10:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002b14:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002b18 <xQueueSemaphoreTake>:
##@@@F_:xQueueSemaphoreTake():
##@@@P_:queue.c:1648
##@@@L1643_:}   
##@@@L1644_:/*-----------------------------------------------------------*/   
##@@@L1645_:
##@@@L1646_:BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,   
##@@@L1647_:                                TickType_t xTicksToWait )   
##@@@L1648_:{   
80002b18:	bf 5f       	PUSH      {R6-R11,LR}
80002b1a:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:queue.c:1660
##@@@L1655_:    #endif   
##@@@L1656_:
##@@@L1657_:    traceENTER_xQueueSemaphoreTake( xQueue, xTicksToWait );   
##@@@L1658_:
##@@@L1659_:    /* Check the queue pointer is not NULL. */   
##@@@L1660_:    configASSERT( ( pxQueue ) );   
80002b1c:	00 38       	CMP       R0, #0			;->0x00
80002b1e:	04 21       	ST.W      [SP + #4], R1
80002b20:	02 f1       	JNZ       $+2                   ;->0x80002b24
80002b22:	b0 04       	SJMP      $+176                 ;->0x80002c82
80002b24:	c0 58       	MOV       R6, R0
##@@@P_:queue.c:1664
##@@@L1661_:
##@@@L1662_:    /* Check this really is a semaphore, in which case the item size will be   
##@@@L1663_:     * 0. */   
##@@@L1664_:    configASSERT( pxQueue->uxItemSize == 0 );   
80002b26:	28 9c       	LD.W      R5, [R0 + #16]
80002b28:	50 38       	CMP       R5, #0			;->0x00
80002b2a:	02 f0       	JZ        $+2                   ;->0x80002b2e
80002b2c:	ce 04       	SJMP      $+206                 ;->0x80002cc8
80002b2e:	e1 58       	MOV       R7, R1
##@@@P_:queue.c:1675
##@@@L1670_:    }   
##@@@L1671_:    #endif   
##@@@L1672_:
##@@@L1673_:    for( ; ; )   
##@@@L1674_:    {   
##@@@L1675_:        taskENTER_CRITICAL();   
80002b30:	10 45       	LD        R5, [PC + #16]        ;->0x80002b70  :=0x800056cc
80002b32:	05 5c       	LJMP      R5
##@@@P_:queue.c:1679
##@@@L1676_:        {   
##@@@L1677_:            /* Semaphores are queues with an item size of 0, and where the   
##@@@L1678_:             * number of messages in the queue is the semaphore's count value. */   
##@@@L1679_:            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;   
80002b34:	ae 9b       	LD.W      R5, [R6 + #14]
##@@@P_:queue.c:1683
##@@@L1680_:
##@@@L1681_:            /* Is there data in the queue now?  To be running the calling task   
##@@@L1682_:             * must be the highest priority task wanting to access the queue. */   
##@@@L1683_:            if( uxSemaphoreCount > ( UBaseType_t ) 0 )   
80002b36:	50 38       	CMP       R5, #0			;->0x00
80002b38:	26 f0       	JZ        $+38                  ;->0x80002b84
##@@@P_:queue.c:1689
##@@@L1684_:            {   
##@@@L1685_:                traceQUEUE_RECEIVE( pxQueue );   
##@@@L1686_:
##@@@L1687_:                /* Semaphores are queues with a data size of zero and where the   
##@@@L1688_:                 * messages waiting is the semaphore's count.  Reduce the count. */   
##@@@L1689_:                pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxSemaphoreCount - ( UBaseType_t ) 1 );   
80002b3a:	6d cc       	SUB       R5, R5, #1
80002b3c:	b5 a3       	ST.W      [R6 + #14], R5
##@@@P_:queue.c:1693
##@@@L1690_:
##@@@L1691_:                #if ( configUSE_MUTEXES == 1 )   
##@@@L1692_:                {   
##@@@L1693_:                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )   
80002b3e:	56 82       	LD.W      R5, [R6]
80002b40:	50 38       	CMP       R5, #0			;->0x00
80002b42:	04 f1       	JNZ       $+4                   ;->0x80002b4a
##@@@P_:queue.c:1697
##@@@L1694_:                    {   
##@@@L1695_:                        /* Record the information required to implement   
##@@@L1696_:                         * priority inheritance should it become necessary. */   
##@@@L1697_:                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();   
80002b44:	0c 45       	LD        R5, [PC + #12]        ;->0x80002b74  :=0x80007b84
80002b46:	05 5c       	LJMP      R5
80002b48:	b0 a0       	ST.W      [R6 + #2], R0
##@@@P_:queue.c:1708
##@@@L1703_:                }   
##@@@L1704_:                #endif /* configUSE_MUTEXES */   
##@@@L1705_:
##@@@L1706_:                /* Check to see if other tasks are blocked waiting to give the   
##@@@L1707_:                 * semaphore, and if so, unblock the highest priority such task. */   
##@@@L1708_:                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )   
80002b4a:	2e 99       	LD.W      R5, [R6 + #4]
80002b4c:	50 38       	CMP       R5, #0			;->0x00
80002b4e:	09 f0       	JZ        $+9                   ;->0x80002b60
80002b50:	60 29       	ADD       R6, #16			;->0x10
##@@@P_:queue.c:1710
##@@@L1709_:                {   
##@@@L1710_:                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )   
80002b52:	06 58       	MOV       R0, R6
80002b54:	09 45       	LD        R5, [PC + #9]         ;->0x80002b78  :=0x80006ffc
80002b56:	05 5c       	LJMP      R5
80002b58:	00 38       	CMP       R0, #0			;->0x00
80002b5a:	03 f0       	JZ        $+3                   ;->0x80002b60
##@@@P_:queue.c:1712
##@@@L1711_:                    {   
##@@@L1712_:                        queueYIELD_IF_USING_PREEMPTION();   
80002b5c:	08 45       	LD        R5, [PC + #8]         ;->0x80002b7c  :=0x80008f64
80002b5e:	05 5c       	LJMP      R5
80002b60:	91 10       	MOV       R9, #1			;->0x0001
80002b62:	08 45       	LD        R5, [PC + #8]         ;->0x80002b80  :=0x80005730
80002b64:	05 5c       	LJMP      R5
##@@@P_:queue.c:1868
##@@@L1863_:            {   
##@@@L1864_:                mtCOVERAGE_TEST_MARKER();   
##@@@L1865_:            }   
##@@@L1866_:        }   
##@@@L1867_:    }   
##@@@L1868_:}   
80002b66:	09 58       	MOV       R0, R9
80002b68:	e4 29       	ADD       SP, #20			;->0x14
80002b6a:	3f 5e       	POP       {R6-R11}
80002b6c:	0d 5d       	POP       LR
80002b6e:	1d 5c       	JMP       LR
80002b70:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80002b70
80002b74:	84 7b 00 80 	.long     0x80007b84 ->-2147452028  [!!!@2@:LSL       R0, #28	@@: LD.B      R0, [R0]
80002b78:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
80002b7c:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80002b80:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80002b80
80002b84:	90 10       	MOV       R9, #0			;->0x0000
##@@@P_:queue.c:1732
##@@@L1727_:
##@@@L1728_:                return pdPASS;   
##@@@L1729_:            }   
##@@@L1730_:            else   
##@@@L1731_:            {   
##@@@L1732_:                if( xTicksToWait == ( TickType_t ) 0 )   
80002b86:	70 38       	CMP       R7, #0			;->0x00
80002b88:	ed f0       	JZ        $-19                  ;->0x80002b62
80002b8a:	a6 58       	MOV       R5, R6
80002b8c:	54 2a       	ADD       R5, #36			;->0x24
80002b8e:	01 25       	ST.W      [SP + #1], R5
80002b90:	b1 10       	MOV       R11, #1			;->0x0001
80002b92:	af 1f       	MOV       R10, #255			;->0x00FF
80002b94:	09 59       	MOV       R8, R9
80002b96:	ab 58       	MOV       R5, R11
##@@@P_:queue.c:1743
##@@@L1738_:                    traceQUEUE_RECEIVE_FAILED( pxQueue );   
##@@@L1739_:                    traceRETURN_xQueueSemaphoreTake( errQUEUE_EMPTY );   
##@@@L1740_:
##@@@L1741_:                    return errQUEUE_EMPTY;   
##@@@L1742_:                }   
##@@@L1743_:                else if( xEntryTimeSet == pdFALSE )   
80002b98:	5b 69       	ANL       R5, R11
80002b9a:	50 38       	CMP       R5, #0			;->0x00
80002b9c:	05 f0       	JZ        $+5                   ;->0x80002ba6
80002b9e:	5d 40       	LD        R0, [PC + #93]        ;->0x80002d10  :=0x8
80002ba0:	0e 64       	ADD       R0, SP
##@@@P_:queue.c:1747
##@@@L1744_:                {   
##@@@L1745_:                    /* The semaphore count was 0 and a block time was specified   
##@@@L1746_:                     * so configure the timeout structure ready to block. */   
##@@@L1747_:                    vTaskInternalSetTimeOutState( &xTimeOut );   
80002ba2:	5d 45       	LD        R5, [PC + #93]        ;->0x80002d14  :=0x80007304
80002ba4:	05 5c       	LJMP      R5
##@@@P_:queue.c:1757
##@@@L1752_:                    /* Entry time was already set. */   
##@@@L1753_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L1754_:                }   
##@@@L1755_:            }   
##@@@L1756_:        }   
##@@@L1757_:        taskEXIT_CRITICAL();   
80002ba6:	5d 45       	LD        R5, [PC + #93]        ;->0x80002d18  :=0x80005730
80002ba8:	05 5c       	LJMP      R5
##@@@P_:queue.c:1762
##@@@L1758_:
##@@@L1759_:        /* Interrupts and other tasks can give to and take from the semaphore   
##@@@L1760_:         * now the critical section has been exited. */   
##@@@L1761_:
##@@@L1762_:        vTaskSuspendAll();   
80002baa:	5d 45       	LD        R5, [PC + #93]        ;->0x80002d1c  :=0x800059b0
80002bac:	05 5c       	LJMP      R5
##@@@P_:queue.c:1763
##@@@L1763_:        prvLockQueue( pxQueue );   
80002bae:	5d 45       	LD        R5, [PC + #93]        ;->0x80002d20  :=0x800056cc
80002bb0:	05 5c       	LJMP      R5
80002bb2:	51 00 c5 10 	LD.B      R5, [R6 + #68]			;->0x44
80002bb6:	5a 70       	CMP       R5, R10
80002bb8:	03 f1       	JNZ       $+3                   ;->0x80002bbe
80002bba:	79 00 c9 10 	ST.B      [R6 + #68], R9			;->0x44
80002bbe:	51 00 c5 14 	LD.B      R5, [R6 + #69]			;->0x45
80002bc2:	5a 70       	CMP       R5, R10
80002bc4:	03 f1       	JNZ       $+3                   ;->0x80002bca
80002bc6:	79 00 c9 14 	ST.B      [R6 + #69], R9			;->0x45
80002bca:	54 45       	LD        R5, [PC + #84]        ;->0x80002d18  :=0x80005730
80002bcc:	05 5c       	LJMP      R5
80002bce:	51 40       	LD        R0, [PC + #81]        ;->0x80002d10  :=0x8
80002bd0:	0e 64       	ADD       R0, SP
80002bd2:	55 41       	LD        R1, [PC + #85]        ;->0x80002d24  :=0x10
80002bd4:	1e 64       	ADD       R1, SP
##@@@P_:queue.c:1766
##@@@L1764_:
##@@@L1765_:        /* Update the timeout state to see if it has expired yet. */   
##@@@L1766_:        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )   
80002bd6:	55 45       	LD        R5, [PC + #85]        ;->0x80002d28  :=0x8000731c
80002bd8:	05 5c       	LJMP      R5
80002bda:	00 38       	CMP       R0, #0			;->0x00
80002bdc:	0e f0       	JZ        $+14                  ;->0x80002bf8
##@@@P_:queue.c:1816
##@@@L1811_:            }   
##@@@L1812_:        }   
##@@@L1813_:        else   
##@@@L1814_:        {   
##@@@L1815_:            /* Timed out. */   
##@@@L1816_:            prvUnlockQueue( pxQueue );   
80002bde:	06 58       	MOV       R0, R6
80002be0:	53 45       	LD        R5, [PC + #83]        ;->0x80002d2c  :=0x80002e64
80002be2:	05 5c       	LJMP      R5
##@@@P_:queue.c:1817
##@@@L1817_:            ( void ) xTaskResumeAll();   
80002be4:	53 45       	LD        R5, [PC + #83]        ;->0x80002d30  :=0x80005a70
80002be6:	05 5c       	LJMP      R5
##@@@F_:prvIsQueueEmpty():
##@@@P_:queue.c:2606
##@@@L2601_:
##@@@L2602_:static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )   
##@@@L2603_:{   
##@@@L2604_:    BaseType_t xReturn;   
##@@@L2605_:
##@@@L2606_:    taskENTER_CRITICAL();   
80002be8:	4e 45       	LD        R5, [PC + #78]        ;->0x80002d20  :=0x800056cc
80002bea:	05 5c       	LJMP      R5
##@@@P_:queue.c:2608
##@@@L2607_:    {   
##@@@L2608_:        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )   
80002bec:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2617
##@@@L2612_:        else   
##@@@L2613_:        {   
##@@@L2614_:            xReturn = pdFALSE;   
##@@@L2615_:        }   
##@@@L2616_:    }   
##@@@L2617_:    taskEXIT_CRITICAL();   
80002bee:	4b 45       	LD        R5, [PC + #75]        ;->0x80002d18  :=0x80005730
80002bf0:	05 5c       	LJMP      R5
##@@@F_:xQueueSemaphoreTake():
##@@@P_:queue.c:1823
##@@@L1818_:
##@@@L1819_:            /* If the semaphore count is 0 exit now as the timeout has   
##@@@L1820_:             * expired.  Otherwise return to attempt to take the semaphore that is   
##@@@L1821_:             * known to be available.  As semaphores are implemented by queues the   
##@@@L1822_:             * queue being empty is equivalent to the semaphore count being 0. */   
##@@@L1823_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
80002bf2:	70 38       	CMP       R7, #0			;->0x00
80002bf4:	27 f1       	JNZ       $+39                  ;->0x80002c42
80002bf6:	32 04       	SJMP      $+50                  ;->0x80002c5a
##@@@F_:prvIsQueueEmpty():
##@@@P_:queue.c:2606
##@@@L2601_:
##@@@L2602_:static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )   
##@@@L2603_:{   
##@@@L2604_:    BaseType_t xReturn;   
##@@@L2605_:
##@@@L2606_:    taskENTER_CRITICAL();   
80002bf8:	4a 45       	LD        R5, [PC + #74]        ;->0x80002d20  :=0x800056cc
80002bfa:	05 5c       	LJMP      R5
##@@@P_:queue.c:2608
##@@@L2607_:    {   
##@@@L2608_:        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )   
80002bfc:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2617
##@@@L2612_:        else   
##@@@L2613_:        {   
##@@@L2614_:            xReturn = pdFALSE;   
##@@@L2615_:        }   
##@@@L2616_:    }   
##@@@L2617_:    taskEXIT_CRITICAL();   
80002bfe:	47 45       	LD        R5, [PC + #71]        ;->0x80002d18  :=0x80005730
80002c00:	05 5c       	LJMP      R5
##@@@F_:xQueueSemaphoreTake():
##@@@P_:queue.c:1772
##@@@L1767_:        {   
##@@@L1768_:            /* A block time is specified and not expired.  If the semaphore   
##@@@L1769_:             * count is 0 then enter the Blocked state to wait for a semaphore to   
##@@@L1770_:             * become available.  As semaphores are implemented with queues the   
##@@@L1771_:             * queue being empty is equivalent to the semaphore count being 0. */   
##@@@L1772_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
80002c02:	70 38       	CMP       R7, #0			;->0x00
80002c04:	07 f0       	JZ        $+7                   ;->0x80002c12
##@@@P_:queue.c:1809
##@@@L1804_:            }   
##@@@L1805_:            else   
##@@@L1806_:            {   
##@@@L1807_:                /* There was no timeout and the semaphore count was not 0, so   
##@@@L1808_:                 * attempt to take the semaphore again. */   
##@@@L1809_:                prvUnlockQueue( pxQueue );   
80002c06:	06 58       	MOV       R0, R6
80002c08:	49 45       	LD        R5, [PC + #73]        ;->0x80002d2c  :=0x80002e64
80002c0a:	05 5c       	LJMP      R5
##@@@P_:queue.c:1810
##@@@L1810_:                ( void ) xTaskResumeAll();   
80002c0c:	49 45       	LD        R5, [PC + #73]        ;->0x80002d30  :=0x80005a70
80002c0e:	05 5c       	LJMP      R5
80002c10:	19 04       	SJMP      $+25                  ;->0x80002c42
##@@@P_:queue.c:1778
##@@@L1773_:            {   
##@@@L1774_:                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );   
##@@@L1775_:
##@@@L1776_:                #if ( configUSE_MUTEXES == 1 )   
##@@@L1777_:                {   
##@@@L1778_:                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )   
80002c12:	56 82       	LD.W      R5, [R6]
80002c14:	50 38       	CMP       R5, #0			;->0x00
80002c16:	09 f1       	JNZ       $+9                   ;->0x80002c28
##@@@P_:queue.c:1780
##@@@L1779_:                    {   
##@@@L1780_:                        taskENTER_CRITICAL();   
80002c18:	42 45       	LD        R5, [PC + #66]        ;->0x80002d20  :=0x800056cc
80002c1a:	05 5c       	LJMP      R5
##@@@P_:queue.c:1782
##@@@L1781_:                        {   
##@@@L1782_:                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );   
80002c1c:	86 98       	LD.W      R0, [R6 + #2]
80002c1e:	46 45       	LD        R5, [PC + #70]        ;->0x80002d34  :=0x8000761c
80002c20:	05 5c       	LJMP      R5
80002c22:	00 59       	MOV       R8, R0
##@@@P_:queue.c:1784
##@@@L1783_:                        }   
##@@@L1784_:                        taskEXIT_CRITICAL();   
80002c24:	3d 45       	LD        R5, [PC + #61]        ;->0x80002d18  :=0x80005730
80002c26:	05 5c       	LJMP      R5
##@@@P_:queue.c:1793
##@@@L1788_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L1789_:                    }   
##@@@L1790_:                }   
##@@@L1791_:                #endif /* if ( configUSE_MUTEXES == 1 ) */   
##@@@L1792_:
##@@@L1793_:                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );   
80002c28:	04 09       	LD.W      R1, [SP + #4]
80002c2a:	01 08       	LD.W      R0, [SP + #1]
80002c2c:	43 45       	LD        R5, [PC + #67]        ;->0x80002d38  :=0x80006e8c
80002c2e:	05 5c       	LJMP      R5
##@@@P_:queue.c:1794
##@@@L1794_:                prvUnlockQueue( pxQueue );   
80002c30:	06 58       	MOV       R0, R6
80002c32:	3f 45       	LD        R5, [PC + #63]        ;->0x80002d2c  :=0x80002e64
80002c34:	05 5c       	LJMP      R5
##@@@P_:queue.c:1796
##@@@L1795_:
##@@@L1796_:                if( xTaskResumeAll() == pdFALSE )   
80002c36:	3f 45       	LD        R5, [PC + #63]        ;->0x80002d30  :=0x80005a70
80002c38:	05 5c       	LJMP      R5
80002c3a:	00 38       	CMP       R0, #0			;->0x00
80002c3c:	03 f1       	JNZ       $+3                   ;->0x80002c42
##@@@P_:queue.c:1798
##@@@L1797_:                {   
##@@@L1798_:                    taskYIELD_WITHIN_API();   
80002c3e:	40 45       	LD        R5, [PC + #64]        ;->0x80002d3c  :=0x80008f64
80002c40:	05 5c       	LJMP      R5
##@@@P_:queue.c:1675
##@@@L1670_:    }   
##@@@L1671_:    #endif   
##@@@L1672_:
##@@@L1673_:    for( ; ; )   
##@@@L1674_:    {   
##@@@L1675_:        taskENTER_CRITICAL();   
80002c42:	38 45       	LD        R5, [PC + #56]        ;->0x80002d20  :=0x800056cc
80002c44:	05 5c       	LJMP      R5
##@@@P_:queue.c:1679
##@@@L1676_:        {   
##@@@L1677_:            /* Semaphores are queues with an item size of 0, and where the   
##@@@L1678_:             * number of messages in the queue is the semaphore's count value. */   
##@@@L1679_:            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;   
80002c46:	ae 9b       	LD.W      R5, [R6 + #14]
##@@@P_:queue.c:1683
##@@@L1680_:
##@@@L1681_:            /* Is there data in the queue now?  To be running the calling task   
##@@@L1682_:             * must be the highest priority task wanting to access the queue. */   
##@@@L1683_:            if( uxSemaphoreCount > ( UBaseType_t ) 0 )   
80002c48:	50 38       	CMP       R5, #0			;->0x00
80002c4a:	02 f0       	JZ        $+2                   ;->0x80002c4e
80002c4c:	77 07       	SJMP      $-137                 ;->0x80002b3a
##@@@P_:queue.c:1732
##@@@L1727_:
##@@@L1728_:                return pdPASS;   
##@@@L1729_:            }   
##@@@L1730_:            else   
##@@@L1731_:            {   
##@@@L1732_:                if( xTicksToWait == ( TickType_t ) 0 )   
80002c4e:	04 0d       	LD.W      R5, [SP + #4]
80002c50:	50 38       	CMP       R5, #0			;->0x00
80002c52:	a9 58       	MOV       R5, R9
80002c54:	02 f0       	JZ        $+2                   ;->0x80002c58
80002c56:	a1 07       	SJMP      $-95                  ;->0x80002b98
80002c58:	85 07       	SJMP      $-123                 ;->0x80002b62
##@@@P_:queue.c:1830
##@@@L1825_:                #if ( configUSE_MUTEXES == 1 )   
##@@@L1826_:                {   
##@@@L1827_:                    /* xInheritanceOccurred could only have be set if   
##@@@L1828_:                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to   
##@@@L1829_:                     * test the mutex type again to check it is actually a mutex. */   
##@@@L1830_:                    if( xInheritanceOccurred != pdFALSE )   
80002c5a:	80 38       	CMP       R8, #0			;->0x00
80002c5c:	0b f0       	JZ        $+11                  ;->0x80002c72
##@@@P_:queue.c:1832
##@@@L1831_:                    {   
##@@@L1832_:                        taskENTER_CRITICAL();   
80002c5e:	31 45       	LD        R5, [PC + #49]        ;->0x80002d20  :=0x800056cc
80002c60:	05 5c       	LJMP      R5
##@@@F_:prvGetDisinheritPriorityAfterTimeout():
##@@@P_:queue.c:2363
##@@@L2358_:         * priority, but the waiting task times out, then the holder should   
##@@@L2359_:         * disinherit the priority - but only down to the highest priority of any   
##@@@L2360_:         * other tasks that are waiting for the same mutex.  For this purpose,   
##@@@L2361_:         * return the priority of the highest priority task that is waiting for the   
##@@@L2362_:         * mutex. */   
##@@@L2363_:        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )   
80002c62:	6e 9a       	LD.W      R5, [R6 + #9]
80002c64:	50 38       	CMP       R5, #0			;->0x00
80002c66:	08 f0       	JZ        $+8                   ;->0x80002c76
##@@@P_:queue.c:2365
##@@@L2364_:        {   
##@@@L2365_:            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) ( ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) ) );   
80002c68:	2e 9b       	LD.W      R5, [R6 + #12]
80002c6a:	55 82       	LD.W      R5, [R5]
80002c6c:	4e 11       	MOV       R4, #30			;->0x001E
80002c6e:	4c c7       	SUB       R1, R4, R5
80002c70:	04 04       	SJMP      $+4                   ;->0x80002c78
##@@@F_:xQueueSemaphoreTake():
80002c72:	90 10       	MOV       R9, #0			;->0x0000
80002c74:	79 07       	SJMP      $-135                 ;->0x80002b66
80002c76:	10 10       	MOV       R1, #0			;->0x0000
##@@@P_:queue.c:1850
##@@@L1845_:                             * mutex to the ready list for its new priority. Coverity thinks that   
##@@@L1846_:                             * it can result in out-of-bounds access which is not true because   
##@@@L1847_:                             * uxHighestWaitingPriority, as returned by prvGetDisinheritPriorityAfterTimeout,   
##@@@L1848_:                             * is capped at ( configMAX_PRIORITIES - 1 ). */   
##@@@L1849_:                            /* coverity[overrun] */   
##@@@L1850_:                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );   
80002c78:	86 98       	LD.W      R0, [R6 + #2]
80002c7a:	32 45       	LD        R5, [PC + #50]        ;->0x80002d40  :=0x800077e0
80002c7c:	05 5c       	LJMP      R5
80002c7e:	90 10       	MOV       R9, #0			;->0x0000
80002c80:	71 07       	SJMP      $-143                 ;->0x80002b62
##@@@P_:queue.c:1660
##@@@L1655_:    #endif   
##@@@L1656_:
##@@@L1657_:    traceENTER_xQueueSemaphoreTake( xQueue, xTicksToWait );   
##@@@L1658_:
##@@@L1659_:    /* Check the queue pointer is not NULL. */   
##@@@L1660_:    configASSERT( ( pxQueue ) );   
80002c82:	20 5d       	PUSH      R0
80002c84:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002c88:	08 00       	SYNC     SYNC     
80002c8a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002c8e:	08 00       	SYNC     SYNC     
80002c90:	00 5d       	POP       R0
80002c92:	20 5d       	PUSH      R0
80002c94:	21 5d       	PUSH      R1
80002c96:	2c 45       	LD        R5, [PC + #44]        ;->0x80002d44  :=0x1ff
80002c98:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002c9c:	25 58       	MOV       R1, R5
80002c9e:	11 68       	NOT       R1, R1
80002ca0:	01 69       	ANL       R0, R1
80002ca2:	5f 11       	MOV       R5, #31			;->0x001F
80002ca4:	25 58       	MOV       R1, R5
80002ca6:	01 6a       	ORL       R0, R1
80002ca8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002cac:	08 00       	SYNC     SYNC     
80002cae:	01 5d       	POP       R1
80002cb0:	00 5d       	POP       R0
80002cb2:	20 5d       	PUSH      R0
80002cb4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002cb8:	08 00       	SYNC     SYNC     
80002cba:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002cbe:	08 00       	SYNC     SYNC     
80002cc0:	00 5d       	POP       R0
80002cc2:	07 00       	BREAK    BREAK    
80002cc4:	21 45       	LD        R5, [PC + #33]        ;->0x80002d48  :=0x8000911c
80002cc6:	05 5c       	LJMP      R5
##@@@P_:queue.c:1664
##@@@L1661_:
##@@@L1662_:    /* Check this really is a semaphore, in which case the item size will be   
##@@@L1663_:     * 0. */   
##@@@L1664_:    configASSERT( pxQueue->uxItemSize == 0 );   
80002cc8:	20 5d       	PUSH      R0
80002cca:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002cce:	08 00       	SYNC     SYNC     
80002cd0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002cd4:	08 00       	SYNC     SYNC     
80002cd6:	00 5d       	POP       R0
80002cd8:	20 5d       	PUSH      R0
80002cda:	21 5d       	PUSH      R1
80002cdc:	1a 45       	LD        R5, [PC + #26]        ;->0x80002d44  :=0x1ff
80002cde:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002ce2:	25 58       	MOV       R1, R5
80002ce4:	11 68       	NOT       R1, R1
80002ce6:	01 69       	ANL       R0, R1
80002ce8:	5f 11       	MOV       R5, #31			;->0x001F
80002cea:	25 58       	MOV       R1, R5
80002cec:	01 6a       	ORL       R0, R1
80002cee:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002cf2:	08 00       	SYNC     SYNC     
80002cf4:	01 5d       	POP       R1
80002cf6:	00 5d       	POP       R0
80002cf8:	20 5d       	PUSH      R0
80002cfa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002cfe:	08 00       	SYNC     SYNC     
80002d00:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002d04:	08 00       	SYNC     SYNC     
80002d06:	00 5d       	POP       R0
80002d08:	07 00       	BREAK    BREAK    
80002d0a:	10 45       	LD        R5, [PC + #16]        ;->0x80002d48  :=0x8000911c
80002d0c:	05 5c       	LJMP      R5
80002d0e:	00 00       	NOP      NOP      
80002d10:	08 00 00 00 	.long     0x00000008 ->000000008  [!!!@2@:SYNC     	@@: NOP      
80002d14:	04 73 00 80 	.long     0x80007304 ->-2147454204  [!!!@2@:ST.W      [R0++], R4	@@: LD.B      R0, [R0]
80002d18:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80002d18
80002d1c:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80002d20:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80002d20
80002d24:	10 00 00 00 	.long     0x00000010 ->000000016  [!!!@4@:DMAC16LL  ACC0, ACC0, R0, R0
80002d28:	1c 73 00 80 	.long     0x8000731c ->-2147454180  [!!!@2@:ST.W      [R1++], R12	@@: LD.B      R0, [R0]
80002d2c:	64 2e 00 80 	.long     0x80002e64 ->-2147471772  [!!!@2@:ADD       R6, #100	@@: LD.B      R0, [R0]
80002d30:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80002d34:	1c 76 00 80 	.long     0x8000761c ->-2147453412  [!!!@2@:LD.B      R1, [R12++]	@@: LD.B      R0, [R0]
80002d38:	8c 6e 00 80 	.long     0x80006e8c ->-2147455348  [!!!@2@:ASR       R8, R12	@@: LD.B      R0, [R0]
80002d3c:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80002d40:	e0 77 00 80 	.long     0x800077e0 ->-2147452960  [!!!@2@:ST.B      [SP++], R0	@@: LD.B      R0, [R0]
80002d44:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002d48:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002d4c <xQueueCreateCountingSemaphoreStatic>:
##@@@F_:xQueueCreateCountingSemaphoreStatic():
##@@@P_:queue.c:865
##@@@L0860_:#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )   
##@@@L0861_:
##@@@L0862_:    QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,   
##@@@L0863_:                                                       const UBaseType_t uxInitialCount,   
##@@@L0864_:                                                       StaticQueue_t * pxStaticQueue )   
##@@@L0865_:    {   
80002d4c:	81 5f       	PUSH      {R6,LR}
80002d4e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:870
##@@@L0866_:        QueueHandle_t xHandle = NULL;   
##@@@L0867_:
##@@@L0868_:        traceENTER_xQueueCreateCountingSemaphoreStatic( uxMaxCount, uxInitialCount, pxStaticQueue );   
##@@@L0869_:
##@@@L0870_:        if( ( uxMaxCount != 0U ) &&   
80002d50:	00 38       	CMP       R0, #0			;->0x00
80002d52:	13 f0       	JZ        $+19                  ;->0x80002d78
80002d54:	c1 58       	MOV       R6, R1
80002d56:	10 70       	CMP       R1, R0
80002d58:	10 f8       	JHI       $+16                  ;->0x80002d78
80002d5a:	62 58       	MOV       R3, R2
80002d5c:	10 10       	MOV       R1, #0			;->0x0000
80002d5e:	42 10       	MOV       R4, #2			;->0x0002
##@@@P_:queue.c:873
##@@@L0871_:            ( uxInitialCount <= uxMaxCount ) )   
##@@@L0872_:        {   
##@@@L0873_:            xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );   
80002d60:	41 58       	MOV       R2, R1
80002d62:	05 45       	LD        R5, [PC + #5]         ;->0x80002d74  :=0x800023f0
80002d64:	05 5c       	LJMP      R5
##@@@P_:queue.c:875
##@@@L0874_:
##@@@L0875_:            if( xHandle != NULL )   
80002d66:	00 38       	CMP       R0, #0			;->0x00
80002d68:	02 f0       	JZ        $+2                   ;->0x80002d6c
##@@@P_:queue.c:877
##@@@L0876_:            {   
##@@@L0877_:                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;   
80002d6a:	86 a3       	ST.W      [R0 + #14], R6
##@@@P_:queue.c:894
##@@@L0889_:            mtCOVERAGE_TEST_MARKER();   
##@@@L0890_:        }   
##@@@L0891_:
##@@@L0892_:        traceRETURN_xQueueCreateCountingSemaphoreStatic( xHandle );   
##@@@L0893_:
##@@@L0894_:        return xHandle;   
80002d6c:	e4 28       	ADD       SP, #4			;->0x04
80002d6e:	06 5d       	POP       R6
80002d70:	0d 5d       	POP       LR
80002d72:	1d 5c       	JMP       LR
80002d74:	f0 23 00 80 	.long     0x800023f0 ->-2147474448  [!!!@2@:ST.W      [SP + #240], R3	@@: LD.B      R0, [R0]
##@@@P_:queue.c:888
##@@@L0883_:                traceCREATE_COUNTING_SEMAPHORE_FAILED();   
##@@@L0884_:            }   
##@@@L0885_:        }   
##@@@L0886_:        else   
##@@@L0887_:        {   
##@@@L0888_:            configASSERT( xHandle );   
80002d78:	20 5d       	PUSH      R0
80002d7a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002d7e:	08 00       	SYNC     SYNC     
80002d80:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002d84:	08 00       	SYNC     SYNC     
80002d86:	00 5d       	POP       R0
80002d88:	20 5d       	PUSH      R0
80002d8a:	21 5d       	PUSH      R1
80002d8c:	0d 45       	LD        R5, [PC + #13]        ;->0x80002dc0  :=0x1ff
80002d8e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002d92:	25 58       	MOV       R1, R5
80002d94:	11 68       	NOT       R1, R1
80002d96:	01 69       	ANL       R0, R1
80002d98:	5f 11       	MOV       R5, #31			;->0x001F
80002d9a:	25 58       	MOV       R1, R5
80002d9c:	01 6a       	ORL       R0, R1
80002d9e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002da2:	08 00       	SYNC     SYNC     
80002da4:	01 5d       	POP       R1
80002da6:	00 5d       	POP       R0
80002da8:	20 5d       	PUSH      R0
80002daa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002dae:	08 00       	SYNC     SYNC     
80002db0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002db4:	08 00       	SYNC     SYNC     
80002db6:	00 5d       	POP       R0
80002db8:	07 00       	BREAK    BREAK    
80002dba:	03 45       	LD        R5, [PC + #3]         ;->0x80002dc4  :=0x8000911c
80002dbc:	05 5c       	LJMP      R5
80002dbe:	00 00       	NOP      NOP      
80002dc0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002dc4:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002dc8 <xQueueCreateCountingSemaphore>:
##@@@F_:xQueueCreateCountingSemaphore():
##@@@P_:queue.c:904
##@@@L0899_:
##@@@L0900_:#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )   
##@@@L0901_:
##@@@L0902_:    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,   
##@@@L0903_:                                                 const UBaseType_t uxInitialCount )   
##@@@L0904_:    {   
80002dc8:	83 5f       	PUSH      {R6-R7,LR}
80002dca:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:queue.c:909
##@@@L0905_:        QueueHandle_t xHandle = NULL;   
##@@@L0906_:
##@@@L0907_:        traceENTER_xQueueCreateCountingSemaphore( uxMaxCount, uxInitialCount );   
##@@@L0908_:
##@@@L0909_:        if( ( uxMaxCount != 0U ) &&   
80002dcc:	00 38       	CMP       R0, #0			;->0x00
80002dce:	23 f0       	JZ        $+35                  ;->0x80002e14
80002dd0:	e0 58       	MOV       R7, R0
80002dd2:	10 70       	CMP       R1, R0
80002dd4:	20 f8       	JHI       $+32                  ;->0x80002e14
80002dd6:	01 21       	ST.W      [SP + #1], R1
80002dd8:	00 15       	MOV       R0, #80			;->0x0050
##@@@F_:xQueueGenericCreate():
##@@@P_:queue.c:526
##@@@L0521_:            xQueueSizeInBytes = ( size_t ) ( ( size_t ) uxQueueLength * ( size_t ) uxItemSize );   
##@@@L0522_:
##@@@L0523_:            /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L0524_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0525_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0526_:            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );   
80002dda:	0d 45       	LD        R5, [PC + #13]        ;->0x80002e0c  :=0x80008960
80002ddc:	05 5c       	LJMP      R5
80002dde:	c0 58       	MOV       R6, R0
80002de0:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:queue.c:528
##@@@L0527_:
##@@@L0528_:            if( pxNewQueue != NULL )   
80002de2:	60 38       	CMP       R6, #0			;->0x00
80002de4:	10 f0       	JZ        $+16                  ;->0x80002e04
##@@@F_:prvInitialiseNewQueue():
##@@@P_:queue.c:592
##@@@L0587_:        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;   
##@@@L0588_:    }   
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
80002de6:	f7 a3       	ST.W      [R6 + #15], R7
##@@@P_:queue.c:593
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
80002de8:	30 a4       	ST.W      [R6 + #16], R0
##@@@F_:xQueueGenericCreate():
80002dea:	79 00 c0 18 	ST.B      [R6 + #70], R0			;->0x46
##@@@F_:prvInitialiseNewQueue():
##@@@P_:queue.c:540
##@@@L0535_:                #if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L0536_:                {   
##@@@L0537_:                    /* Queues can be created either statically or dynamically, so   
##@@@L0538_:                     * note this task was created dynamically in case it is later   
##@@@L0539_:                     * deleted. */   
##@@@L0540_:                    pxNewQueue->ucStaticallyAllocated = pdFALSE;   
80002dee:	66 85       	ST.W      [R6], R6
80002df0:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:queue.c:594
##@@@L0589_:
##@@@L0590_:    /* Initialise the queue members as described where the queue type is   
##@@@L0591_:     * defined. */   
##@@@L0592_:    pxNewQueue->uxLength = uxQueueLength;   
##@@@L0593_:    pxNewQueue->uxItemSize = uxItemSize;   
##@@@L0594_:    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );   
80002df2:	06 58       	MOV       R0, R6
80002df4:	07 45       	LD        R5, [PC + #7]         ;->0x80002e10  :=0x800022b4
80002df6:	05 5c       	LJMP      R5
80002df8:	52 10       	MOV       R5, #2			;->0x0002
80002dfa:	79 00 c5 30 	ST.B      [R6 + #76], R5			;->0x4C
##@@@F_:xQueueCreateCountingSemaphore():
##@@@P_:queue.c:916
##@@@L0911_:        {   
##@@@L0912_:            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );   
##@@@L0913_:
##@@@L0914_:            if( xHandle != NULL )   
##@@@L0915_:            {   
##@@@L0916_:                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;   
80002dfe:	01 0d       	LD.W      R5, [SP + #1]
80002e00:	b5 a3       	ST.W      [R6 + #14], R5
80002e02:	06 58       	MOV       R0, R6
##@@@P_:queue.c:933
##@@@L0928_:            mtCOVERAGE_TEST_MARKER();   
##@@@L0929_:        }   
##@@@L0930_:
##@@@L0931_:        traceRETURN_xQueueCreateCountingSemaphore( xHandle );   
##@@@L0932_:
##@@@L0933_:        return xHandle;   
80002e04:	e8 28       	ADD       SP, #8			;->0x08
80002e06:	03 5e       	POP       {R6-R7}
80002e08:	0d 5d       	POP       LR
80002e0a:	1d 5c       	JMP       LR
80002e0c:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
80002e10:	b4 22 00 80 	.long     0x800022b4 ->-2147474764  [!!!@2@:ST.W      [SP + #180], R2	@@: LD.B      R0, [R0]
##@@@P_:queue.c:927
##@@@L0922_:                traceCREATE_COUNTING_SEMAPHORE_FAILED();   
##@@@L0923_:            }   
##@@@L0924_:        }   
##@@@L0925_:        else   
##@@@L0926_:        {   
##@@@L0927_:            configASSERT( xHandle );   
80002e14:	20 5d       	PUSH      R0
80002e16:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002e1a:	08 00       	SYNC     SYNC     
80002e1c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80002e20:	08 00       	SYNC     SYNC     
80002e22:	00 5d       	POP       R0
80002e24:	20 5d       	PUSH      R0
80002e26:	21 5d       	PUSH      R1
80002e28:	0d 45       	LD        R5, [PC + #13]        ;->0x80002e5c  :=0x1ff
80002e2a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80002e2e:	25 58       	MOV       R1, R5
80002e30:	11 68       	NOT       R1, R1
80002e32:	01 69       	ANL       R0, R1
80002e34:	5f 11       	MOV       R5, #31			;->0x001F
80002e36:	25 58       	MOV       R1, R5
80002e38:	01 6a       	ORL       R0, R1
80002e3a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80002e3e:	08 00       	SYNC     SYNC     
80002e40:	01 5d       	POP       R1
80002e42:	00 5d       	POP       R0
80002e44:	20 5d       	PUSH      R0
80002e46:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80002e4a:	08 00       	SYNC     SYNC     
80002e4c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80002e50:	08 00       	SYNC     SYNC     
80002e52:	00 5d       	POP       R0
80002e54:	07 00       	BREAK    BREAK    
80002e56:	03 45       	LD        R5, [PC + #3]         ;->0x80002e60  :=0x8000911c
80002e58:	05 5c       	LJMP      R5
80002e5a:	00 00       	NOP      NOP      
80002e5c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80002e60:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80002e64 <prvUnlockQueue>:
##@@@F_:prvUnlockQueue():
##@@@P_:queue.c:2483
##@@@L2478_:    }   
##@@@L2479_:}   
##@@@L2480_:/*-----------------------------------------------------------*/   
##@@@L2481_:
##@@@L2482_:static void prvUnlockQueue( Queue_t * const pxQueue )   
##@@@L2483_:{   
80002e64:	8f 5f       	PUSH      {R6-R9,LR}
80002e66:	e4 30       	SUB       SP, #4			;->0x04
80002e68:	20 59       	MOV       R9, R0
##@@@P_:queue.c:2490
##@@@L2485_:
##@@@L2486_:    /* The lock counts contains the number of extra data items placed or   
##@@@L2487_:     * removed from the queue while the queue was locked.  When a queue is   
##@@@L2488_:     * locked items can be added or removed, but the event lists cannot be   
##@@@L2489_:     * updated. */   
##@@@L2490_:    taskENTER_CRITICAL();   
80002e6a:	21 45       	LD        R5, [PC + #33]        ;->0x80002eec  :=0x800056cc
80002e6c:	05 5c       	LJMP      R5
80002e6e:	61 00 26 15 	LDS.B     R6, [R9 + #69]			;->0x45
##@@@P_:queue.c:2495
##@@@L2491_:    {   
##@@@L2492_:        int8_t cTxLock = pxQueue->cTxLock;   
##@@@L2493_:
##@@@L2494_:        /* See if data was added to the queue while it was locked. */   
##@@@L2495_:        while( cTxLock > queueLOCKED_UNMODIFIED )   
80002e72:	61 38       	CMP       R6, #1			;->0x01
80002e74:	15 fb       	JLT       $+21                  ;->0x80002e9e
80002e76:	e9 58       	MOV       R7, R9
80002e78:	74 2a       	ADD       R7, #36			;->0x24
80002e7a:	07 04       	SJMP      $+7                   ;->0x80002e88
##@@@P_:queue.c:2563
##@@@L2558_:                    break;   
##@@@L2559_:                }   
##@@@L2560_:            }   
##@@@L2561_:            #endif /* configUSE_QUEUE_SETS */   
##@@@L2562_:
##@@@L2563_:            --cTxLock;   
80002e7c:	6e cc       	SUB       R5, R6, #1
80002e7e:	b0 7b       	LSL       R6, #24			;->0x18
80002e80:	b0 79       	ASR       R6, #24			;->0x18
##@@@P_:queue.c:2495
##@@@L2490_:    taskENTER_CRITICAL();   
##@@@L2491_:    {   
##@@@L2492_:        int8_t cTxLock = pxQueue->cTxLock;   
##@@@L2493_:
##@@@L2494_:        /* See if data was added to the queue while it was locked. */   
##@@@L2495_:        while( cTxLock > queueLOCKED_UNMODIFIED )   
80002e82:	61 38       	CMP       R6, #1			;->0x01
80002e84:	c5 58       	MOV       R6, R5
80002e86:	0c fd       	JLE       $+12                  ;->0x80002e9e
##@@@P_:queue.c:2543
##@@@L2538_:            }   
##@@@L2539_:            #else /* configUSE_QUEUE_SETS */   
##@@@L2540_:            {   
##@@@L2541_:                /* Tasks that are removed from the event list will get added to   
##@@@L2542_:                 * the pending ready list as the scheduler is still suspended. */   
##@@@L2543_:                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )   
80002e88:	57 82       	LD.W      R5, [R7]
80002e8a:	50 38       	CMP       R5, #0			;->0x00
80002e8c:	09 f0       	JZ        $+9                   ;->0x80002e9e
##@@@P_:queue.c:2545
##@@@L2544_:                {   
##@@@L2545_:                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )   
80002e8e:	07 58       	MOV       R0, R7
80002e90:	18 45       	LD        R5, [PC + #24]        ;->0x80002ef0  :=0x80006ffc
80002e92:	05 5c       	LJMP      R5
80002e94:	00 38       	CMP       R0, #0			;->0x00
80002e96:	f3 f0       	JZ        $-13                  ;->0x80002e7c
##@@@P_:queue.c:2549
##@@@L2546_:                    {   
##@@@L2547_:                        /* The task waiting has a higher priority so record that   
##@@@L2548_:                         * a context switch is required. */   
##@@@L2549_:                        vTaskMissedYield();   
80002e98:	17 45       	LD        R5, [PC + #23]        ;->0x80002ef4  :=0x80007438
80002e9a:	05 5c       	LJMP      R5
80002e9c:	f0 07       	SJMP      $-16                  ;->0x80002e7c
80002e9e:	8f 1f       	MOV       R8, #255			;->0x00FF
80002ea0:	79 00 28 15 	ST.B      [R9 + #69], R8			;->0x45
##@@@P_:queue.c:2568
##@@@L2563_:            --cTxLock;   
##@@@L2564_:        }   
##@@@L2565_:
##@@@L2566_:        pxQueue->cTxLock = queueUNLOCKED;   
##@@@L2567_:    }   
##@@@L2568_:    taskEXIT_CRITICAL();   
80002ea4:	15 45       	LD        R5, [PC + #21]        ;->0x80002ef8  :=0x80005730
80002ea6:	05 5c       	LJMP      R5
##@@@P_:queue.c:2571
##@@@L2569_:
##@@@L2570_:    /* Do the same for the Rx lock. */   
##@@@L2571_:    taskENTER_CRITICAL();   
80002ea8:	11 45       	LD        R5, [PC + #17]        ;->0x80002eec  :=0x800056cc
80002eaa:	05 5c       	LJMP      R5
80002eac:	61 00 26 11 	LDS.B     R6, [R9 + #68]			;->0x44
##@@@P_:queue.c:2575
##@@@L2572_:    {   
##@@@L2573_:        int8_t cRxLock = pxQueue->cRxLock;   
##@@@L2574_:
##@@@L2575_:        while( cRxLock > queueLOCKED_UNMODIFIED )   
80002eb0:	61 38       	CMP       R6, #1			;->0x01
80002eb2:	15 fb       	JLT       $+21                  ;->0x80002edc
80002eb4:	e9 58       	MOV       R7, R9
80002eb6:	70 29       	ADD       R7, #16			;->0x10
80002eb8:	07 04       	SJMP      $+7                   ;->0x80002ec6
##@@@P_:queue.c:2588
##@@@L2583_:                else   
##@@@L2584_:                {   
##@@@L2585_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L2586_:                }   
##@@@L2587_:
##@@@L2588_:                --cRxLock;   
80002eba:	6e cc       	SUB       R5, R6, #1
80002ebc:	b0 7b       	LSL       R6, #24			;->0x18
80002ebe:	b0 79       	ASR       R6, #24			;->0x18
##@@@P_:queue.c:2575
##@@@L2570_:    /* Do the same for the Rx lock. */   
##@@@L2571_:    taskENTER_CRITICAL();   
##@@@L2572_:    {   
##@@@L2573_:        int8_t cRxLock = pxQueue->cRxLock;   
##@@@L2574_:
##@@@L2575_:        while( cRxLock > queueLOCKED_UNMODIFIED )   
80002ec0:	61 38       	CMP       R6, #1			;->0x01
80002ec2:	c5 58       	MOV       R6, R5
80002ec4:	0c fd       	JLE       $+12                  ;->0x80002edc
##@@@P_:queue.c:2577
##@@@L2576_:        {   
##@@@L2577_:            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )   
80002ec6:	57 82       	LD.W      R5, [R7]
80002ec8:	50 38       	CMP       R5, #0			;->0x00
80002eca:	09 f0       	JZ        $+9                   ;->0x80002edc
##@@@P_:queue.c:2579
##@@@L2578_:            {   
##@@@L2579_:                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )   
80002ecc:	07 58       	MOV       R0, R7
80002ece:	09 45       	LD        R5, [PC + #9]         ;->0x80002ef0  :=0x80006ffc
80002ed0:	05 5c       	LJMP      R5
80002ed2:	00 38       	CMP       R0, #0			;->0x00
80002ed4:	f3 f0       	JZ        $-13                  ;->0x80002eba
##@@@P_:queue.c:2581
##@@@L2580_:                {   
##@@@L2581_:                    vTaskMissedYield();   
80002ed6:	08 45       	LD        R5, [PC + #8]         ;->0x80002ef4  :=0x80007438
80002ed8:	05 5c       	LJMP      R5
80002eda:	f0 07       	SJMP      $-16                  ;->0x80002eba
80002edc:	79 00 28 11 	ST.B      [R9 + #68], R8			;->0x44
##@@@P_:queue.c:2598
##@@@L2593_:            }   
##@@@L2594_:        }   
##@@@L2595_:
##@@@L2596_:        pxQueue->cRxLock = queueUNLOCKED;   
##@@@L2597_:    }   
##@@@L2598_:    taskEXIT_CRITICAL();   
80002ee0:	06 45       	LD        R5, [PC + #6]         ;->0x80002ef8  :=0x80005730
80002ee2:	05 5c       	LJMP      R5
##@@@P_:queue.c:2599
##@@@L2599_:}   
80002ee4:	e4 28       	ADD       SP, #4			;->0x04
80002ee6:	0f 5e       	POP       {R6-R9}
80002ee8:	0d 5d       	POP       LR
80002eea:	1d 5c       	JMP       LR
80002eec:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80002eec
80002ef0:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
80002ef4:	38 74 00 80 	.long     0x80007438 ->-2147453896  [!!!@2@:LD.H      R3, [R8++]	@@: LD.B      R0, [R0]
80002ef8:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80002ef8

80002efc <xQueueGenericSendFromISR>:
##@@@F_:xQueueGenericSendFromISR():
##@@@P_:queue.c:1161
##@@@L1156_:
##@@@L1157_:BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,   
##@@@L1158_:                                     const void * const pvItemToQueue,   
##@@@L1159_:                                     BaseType_t * const pxHigherPriorityTaskWoken,   
##@@@L1160_:                                     const BaseType_t xCopyPosition )   
##@@@L1161_:{   
80002efc:	bf 5f       	PUSH      {R6-R11,LR}
80002efe:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:queue.c:1168
##@@@L1163_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L1164_:    Queue_t * const pxQueue = xQueue;   
##@@@L1165_:
##@@@L1166_:    traceENTER_xQueueGenericSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition );   
##@@@L1167_:
##@@@L1168_:    configASSERT( pxQueue );   
80002f00:	00 38       	CMP       R0, #0			;->0x00
80002f02:	02 f1       	JNZ       $+2                   ;->0x80002f06
80002f04:	92 04       	SJMP      $+146                 ;->0x80003028
80002f06:	e0 58       	MOV       R7, R0
80002f08:	43 59       	MOV       R10, R3
80002f0a:	02 59       	MOV       R8, R2
80002f0c:	61 59       	MOV       R11, R1
##@@@P_:queue.c:1169
##@@@L1169_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
80002f0e:	10 38       	CMP       R1, #0			;->0x00
80002f10:	05 f1       	JNZ       $+5                   ;->0x80002f1a
80002f12:	2f 9c       	LD.W      R5, [R7 + #16]
80002f14:	50 38       	CMP       R5, #0			;->0x00
80002f16:	02 f0       	JZ        $+2                   ;->0x80002f1a
80002f18:	ce 04       	SJMP      $+206                 ;->0x800030b4
##@@@P_:queue.c:1170
##@@@L1170_:    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );   
80002f1a:	a2 38       	CMP       R10, #2			;->0x02
80002f1c:	05 f1       	JNZ       $+5                   ;->0x80002f26
80002f1e:	ef 9b       	LD.W      R5, [R7 + #15]
80002f20:	51 38       	CMP       R5, #1			;->0x01
80002f22:	02 f0       	JZ        $+2                   ;->0x80002f26
80002f24:	a5 04       	SJMP      $+165                 ;->0x8000306e
##@@@P_:queue.c:1193
##@@@L1188_:    /* Similar to xQueueGenericSend, except without blocking if there is no room   
##@@@L1189_:     * in the queue.  Also don't directly wake a task that was blocked on a queue   
##@@@L1190_:     * read, instead return a flag to say whether a context switch is required or   
##@@@L1191_:     * not (i.e. has a task with a higher priority than us been woken by this   
##@@@L1192_:     * post). */   
##@@@L1193_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80002f26:	3a 45       	LD        R5, [PC + #58]        ;->0x8000300c  :=0x80008ff0
80002f28:	05 5c       	LJMP      R5
80002f2a:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:queue.c:1195
##@@@L1194_:    {   
##@@@L1195_:        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )   
80002f2c:	ef 9b       	LD.W      R5, [R7 + #15]
80002f2e:	a7 9b       	LD.W      R4, [R7 + #14]
80002f30:	a2 38       	CMP       R10, #2			;->0x02
##@@@P_:queue.c:1193
##@@@L1188_:    /* Similar to xQueueGenericSend, except without blocking if there is no room   
##@@@L1189_:     * in the queue.  Also don't directly wake a task that was blocked on a queue   
##@@@L1190_:     * read, instead return a flag to say whether a context switch is required or   
##@@@L1191_:     * not (i.e. has a task with a higher priority than us been woken by this   
##@@@L1192_:     * post). */   
##@@@L1193_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80002f32:	20 59       	MOV       R9, R0
##@@@P_:queue.c:1195
##@@@L1194_:    {   
##@@@L1195_:        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )   
80002f34:	04 f0       	JZ        $+4                   ;->0x80002f3c
80002f36:	45 70       	CMP       R4, R5
80002f38:	02 f3       	JNC       $+2                   ;->0x80002f3c
80002f3a:	61 04       	SJMP      $+97                  ;->0x80002ffc
80002f3c:	61 00 e5 14 	LDS.B     R5, [R7 + #69]			;->0x45
##@@@P_:queue.c:1198
##@@@L1196_:        {   
##@@@L1197_:            const int8_t cTxLock = pxQueue->cTxLock;   
##@@@L1198_:            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;   
80002f40:	02 25       	ST.W      [SP + #2], R5
80002f42:	af 9b       	LD.W      R5, [R7 + #14]
##@@@F_:prvCopyDataToQueue():
##@@@P_:queue.c:2387
##@@@L2382_:    BaseType_t xReturn = pdFALSE;   
##@@@L2383_:    UBaseType_t uxMessagesWaiting;   
##@@@L2384_:
##@@@L2385_:    /* This function is called from a critical section. */   
##@@@L2386_:
##@@@L2387_:    uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
80002f44:	9f 9b       	LD.W      R3, [R7 + #14]
##@@@P_:queue.c:2389
##@@@L2388_:
##@@@L2389_:    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )   
80002f46:	17 9c       	LD.W      R2, [R7 + #16]
80002f48:	20 38       	CMP       R2, #0			;->0x00
80002f4a:	1f f0       	JZ        $+31                  ;->0x80002f88
80002f4c:	01 23       	ST.W      [SP + #1], R3
##@@@P_:queue.c:2406
##@@@L2401_:                mtCOVERAGE_TEST_MARKER();   
##@@@L2402_:            }   
##@@@L2403_:        }   
##@@@L2404_:        #endif /* configUSE_MUTEXES */   
##@@@L2405_:    }   
##@@@L2406_:    else if( xPosition == queueSEND_TO_BACK )   
80002f4e:	a0 38       	CMP       R10, #0			;->0x00
80002f50:	28 f0       	JZ        $+40                  ;->0x80002fa0
##@@@P_:queue.c:2422
##@@@L2417_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2418_:        }   
##@@@L2419_:    }   
##@@@L2420_:    else   
##@@@L2421_:    {   
##@@@L2422_:        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );   
80002f52:	c7 98       	LD.W      R0, [R7 + #3]
80002f54:	2b 58       	MOV       R1, R11
80002f56:	2f 45       	LD        R5, [PC + #47]        ;->0x80003010  :=0x8000d9ec
80002f58:	05 5c       	LJMP      R5
##@@@P_:queue.c:2423
##@@@L2423_:        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;   
80002f5a:	2f 9c       	LD.W      R5, [R7 + #16]
80002f5c:	e7 98       	LD.W      R4, [R7 + #3]
80002f5e:	64 c7       	SUB       R4, R4, R5
80002f60:	fc a0       	ST.W      [R7 + #3], R4
##@@@P_:queue.c:2425
##@@@L2424_:
##@@@L2425_:        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead )   
80002f62:	37 82       	LD.W      R3, [R7]
80002f64:	43 70       	CMP       R4, R3
80002f66:	05 f2       	JC        $+5                   ;->0x80002f70
##@@@P_:queue.c:2427
##@@@L2426_:        {   
##@@@L2427_:            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );   
80002f68:	a7 98       	LD.W      R4, [R7 + #2]
80002f6a:	6e c7       	SUB       R5, R6, R5
80002f6c:	6c c3       	ADD       R5, R4, R5
80002f6e:	fd a0       	ST.W      [R7 + #3], R5
##@@@F_:xQueueGenericSendFromISR():
80002f70:	41 10       	MOV       R4, #1			;->0x0001
80002f72:	a4 58       	MOV       R5, R4
80002f74:	01 0b       	LD.W      R3, [SP + #1]
##@@@P_:queue.c:1170
##@@@L1165_:
##@@@L1166_:    traceENTER_xQueueGenericSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition );   
##@@@L1167_:
##@@@L1168_:    configASSERT( pxQueue );   
##@@@L1169_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
##@@@L1170_:    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );   
80002f76:	a2 38       	CMP       R10, #2			;->0x02
80002f78:	02 f0       	JZ        $+2                   ;->0x80002f7c
80002f7a:	a6 58       	MOV       R5, R6
80002f7c:	30 38       	CMP       R3, #0			;->0x00
80002f7e:	02 f1       	JNZ       $+2                   ;->0x80002f82
80002f80:	86 58       	MOV       R4, R6
##@@@F_:prvCopyDataToQueue():
##@@@P_:queue.c:2434
##@@@L2429_:        else   
##@@@L2430_:        {   
##@@@L2431_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2432_:        }   
##@@@L2433_:
##@@@L2434_:        if( xPosition == queueOVERWRITE )   
80002f82:	54 69       	ANL       R5, R4
80002f84:	5b c7       	SUB       R3, R3, R5
80002f86:	0b 04       	SJMP      $+11                  ;->0x80002f9c
##@@@P_:queue.c:2393
##@@@L2388_:
##@@@L2389_:    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )   
##@@@L2390_:    {   
##@@@L2391_:        #if ( configUSE_MUTEXES == 1 )   
##@@@L2392_:        {   
##@@@L2393_:            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )   
80002f88:	57 82       	LD.W      R5, [R7]
80002f8a:	50 38       	CMP       R5, #0			;->0x00
80002f8c:	08 f1       	JNZ       $+8                   ;->0x80002f9c
##@@@P_:queue.c:2396
##@@@L2394_:            {   
##@@@L2395_:                /* The mutex is no longer being held. */   
##@@@L2396_:                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );   
80002f8e:	87 98       	LD.W      R0, [R7 + #2]
80002f90:	c3 58       	MOV       R6, R3
80002f92:	21 45       	LD        R5, [PC + #33]        ;->0x80003014  :=0x800076c4
80002f94:	05 5c       	LJMP      R5
80002f96:	66 58       	MOV       R3, R6
80002f98:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:queue.c:2397
##@@@L2397_:                pxQueue->u.xSemaphore.xMutexHolder = NULL;   
80002f9a:	bd a0       	ST.W      [R7 + #2], R5
80002f9c:	02 0e       	LD.W      R6, [SP + #2]
80002f9e:	10 04       	SJMP      $+16                  ;->0x80002fbe
##@@@P_:queue.c:2408
##@@@L2403_:        }   
##@@@L2404_:        #endif /* configUSE_MUTEXES */   
##@@@L2405_:    }   
##@@@L2406_:    else if( xPosition == queueSEND_TO_BACK )   
##@@@L2407_:    {   
##@@@L2408_:        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );   
80002fa0:	47 98       	LD.W      R0, [R7 + #1]
80002fa2:	2b 58       	MOV       R1, R11
80002fa4:	1b 45       	LD        R5, [PC + #27]        ;->0x80003010  :=0x8000d9ec
80002fa6:	05 5c       	LJMP      R5
##@@@P_:queue.c:2409
##@@@L2409_:        pxQueue->pcWriteTo += pxQueue->uxItemSize;   
80002fa8:	2f 9c       	LD.W      R5, [R7 + #16]
80002faa:	67 98       	LD.W      R4, [R7 + #1]
80002fac:	6c c3       	ADD       R5, R4, R5
80002fae:	7d a0       	ST.W      [R7 + #1], R5
##@@@P_:queue.c:2411
##@@@L2410_:
##@@@L2411_:        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )   
80002fb0:	a7 98       	LD.W      R4, [R7 + #2]
80002fb2:	54 70       	CMP       R5, R4
80002fb4:	03 f3       	JNC       $+3                   ;->0x80002fba
##@@@P_:queue.c:2413
##@@@L2412_:        {   
##@@@L2413_:            pxQueue->pcWriteTo = pxQueue->pcHead;   
80002fb6:	57 82       	LD.W      R5, [R7]
80002fb8:	7d a0       	ST.W      [R7 + #1], R5
##@@@F_:xQueueGenericSendFromISR():
80002fba:	02 0e       	LD.W      R6, [SP + #2]
80002fbc:	01 0b       	LD.W      R3, [SP + #1]
##@@@P_:queue.c:1211
##@@@L1206_:             *  the scheduler is suspended before accessing the ready lists. */   
##@@@L1207_:            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );   
##@@@L1208_:
##@@@L1209_:            /* The event list is not altered if the queue is locked.  This will   
##@@@L1210_:             * be done when the queue is unlocked later. */   
##@@@L1211_:            if( cTxLock == queueUNLOCKED )   
80002fbe:	17 45       	LD        R5, [PC + #23]        ;->0x80003018  :=0xffffffff
##@@@F_:prvCopyDataToQueue():
##@@@P_:queue.c:2455
##@@@L2450_:        {   
##@@@L2451_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2452_:        }   
##@@@L2453_:    }   
##@@@L2454_:
##@@@L2455_:    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );   
80002fc0:	63 c0       	ADD       R4, R3, #1
##@@@F_:xQueueGenericSendFromISR():
##@@@P_:queue.c:1211
##@@@L1206_:             *  the scheduler is suspended before accessing the ready lists. */   
##@@@L1207_:            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );   
##@@@L1208_:
##@@@L1209_:            /* The event list is not altered if the queue is locked.  This will   
##@@@L1210_:             * be done when the queue is unlocked later. */   
##@@@L1211_:            if( cTxLock == queueUNLOCKED )   
80002fc2:	65 70       	CMP       R6, R5
##@@@F_:prvCopyDataToQueue():
##@@@P_:queue.c:2455
##@@@L2450_:        {   
##@@@L2451_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2452_:        }   
##@@@L2453_:    }   
##@@@L2454_:
##@@@L2455_:    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );   
80002fc4:	bc a3       	ST.W      [R7 + #14], R4
##@@@F_:xQueueGenericSendFromISR():
##@@@P_:queue.c:1211
##@@@L1206_:             *  the scheduler is suspended before accessing the ready lists. */   
##@@@L1207_:            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );   
##@@@L1208_:
##@@@L1209_:            /* The event list is not altered if the queue is locked.  This will   
##@@@L1210_:             * be done when the queue is unlocked later. */   
##@@@L1211_:            if( cTxLock == queueUNLOCKED )   
80002fc6:	0c f0       	JZ        $+12                  ;->0x80002fde
##@@@P_:queue.c:1307
##@@@L1302_:            }   
##@@@L1303_:            else   
##@@@L1304_:            {   
##@@@L1305_:                /* Increment the lock count so the task that unlocks the queue   
##@@@L1306_:                 * knows that data was posted while it was locked. */   
##@@@L1307_:                prvIncrementQueueTxLock( pxQueue, cTxLock );   
80002fc8:	15 45       	LD        R5, [PC + #21]        ;->0x8000301c  :=0x800069d0
80002fca:	05 5c       	LJMP      R5
80002fcc:	06 70       	CMP       R0, R6
80002fce:	16 f9       	JLS       $+22                  ;->0x80002ffa
80002fd0:	6f 3f       	CMP       R6, #127			;->0x7F
80002fd2:	02 f1       	JNZ       $+2                   ;->0x80002fd6
80002fd4:	93 04       	SJMP      $+147                 ;->0x800030fa
80002fd6:	6e c0       	ADD       R5, R6, #1
80002fd8:	79 00 e5 14 	ST.B      [R7 + #69], R5			;->0x45
80002fdc:	0f 04       	SJMP      $+15                  ;->0x80002ffa
##@@@P_:queue.c:1273
##@@@L1268_:                        }   
##@@@L1269_:                    }   
##@@@L1270_:                }   
##@@@L1271_:                #else /* configUSE_QUEUE_SETS */   
##@@@L1272_:                {   
##@@@L1273_:                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )   
80002fde:	6f 9a       	LD.W      R5, [R7 + #9]
80002fe0:	50 38       	CMP       R5, #0			;->0x00
80002fe2:	0c f0       	JZ        $+12                  ;->0x80002ffa
80002fe4:	74 2a       	ADD       R7, #36			;->0x24
##@@@P_:queue.c:1275
##@@@L1274_:                    {   
##@@@L1275_:                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )   
80002fe6:	07 58       	MOV       R0, R7
80002fe8:	0e 45       	LD        R5, [PC + #14]        ;->0x80003020  :=0x80006ffc
80002fea:	05 5c       	LJMP      R5
80002fec:	61 10       	MOV       R6, #1			;->0x0001
80002fee:	80 38       	CMP       R8, #0			;->0x00
80002ff0:	06 f0       	JZ        $+6                   ;->0x80002ffc
80002ff2:	00 38       	CMP       R0, #0			;->0x00
80002ff4:	04 f0       	JZ        $+4                   ;->0x80002ffc
##@@@P_:queue.c:1281
##@@@L1276_:                        {   
##@@@L1277_:                            /* The task waiting has a higher priority so record that a   
##@@@L1278_:                             * context switch is required. */   
##@@@L1279_:                            if( pxHigherPriorityTaskWoken != NULL )   
##@@@L1280_:                            {   
##@@@L1281_:                                *pxHigherPriorityTaskWoken = pdTRUE;   
80002ff6:	86 85       	ST.W      [R8], R6
80002ff8:	02 04       	SJMP      $+2                   ;->0x80002ffc
80002ffa:	61 10       	MOV       R6, #1			;->0x0001
##@@@P_:queue.c:1318
##@@@L1313_:        {   
##@@@L1314_:            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );   
##@@@L1315_:            xReturn = errQUEUE_FULL;   
##@@@L1316_:        }   
##@@@L1317_:    }   
##@@@L1318_:    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80002ffc:	09 58       	MOV       R0, R9
80002ffe:	0a 45       	LD        R5, [PC + #10]        ;->0x80003024  :=0x80009034
80003000:	05 5c       	LJMP      R5
##@@@P_:queue.c:1322
##@@@L1319_:
##@@@L1320_:    traceRETURN_xQueueGenericSendFromISR( xReturn );   
##@@@L1321_:
##@@@L1322_:    return xReturn;   
80003002:	06 58       	MOV       R0, R6
80003004:	ec 28       	ADD       SP, #12			;->0x0C
80003006:	3f 5e       	POP       {R6-R11}
80003008:	0d 5d       	POP       LR
8000300a:	1d 5c       	JMP       LR
8000300c:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
80003010:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
80003014:	c4 76 00 80 	.long     0x800076c4 ->-2147453244  [!!!@2@:LD.B      R12, [R4++]	@@: LD.B      R0, [R0]
80003018:	ff ff ff ff 	.long     0xffffffff ->-00000001 
8000301c:	d0 69 00 80 	.long     0x800069d0 ->-2147456560  [!!!@2@:ANL       LR, R0	@@: LD.B      R0, [R0]
80003020:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
80003024:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:queue.c:1168
##@@@L1163_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L1164_:    Queue_t * const pxQueue = xQueue;   
##@@@L1165_:
##@@@L1166_:    traceENTER_xQueueGenericSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition );   
##@@@L1167_:
##@@@L1168_:    configASSERT( pxQueue );   
80003028:	20 5d       	PUSH      R0
8000302a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000302e:	08 00       	SYNC     SYNC     
80003030:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003034:	08 00       	SYNC     SYNC     
80003036:	00 5d       	POP       R0
80003038:	20 5d       	PUSH      R0
8000303a:	21 5d       	PUSH      R1
8000303c:	41 45       	LD        R5, [PC + #65]        ;->0x80003140  :=0x1ff
8000303e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003042:	25 58       	MOV       R1, R5
80003044:	11 68       	NOT       R1, R1
80003046:	01 69       	ANL       R0, R1
80003048:	5f 11       	MOV       R5, #31			;->0x001F
8000304a:	25 58       	MOV       R1, R5
8000304c:	01 6a       	ORL       R0, R1
8000304e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003052:	08 00       	SYNC     SYNC     
80003054:	01 5d       	POP       R1
80003056:	00 5d       	POP       R0
80003058:	20 5d       	PUSH      R0
8000305a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000305e:	08 00       	SYNC     SYNC     
80003060:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003064:	08 00       	SYNC     SYNC     
80003066:	00 5d       	POP       R0
80003068:	07 00       	BREAK    BREAK    
8000306a:	37 45       	LD        R5, [PC + #55]        ;->0x80003144  :=0x8000911c
8000306c:	05 5c       	LJMP      R5
##@@@P_:queue.c:1170
##@@@L1169_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
##@@@L1170_:    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );   
8000306e:	20 5d       	PUSH      R0
80003070:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003074:	08 00       	SYNC     SYNC     
80003076:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000307a:	08 00       	SYNC     SYNC     
8000307c:	00 5d       	POP       R0
8000307e:	20 5d       	PUSH      R0
80003080:	21 5d       	PUSH      R1
80003082:	30 45       	LD        R5, [PC + #48]        ;->0x80003140  :=0x1ff
80003084:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003088:	25 58       	MOV       R1, R5
8000308a:	11 68       	NOT       R1, R1
8000308c:	01 69       	ANL       R0, R1
8000308e:	5f 11       	MOV       R5, #31			;->0x001F
80003090:	25 58       	MOV       R1, R5
80003092:	01 6a       	ORL       R0, R1
80003094:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003098:	08 00       	SYNC     SYNC     
8000309a:	01 5d       	POP       R1
8000309c:	00 5d       	POP       R0
8000309e:	20 5d       	PUSH      R0
800030a0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800030a4:	08 00       	SYNC     SYNC     
800030a6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800030aa:	08 00       	SYNC     SYNC     
800030ac:	00 5d       	POP       R0
800030ae:	07 00       	BREAK    BREAK    
800030b0:	25 45       	LD        R5, [PC + #37]        ;->0x80003144  :=0x8000911c
800030b2:	05 5c       	LJMP      R5
##@@@P_:queue.c:1169
##@@@L1164_:    Queue_t * const pxQueue = xQueue;   
##@@@L1165_:
##@@@L1166_:    traceENTER_xQueueGenericSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition );   
##@@@L1167_:
##@@@L1168_:    configASSERT( pxQueue );   
##@@@L1169_:    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
800030b4:	20 5d       	PUSH      R0
800030b6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800030ba:	08 00       	SYNC     SYNC     
800030bc:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800030c0:	08 00       	SYNC     SYNC     
800030c2:	00 5d       	POP       R0
800030c4:	20 5d       	PUSH      R0
800030c6:	21 5d       	PUSH      R1
800030c8:	1e 45       	LD        R5, [PC + #30]        ;->0x80003140  :=0x1ff
800030ca:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800030ce:	25 58       	MOV       R1, R5
800030d0:	11 68       	NOT       R1, R1
800030d2:	01 69       	ANL       R0, R1
800030d4:	5f 11       	MOV       R5, #31			;->0x001F
800030d6:	25 58       	MOV       R1, R5
800030d8:	01 6a       	ORL       R0, R1
800030da:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800030de:	08 00       	SYNC     SYNC     
800030e0:	01 5d       	POP       R1
800030e2:	00 5d       	POP       R0
800030e4:	20 5d       	PUSH      R0
800030e6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800030ea:	08 00       	SYNC     SYNC     
800030ec:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800030f0:	08 00       	SYNC     SYNC     
800030f2:	00 5d       	POP       R0
800030f4:	07 00       	BREAK    BREAK    
800030f6:	14 45       	LD        R5, [PC + #20]        ;->0x80003144  :=0x8000911c
800030f8:	05 5c       	LJMP      R5
##@@@P_:queue.c:1307
##@@@L1302_:            }   
##@@@L1303_:            else   
##@@@L1304_:            {   
##@@@L1305_:                /* Increment the lock count so the task that unlocks the queue   
##@@@L1306_:                 * knows that data was posted while it was locked. */   
##@@@L1307_:                prvIncrementQueueTxLock( pxQueue, cTxLock );   
800030fa:	20 5d       	PUSH      R0
800030fc:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003100:	08 00       	SYNC     SYNC     
80003102:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003106:	08 00       	SYNC     SYNC     
80003108:	00 5d       	POP       R0
8000310a:	20 5d       	PUSH      R0
8000310c:	21 5d       	PUSH      R1
8000310e:	0d 45       	LD        R5, [PC + #13]        ;->0x80003140  :=0x1ff
80003110:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003114:	25 58       	MOV       R1, R5
80003116:	11 68       	NOT       R1, R1
80003118:	01 69       	ANL       R0, R1
8000311a:	5f 11       	MOV       R5, #31			;->0x001F
8000311c:	25 58       	MOV       R1, R5
8000311e:	01 6a       	ORL       R0, R1
80003120:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003124:	08 00       	SYNC     SYNC     
80003126:	01 5d       	POP       R1
80003128:	00 5d       	POP       R0
8000312a:	20 5d       	PUSH      R0
8000312c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003130:	08 00       	SYNC     SYNC     
80003132:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003136:	08 00       	SYNC     SYNC     
80003138:	00 5d       	POP       R0
8000313a:	07 00       	BREAK    BREAK    
8000313c:	02 45       	LD        R5, [PC + #2]         ;->0x80003144  :=0x8000911c
8000313e:	05 5c       	LJMP      R5
80003140:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003144:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003148 <xQueueGiveFromISR>:
##@@@F_:xQueueGiveFromISR():
##@@@P_:queue.c:1328
##@@@L1323_:}   
##@@@L1324_:/*-----------------------------------------------------------*/   
##@@@L1325_:
##@@@L1326_:BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,   
##@@@L1327_:                              BaseType_t * const pxHigherPriorityTaskWoken )   
##@@@L1328_:{   
80003148:	8f 5f       	PUSH      {R6-R9,LR}
8000314a:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:queue.c:1341
##@@@L1336_:     * item size is 0.  Don't directly wake a task that was blocked on a queue   
##@@@L1337_:     * read, instead return a flag to say whether a context switch is required or   
##@@@L1338_:     * not (i.e. has a task with a higher priority than us been woken by this   
##@@@L1339_:     * post). */   
##@@@L1340_:
##@@@L1341_:    configASSERT( pxQueue );   
8000314c:	00 38       	CMP       R0, #0			;->0x00
8000314e:	4b f0       	JZ        $+75                  ;->0x800031e4
80003150:	e0 58       	MOV       R7, R0
##@@@P_:queue.c:1345
##@@@L1342_:
##@@@L1343_:    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()   
##@@@L1344_:     * if the item size is not 0. */   
##@@@L1345_:    configASSERT( pxQueue->uxItemSize == 0 );   
80003152:	28 9c       	LD.W      R5, [R0 + #16]
80003154:	50 38       	CMP       R5, #0			;->0x00
80003156:	6a f1       	JNZ       $+106                 ;->0x8000322a
80003158:	01 59       	MOV       R8, R1
##@@@P_:queue.c:1350
##@@@L1346_:
##@@@L1347_:    /* Normally a mutex would not be given from an interrupt, especially if   
##@@@L1348_:     * there is a mutex holder, as priority inheritance makes no sense for an   
##@@@L1349_:     * interrupts, only tasks. */   
##@@@L1350_:    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );   
8000315a:	57 82       	LD.W      R5, [R7]
8000315c:	50 38       	CMP       R5, #0			;->0x00
8000315e:	05 f1       	JNZ       $+5                   ;->0x80003168
80003160:	af 98       	LD.W      R5, [R7 + #2]
80003162:	50 38       	CMP       R5, #0			;->0x00
80003164:	02 f0       	JZ        $+2                   ;->0x80003168
80003166:	85 04       	SJMP      $+133                 ;->0x80003270
##@@@P_:queue.c:1368
##@@@L1363_:     * safe API to ensure interrupt entry is as fast and as simple as possible.   
##@@@L1364_:     * More information (albeit Cortex-M specific) is provided on the following   
##@@@L1365_:     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L1366_:    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L1367_:
##@@@L1368_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80003168:	1b 45       	LD        R5, [PC + #27]        ;->0x800031d4  :=0x80008ff0
8000316a:	05 5c       	LJMP      R5
##@@@P_:queue.c:1370
##@@@L1369_:    {   
##@@@L1370_:        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
8000316c:	af 9b       	LD.W      R5, [R7 + #14]
##@@@P_:queue.c:1375
##@@@L1371_:
##@@@L1372_:        /* When the queue is used to implement a semaphore no data is ever   
##@@@L1373_:         * moved through the queue but it is still valid to see if the queue 'has   
##@@@L1374_:         * space'. */   
##@@@L1375_:        if( uxMessagesWaiting < pxQueue->uxLength )   
8000316e:	e7 9b       	LD.W      R4, [R7 + #15]
80003170:	54 70       	CMP       R5, R4
##@@@P_:queue.c:1368
##@@@L1363_:     * safe API to ensure interrupt entry is as fast and as simple as possible.   
##@@@L1364_:     * More information (albeit Cortex-M specific) is provided on the following   
##@@@L1365_:     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L1366_:    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L1367_:
##@@@L1368_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80003172:	20 59       	MOV       R9, R0
##@@@P_:queue.c:1375
##@@@L1370_:        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
##@@@L1371_:
##@@@L1372_:        /* When the queue is used to implement a semaphore no data is ever   
##@@@L1373_:         * moved through the queue but it is still valid to see if the queue 'has   
##@@@L1374_:         * space'. */   
##@@@L1375_:        if( uxMessagesWaiting < pxQueue->uxLength )   
80003174:	17 f2       	JC        $+23                  ;->0x800031a2
##@@@P_:queue.c:1387
##@@@L1382_:             * holder - and if there is a mutex holder then the mutex cannot be   
##@@@L1383_:             * given from an ISR.  As this is the ISR version of the function it   
##@@@L1384_:             * can be assumed there is no mutex holder and no need to determine if   
##@@@L1385_:             * priority disinheritance is needed.  Simply increase the count of   
##@@@L1386_:             * messages (semaphores) available. */   
##@@@L1387_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );   
80003176:	6d c0       	ADD       R5, R5, #1
80003178:	51 00 e6 14 	LD.B      R6, [R7 + #69]			;->0x45
##@@@P_:queue.c:1391
##@@@L1388_:
##@@@L1389_:            /* The event list is not altered if the queue is locked.  This will   
##@@@L1390_:             * be done when the queue is unlocked later. */   
##@@@L1391_:            if( cTxLock == queueUNLOCKED )   
8000317c:	4f 1f       	MOV       R4, #255			;->0x00FF
8000317e:	64 70       	CMP       R6, R4
##@@@P_:queue.c:1387
##@@@L1382_:             * holder - and if there is a mutex holder then the mutex cannot be   
##@@@L1383_:             * given from an ISR.  As this is the ISR version of the function it   
##@@@L1384_:             * can be assumed there is no mutex holder and no need to determine if   
##@@@L1385_:             * priority disinheritance is needed.  Simply increase the count of   
##@@@L1386_:             * messages (semaphores) available. */   
##@@@L1387_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );   
80003180:	bd a3       	ST.W      [R7 + #14], R5
##@@@P_:queue.c:1391
##@@@L1388_:
##@@@L1389_:            /* The event list is not altered if the queue is locked.  This will   
##@@@L1390_:             * be done when the queue is unlocked later. */   
##@@@L1391_:            if( cTxLock == queueUNLOCKED )   
80003182:	12 f0       	JZ        $+18                  ;->0x800031a6
80003184:	01 26       	ST.W      [SP + #1], R6
80003186:	b0 7b       	LSL       R6, #24			;->0x18
80003188:	b0 79       	ASR       R6, #24			;->0x18
##@@@P_:queue.c:1477
##@@@L1472_:            }   
##@@@L1473_:            else   
##@@@L1474_:            {   
##@@@L1475_:                /* Increment the lock count so the task that unlocks the queue   
##@@@L1476_:                 * knows that data was posted while it was locked. */   
##@@@L1477_:                prvIncrementQueueTxLock( pxQueue, cTxLock );   
8000318a:	14 45       	LD        R5, [PC + #20]        ;->0x800031d8  :=0x800069d0
8000318c:	05 5c       	LJMP      R5
8000318e:	06 70       	CMP       R0, R6
80003190:	19 f9       	JLS       $+25                  ;->0x800031c2
80003192:	01 0d       	LD.W      R5, [SP + #1]
80003194:	5f 3f       	CMP       R5, #127			;->0x7F
80003196:	02 f1       	JNZ       $+2                   ;->0x8000319a
80003198:	8f 04       	SJMP      $+143                 ;->0x800032b6
8000319a:	6d c0       	ADD       R5, R5, #1
8000319c:	79 00 e5 14 	ST.B      [R7 + #69], R5			;->0x45
800031a0:	11 04       	SJMP      $+17                  ;->0x800031c2
800031a2:	70 10       	MOV       R7, #0			;->0x0000
800031a4:	10 04       	SJMP      $+16                  ;->0x800031c4
##@@@P_:queue.c:1446
##@@@L1441_:                        }   
##@@@L1442_:                    }   
##@@@L1443_:                }   
##@@@L1444_:                #else /* configUSE_QUEUE_SETS */   
##@@@L1445_:                {   
##@@@L1446_:                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )   
800031a6:	6f 9a       	LD.W      R5, [R7 + #9]
800031a8:	50 38       	CMP       R5, #0			;->0x00
800031aa:	0c f0       	JZ        $+12                  ;->0x800031c2
800031ac:	74 2a       	ADD       R7, #36			;->0x24
##@@@P_:queue.c:1448
##@@@L1447_:                    {   
##@@@L1448_:                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )   
800031ae:	07 58       	MOV       R0, R7
800031b0:	0b 45       	LD        R5, [PC + #11]        ;->0x800031dc  :=0x80006ffc
800031b2:	05 5c       	LJMP      R5
800031b4:	71 10       	MOV       R7, #1			;->0x0001
800031b6:	80 38       	CMP       R8, #0			;->0x00
800031b8:	06 f0       	JZ        $+6                   ;->0x800031c4
800031ba:	00 38       	CMP       R0, #0			;->0x00
800031bc:	04 f0       	JZ        $+4                   ;->0x800031c4
##@@@P_:queue.c:1454
##@@@L1449_:                        {   
##@@@L1450_:                            /* The task waiting has a higher priority so record that a   
##@@@L1451_:                             * context switch is required. */   
##@@@L1452_:                            if( pxHigherPriorityTaskWoken != NULL )   
##@@@L1453_:                            {   
##@@@L1454_:                                *pxHigherPriorityTaskWoken = pdTRUE;   
800031be:	87 85       	ST.W      [R8], R7
800031c0:	02 04       	SJMP      $+2                   ;->0x800031c4
800031c2:	71 10       	MOV       R7, #1			;->0x0001
##@@@P_:queue.c:1488
##@@@L1483_:        {   
##@@@L1484_:            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );   
##@@@L1485_:            xReturn = errQUEUE_FULL;   
##@@@L1486_:        }   
##@@@L1487_:    }   
##@@@L1488_:    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
800031c4:	09 58       	MOV       R0, R9
800031c6:	07 45       	LD        R5, [PC + #7]         ;->0x800031e0  :=0x80009034
800031c8:	05 5c       	LJMP      R5
##@@@P_:queue.c:1492
##@@@L1489_:
##@@@L1490_:    traceRETURN_xQueueGiveFromISR( xReturn );   
##@@@L1491_:
##@@@L1492_:    return xReturn;   
800031ca:	07 58       	MOV       R0, R7
800031cc:	e8 28       	ADD       SP, #8			;->0x08
800031ce:	0f 5e       	POP       {R6-R9}
800031d0:	0d 5d       	POP       LR
800031d2:	1d 5c       	JMP       LR
800031d4:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
800031d8:	d0 69 00 80 	.long     0x800069d0 ->-2147456560  [!!!@2@:ANL       LR, R0	@@: LD.B      R0, [R0]
800031dc:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
800031e0:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:queue.c:1341
##@@@L1336_:     * item size is 0.  Don't directly wake a task that was blocked on a queue   
##@@@L1337_:     * read, instead return a flag to say whether a context switch is required or   
##@@@L1338_:     * not (i.e. has a task with a higher priority than us been woken by this   
##@@@L1339_:     * post). */   
##@@@L1340_:
##@@@L1341_:    configASSERT( pxQueue );   
800031e4:	20 5d       	PUSH      R0
800031e6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800031ea:	08 00       	SYNC     SYNC     
800031ec:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800031f0:	08 00       	SYNC     SYNC     
800031f2:	00 5d       	POP       R0
800031f4:	20 5d       	PUSH      R0
800031f6:	21 5d       	PUSH      R1
800031f8:	41 45       	LD        R5, [PC + #65]        ;->0x800032fc  :=0x1ff
800031fa:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800031fe:	25 58       	MOV       R1, R5
80003200:	11 68       	NOT       R1, R1
80003202:	01 69       	ANL       R0, R1
80003204:	5f 11       	MOV       R5, #31			;->0x001F
80003206:	25 58       	MOV       R1, R5
80003208:	01 6a       	ORL       R0, R1
8000320a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000320e:	08 00       	SYNC     SYNC     
80003210:	01 5d       	POP       R1
80003212:	00 5d       	POP       R0
80003214:	20 5d       	PUSH      R0
80003216:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000321a:	08 00       	SYNC     SYNC     
8000321c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003220:	08 00       	SYNC     SYNC     
80003222:	00 5d       	POP       R0
80003224:	07 00       	BREAK    BREAK    
80003226:	37 45       	LD        R5, [PC + #55]        ;->0x80003300  :=0x8000911c
80003228:	05 5c       	LJMP      R5
##@@@P_:queue.c:1345
##@@@L1342_:
##@@@L1343_:    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()   
##@@@L1344_:     * if the item size is not 0. */   
##@@@L1345_:    configASSERT( pxQueue->uxItemSize == 0 );   
8000322a:	20 5d       	PUSH      R0
8000322c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003230:	08 00       	SYNC     SYNC     
80003232:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003236:	08 00       	SYNC     SYNC     
80003238:	00 5d       	POP       R0
8000323a:	20 5d       	PUSH      R0
8000323c:	21 5d       	PUSH      R1
8000323e:	30 45       	LD        R5, [PC + #48]        ;->0x800032fc  :=0x1ff
80003240:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003244:	25 58       	MOV       R1, R5
80003246:	11 68       	NOT       R1, R1
80003248:	01 69       	ANL       R0, R1
8000324a:	5f 11       	MOV       R5, #31			;->0x001F
8000324c:	25 58       	MOV       R1, R5
8000324e:	01 6a       	ORL       R0, R1
80003250:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003254:	08 00       	SYNC     SYNC     
80003256:	01 5d       	POP       R1
80003258:	00 5d       	POP       R0
8000325a:	20 5d       	PUSH      R0
8000325c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003260:	08 00       	SYNC     SYNC     
80003262:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003266:	08 00       	SYNC     SYNC     
80003268:	00 5d       	POP       R0
8000326a:	07 00       	BREAK    BREAK    
8000326c:	25 45       	LD        R5, [PC + #37]        ;->0x80003300  :=0x8000911c
8000326e:	05 5c       	LJMP      R5
##@@@P_:queue.c:1350
##@@@L1346_:
##@@@L1347_:    /* Normally a mutex would not be given from an interrupt, especially if   
##@@@L1348_:     * there is a mutex holder, as priority inheritance makes no sense for an   
##@@@L1349_:     * interrupts, only tasks. */   
##@@@L1350_:    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );   
80003270:	20 5d       	PUSH      R0
80003272:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003276:	08 00       	SYNC     SYNC     
80003278:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000327c:	08 00       	SYNC     SYNC     
8000327e:	00 5d       	POP       R0
80003280:	20 5d       	PUSH      R0
80003282:	21 5d       	PUSH      R1
80003284:	1e 45       	LD        R5, [PC + #30]        ;->0x800032fc  :=0x1ff
80003286:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000328a:	25 58       	MOV       R1, R5
8000328c:	11 68       	NOT       R1, R1
8000328e:	01 69       	ANL       R0, R1
80003290:	5f 11       	MOV       R5, #31			;->0x001F
80003292:	25 58       	MOV       R1, R5
80003294:	01 6a       	ORL       R0, R1
80003296:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000329a:	08 00       	SYNC     SYNC     
8000329c:	01 5d       	POP       R1
8000329e:	00 5d       	POP       R0
800032a0:	20 5d       	PUSH      R0
800032a2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800032a6:	08 00       	SYNC     SYNC     
800032a8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800032ac:	08 00       	SYNC     SYNC     
800032ae:	00 5d       	POP       R0
800032b0:	07 00       	BREAK    BREAK    
800032b2:	14 45       	LD        R5, [PC + #20]        ;->0x80003300  :=0x8000911c
800032b4:	05 5c       	LJMP      R5
##@@@P_:queue.c:1477
##@@@L1472_:            }   
##@@@L1473_:            else   
##@@@L1474_:            {   
##@@@L1475_:                /* Increment the lock count so the task that unlocks the queue   
##@@@L1476_:                 * knows that data was posted while it was locked. */   
##@@@L1477_:                prvIncrementQueueTxLock( pxQueue, cTxLock );   
800032b6:	20 5d       	PUSH      R0
800032b8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800032bc:	08 00       	SYNC     SYNC     
800032be:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800032c2:	08 00       	SYNC     SYNC     
800032c4:	00 5d       	POP       R0
800032c6:	20 5d       	PUSH      R0
800032c8:	21 5d       	PUSH      R1
800032ca:	0d 45       	LD        R5, [PC + #13]        ;->0x800032fc  :=0x1ff
800032cc:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800032d0:	25 58       	MOV       R1, R5
800032d2:	11 68       	NOT       R1, R1
800032d4:	01 69       	ANL       R0, R1
800032d6:	5f 11       	MOV       R5, #31			;->0x001F
800032d8:	25 58       	MOV       R1, R5
800032da:	01 6a       	ORL       R0, R1
800032dc:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800032e0:	08 00       	SYNC     SYNC     
800032e2:	01 5d       	POP       R1
800032e4:	00 5d       	POP       R0
800032e6:	20 5d       	PUSH      R0
800032e8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800032ec:	08 00       	SYNC     SYNC     
800032ee:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800032f2:	08 00       	SYNC     SYNC     
800032f4:	00 5d       	POP       R0
800032f6:	07 00       	BREAK    BREAK    
800032f8:	02 45       	LD        R5, [PC + #2]         ;->0x80003300  :=0x8000911c
800032fa:	05 5c       	LJMP      R5
800032fc:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003300:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003304 <xQueueReceive>:
##@@@F_:xQueueReceive():
##@@@P_:queue.c:1499
##@@@L1494_:/*-----------------------------------------------------------*/   
##@@@L1495_:
##@@@L1496_:BaseType_t xQueueReceive( QueueHandle_t xQueue,   
##@@@L1497_:                          void * const pvBuffer,   
##@@@L1498_:                          TickType_t xTicksToWait )   
##@@@L1499_:{   
80003304:	9f 5f       	PUSH      {R6-R10,LR}
80003306:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:queue.c:1507
##@@@L1502_:    Queue_t * const pxQueue = xQueue;   
##@@@L1503_:
##@@@L1504_:    traceENTER_xQueueReceive( xQueue, pvBuffer, xTicksToWait );   
##@@@L1505_:
##@@@L1506_:    /* Check the pointer is not NULL. */   
##@@@L1507_:    configASSERT( ( pxQueue ) );   
80003308:	00 38       	CMP       R0, #0			;->0x00
8000330a:	04 22       	ST.W      [SP + #4], R2
8000330c:	02 f1       	JNZ       $+2                   ;->0x80003310
8000330e:	96 04       	SJMP      $+150                 ;->0x8000343a
80003310:	21 59       	MOV       R9, R1
80003312:	c0 58       	MOV       R6, R0
80003314:	01 22       	ST.W      [SP + #1], R2
##@@@P_:queue.c:1511
##@@@L1508_:
##@@@L1509_:    /* The buffer into which data is received can only be NULL if the data size   
##@@@L1510_:     * is zero (so no data is copied into the buffer). */   
##@@@L1511_:    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );   
80003316:	10 38       	CMP       R1, #0			;->0x00
80003318:	05 f1       	JNZ       $+5                   ;->0x80003322
8000331a:	2e 9c       	LD.W      R5, [R6 + #16]
8000331c:	50 38       	CMP       R5, #0			;->0x00
8000331e:	02 f0       	JZ        $+2                   ;->0x80003322
80003320:	b0 04       	SJMP      $+176                 ;->0x80003480
##@@@P_:queue.c:1522
##@@@L1517_:    }   
##@@@L1518_:    #endif   
##@@@L1519_:
##@@@L1520_:    for( ; ; )   
##@@@L1521_:    {   
##@@@L1522_:        taskENTER_CRITICAL();   
80003322:	15 45       	LD        R5, [PC + #21]        ;->0x80003374  :=0x800056cc
80003324:	05 5c       	LJMP      R5
##@@@P_:queue.c:1524
##@@@L1523_:        {   
##@@@L1524_:            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
80003326:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:1528
##@@@L1525_:
##@@@L1526_:            /* Is there data in the queue now?  To be running the calling task   
##@@@L1527_:             * must be the highest priority task wanting to access the queue. */   
##@@@L1528_:            if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
80003328:	70 38       	CMP       R7, #0			;->0x00
8000332a:	2f f0       	JZ        $+47                  ;->0x80003388
##@@@F_:prvCopyDataFromQueue():
##@@@P_:queue.c:2464
##@@@L2459_:/*-----------------------------------------------------------*/   
##@@@L2460_:
##@@@L2461_:static void prvCopyDataFromQueue( Queue_t * const pxQueue,   
##@@@L2462_:                                  void * const pvBuffer )   
##@@@L2463_:{   
##@@@L2464_:    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )   
8000332c:	16 9c       	LD.W      R2, [R6 + #16]
8000332e:	20 38       	CMP       R2, #0			;->0x00
80003330:	0c f0       	JZ        $+12                  ;->0x80003348
##@@@P_:queue.c:2466
##@@@L2465_:    {   
##@@@L2466_:        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;   
80003332:	ee 98       	LD.W      R5, [R6 + #3]
80003334:	8d c2       	ADD       R1, R5, R2
80003336:	f1 a0       	ST.W      [R6 + #3], R1
##@@@P_:queue.c:2468
##@@@L2467_:
##@@@L2468_:        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )   
80003338:	ae 98       	LD.W      R5, [R6 + #2]
8000333a:	15 70       	CMP       R1, R5
8000333c:	03 f3       	JNC       $+3                   ;->0x80003342
##@@@P_:queue.c:2470
##@@@L2469_:        {   
##@@@L2470_:            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;   
8000333e:	16 82       	LD.W      R1, [R6]
80003340:	f1 a0       	ST.W      [R6 + #3], R1
##@@@P_:queue.c:2477
##@@@L2472_:        else   
##@@@L2473_:        {   
##@@@L2474_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2475_:        }   
##@@@L2476_:
##@@@L2477_:        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );   
80003342:	09 58       	MOV       R0, R9
80003344:	0d 45       	LD        R5, [PC + #13]        ;->0x80003378  :=0x8000d9ec
80003346:	05 5c       	LJMP      R5
##@@@F_:xQueueReceive():
##@@@P_:queue.c:1533
##@@@L1528_:            if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
##@@@L1529_:            {   
##@@@L1530_:                /* Data available, remove one item. */   
##@@@L1531_:                prvCopyDataFromQueue( pxQueue, pvBuffer );   
##@@@L1532_:                traceQUEUE_RECEIVE( pxQueue );   
##@@@L1533_:                pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );   
80003348:	6f cc       	SUB       R5, R7, #1
8000334a:	b5 a3       	ST.W      [R6 + #14], R5
##@@@P_:queue.c:1538
##@@@L1534_:
##@@@L1535_:                /* There is now space in the queue, were any tasks waiting to   
##@@@L1536_:                 * post to the queue?  If so, unblock the highest priority waiting   
##@@@L1537_:                 * task. */   
##@@@L1538_:                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )   
8000334c:	2e 99       	LD.W      R5, [R6 + #4]
8000334e:	50 38       	CMP       R5, #0			;->0x00
80003350:	09 f0       	JZ        $+9                   ;->0x80003362
80003352:	60 29       	ADD       R6, #16			;->0x10
##@@@P_:queue.c:1540
##@@@L1539_:                {   
##@@@L1540_:                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )   
80003354:	06 58       	MOV       R0, R6
80003356:	0a 45       	LD        R5, [PC + #10]        ;->0x8000337c  :=0x80006ffc
80003358:	05 5c       	LJMP      R5
8000335a:	00 38       	CMP       R0, #0			;->0x00
8000335c:	03 f0       	JZ        $+3                   ;->0x80003362
##@@@P_:queue.c:1542
##@@@L1541_:                    {   
##@@@L1542_:                        queueYIELD_IF_USING_PREEMPTION();   
8000335e:	09 45       	LD        R5, [PC + #9]         ;->0x80003380  :=0x80008f64
80003360:	05 5c       	LJMP      R5
80003362:	81 10       	MOV       R8, #1			;->0x0001
80003364:	08 45       	LD        R5, [PC + #8]         ;->0x80003384  :=0x80005730
80003366:	05 5c       	LJMP      R5
##@@@P_:queue.c:1643
##@@@L1638_:            {   
##@@@L1639_:                mtCOVERAGE_TEST_MARKER();   
##@@@L1640_:            }   
##@@@L1641_:        }   
##@@@L1642_:    }   
##@@@L1643_:}   
80003368:	08 58       	MOV       R0, R8
8000336a:	e4 29       	ADD       SP, #20			;->0x14
8000336c:	1f 5e       	POP       {R6-R10}
8000336e:	0d 5d       	POP       LR
80003370:	1d 5c       	JMP       LR
80003372:	00 00       	NOP      NOP      
80003374:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80003374
80003378:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
8000337c:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
80003380:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80003384:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80003384
80003388:	80 10       	MOV       R8, #0			;->0x0000
##@@@P_:queue.c:1562
##@@@L1557_:
##@@@L1558_:                return pdPASS;   
##@@@L1559_:            }   
##@@@L1560_:            else   
##@@@L1561_:            {   
##@@@L1562_:                if( xTicksToWait == ( TickType_t ) 0 )   
8000338a:	01 0d       	LD.W      R5, [SP + #1]
8000338c:	50 38       	CMP       R5, #0			;->0x00
8000338e:	eb f0       	JZ        $-21                  ;->0x80003364
80003390:	a6 58       	MOV       R5, R6
80003392:	54 2a       	ADD       R5, #36			;->0x24
80003394:	01 25       	ST.W      [SP + #1], R5
80003396:	4d 40       	LD        R0, [PC + #77]        ;->0x800034c8  :=0x8
80003398:	0e 64       	ADD       R0, SP
##@@@P_:queue.c:1577
##@@@L1572_:                }   
##@@@L1573_:                else if( xEntryTimeSet == pdFALSE )   
##@@@L1574_:                {   
##@@@L1575_:                    /* The queue was empty and a block time was specified so   
##@@@L1576_:                     * configure the timeout structure. */   
##@@@L1577_:                    vTaskInternalSetTimeOutState( &xTimeOut );   
8000339a:	4d 45       	LD        R5, [PC + #77]        ;->0x800034cc  :=0x80007304
8000339c:	05 5c       	LJMP      R5
8000339e:	af 1f       	MOV       R10, #255			;->0x00FF
##@@@P_:queue.c:1587
##@@@L1582_:                    /* Entry time was already set. */   
##@@@L1583_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L1584_:                }   
##@@@L1585_:            }   
##@@@L1586_:        }   
##@@@L1587_:        taskEXIT_CRITICAL();   
800033a0:	4c 45       	LD        R5, [PC + #76]        ;->0x800034d0  :=0x80005730
800033a2:	05 5c       	LJMP      R5
##@@@P_:queue.c:1592
##@@@L1588_:
##@@@L1589_:        /* Interrupts and other tasks can send to and receive from the queue   
##@@@L1590_:         * now the critical section has been exited. */   
##@@@L1591_:
##@@@L1592_:        vTaskSuspendAll();   
800033a4:	4c 45       	LD        R5, [PC + #76]        ;->0x800034d4  :=0x800059b0
800033a6:	05 5c       	LJMP      R5
##@@@P_:queue.c:1593
##@@@L1593_:        prvLockQueue( pxQueue );   
800033a8:	4c 45       	LD        R5, [PC + #76]        ;->0x800034d8  :=0x800056cc
800033aa:	05 5c       	LJMP      R5
800033ac:	51 00 c5 10 	LD.B      R5, [R6 + #68]			;->0x44
800033b0:	5a 70       	CMP       R5, R10
800033b2:	03 f1       	JNZ       $+3                   ;->0x800033b8
800033b4:	79 00 c8 10 	ST.B      [R6 + #68], R8			;->0x44
800033b8:	51 00 c5 14 	LD.B      R5, [R6 + #69]			;->0x45
800033bc:	5a 70       	CMP       R5, R10
800033be:	03 f1       	JNZ       $+3                   ;->0x800033c4
800033c0:	79 00 c8 14 	ST.B      [R6 + #69], R8			;->0x45
800033c4:	43 45       	LD        R5, [PC + #67]        ;->0x800034d0  :=0x80005730
800033c6:	05 5c       	LJMP      R5
800033c8:	40 40       	LD        R0, [PC + #64]        ;->0x800034c8  :=0x8
800033ca:	0e 64       	ADD       R0, SP
800033cc:	44 41       	LD        R1, [PC + #68]        ;->0x800034dc  :=0x10
800033ce:	1e 64       	ADD       R1, SP
##@@@P_:queue.c:1596
##@@@L1594_:
##@@@L1595_:        /* Update the timeout state to see if it has expired yet. */   
##@@@L1596_:        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )   
800033d0:	44 45       	LD        R5, [PC + #68]        ;->0x800034e0  :=0x8000731c
800033d2:	05 5c       	LJMP      R5
800033d4:	00 38       	CMP       R0, #0			;->0x00
800033d6:	0e f0       	JZ        $+14                  ;->0x800033f2
##@@@P_:queue.c:1627
##@@@L1622_:        }   
##@@@L1623_:        else   
##@@@L1624_:        {   
##@@@L1625_:            /* Timed out.  If there is no data in the queue exit, otherwise loop   
##@@@L1626_:             * back and attempt to read the data. */   
##@@@L1627_:            prvUnlockQueue( pxQueue );   
800033d8:	06 58       	MOV       R0, R6
800033da:	43 45       	LD        R5, [PC + #67]        ;->0x800034e4  :=0x80002e64
800033dc:	05 5c       	LJMP      R5
##@@@P_:queue.c:1628
##@@@L1628_:            ( void ) xTaskResumeAll();   
800033de:	43 45       	LD        R5, [PC + #67]        ;->0x800034e8  :=0x80005a70
800033e0:	05 5c       	LJMP      R5
##@@@F_:prvIsQueueEmpty():
##@@@P_:queue.c:2606
##@@@L2601_:
##@@@L2602_:static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )   
##@@@L2603_:{   
##@@@L2604_:    BaseType_t xReturn;   
##@@@L2605_:
##@@@L2606_:    taskENTER_CRITICAL();   
800033e2:	3e 45       	LD        R5, [PC + #62]        ;->0x800034d8  :=0x800056cc
800033e4:	05 5c       	LJMP      R5
##@@@P_:queue.c:2608
##@@@L2607_:    {   
##@@@L2608_:        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )   
800033e6:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2617
##@@@L2612_:        else   
##@@@L2613_:        {   
##@@@L2614_:            xReturn = pdFALSE;   
##@@@L2615_:        }   
##@@@L2616_:    }   
##@@@L2617_:    taskEXIT_CRITICAL();   
800033e8:	3a 45       	LD        R5, [PC + #58]        ;->0x800034d0  :=0x80005730
800033ea:	05 5c       	LJMP      R5
##@@@F_:xQueueReceive():
##@@@P_:queue.c:1630
##@@@L1625_:            /* Timed out.  If there is no data in the queue exit, otherwise loop   
##@@@L1626_:             * back and attempt to read the data. */   
##@@@L1627_:            prvUnlockQueue( pxQueue );   
##@@@L1628_:            ( void ) xTaskResumeAll();   
##@@@L1629_:
##@@@L1630_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
800033ec:	70 38       	CMP       R7, #0			;->0x00
800033ee:	1c f1       	JNZ       $+28                  ;->0x80003426
800033f0:	bc 07       	SJMP      $-68                  ;->0x80003368
##@@@F_:prvIsQueueEmpty():
##@@@P_:queue.c:2606
##@@@L2601_:
##@@@L2602_:static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )   
##@@@L2603_:{   
##@@@L2604_:    BaseType_t xReturn;   
##@@@L2605_:
##@@@L2606_:    taskENTER_CRITICAL();   
800033f2:	3a 45       	LD        R5, [PC + #58]        ;->0x800034d8  :=0x800056cc
800033f4:	05 5c       	LJMP      R5
##@@@P_:queue.c:2608
##@@@L2607_:    {   
##@@@L2608_:        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )   
800033f6:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2617
##@@@L2612_:        else   
##@@@L2613_:        {   
##@@@L2614_:            xReturn = pdFALSE;   
##@@@L2615_:        }   
##@@@L2616_:    }   
##@@@L2617_:    taskEXIT_CRITICAL();   
800033f8:	36 45       	LD        R5, [PC + #54]        ;->0x800034d0  :=0x80005730
800033fa:	05 5c       	LJMP      R5
##@@@F_:xQueueReceive():
##@@@P_:queue.c:1600
##@@@L1595_:        /* Update the timeout state to see if it has expired yet. */   
##@@@L1596_:        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )   
##@@@L1597_:        {   
##@@@L1598_:            /* The timeout has not expired.  If the queue is still empty place   
##@@@L1599_:             * the task on the list of tasks waiting to receive from the queue. */   
##@@@L1600_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
800033fc:	70 38       	CMP       R7, #0			;->0x00
800033fe:	07 f0       	JZ        $+7                   ;->0x8000340c
##@@@P_:queue.c:1619
##@@@L1614_:            }   
##@@@L1615_:            else   
##@@@L1616_:            {   
##@@@L1617_:                /* The queue contains data again.  Loop back to try and read the   
##@@@L1618_:                 * data. */   
##@@@L1619_:                prvUnlockQueue( pxQueue );   
80003400:	06 58       	MOV       R0, R6
80003402:	39 45       	LD        R5, [PC + #57]        ;->0x800034e4  :=0x80002e64
80003404:	05 5c       	LJMP      R5
##@@@P_:queue.c:1620
##@@@L1620_:                ( void ) xTaskResumeAll();   
80003406:	39 45       	LD        R5, [PC + #57]        ;->0x800034e8  :=0x80005a70
80003408:	05 5c       	LJMP      R5
8000340a:	0e 04       	SJMP      $+14                  ;->0x80003426
##@@@P_:queue.c:1603
##@@@L1598_:            /* The timeout has not expired.  If the queue is still empty place   
##@@@L1599_:             * the task on the list of tasks waiting to receive from the queue. */   
##@@@L1600_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
##@@@L1601_:            {   
##@@@L1602_:                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );   
##@@@L1603_:                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );   
8000340c:	04 09       	LD.W      R1, [SP + #4]
8000340e:	01 08       	LD.W      R0, [SP + #1]
80003410:	37 45       	LD        R5, [PC + #55]        ;->0x800034ec  :=0x80006e8c
80003412:	05 5c       	LJMP      R5
##@@@P_:queue.c:1604
##@@@L1604_:                prvUnlockQueue( pxQueue );   
80003414:	06 58       	MOV       R0, R6
80003416:	34 45       	LD        R5, [PC + #52]        ;->0x800034e4  :=0x80002e64
80003418:	05 5c       	LJMP      R5
##@@@P_:queue.c:1606
##@@@L1605_:
##@@@L1606_:                if( xTaskResumeAll() == pdFALSE )   
8000341a:	34 45       	LD        R5, [PC + #52]        ;->0x800034e8  :=0x80005a70
8000341c:	05 5c       	LJMP      R5
8000341e:	00 38       	CMP       R0, #0			;->0x00
80003420:	03 f1       	JNZ       $+3                   ;->0x80003426
##@@@P_:queue.c:1608
##@@@L1607_:                {   
##@@@L1608_:                    taskYIELD_WITHIN_API();   
80003422:	34 45       	LD        R5, [PC + #52]        ;->0x800034f0  :=0x80008f64
80003424:	05 5c       	LJMP      R5
##@@@P_:queue.c:1522
##@@@L1517_:    }   
##@@@L1518_:    #endif   
##@@@L1519_:
##@@@L1520_:    for( ; ; )   
##@@@L1521_:    {   
##@@@L1522_:        taskENTER_CRITICAL();   
80003426:	2d 45       	LD        R5, [PC + #45]        ;->0x800034d8  :=0x800056cc
80003428:	05 5c       	LJMP      R5
##@@@P_:queue.c:1524
##@@@L1523_:        {   
##@@@L1524_:            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
8000342a:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:1528
##@@@L1525_:
##@@@L1526_:            /* Is there data in the queue now?  To be running the calling task   
##@@@L1527_:             * must be the highest priority task wanting to access the queue. */   
##@@@L1528_:            if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
8000342c:	70 38       	CMP       R7, #0			;->0x00
8000342e:	02 f0       	JZ        $+2                   ;->0x80003432
80003430:	7e 07       	SJMP      $-130                 ;->0x8000332c
##@@@P_:queue.c:1562
##@@@L1557_:
##@@@L1558_:                return pdPASS;   
##@@@L1559_:            }   
##@@@L1560_:            else   
##@@@L1561_:            {   
##@@@L1562_:                if( xTicksToWait == ( TickType_t ) 0 )   
80003432:	04 0d       	LD.W      R5, [SP + #4]
80003434:	50 38       	CMP       R5, #0			;->0x00
80003436:	b5 f1       	JNZ       $-75                  ;->0x800033a0
80003438:	96 07       	SJMP      $-106                 ;->0x80003364
##@@@P_:queue.c:1507
##@@@L1502_:    Queue_t * const pxQueue = xQueue;   
##@@@L1503_:
##@@@L1504_:    traceENTER_xQueueReceive( xQueue, pvBuffer, xTicksToWait );   
##@@@L1505_:
##@@@L1506_:    /* Check the pointer is not NULL. */   
##@@@L1507_:    configASSERT( ( pxQueue ) );   
8000343a:	20 5d       	PUSH      R0
8000343c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003440:	08 00       	SYNC     SYNC     
80003442:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003446:	08 00       	SYNC     SYNC     
80003448:	00 5d       	POP       R0
8000344a:	20 5d       	PUSH      R0
8000344c:	21 5d       	PUSH      R1
8000344e:	2a 45       	LD        R5, [PC + #42]        ;->0x800034f4  :=0x1ff
80003450:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003454:	25 58       	MOV       R1, R5
80003456:	11 68       	NOT       R1, R1
80003458:	01 69       	ANL       R0, R1
8000345a:	5f 11       	MOV       R5, #31			;->0x001F
8000345c:	25 58       	MOV       R1, R5
8000345e:	01 6a       	ORL       R0, R1
80003460:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003464:	08 00       	SYNC     SYNC     
80003466:	01 5d       	POP       R1
80003468:	00 5d       	POP       R0
8000346a:	20 5d       	PUSH      R0
8000346c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003470:	08 00       	SYNC     SYNC     
80003472:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003476:	08 00       	SYNC     SYNC     
80003478:	00 5d       	POP       R0
8000347a:	07 00       	BREAK    BREAK    
8000347c:	1f 45       	LD        R5, [PC + #31]        ;->0x800034f8  :=0x8000911c
8000347e:	05 5c       	LJMP      R5
##@@@P_:queue.c:1511
##@@@L1508_:
##@@@L1509_:    /* The buffer into which data is received can only be NULL if the data size   
##@@@L1510_:     * is zero (so no data is copied into the buffer). */   
##@@@L1511_:    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );   
80003480:	20 5d       	PUSH      R0
80003482:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003486:	08 00       	SYNC     SYNC     
80003488:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000348c:	08 00       	SYNC     SYNC     
8000348e:	00 5d       	POP       R0
80003490:	20 5d       	PUSH      R0
80003492:	21 5d       	PUSH      R1
80003494:	18 45       	LD        R5, [PC + #24]        ;->0x800034f4  :=0x1ff
80003496:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000349a:	25 58       	MOV       R1, R5
8000349c:	11 68       	NOT       R1, R1
8000349e:	01 69       	ANL       R0, R1
800034a0:	5f 11       	MOV       R5, #31			;->0x001F
800034a2:	25 58       	MOV       R1, R5
800034a4:	01 6a       	ORL       R0, R1
800034a6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800034aa:	08 00       	SYNC     SYNC     
800034ac:	01 5d       	POP       R1
800034ae:	00 5d       	POP       R0
800034b0:	20 5d       	PUSH      R0
800034b2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800034b6:	08 00       	SYNC     SYNC     
800034b8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800034bc:	08 00       	SYNC     SYNC     
800034be:	00 5d       	POP       R0
800034c0:	07 00       	BREAK    BREAK    
800034c2:	0e 45       	LD        R5, [PC + #14]        ;->0x800034f8  :=0x8000911c
800034c4:	05 5c       	LJMP      R5
800034c6:	00 00       	NOP      NOP      
800034c8:	08 00 00 00 	.long     0x00000008 ->000000008  [!!!@2@:SYNC     	@@: NOP      
800034cc:	04 73 00 80 	.long     0x80007304 ->-2147454204  [!!!@2@:ST.W      [R0++], R4	@@: LD.B      R0, [R0]
800034d0:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x800034d0
800034d4:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
800034d8:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x800034d8
800034dc:	10 00 00 00 	.long     0x00000010 ->000000016  [!!!@4@:DMAC16LL  ACC0, ACC0, R0, R0
800034e0:	1c 73 00 80 	.long     0x8000731c ->-2147454180  [!!!@2@:ST.W      [R1++], R12	@@: LD.B      R0, [R0]
800034e4:	64 2e 00 80 	.long     0x80002e64 ->-2147471772  [!!!@2@:ADD       R6, #100	@@: LD.B      R0, [R0]
800034e8:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
800034ec:	8c 6e 00 80 	.long     0x80006e8c ->-2147455348  [!!!@2@:ASR       R8, R12	@@: LD.B      R0, [R0]
800034f0:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
800034f4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800034f8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800034fc <xQueuePeek>:
##@@@F_:xQueuePeek():
##@@@P_:queue.c:1874
##@@@L1869_:/*-----------------------------------------------------------*/   
##@@@L1870_:
##@@@L1871_:BaseType_t xQueuePeek( QueueHandle_t xQueue,   
##@@@L1872_:                       void * const pvBuffer,   
##@@@L1873_:                       TickType_t xTicksToWait )   
##@@@L1874_:{   
800034fc:	9f 5f       	PUSH      {R6-R10,LR}
800034fe:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:queue.c:1883
##@@@L1878_:    Queue_t * const pxQueue = xQueue;   
##@@@L1879_:
##@@@L1880_:    traceENTER_xQueuePeek( xQueue, pvBuffer, xTicksToWait );   
##@@@L1881_:
##@@@L1882_:    /* Check the pointer is not NULL. */   
##@@@L1883_:    configASSERT( ( pxQueue ) );   
80003500:	00 38       	CMP       R0, #0			;->0x00
80003502:	04 22       	ST.W      [SP + #4], R2
80003504:	02 f1       	JNZ       $+2                   ;->0x80003508
80003506:	93 04       	SJMP      $+147                 ;->0x8000362c
80003508:	e2 58       	MOV       R7, R2
8000350a:	21 59       	MOV       R9, R1
8000350c:	c0 58       	MOV       R6, R0
##@@@P_:queue.c:1887
##@@@L1884_:
##@@@L1885_:    /* The buffer into which data is received can only be NULL if the data size   
##@@@L1886_:     * is zero (so no data is copied into the buffer. */   
##@@@L1887_:    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );   
8000350e:	10 38       	CMP       R1, #0			;->0x00
80003510:	05 f1       	JNZ       $+5                   ;->0x8000351a
80003512:	2e 9c       	LD.W      R5, [R6 + #16]
80003514:	50 38       	CMP       R5, #0			;->0x00
80003516:	02 f0       	JZ        $+2                   ;->0x8000351a
80003518:	ad 04       	SJMP      $+173                 ;->0x80003672
##@@@P_:queue.c:1898
##@@@L1893_:    }   
##@@@L1894_:    #endif   
##@@@L1895_:
##@@@L1896_:    for( ; ; )   
##@@@L1897_:    {   
##@@@L1898_:        taskENTER_CRITICAL();   
8000351a:	14 45       	LD        R5, [PC + #20]        ;->0x80003568  :=0x800056cc
8000351c:	05 5c       	LJMP      R5
##@@@P_:queue.c:1900
##@@@L1899_:        {   
##@@@L1900_:            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
8000351e:	ae 9b       	LD.W      R5, [R6 + #14]
##@@@P_:queue.c:1904
##@@@L1901_:
##@@@L1902_:            /* Is there data in the queue now?  To be running the calling task   
##@@@L1903_:             * must be the highest priority task wanting to access the queue. */   
##@@@L1904_:            if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
80003520:	50 38       	CMP       R5, #0			;->0x00
80003522:	2d f0       	JZ        $+45                  ;->0x8000357c
##@@@F_:prvCopyDataFromQueue():
##@@@P_:queue.c:2464
##@@@L2459_:/*-----------------------------------------------------------*/   
##@@@L2460_:
##@@@L2461_:static void prvCopyDataFromQueue( Queue_t * const pxQueue,   
##@@@L2462_:                                  void * const pvBuffer )   
##@@@L2463_:{   
##@@@L2464_:    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )   
80003524:	16 9c       	LD.W      R2, [R6 + #16]
##@@@F_:xQueuePeek():
##@@@P_:queue.c:1909
##@@@L1904_:            if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
##@@@L1905_:            {   
##@@@L1906_:                /* Remember the read position so it can be reset after the data   
##@@@L1907_:                 * is read from the queue as this function is only peeking the   
##@@@L1908_:                 * data, not removing it. */   
##@@@L1909_:                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;   
80003526:	fe 98       	LD.W      R7, [R6 + #3]
##@@@F_:prvCopyDataFromQueue():
##@@@P_:queue.c:2464
##@@@L2459_:/*-----------------------------------------------------------*/   
##@@@L2460_:
##@@@L2461_:static void prvCopyDataFromQueue( Queue_t * const pxQueue,   
##@@@L2462_:                                  void * const pvBuffer )   
##@@@L2463_:{   
##@@@L2464_:    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )   
80003528:	20 38       	CMP       R2, #0			;->0x00
8000352a:	0b f0       	JZ        $+11                  ;->0x80003540
##@@@P_:queue.c:2466
##@@@L2465_:    {   
##@@@L2466_:        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;   
8000352c:	8f c2       	ADD       R1, R7, R2
8000352e:	f1 a0       	ST.W      [R6 + #3], R1
##@@@P_:queue.c:2468
##@@@L2467_:
##@@@L2468_:        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )   
80003530:	ae 98       	LD.W      R5, [R6 + #2]
80003532:	15 70       	CMP       R1, R5
80003534:	03 f3       	JNC       $+3                   ;->0x8000353a
##@@@P_:queue.c:2470
##@@@L2469_:        {   
##@@@L2470_:            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;   
80003536:	16 82       	LD.W      R1, [R6]
80003538:	f1 a0       	ST.W      [R6 + #3], R1
##@@@P_:queue.c:2477
##@@@L2472_:        else   
##@@@L2473_:        {   
##@@@L2474_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2475_:        }   
##@@@L2476_:
##@@@L2477_:        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );   
8000353a:	09 58       	MOV       R0, R9
8000353c:	0c 45       	LD        R5, [PC + #12]        ;->0x8000356c  :=0x8000d9ec
8000353e:	05 5c       	LJMP      R5
##@@@F_:xQueuePeek():
##@@@P_:queue.c:1915
##@@@L1910_:
##@@@L1911_:                prvCopyDataFromQueue( pxQueue, pvBuffer );   
##@@@L1912_:                traceQUEUE_PEEK( pxQueue );   
##@@@L1913_:
##@@@L1914_:                /* The data is not being removed, so reset the read pointer. */   
##@@@L1915_:                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;   
80003540:	f7 a0       	ST.W      [R6 + #3], R7
##@@@P_:queue.c:1919
##@@@L1916_:
##@@@L1917_:                /* The data is being left in the queue, so see if there are   
##@@@L1918_:                 * any other tasks waiting for the data. */   
##@@@L1919_:                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )   
80003542:	6e 9a       	LD.W      R5, [R6 + #9]
80003544:	50 38       	CMP       R5, #0			;->0x00
80003546:	09 f0       	JZ        $+9                   ;->0x80003558
80003548:	64 2a       	ADD       R6, #36			;->0x24
##@@@P_:queue.c:1921
##@@@L1920_:                {   
##@@@L1921_:                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )   
8000354a:	06 58       	MOV       R0, R6
8000354c:	09 45       	LD        R5, [PC + #9]         ;->0x80003570  :=0x80006ffc
8000354e:	05 5c       	LJMP      R5
80003550:	00 38       	CMP       R0, #0			;->0x00
80003552:	03 f0       	JZ        $+3                   ;->0x80003558
##@@@P_:queue.c:1924
##@@@L1922_:                    {   
##@@@L1923_:                        /* The task waiting has a higher priority than this task. */   
##@@@L1924_:                        queueYIELD_IF_USING_PREEMPTION();   
80003554:	08 45       	LD        R5, [PC + #8]         ;->0x80003574  :=0x80008f64
80003556:	05 5c       	LJMP      R5
80003558:	81 10       	MOV       R8, #1			;->0x0001
8000355a:	08 45       	LD        R5, [PC + #8]         ;->0x80003578  :=0x80005730
8000355c:	05 5c       	LJMP      R5
##@@@P_:queue.c:2026
##@@@L2021_:            {   
##@@@L2022_:                mtCOVERAGE_TEST_MARKER();   
##@@@L2023_:            }   
##@@@L2024_:        }   
##@@@L2025_:    }   
##@@@L2026_:}   
8000355e:	08 58       	MOV       R0, R8
80003560:	e4 29       	ADD       SP, #20			;->0x14
80003562:	1f 5e       	POP       {R6-R10}
80003564:	0d 5d       	POP       LR
80003566:	1d 5c       	JMP       LR
80003568:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80003568
8000356c:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
80003570:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
80003574:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80003578:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80003578
8000357c:	80 10       	MOV       R8, #0			;->0x0000
##@@@P_:queue.c:1944
##@@@L1939_:
##@@@L1940_:                return pdPASS;   
##@@@L1941_:            }   
##@@@L1942_:            else   
##@@@L1943_:            {   
##@@@L1944_:                if( xTicksToWait == ( TickType_t ) 0 )   
8000357e:	70 38       	CMP       R7, #0			;->0x00
80003580:	ed f0       	JZ        $-19                  ;->0x8000355a
80003582:	a6 58       	MOV       R5, R6
80003584:	54 2a       	ADD       R5, #36			;->0x24
80003586:	01 25       	ST.W      [SP + #1], R5
80003588:	4c 40       	LD        R0, [PC + #76]        ;->0x800036b8  :=0x8
8000358a:	0e 64       	ADD       R0, SP
##@@@P_:queue.c:1960
##@@@L1955_:                else if( xEntryTimeSet == pdFALSE )   
##@@@L1956_:                {   
##@@@L1957_:                    /* The queue was empty and a block time was specified so   
##@@@L1958_:                     * configure the timeout structure ready to enter the blocked   
##@@@L1959_:                     * state. */   
##@@@L1960_:                    vTaskInternalSetTimeOutState( &xTimeOut );   
8000358c:	4c 45       	LD        R5, [PC + #76]        ;->0x800036bc  :=0x80007304
8000358e:	05 5c       	LJMP      R5
80003590:	af 1f       	MOV       R10, #255			;->0x00FF
##@@@P_:queue.c:1970
##@@@L1965_:                    /* Entry time was already set. */   
##@@@L1966_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L1967_:                }   
##@@@L1968_:            }   
##@@@L1969_:        }   
##@@@L1970_:        taskEXIT_CRITICAL();   
80003592:	4c 45       	LD        R5, [PC + #76]        ;->0x800036c0  :=0x80005730
80003594:	05 5c       	LJMP      R5
##@@@P_:queue.c:1975
##@@@L1971_:
##@@@L1972_:        /* Interrupts and other tasks can send to and receive from the queue   
##@@@L1973_:         * now that the critical section has been exited. */   
##@@@L1974_:
##@@@L1975_:        vTaskSuspendAll();   
80003596:	4c 45       	LD        R5, [PC + #76]        ;->0x800036c4  :=0x800059b0
80003598:	05 5c       	LJMP      R5
##@@@P_:queue.c:1976
##@@@L1976_:        prvLockQueue( pxQueue );   
8000359a:	4c 45       	LD        R5, [PC + #76]        ;->0x800036c8  :=0x800056cc
8000359c:	05 5c       	LJMP      R5
8000359e:	51 00 c5 10 	LD.B      R5, [R6 + #68]			;->0x44
800035a2:	5a 70       	CMP       R5, R10
800035a4:	03 f1       	JNZ       $+3                   ;->0x800035aa
800035a6:	79 00 c8 10 	ST.B      [R6 + #68], R8			;->0x44
800035aa:	51 00 c5 14 	LD.B      R5, [R6 + #69]			;->0x45
800035ae:	5a 70       	CMP       R5, R10
800035b0:	03 f1       	JNZ       $+3                   ;->0x800035b6
800035b2:	79 00 c8 14 	ST.B      [R6 + #69], R8			;->0x45
800035b6:	43 45       	LD        R5, [PC + #67]        ;->0x800036c0  :=0x80005730
800035b8:	05 5c       	LJMP      R5
800035ba:	40 40       	LD        R0, [PC + #64]        ;->0x800036b8  :=0x8
800035bc:	0e 64       	ADD       R0, SP
800035be:	44 41       	LD        R1, [PC + #68]        ;->0x800036cc  :=0x10
800035c0:	1e 64       	ADD       R1, SP
##@@@P_:queue.c:1979
##@@@L1977_:
##@@@L1978_:        /* Update the timeout state to see if it has expired yet. */   
##@@@L1979_:        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )   
800035c2:	44 45       	LD        R5, [PC + #68]        ;->0x800036d0  :=0x8000731c
800035c4:	05 5c       	LJMP      R5
800035c6:	00 38       	CMP       R0, #0			;->0x00
800035c8:	0e f0       	JZ        $+14                  ;->0x800035e4
##@@@P_:queue.c:2010
##@@@L2005_:        }   
##@@@L2006_:        else   
##@@@L2007_:        {   
##@@@L2008_:            /* The timeout has expired.  If there is still no data in the queue   
##@@@L2009_:             * exit, otherwise go back and try to read the data again. */   
##@@@L2010_:            prvUnlockQueue( pxQueue );   
800035ca:	06 58       	MOV       R0, R6
800035cc:	42 45       	LD        R5, [PC + #66]        ;->0x800036d4  :=0x80002e64
800035ce:	05 5c       	LJMP      R5
##@@@P_:queue.c:2011
##@@@L2011_:            ( void ) xTaskResumeAll();   
800035d0:	42 45       	LD        R5, [PC + #66]        ;->0x800036d8  :=0x80005a70
800035d2:	05 5c       	LJMP      R5
##@@@F_:prvIsQueueEmpty():
##@@@P_:queue.c:2606
##@@@L2601_:
##@@@L2602_:static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )   
##@@@L2603_:{   
##@@@L2604_:    BaseType_t xReturn;   
##@@@L2605_:
##@@@L2606_:    taskENTER_CRITICAL();   
800035d4:	3d 45       	LD        R5, [PC + #61]        ;->0x800036c8  :=0x800056cc
800035d6:	05 5c       	LJMP      R5
##@@@P_:queue.c:2608
##@@@L2607_:    {   
##@@@L2608_:        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )   
800035d8:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2617
##@@@L2612_:        else   
##@@@L2613_:        {   
##@@@L2614_:            xReturn = pdFALSE;   
##@@@L2615_:        }   
##@@@L2616_:    }   
##@@@L2617_:    taskEXIT_CRITICAL();   
800035da:	3a 45       	LD        R5, [PC + #58]        ;->0x800036c0  :=0x80005730
800035dc:	05 5c       	LJMP      R5
##@@@F_:xQueuePeek():
##@@@P_:queue.c:2013
##@@@L2008_:            /* The timeout has expired.  If there is still no data in the queue   
##@@@L2009_:             * exit, otherwise go back and try to read the data again. */   
##@@@L2010_:            prvUnlockQueue( pxQueue );   
##@@@L2011_:            ( void ) xTaskResumeAll();   
##@@@L2012_:
##@@@L2013_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
800035de:	70 38       	CMP       R7, #0			;->0x00
800035e0:	1c f1       	JNZ       $+28                  ;->0x80003618
800035e2:	be 07       	SJMP      $-66                  ;->0x8000355e
##@@@F_:prvIsQueueEmpty():
##@@@P_:queue.c:2606
##@@@L2601_:
##@@@L2602_:static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )   
##@@@L2603_:{   
##@@@L2604_:    BaseType_t xReturn;   
##@@@L2605_:
##@@@L2606_:    taskENTER_CRITICAL();   
800035e4:	39 45       	LD        R5, [PC + #57]        ;->0x800036c8  :=0x800056cc
800035e6:	05 5c       	LJMP      R5
##@@@P_:queue.c:2608
##@@@L2607_:    {   
##@@@L2608_:        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )   
800035e8:	be 9b       	LD.W      R7, [R6 + #14]
##@@@P_:queue.c:2617
##@@@L2612_:        else   
##@@@L2613_:        {   
##@@@L2614_:            xReturn = pdFALSE;   
##@@@L2615_:        }   
##@@@L2616_:    }   
##@@@L2617_:    taskEXIT_CRITICAL();   
800035ea:	36 45       	LD        R5, [PC + #54]        ;->0x800036c0  :=0x80005730
800035ec:	05 5c       	LJMP      R5
##@@@F_:xQueuePeek():
##@@@P_:queue.c:1983
##@@@L1978_:        /* Update the timeout state to see if it has expired yet. */   
##@@@L1979_:        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )   
##@@@L1980_:        {   
##@@@L1981_:            /* Timeout has not expired yet, check to see if there is data in the   
##@@@L1982_:            * queue now, and if not enter the Blocked state to wait for data. */   
##@@@L1983_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
800035ee:	70 38       	CMP       R7, #0			;->0x00
800035f0:	07 f0       	JZ        $+7                   ;->0x800035fe
##@@@P_:queue.c:2002
##@@@L1997_:            }   
##@@@L1998_:            else   
##@@@L1999_:            {   
##@@@L2000_:                /* There is data in the queue now, so don't enter the blocked   
##@@@L2001_:                 * state, instead return to try and obtain the data. */   
##@@@L2002_:                prvUnlockQueue( pxQueue );   
800035f2:	06 58       	MOV       R0, R6
800035f4:	38 45       	LD        R5, [PC + #56]        ;->0x800036d4  :=0x80002e64
800035f6:	05 5c       	LJMP      R5
##@@@P_:queue.c:2003
##@@@L2003_:                ( void ) xTaskResumeAll();   
800035f8:	38 45       	LD        R5, [PC + #56]        ;->0x800036d8  :=0x80005a70
800035fa:	05 5c       	LJMP      R5
800035fc:	0e 04       	SJMP      $+14                  ;->0x80003618
##@@@P_:queue.c:1986
##@@@L1981_:            /* Timeout has not expired yet, check to see if there is data in the   
##@@@L1982_:            * queue now, and if not enter the Blocked state to wait for data. */   
##@@@L1983_:            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )   
##@@@L1984_:            {   
##@@@L1985_:                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );   
##@@@L1986_:                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );   
800035fe:	04 09       	LD.W      R1, [SP + #4]
80003600:	01 08       	LD.W      R0, [SP + #1]
80003602:	37 45       	LD        R5, [PC + #55]        ;->0x800036dc  :=0x80006e8c
80003604:	05 5c       	LJMP      R5
##@@@P_:queue.c:1987
##@@@L1987_:                prvUnlockQueue( pxQueue );   
80003606:	06 58       	MOV       R0, R6
80003608:	33 45       	LD        R5, [PC + #51]        ;->0x800036d4  :=0x80002e64
8000360a:	05 5c       	LJMP      R5
##@@@P_:queue.c:1989
##@@@L1988_:
##@@@L1989_:                if( xTaskResumeAll() == pdFALSE )   
8000360c:	33 45       	LD        R5, [PC + #51]        ;->0x800036d8  :=0x80005a70
8000360e:	05 5c       	LJMP      R5
80003610:	00 38       	CMP       R0, #0			;->0x00
80003612:	03 f1       	JNZ       $+3                   ;->0x80003618
##@@@P_:queue.c:1991
##@@@L1990_:                {   
##@@@L1991_:                    taskYIELD_WITHIN_API();   
80003614:	33 45       	LD        R5, [PC + #51]        ;->0x800036e0  :=0x80008f64
80003616:	05 5c       	LJMP      R5
##@@@P_:queue.c:1898
##@@@L1893_:    }   
##@@@L1894_:    #endif   
##@@@L1895_:
##@@@L1896_:    for( ; ; )   
##@@@L1897_:    {   
##@@@L1898_:        taskENTER_CRITICAL();   
80003618:	2c 45       	LD        R5, [PC + #44]        ;->0x800036c8  :=0x800056cc
8000361a:	05 5c       	LJMP      R5
##@@@P_:queue.c:1900
##@@@L1899_:        {   
##@@@L1900_:            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
8000361c:	ae 9b       	LD.W      R5, [R6 + #14]
##@@@P_:queue.c:1904
##@@@L1901_:
##@@@L1902_:            /* Is there data in the queue now?  To be running the calling task   
##@@@L1903_:             * must be the highest priority task wanting to access the queue. */   
##@@@L1904_:            if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
8000361e:	50 38       	CMP       R5, #0			;->0x00
80003620:	02 f0       	JZ        $+2                   ;->0x80003624
80003622:	81 07       	SJMP      $-127                 ;->0x80003524
##@@@P_:queue.c:1944
##@@@L1939_:
##@@@L1940_:                return pdPASS;   
##@@@L1941_:            }   
##@@@L1942_:            else   
##@@@L1943_:            {   
##@@@L1944_:                if( xTicksToWait == ( TickType_t ) 0 )   
80003624:	04 0d       	LD.W      R5, [SP + #4]
80003626:	50 38       	CMP       R5, #0			;->0x00
80003628:	b5 f1       	JNZ       $-75                  ;->0x80003592
8000362a:	98 07       	SJMP      $-104                 ;->0x8000355a
##@@@P_:queue.c:1883
##@@@L1878_:    Queue_t * const pxQueue = xQueue;   
##@@@L1879_:
##@@@L1880_:    traceENTER_xQueuePeek( xQueue, pvBuffer, xTicksToWait );   
##@@@L1881_:
##@@@L1882_:    /* Check the pointer is not NULL. */   
##@@@L1883_:    configASSERT( ( pxQueue ) );   
8000362c:	20 5d       	PUSH      R0
8000362e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003632:	08 00       	SYNC     SYNC     
80003634:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003638:	08 00       	SYNC     SYNC     
8000363a:	00 5d       	POP       R0
8000363c:	20 5d       	PUSH      R0
8000363e:	21 5d       	PUSH      R1
80003640:	29 45       	LD        R5, [PC + #41]        ;->0x800036e4  :=0x1ff
80003642:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003646:	25 58       	MOV       R1, R5
80003648:	11 68       	NOT       R1, R1
8000364a:	01 69       	ANL       R0, R1
8000364c:	5f 11       	MOV       R5, #31			;->0x001F
8000364e:	25 58       	MOV       R1, R5
80003650:	01 6a       	ORL       R0, R1
80003652:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003656:	08 00       	SYNC     SYNC     
80003658:	01 5d       	POP       R1
8000365a:	00 5d       	POP       R0
8000365c:	20 5d       	PUSH      R0
8000365e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003662:	08 00       	SYNC     SYNC     
80003664:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003668:	08 00       	SYNC     SYNC     
8000366a:	00 5d       	POP       R0
8000366c:	07 00       	BREAK    BREAK    
8000366e:	1f 45       	LD        R5, [PC + #31]        ;->0x800036e8  :=0x8000911c
80003670:	05 5c       	LJMP      R5
##@@@P_:queue.c:1887
##@@@L1884_:
##@@@L1885_:    /* The buffer into which data is received can only be NULL if the data size   
##@@@L1886_:     * is zero (so no data is copied into the buffer. */   
##@@@L1887_:    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );   
80003672:	20 5d       	PUSH      R0
80003674:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003678:	08 00       	SYNC     SYNC     
8000367a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000367e:	08 00       	SYNC     SYNC     
80003680:	00 5d       	POP       R0
80003682:	20 5d       	PUSH      R0
80003684:	21 5d       	PUSH      R1
80003686:	18 45       	LD        R5, [PC + #24]        ;->0x800036e4  :=0x1ff
80003688:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000368c:	25 58       	MOV       R1, R5
8000368e:	11 68       	NOT       R1, R1
80003690:	01 69       	ANL       R0, R1
80003692:	5f 11       	MOV       R5, #31			;->0x001F
80003694:	25 58       	MOV       R1, R5
80003696:	01 6a       	ORL       R0, R1
80003698:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000369c:	08 00       	SYNC     SYNC     
8000369e:	01 5d       	POP       R1
800036a0:	00 5d       	POP       R0
800036a2:	20 5d       	PUSH      R0
800036a4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800036a8:	08 00       	SYNC     SYNC     
800036aa:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800036ae:	08 00       	SYNC     SYNC     
800036b0:	00 5d       	POP       R0
800036b2:	07 00       	BREAK    BREAK    
800036b4:	0d 45       	LD        R5, [PC + #13]        ;->0x800036e8  :=0x8000911c
800036b6:	05 5c       	LJMP      R5
800036b8:	08 00 00 00 	.long     0x00000008 ->000000008  [!!!@2@:SYNC     	@@: NOP      
800036bc:	04 73 00 80 	.long     0x80007304 ->-2147454204  [!!!@2@:ST.W      [R0++], R4	@@: LD.B      R0, [R0]
800036c0:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x800036c0
800036c4:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
800036c8:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x800036c8
800036cc:	10 00 00 00 	.long     0x00000010 ->000000016  [!!!@4@:DMAC16LL  ACC0, ACC0, R0, R0
800036d0:	1c 73 00 80 	.long     0x8000731c ->-2147454180  [!!!@2@:ST.W      [R1++], R12	@@: LD.B      R0, [R0]
800036d4:	64 2e 00 80 	.long     0x80002e64 ->-2147471772  [!!!@2@:ADD       R6, #100	@@: LD.B      R0, [R0]
800036d8:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
800036dc:	8c 6e 00 80 	.long     0x80006e8c ->-2147455348  [!!!@2@:ASR       R8, R12	@@: LD.B      R0, [R0]
800036e0:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
800036e4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800036e8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800036ec <xQueueReceiveFromISR>:
##@@@F_:xQueueReceiveFromISR():
##@@@P_:queue.c:2032
##@@@L2027_:/*-----------------------------------------------------------*/   
##@@@L2028_:
##@@@L2029_:BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,   
##@@@L2030_:                                 void * const pvBuffer,   
##@@@L2031_:                                 BaseType_t * const pxHigherPriorityTaskWoken )   
##@@@L2032_:{   
800036ec:	9f 5f       	PUSH      {R6-R10,LR}
800036ee:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:queue.c:2039
##@@@L2034_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L2035_:    Queue_t * const pxQueue = xQueue;   
##@@@L2036_:
##@@@L2037_:    traceENTER_xQueueReceiveFromISR( xQueue, pvBuffer, pxHigherPriorityTaskWoken );   
##@@@L2038_:
##@@@L2039_:    configASSERT( pxQueue );   
800036f0:	00 38       	CMP       R0, #0			;->0x00
800036f2:	02 f1       	JNZ       $+2                   ;->0x800036f6
800036f4:	56 04       	SJMP      $+86                  ;->0x800037a0
800036f6:	e0 58       	MOV       R7, R0
800036f8:	02 59       	MOV       R8, R2
800036fa:	21 59       	MOV       R9, R1
##@@@P_:queue.c:2040
##@@@L2040_:    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
800036fc:	10 38       	CMP       R1, #0			;->0x00
800036fe:	04 f1       	JNZ       $+4                   ;->0x80003706
80003700:	2f 9c       	LD.W      R5, [R7 + #16]
80003702:	50 38       	CMP       R5, #0			;->0x00
80003704:	71 f1       	JNZ       $+113                 ;->0x800037e6
##@@@P_:queue.c:2058
##@@@L2053_:     * safe API to ensure interrupt entry is as fast and as simple as possible.   
##@@@L2054_:     * More information (albeit Cortex-M specific) is provided on the following   
##@@@L2055_:     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L2056_:    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L2057_:
##@@@L2058_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80003706:	21 45       	LD        R5, [PC + #33]        ;->0x80003788  :=0x80008ff0
80003708:	05 5c       	LJMP      R5
##@@@P_:queue.c:2060
##@@@L2059_:    {   
##@@@L2060_:        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
8000370a:	b7 9b       	LD.W      R6, [R7 + #14]
##@@@P_:queue.c:2063
##@@@L2061_:
##@@@L2062_:        /* Cannot block in an ISR, so check there is data available. */   
##@@@L2063_:        if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
8000370c:	60 38       	CMP       R6, #0			;->0x00
##@@@P_:queue.c:2058
##@@@L2053_:     * safe API to ensure interrupt entry is as fast and as simple as possible.   
##@@@L2054_:     * More information (albeit Cortex-M specific) is provided on the following   
##@@@L2055_:     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L2056_:    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L2057_:
##@@@L2058_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
8000370e:	40 59       	MOV       R10, R0
##@@@P_:queue.c:2063
##@@@L2059_:    {   
##@@@L2060_:        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;   
##@@@L2061_:
##@@@L2062_:        /* Cannot block in an ISR, so check there is data available. */   
##@@@L2063_:        if( uxMessagesWaiting > ( UBaseType_t ) 0 )   
80003710:	22 f0       	JZ        $+34                  ;->0x80003754
80003712:	61 00 e5 10 	LDS.B     R5, [R7 + #68]			;->0x44
##@@@F_:prvCopyDataFromQueue():
##@@@P_:queue.c:2464
##@@@L2459_:/*-----------------------------------------------------------*/   
##@@@L2460_:
##@@@L2461_:static void prvCopyDataFromQueue( Queue_t * const pxQueue,   
##@@@L2462_:                                  void * const pvBuffer )   
##@@@L2463_:{   
##@@@L2464_:    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )   
80003716:	01 25       	ST.W      [SP + #1], R5
80003718:	17 9c       	LD.W      R2, [R7 + #16]
8000371a:	20 38       	CMP       R2, #0			;->0x00
8000371c:	0c f0       	JZ        $+12                  ;->0x80003734
##@@@P_:queue.c:2466
##@@@L2465_:    {   
##@@@L2466_:        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;   
8000371e:	ef 98       	LD.W      R5, [R7 + #3]
80003720:	8d c2       	ADD       R1, R5, R2
80003722:	f9 a0       	ST.W      [R7 + #3], R1
##@@@P_:queue.c:2468
##@@@L2467_:
##@@@L2468_:        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )   
80003724:	af 98       	LD.W      R5, [R7 + #2]
80003726:	15 70       	CMP       R1, R5
80003728:	03 f3       	JNC       $+3                   ;->0x8000372e
##@@@P_:queue.c:2470
##@@@L2469_:        {   
##@@@L2470_:            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;   
8000372a:	17 82       	LD.W      R1, [R7]
8000372c:	f9 a0       	ST.W      [R7 + #3], R1
##@@@P_:queue.c:2477
##@@@L2472_:        else   
##@@@L2473_:        {   
##@@@L2474_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2475_:        }   
##@@@L2476_:
##@@@L2477_:        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );   
8000372e:	09 58       	MOV       R0, R9
80003730:	17 45       	LD        R5, [PC + #23]        ;->0x8000378c  :=0x8000d9ec
80003732:	05 5c       	LJMP      R5
##@@@F_:xQueueReceiveFromISR():
##@@@P_:queue.c:2076
##@@@L2071_:
##@@@L2072_:            /* If the queue is locked the event list will not be modified.   
##@@@L2073_:             * Instead update the lock count so the task that unlocks the queue   
##@@@L2074_:             * will know that an ISR has removed data while the queue was   
##@@@L2075_:             * locked. */   
##@@@L2076_:            if( cRxLock == queueUNLOCKED )   
80003734:	17 45       	LD        R5, [PC + #23]        ;->0x80003790  :=0xffffffff
##@@@P_:queue.c:2070
##@@@L2065_:            const int8_t cRxLock = pxQueue->cRxLock;   
##@@@L2066_:
##@@@L2067_:            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );   
##@@@L2068_:
##@@@L2069_:            prvCopyDataFromQueue( pxQueue, pvBuffer );   
##@@@L2070_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );   
80003736:	66 cc       	SUB       R4, R6, #1
80003738:	01 0e       	LD.W      R6, [SP + #1]
##@@@P_:queue.c:2076
##@@@L2071_:
##@@@L2072_:            /* If the queue is locked the event list will not be modified.   
##@@@L2073_:             * Instead update the lock count so the task that unlocks the queue   
##@@@L2074_:             * will know that an ISR has removed data while the queue was   
##@@@L2075_:             * locked. */   
##@@@L2076_:            if( cRxLock == queueUNLOCKED )   
8000373a:	65 70       	CMP       R6, R5
##@@@P_:queue.c:2070
##@@@L2065_:            const int8_t cRxLock = pxQueue->cRxLock;   
##@@@L2066_:
##@@@L2067_:            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );   
##@@@L2068_:
##@@@L2069_:            prvCopyDataFromQueue( pxQueue, pvBuffer );   
##@@@L2070_:            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );   
8000373c:	bc a3       	ST.W      [R7 + #14], R4
##@@@P_:queue.c:2076
##@@@L2071_:
##@@@L2072_:            /* If the queue is locked the event list will not be modified.   
##@@@L2073_:             * Instead update the lock count so the task that unlocks the queue   
##@@@L2074_:             * will know that an ISR has removed data while the queue was   
##@@@L2075_:             * locked. */   
##@@@L2076_:            if( cRxLock == queueUNLOCKED )   
8000373e:	0d f0       	JZ        $+13                  ;->0x80003758
##@@@P_:queue.c:2107
##@@@L2102_:            }   
##@@@L2103_:            else   
##@@@L2104_:            {   
##@@@L2105_:                /* Increment the lock count so the task that unlocks the queue   
##@@@L2106_:                 * knows that data was removed while it was locked. */   
##@@@L2107_:                prvIncrementQueueRxLock( pxQueue, cRxLock );   
80003740:	15 45       	LD        R5, [PC + #21]        ;->0x80003794  :=0x800069d0
80003742:	05 5c       	LJMP      R5
80003744:	06 70       	CMP       R0, R6
80003746:	17 f9       	JLS       $+23                  ;->0x80003774
80003748:	6f 3f       	CMP       R6, #127			;->0x7F
8000374a:	71 f0       	JZ        $+113                 ;->0x8000382c
8000374c:	6e c0       	ADD       R5, R6, #1
8000374e:	79 00 e5 10 	ST.B      [R7 + #68], R5			;->0x44
80003752:	11 04       	SJMP      $+17                  ;->0x80003774
80003754:	70 10       	MOV       R7, #0			;->0x0000
80003756:	10 04       	SJMP      $+16                  ;->0x80003776
##@@@P_:queue.c:2078
##@@@L2073_:             * Instead update the lock count so the task that unlocks the queue   
##@@@L2074_:             * will know that an ISR has removed data while the queue was   
##@@@L2075_:             * locked. */   
##@@@L2076_:            if( cRxLock == queueUNLOCKED )   
##@@@L2077_:            {   
##@@@L2078_:                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )   
80003758:	2f 99       	LD.W      R5, [R7 + #4]
8000375a:	50 38       	CMP       R5, #0			;->0x00
8000375c:	0c f0       	JZ        $+12                  ;->0x80003774
8000375e:	70 29       	ADD       R7, #16			;->0x10
##@@@P_:queue.c:2080
##@@@L2079_:                {   
##@@@L2080_:                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )   
80003760:	07 58       	MOV       R0, R7
80003762:	0e 45       	LD        R5, [PC + #14]        ;->0x80003798  :=0x80006ffc
80003764:	05 5c       	LJMP      R5
80003766:	71 10       	MOV       R7, #1			;->0x0001
80003768:	80 38       	CMP       R8, #0			;->0x00
8000376a:	06 f0       	JZ        $+6                   ;->0x80003776
8000376c:	00 38       	CMP       R0, #0			;->0x00
8000376e:	04 f0       	JZ        $+4                   ;->0x80003776
##@@@P_:queue.c:2086
##@@@L2081_:                    {   
##@@@L2082_:                        /* The task waiting has a higher priority than us so   
##@@@L2083_:                         * force a context switch. */   
##@@@L2084_:                        if( pxHigherPriorityTaskWoken != NULL )   
##@@@L2085_:                        {   
##@@@L2086_:                            *pxHigherPriorityTaskWoken = pdTRUE;   
80003770:	87 85       	ST.W      [R8], R7
80003772:	02 04       	SJMP      $+2                   ;->0x80003776
80003774:	71 10       	MOV       R7, #1			;->0x0001
##@@@P_:queue.c:2118
##@@@L2113_:        {   
##@@@L2114_:            xReturn = pdFAIL;   
##@@@L2115_:            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );   
##@@@L2116_:        }   
##@@@L2117_:    }   
##@@@L2118_:    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80003776:	0a 58       	MOV       R0, R10
80003778:	09 45       	LD        R5, [PC + #9]         ;->0x8000379c  :=0x80009034
8000377a:	05 5c       	LJMP      R5
##@@@P_:queue.c:2122
##@@@L2119_:
##@@@L2120_:    traceRETURN_xQueueReceiveFromISR( xReturn );   
##@@@L2121_:
##@@@L2122_:    return xReturn;   
8000377c:	07 58       	MOV       R0, R7
8000377e:	e8 28       	ADD       SP, #8			;->0x08
80003780:	1f 5e       	POP       {R6-R10}
80003782:	0d 5d       	POP       LR
80003784:	1d 5c       	JMP       LR
80003786:	00 00       	NOP      NOP      
80003788:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
8000378c:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
80003790:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80003794:	d0 69 00 80 	.long     0x800069d0 ->-2147456560  [!!!@2@:ANL       LR, R0	@@: LD.B      R0, [R0]
80003798:	fc 6f 00 80 	.long     0x80006ffc ->-2147454980  [!!!@2@:ROR       PC, R12	@@: LD.B      R0, [R0]
8000379c:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:queue.c:2039
##@@@L2034_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L2035_:    Queue_t * const pxQueue = xQueue;   
##@@@L2036_:
##@@@L2037_:    traceENTER_xQueueReceiveFromISR( xQueue, pvBuffer, pxHigherPriorityTaskWoken );   
##@@@L2038_:
##@@@L2039_:    configASSERT( pxQueue );   
800037a0:	20 5d       	PUSH      R0
800037a2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800037a6:	08 00       	SYNC     SYNC     
800037a8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800037ac:	08 00       	SYNC     SYNC     
800037ae:	00 5d       	POP       R0
800037b0:	20 5d       	PUSH      R0
800037b2:	21 5d       	PUSH      R1
800037b4:	30 45       	LD        R5, [PC + #48]        ;->0x80003874  :=0x1ff
800037b6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800037ba:	25 58       	MOV       R1, R5
800037bc:	11 68       	NOT       R1, R1
800037be:	01 69       	ANL       R0, R1
800037c0:	5f 11       	MOV       R5, #31			;->0x001F
800037c2:	25 58       	MOV       R1, R5
800037c4:	01 6a       	ORL       R0, R1
800037c6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800037ca:	08 00       	SYNC     SYNC     
800037cc:	01 5d       	POP       R1
800037ce:	00 5d       	POP       R0
800037d0:	20 5d       	PUSH      R0
800037d2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800037d6:	08 00       	SYNC     SYNC     
800037d8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800037dc:	08 00       	SYNC     SYNC     
800037de:	00 5d       	POP       R0
800037e0:	07 00       	BREAK    BREAK    
800037e2:	26 45       	LD        R5, [PC + #38]        ;->0x80003878  :=0x8000911c
800037e4:	05 5c       	LJMP      R5
##@@@P_:queue.c:2040
##@@@L2040_:    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
800037e6:	20 5d       	PUSH      R0
800037e8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800037ec:	08 00       	SYNC     SYNC     
800037ee:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800037f2:	08 00       	SYNC     SYNC     
800037f4:	00 5d       	POP       R0
800037f6:	20 5d       	PUSH      R0
800037f8:	21 5d       	PUSH      R1
800037fa:	1f 45       	LD        R5, [PC + #31]        ;->0x80003874  :=0x1ff
800037fc:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003800:	25 58       	MOV       R1, R5
80003802:	11 68       	NOT       R1, R1
80003804:	01 69       	ANL       R0, R1
80003806:	5f 11       	MOV       R5, #31			;->0x001F
80003808:	25 58       	MOV       R1, R5
8000380a:	01 6a       	ORL       R0, R1
8000380c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003810:	08 00       	SYNC     SYNC     
80003812:	01 5d       	POP       R1
80003814:	00 5d       	POP       R0
80003816:	20 5d       	PUSH      R0
80003818:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000381c:	08 00       	SYNC     SYNC     
8000381e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003822:	08 00       	SYNC     SYNC     
80003824:	00 5d       	POP       R0
80003826:	07 00       	BREAK    BREAK    
80003828:	14 45       	LD        R5, [PC + #20]        ;->0x80003878  :=0x8000911c
8000382a:	05 5c       	LJMP      R5
##@@@P_:queue.c:2107
##@@@L2102_:            }   
##@@@L2103_:            else   
##@@@L2104_:            {   
##@@@L2105_:                /* Increment the lock count so the task that unlocks the queue   
##@@@L2106_:                 * knows that data was removed while it was locked. */   
##@@@L2107_:                prvIncrementQueueRxLock( pxQueue, cRxLock );   
8000382c:	20 5d       	PUSH      R0
8000382e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003832:	08 00       	SYNC     SYNC     
80003834:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003838:	08 00       	SYNC     SYNC     
8000383a:	00 5d       	POP       R0
8000383c:	20 5d       	PUSH      R0
8000383e:	21 5d       	PUSH      R1
80003840:	0d 45       	LD        R5, [PC + #13]        ;->0x80003874  :=0x1ff
80003842:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003846:	25 58       	MOV       R1, R5
80003848:	11 68       	NOT       R1, R1
8000384a:	01 69       	ANL       R0, R1
8000384c:	5f 11       	MOV       R5, #31			;->0x001F
8000384e:	25 58       	MOV       R1, R5
80003850:	01 6a       	ORL       R0, R1
80003852:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003856:	08 00       	SYNC     SYNC     
80003858:	01 5d       	POP       R1
8000385a:	00 5d       	POP       R0
8000385c:	20 5d       	PUSH      R0
8000385e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003862:	08 00       	SYNC     SYNC     
80003864:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003868:	08 00       	SYNC     SYNC     
8000386a:	00 5d       	POP       R0
8000386c:	07 00       	BREAK    BREAK    
8000386e:	03 45       	LD        R5, [PC + #3]         ;->0x80003878  :=0x8000911c
80003870:	05 5c       	LJMP      R5
80003872:	00 00       	NOP      NOP      
80003874:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003878:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

8000387c <xQueuePeekFromISR>:
##@@@F_:xQueuePeekFromISR():
##@@@P_:queue.c:2128
##@@@L2123_:}   
##@@@L2124_:/*-----------------------------------------------------------*/   
##@@@L2125_:
##@@@L2126_:BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,   
##@@@L2127_:                              void * const pvBuffer )   
##@@@L2128_:{   
8000387c:	87 5f       	PUSH      {R6-R8,LR}
8000387e:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:queue.c:2136
##@@@L2131_:    int8_t * pcOriginalReadPosition;   
##@@@L2132_:    Queue_t * const pxQueue = xQueue;   
##@@@L2133_:
##@@@L2134_:    traceENTER_xQueuePeekFromISR( xQueue, pvBuffer );   
##@@@L2135_:
##@@@L2136_:    configASSERT( pxQueue );   
80003880:	00 38       	CMP       R0, #0			;->0x00
80003882:	31 f0       	JZ        $+49                  ;->0x800038e4
80003884:	c0 58       	MOV       R6, R0
80003886:	e1 58       	MOV       R7, R1
80003888:	28 9c       	LD.W      R5, [R0 + #16]
##@@@P_:queue.c:2137
##@@@L2137_:    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
8000388a:	10 38       	CMP       R1, #0			;->0x00
8000388c:	4f f0       	JZ        $+79                  ;->0x8000392a
##@@@P_:queue.c:2138
##@@@L2138_:    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */   
8000388e:	50 38       	CMP       R5, #0			;->0x00
80003890:	4f f0       	JZ        $+79                  ;->0x8000392e
##@@@P_:queue.c:2156
##@@@L2151_:     * safe API to ensure interrupt entry is as fast and as simple as possible.   
##@@@L2152_:     * More information (albeit Cortex-M specific) is provided on the following   
##@@@L2153_:     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L2154_:    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L2155_:
##@@@L2156_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80003892:	12 45       	LD        R5, [PC + #18]        ;->0x800038d8  :=0x80008ff0
80003894:	05 5c       	LJMP      R5
##@@@P_:queue.c:2159
##@@@L2157_:    {   
##@@@L2158_:        /* Cannot block in an ISR, so check there is data available. */   
##@@@L2159_:        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )   
80003896:	ae 9b       	LD.W      R5, [R6 + #14]
80003898:	50 38       	CMP       R5, #0			;->0x00
##@@@P_:queue.c:2156
##@@@L2151_:     * safe API to ensure interrupt entry is as fast and as simple as possible.   
##@@@L2152_:     * More information (albeit Cortex-M specific) is provided on the following   
##@@@L2153_:     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L2154_:    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L2155_:
##@@@L2156_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
8000389a:	00 59       	MOV       R8, R0
##@@@P_:queue.c:2159
##@@@L2157_:    {   
##@@@L2158_:        /* Cannot block in an ISR, so check there is data available. */   
##@@@L2159_:        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )   
8000389c:	14 f0       	JZ        $+20                  ;->0x800038c4
##@@@F_:prvCopyDataFromQueue():
##@@@P_:queue.c:2464
##@@@L2459_:/*-----------------------------------------------------------*/   
##@@@L2460_:
##@@@L2461_:static void prvCopyDataFromQueue( Queue_t * const pxQueue,   
##@@@L2462_:                                  void * const pvBuffer )   
##@@@L2463_:{   
##@@@L2464_:    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )   
8000389e:	16 9c       	LD.W      R2, [R6 + #16]
##@@@F_:xQueuePeekFromISR():
##@@@P_:queue.c:2165
##@@@L2160_:        {   
##@@@L2161_:            traceQUEUE_PEEK_FROM_ISR( pxQueue );   
##@@@L2162_:
##@@@L2163_:            /* Remember the read position so it can be reset as nothing is   
##@@@L2164_:             * actually being removed from the queue. */   
##@@@L2165_:            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;   
800038a0:	ee 98       	LD.W      R5, [R6 + #3]
##@@@F_:prvCopyDataFromQueue():
##@@@P_:queue.c:2464
##@@@L2459_:/*-----------------------------------------------------------*/   
##@@@L2460_:
##@@@L2461_:static void prvCopyDataFromQueue( Queue_t * const pxQueue,   
##@@@L2462_:                                  void * const pvBuffer )   
##@@@L2463_:{   
##@@@L2464_:    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )   
800038a2:	20 38       	CMP       R2, #0			;->0x00
800038a4:	0d f0       	JZ        $+13                  ;->0x800038be
800038a6:	01 25       	ST.W      [SP + #1], R5
##@@@P_:queue.c:2466
##@@@L2465_:    {   
##@@@L2466_:        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;   
800038a8:	8d c2       	ADD       R1, R5, R2
800038aa:	f1 a0       	ST.W      [R6 + #3], R1
##@@@P_:queue.c:2468
##@@@L2467_:
##@@@L2468_:        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )   
800038ac:	ae 98       	LD.W      R5, [R6 + #2]
800038ae:	15 70       	CMP       R1, R5
800038b0:	03 f3       	JNC       $+3                   ;->0x800038b6
##@@@P_:queue.c:2470
##@@@L2469_:        {   
##@@@L2470_:            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;   
800038b2:	16 82       	LD.W      R1, [R6]
800038b4:	f1 a0       	ST.W      [R6 + #3], R1
##@@@P_:queue.c:2477
##@@@L2472_:        else   
##@@@L2473_:        {   
##@@@L2474_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2475_:        }   
##@@@L2476_:
##@@@L2477_:        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );   
800038b6:	07 58       	MOV       R0, R7
800038b8:	09 45       	LD        R5, [PC + #9]         ;->0x800038dc  :=0x8000d9ec
800038ba:	05 5c       	LJMP      R5
800038bc:	01 0d       	LD.W      R5, [SP + #1]
##@@@F_:xQueuePeekFromISR():
##@@@P_:queue.c:2167
##@@@L2162_:
##@@@L2163_:            /* Remember the read position so it can be reset as nothing is   
##@@@L2164_:             * actually being removed from the queue. */   
##@@@L2165_:            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;   
##@@@L2166_:            prvCopyDataFromQueue( pxQueue, pvBuffer );   
##@@@L2167_:            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;   
800038be:	f5 a0       	ST.W      [R6 + #3], R5
800038c0:	61 10       	MOV       R6, #1			;->0x0001
800038c2:	02 04       	SJMP      $+2                   ;->0x800038c6
800038c4:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:queue.c:2177
##@@@L2172_:        {   
##@@@L2173_:            xReturn = pdFAIL;   
##@@@L2174_:            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );   
##@@@L2175_:        }   
##@@@L2176_:    }   
##@@@L2177_:    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
800038c6:	08 58       	MOV       R0, R8
800038c8:	06 45       	LD        R5, [PC + #6]         ;->0x800038e0  :=0x80009034
800038ca:	05 5c       	LJMP      R5
##@@@P_:queue.c:2181
##@@@L2178_:
##@@@L2179_:    traceRETURN_xQueuePeekFromISR( xReturn );   
##@@@L2180_:
##@@@L2181_:    return xReturn;   
800038cc:	06 58       	MOV       R0, R6
800038ce:	e8 28       	ADD       SP, #8			;->0x08
800038d0:	07 5e       	POP       {R6-R8}
800038d2:	0d 5d       	POP       LR
800038d4:	1d 5c       	JMP       LR
800038d6:	00 00       	NOP      NOP      
800038d8:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
800038dc:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
800038e0:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:queue.c:2136
##@@@L2131_:    int8_t * pcOriginalReadPosition;   
##@@@L2132_:    Queue_t * const pxQueue = xQueue;   
##@@@L2133_:
##@@@L2134_:    traceENTER_xQueuePeekFromISR( xQueue, pvBuffer );   
##@@@L2135_:
##@@@L2136_:    configASSERT( pxQueue );   
800038e4:	20 5d       	PUSH      R0
800038e6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800038ea:	08 00       	SYNC     SYNC     
800038ec:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800038f0:	08 00       	SYNC     SYNC     
800038f2:	00 5d       	POP       R0
800038f4:	20 5d       	PUSH      R0
800038f6:	21 5d       	PUSH      R1
800038f8:	31 45       	LD        R5, [PC + #49]        ;->0x800039bc  :=0x1ff
800038fa:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800038fe:	25 58       	MOV       R1, R5
80003900:	11 68       	NOT       R1, R1
80003902:	01 69       	ANL       R0, R1
80003904:	5f 11       	MOV       R5, #31			;->0x001F
80003906:	25 58       	MOV       R1, R5
80003908:	01 6a       	ORL       R0, R1
8000390a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000390e:	08 00       	SYNC     SYNC     
80003910:	01 5d       	POP       R1
80003912:	00 5d       	POP       R0
80003914:	20 5d       	PUSH      R0
80003916:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000391a:	08 00       	SYNC     SYNC     
8000391c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003920:	08 00       	SYNC     SYNC     
80003922:	00 5d       	POP       R0
80003924:	07 00       	BREAK    BREAK    
80003926:	27 45       	LD        R5, [PC + #39]        ;->0x800039c0  :=0x8000911c
80003928:	05 5c       	LJMP      R5
##@@@P_:queue.c:2137
##@@@L2137_:    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
8000392a:	50 38       	CMP       R5, #0			;->0x00
8000392c:	24 f1       	JNZ       $+36                  ;->0x80003974
##@@@P_:queue.c:2138
##@@@L2138_:    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */   
8000392e:	20 5d       	PUSH      R0
80003930:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003934:	08 00       	SYNC     SYNC     
80003936:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000393a:	08 00       	SYNC     SYNC     
8000393c:	00 5d       	POP       R0
8000393e:	20 5d       	PUSH      R0
80003940:	21 5d       	PUSH      R1
80003942:	1f 45       	LD        R5, [PC + #31]        ;->0x800039bc  :=0x1ff
80003944:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003948:	25 58       	MOV       R1, R5
8000394a:	11 68       	NOT       R1, R1
8000394c:	01 69       	ANL       R0, R1
8000394e:	5f 11       	MOV       R5, #31			;->0x001F
80003950:	25 58       	MOV       R1, R5
80003952:	01 6a       	ORL       R0, R1
80003954:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003958:	08 00       	SYNC     SYNC     
8000395a:	01 5d       	POP       R1
8000395c:	00 5d       	POP       R0
8000395e:	20 5d       	PUSH      R0
80003960:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003964:	08 00       	SYNC     SYNC     
80003966:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000396a:	08 00       	SYNC     SYNC     
8000396c:	00 5d       	POP       R0
8000396e:	07 00       	BREAK    BREAK    
80003970:	14 45       	LD        R5, [PC + #20]        ;->0x800039c0  :=0x8000911c
80003972:	05 5c       	LJMP      R5
##@@@P_:queue.c:2137
##@@@L2132_:    Queue_t * const pxQueue = xQueue;   
##@@@L2133_:
##@@@L2134_:    traceENTER_xQueuePeekFromISR( xQueue, pvBuffer );   
##@@@L2135_:
##@@@L2136_:    configASSERT( pxQueue );   
##@@@L2137_:    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );   
80003974:	20 5d       	PUSH      R0
80003976:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000397a:	08 00       	SYNC     SYNC     
8000397c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003980:	08 00       	SYNC     SYNC     
80003982:	00 5d       	POP       R0
80003984:	20 5d       	PUSH      R0
80003986:	21 5d       	PUSH      R1
80003988:	0d 45       	LD        R5, [PC + #13]        ;->0x800039bc  :=0x1ff
8000398a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000398e:	25 58       	MOV       R1, R5
80003990:	11 68       	NOT       R1, R1
80003992:	01 69       	ANL       R0, R1
80003994:	5f 11       	MOV       R5, #31			;->0x001F
80003996:	25 58       	MOV       R1, R5
80003998:	01 6a       	ORL       R0, R1
8000399a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000399e:	08 00       	SYNC     SYNC     
800039a0:	01 5d       	POP       R1
800039a2:	00 5d       	POP       R0
800039a4:	20 5d       	PUSH      R0
800039a6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800039aa:	08 00       	SYNC     SYNC     
800039ac:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800039b0:	08 00       	SYNC     SYNC     
800039b2:	00 5d       	POP       R0
800039b4:	07 00       	BREAK    BREAK    
800039b6:	03 45       	LD        R5, [PC + #3]         ;->0x800039c0  :=0x8000911c
800039b8:	05 5c       	LJMP      R5
800039ba:	00 00       	NOP      NOP      
800039bc:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800039c0:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800039c4 <uxQueueMessagesWaiting>:
##@@@F_:uxQueueMessagesWaiting():
##@@@P_:queue.c:2186
##@@@L2181_:    return xReturn;   
##@@@L2182_:}   
##@@@L2183_:/*-----------------------------------------------------------*/   
##@@@L2184_:
##@@@L2185_:UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )   
##@@@L2186_:{   
800039c4:	81 5f       	PUSH      {R6,LR}
800039c6:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:2191
##@@@L2187_:    UBaseType_t uxReturn;   
##@@@L2188_:
##@@@L2189_:    traceENTER_uxQueueMessagesWaiting( xQueue );   
##@@@L2190_:
##@@@L2191_:    configASSERT( xQueue );   
800039c8:	00 38       	CMP       R0, #0			;->0x00
800039ca:	11 f0       	JZ        $+17                  ;->0x800039ec
800039cc:	c0 58       	MOV       R6, R0
##@@@P_:queue.c:2193
##@@@L2192_:
##@@@L2193_:    taskENTER_CRITICAL();   
800039ce:	06 45       	LD        R5, [PC + #6]         ;->0x800039e4  :=0x800056cc
800039d0:	05 5c       	LJMP      R5
##@@@P_:queue.c:2195
##@@@L2194_:    {   
##@@@L2195_:        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;   
800039d2:	b6 9b       	LD.W      R6, [R6 + #14]
##@@@P_:queue.c:2197
##@@@L2196_:    }   
##@@@L2197_:    taskEXIT_CRITICAL();   
800039d4:	05 45       	LD        R5, [PC + #5]         ;->0x800039e8  :=0x80005730
800039d6:	05 5c       	LJMP      R5
##@@@P_:queue.c:2201
##@@@L2198_:
##@@@L2199_:    traceRETURN_uxQueueMessagesWaiting( uxReturn );   
##@@@L2200_:
##@@@L2201_:    return uxReturn;   
800039d8:	06 58       	MOV       R0, R6
800039da:	e4 28       	ADD       SP, #4			;->0x04
800039dc:	06 5d       	POP       R6
800039de:	0d 5d       	POP       LR
800039e0:	1d 5c       	JMP       LR
800039e2:	00 00       	NOP      NOP      
800039e4:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x800039e4
800039e8:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x800039e8
##@@@P_:queue.c:2191
##@@@L2186_:{   
##@@@L2187_:    UBaseType_t uxReturn;   
##@@@L2188_:
##@@@L2189_:    traceENTER_uxQueueMessagesWaiting( xQueue );   
##@@@L2190_:
##@@@L2191_:    configASSERT( xQueue );   
800039ec:	20 5d       	PUSH      R0
800039ee:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800039f2:	08 00       	SYNC     SYNC     
800039f4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800039f8:	08 00       	SYNC     SYNC     
800039fa:	00 5d       	POP       R0
800039fc:	20 5d       	PUSH      R0
800039fe:	21 5d       	PUSH      R1
80003a00:	0d 45       	LD        R5, [PC + #13]        ;->0x80003a34  :=0x1ff
80003a02:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003a06:	25 58       	MOV       R1, R5
80003a08:	11 68       	NOT       R1, R1
80003a0a:	01 69       	ANL       R0, R1
80003a0c:	5f 11       	MOV       R5, #31			;->0x001F
80003a0e:	25 58       	MOV       R1, R5
80003a10:	01 6a       	ORL       R0, R1
80003a12:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003a16:	08 00       	SYNC     SYNC     
80003a18:	01 5d       	POP       R1
80003a1a:	00 5d       	POP       R0
80003a1c:	20 5d       	PUSH      R0
80003a1e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003a22:	08 00       	SYNC     SYNC     
80003a24:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003a28:	08 00       	SYNC     SYNC     
80003a2a:	00 5d       	POP       R0
80003a2c:	07 00       	BREAK    BREAK    
80003a2e:	03 45       	LD        R5, [PC + #3]         ;->0x80003a38  :=0x8000911c
80003a30:	05 5c       	LJMP      R5
80003a32:	00 00       	NOP      NOP      
80003a34:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003a38:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003a3c <uxQueueSpacesAvailable>:
##@@@F_:uxQueueSpacesAvailable():
##@@@P_:queue.c:2206
##@@@L2201_:    return uxReturn;   
##@@@L2202_:}   
##@@@L2203_:/*-----------------------------------------------------------*/   
##@@@L2204_:
##@@@L2205_:UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )   
##@@@L2206_:{   
80003a3c:	81 5f       	PUSH      {R6,LR}
80003a3e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:2212
##@@@L2207_:    UBaseType_t uxReturn;   
##@@@L2208_:    Queue_t * const pxQueue = xQueue;   
##@@@L2209_:
##@@@L2210_:    traceENTER_uxQueueSpacesAvailable( xQueue );   
##@@@L2211_:
##@@@L2212_:    configASSERT( pxQueue );   
80003a40:	00 38       	CMP       R0, #0			;->0x00
80003a42:	13 f0       	JZ        $+19                  ;->0x80003a68
80003a44:	c0 58       	MOV       R6, R0
##@@@P_:queue.c:2214
##@@@L2213_:
##@@@L2214_:    taskENTER_CRITICAL();   
80003a46:	07 45       	LD        R5, [PC + #7]         ;->0x80003a60  :=0x800056cc
80003a48:	05 5c       	LJMP      R5
##@@@P_:queue.c:2216
##@@@L2215_:    {   
##@@@L2216_:        uxReturn = ( UBaseType_t ) ( pxQueue->uxLength - pxQueue->uxMessagesWaiting );   
80003a4a:	ae 9b       	LD.W      R5, [R6 + #14]
80003a4c:	e6 9b       	LD.W      R4, [R6 + #15]
80003a4e:	74 c7       	SUB       R6, R4, R5
##@@@P_:queue.c:2218
##@@@L2217_:    }   
##@@@L2218_:    taskEXIT_CRITICAL();   
80003a50:	05 45       	LD        R5, [PC + #5]         ;->0x80003a64  :=0x80005730
80003a52:	05 5c       	LJMP      R5
##@@@P_:queue.c:2222
##@@@L2219_:
##@@@L2220_:    traceRETURN_uxQueueSpacesAvailable( uxReturn );   
##@@@L2221_:
##@@@L2222_:    return uxReturn;   
80003a54:	06 58       	MOV       R0, R6
80003a56:	e4 28       	ADD       SP, #4			;->0x04
80003a58:	06 5d       	POP       R6
80003a5a:	0d 5d       	POP       LR
80003a5c:	1d 5c       	JMP       LR
80003a5e:	00 00       	NOP      NOP      
80003a60:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80003a60
80003a64:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80003a64
##@@@P_:queue.c:2212
##@@@L2207_:    UBaseType_t uxReturn;   
##@@@L2208_:    Queue_t * const pxQueue = xQueue;   
##@@@L2209_:
##@@@L2210_:    traceENTER_uxQueueSpacesAvailable( xQueue );   
##@@@L2211_:
##@@@L2212_:    configASSERT( pxQueue );   
80003a68:	20 5d       	PUSH      R0
80003a6a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003a6e:	08 00       	SYNC     SYNC     
80003a70:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003a74:	08 00       	SYNC     SYNC     
80003a76:	00 5d       	POP       R0
80003a78:	20 5d       	PUSH      R0
80003a7a:	21 5d       	PUSH      R1
80003a7c:	0d 45       	LD        R5, [PC + #13]        ;->0x80003ab0  :=0x1ff
80003a7e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003a82:	25 58       	MOV       R1, R5
80003a84:	11 68       	NOT       R1, R1
80003a86:	01 69       	ANL       R0, R1
80003a88:	5f 11       	MOV       R5, #31			;->0x001F
80003a8a:	25 58       	MOV       R1, R5
80003a8c:	01 6a       	ORL       R0, R1
80003a8e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003a92:	08 00       	SYNC     SYNC     
80003a94:	01 5d       	POP       R1
80003a96:	00 5d       	POP       R0
80003a98:	20 5d       	PUSH      R0
80003a9a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003a9e:	08 00       	SYNC     SYNC     
80003aa0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003aa4:	08 00       	SYNC     SYNC     
80003aa6:	00 5d       	POP       R0
80003aa8:	07 00       	BREAK    BREAK    
80003aaa:	03 45       	LD        R5, [PC + #3]         ;->0x80003ab4  :=0x8000911c
80003aac:	05 5c       	LJMP      R5
80003aae:	00 00       	NOP      NOP      
80003ab0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003ab4:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003ab8 <uxQueueMessagesWaitingFromISR>:
##@@@F_:uxQueueMessagesWaitingFromISR():
##@@@P_:queue.c:2227
##@@@L2222_:    return uxReturn;   
##@@@L2223_:}   
##@@@L2224_:/*-----------------------------------------------------------*/   
##@@@L2225_:
##@@@L2226_:UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )   
##@@@L2227_:{   
80003ab8:	2d 5d       	PUSH      LR
80003aba:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:2233
##@@@L2228_:    UBaseType_t uxReturn;   
##@@@L2229_:    Queue_t * const pxQueue = xQueue;   
##@@@L2230_:
##@@@L2231_:    traceENTER_uxQueueMessagesWaitingFromISR( xQueue );   
##@@@L2232_:
##@@@L2233_:    configASSERT( pxQueue );   
80003abc:	00 38       	CMP       R0, #0			;->0x00
80003abe:	05 f0       	JZ        $+5                   ;->0x80003ac8
##@@@P_:queue.c:2234
##@@@L2234_:    uxReturn = pxQueue->uxMessagesWaiting;   
80003ac0:	80 9b       	LD.W      R0, [R0 + #14]
##@@@P_:queue.c:2238
##@@@L2235_:
##@@@L2236_:    traceRETURN_uxQueueMessagesWaitingFromISR( uxReturn );   
##@@@L2237_:
##@@@L2238_:    return uxReturn;   
80003ac2:	e4 28       	ADD       SP, #4			;->0x04
80003ac4:	0d 5d       	POP       LR
80003ac6:	1d 5c       	JMP       LR
##@@@P_:queue.c:2233
##@@@L2228_:    UBaseType_t uxReturn;   
##@@@L2229_:    Queue_t * const pxQueue = xQueue;   
##@@@L2230_:
##@@@L2231_:    traceENTER_uxQueueMessagesWaitingFromISR( xQueue );   
##@@@L2232_:
##@@@L2233_:    configASSERT( pxQueue );   
80003ac8:	20 5d       	PUSH      R0
80003aca:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003ace:	08 00       	SYNC     SYNC     
80003ad0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003ad4:	08 00       	SYNC     SYNC     
80003ad6:	00 5d       	POP       R0
80003ad8:	20 5d       	PUSH      R0
80003ada:	21 5d       	PUSH      R1
80003adc:	0d 45       	LD        R5, [PC + #13]        ;->0x80003b10  :=0x1ff
80003ade:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003ae2:	25 58       	MOV       R1, R5
80003ae4:	11 68       	NOT       R1, R1
80003ae6:	01 69       	ANL       R0, R1
80003ae8:	5f 11       	MOV       R5, #31			;->0x001F
80003aea:	25 58       	MOV       R1, R5
80003aec:	01 6a       	ORL       R0, R1
80003aee:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003af2:	08 00       	SYNC     SYNC     
80003af4:	01 5d       	POP       R1
80003af6:	00 5d       	POP       R0
80003af8:	20 5d       	PUSH      R0
80003afa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003afe:	08 00       	SYNC     SYNC     
80003b00:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003b04:	08 00       	SYNC     SYNC     
80003b06:	00 5d       	POP       R0
80003b08:	07 00       	BREAK    BREAK    
80003b0a:	03 45       	LD        R5, [PC + #3]         ;->0x80003b14  :=0x8000911c
80003b0c:	05 5c       	LJMP      R5
80003b0e:	00 00       	NOP      NOP      
80003b10:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003b14:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003b18 <vQueueDelete>:
##@@@F_:vQueueDelete():
##@@@P_:queue.c:2243
##@@@L2238_:    return uxReturn;   
##@@@L2239_:}   
##@@@L2240_:/*-----------------------------------------------------------*/   
##@@@L2241_:
##@@@L2242_:void vQueueDelete( QueueHandle_t xQueue )   
##@@@L2243_:{   
80003b18:	2d 5d       	PUSH      LR
80003b1a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:2248
##@@@L2244_:    Queue_t * const pxQueue = xQueue;   
##@@@L2245_:
##@@@L2246_:    traceENTER_vQueueDelete( xQueue );   
##@@@L2247_:
##@@@L2248_:    configASSERT( pxQueue );   
80003b1c:	00 38       	CMP       R0, #0			;->0x00
80003b1e:	0d f0       	JZ        $+13                  ;->0x80003b38
80003b20:	51 00 05 18 	LD.B      R5, [R0 + #70]			;->0x46
##@@@P_:queue.c:2267
##@@@L2262_:    }   
##@@@L2263_:    #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )   
##@@@L2264_:    {   
##@@@L2265_:        /* The queue could have been allocated statically or dynamically, so   
##@@@L2266_:         * check before attempting to free the memory. */   
##@@@L2267_:        if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )   
80003b24:	50 38       	CMP       R5, #0			;->0x00
80003b26:	03 f1       	JNZ       $+3                   ;->0x80003b2c
##@@@P_:queue.c:2269
##@@@L2268_:        {   
##@@@L2269_:            vPortFree( pxQueue );   
80003b28:	03 45       	LD        R5, [PC + #3]         ;->0x80003b34  :=0x80008b9c
80003b2a:	05 5c       	LJMP      R5
##@@@P_:queue.c:2285
##@@@L2280_:        ( void ) pxQueue;   
##@@@L2281_:    }   
##@@@L2282_:    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */   
##@@@L2283_:
##@@@L2284_:    traceRETURN_vQueueDelete();   
##@@@L2285_:}   
80003b2c:	e4 28       	ADD       SP, #4			;->0x04
80003b2e:	0d 5d       	POP       LR
80003b30:	1d 5c       	JMP       LR
80003b32:	00 00       	NOP      NOP      
80003b34:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]
##@@@P_:queue.c:2248
##@@@L2243_:{   
##@@@L2244_:    Queue_t * const pxQueue = xQueue;   
##@@@L2245_:
##@@@L2246_:    traceENTER_vQueueDelete( xQueue );   
##@@@L2247_:
##@@@L2248_:    configASSERT( pxQueue );   
80003b38:	20 5d       	PUSH      R0
80003b3a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003b3e:	08 00       	SYNC     SYNC     
80003b40:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003b44:	08 00       	SYNC     SYNC     
80003b46:	00 5d       	POP       R0
80003b48:	20 5d       	PUSH      R0
80003b4a:	21 5d       	PUSH      R1
80003b4c:	0d 45       	LD        R5, [PC + #13]        ;->0x80003b80  :=0x1ff
80003b4e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003b52:	25 58       	MOV       R1, R5
80003b54:	11 68       	NOT       R1, R1
80003b56:	01 69       	ANL       R0, R1
80003b58:	5f 11       	MOV       R5, #31			;->0x001F
80003b5a:	25 58       	MOV       R1, R5
80003b5c:	01 6a       	ORL       R0, R1
80003b5e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003b62:	08 00       	SYNC     SYNC     
80003b64:	01 5d       	POP       R1
80003b66:	00 5d       	POP       R0
80003b68:	20 5d       	PUSH      R0
80003b6a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003b6e:	08 00       	SYNC     SYNC     
80003b70:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003b74:	08 00       	SYNC     SYNC     
80003b76:	00 5d       	POP       R0
80003b78:	07 00       	BREAK    BREAK    
80003b7a:	03 45       	LD        R5, [PC + #3]         ;->0x80003b84  :=0x8000911c
80003b7c:	05 5c       	LJMP      R5
80003b7e:	00 00       	NOP      NOP      
80003b80:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003b84:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003b88 <uxQueueGetQueueNumber>:
##@@@F_:uxQueueGetQueueNumber():
##@@@P_:queue.c:2296
##@@@L2291_:    {   
##@@@L2292_:        traceENTER_uxQueueGetQueueNumber( xQueue );   
##@@@L2293_:
##@@@L2294_:        traceRETURN_uxQueueGetQueueNumber( ( ( Queue_t * ) xQueue )->uxQueueNumber );   
##@@@L2295_:
##@@@L2296_:        return ( ( Queue_t * ) xQueue )->uxQueueNumber;   
80003b88:	80 9c       	LD.W      R0, [R0 + #18]
80003b8a:	1d 5c       	JMP       LR

80003b8c <vQueueSetQueueNumber>:
##@@@F_:vQueueSetQueueNumber():
##@@@P_:queue.c:2309
##@@@L2304_:    void vQueueSetQueueNumber( QueueHandle_t xQueue,   
##@@@L2305_:                               UBaseType_t uxQueueNumber )   
##@@@L2306_:    {   
##@@@L2307_:        traceENTER_vQueueSetQueueNumber( xQueue, uxQueueNumber );   
##@@@L2308_:
##@@@L2309_:        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;   
80003b8c:	81 a4       	ST.W      [R0 + #18], R1
##@@@P_:queue.c:2312
##@@@L2310_:
##@@@L2311_:        traceRETURN_vQueueSetQueueNumber();   
##@@@L2312_:    }   
80003b8e:	1d 5c       	JMP       LR

80003b90 <ucQueueGetQueueType>:
##@@@F_:ucQueueGetQueueType():
##@@@P_:queue.c:2320
##@@@L2315_:/*-----------------------------------------------------------*/   
##@@@L2316_:
##@@@L2317_:#if ( configUSE_TRACE_FACILITY == 1 )   
##@@@L2318_:
##@@@L2319_:    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )   
##@@@L2320_:    {   
80003b90:	51 00 00 30 	LD.B      R0, [R0 + #76]			;->0x4C
##@@@P_:queue.c:2325
##@@@L2321_:        traceENTER_ucQueueGetQueueType( xQueue );   
##@@@L2322_:
##@@@L2323_:        traceRETURN_ucQueueGetQueueType( ( ( Queue_t * ) xQueue )->ucQueueType );   
##@@@L2324_:
##@@@L2325_:        return ( ( Queue_t * ) xQueue )->ucQueueType;   
80003b94:	1d 5c       	JMP       LR
	...

80003b98 <uxQueueGetQueueItemSize>:
##@@@F_:uxQueueGetQueueItemSize():
##@@@P_:queue.c:2337
##@@@L2332_:{   
##@@@L2333_:    traceENTER_uxQueueGetQueueItemSize( xQueue );   
##@@@L2334_:
##@@@L2335_:    traceRETURN_uxQueueGetQueueItemSize( ( ( Queue_t * ) xQueue )->uxItemSize );   
##@@@L2336_:
##@@@L2337_:    return ( ( Queue_t * ) xQueue )->uxItemSize;   
80003b98:	00 9c       	LD.W      R0, [R0 + #16]
80003b9a:	1d 5c       	JMP       LR

80003b9c <uxQueueGetQueueLength>:
##@@@F_:uxQueueGetQueueLength():
##@@@P_:queue.c:2347
##@@@L2342_:{   
##@@@L2343_:    traceENTER_uxQueueGetQueueLength( xQueue );   
##@@@L2344_:
##@@@L2345_:    traceRETURN_uxQueueGetQueueLength( ( ( Queue_t * ) xQueue )->uxLength );   
##@@@L2346_:
##@@@L2347_:    return ( ( Queue_t * ) xQueue )->uxLength;   
80003b9c:	c0 9b       	LD.W      R0, [R0 + #15]
80003b9e:	1d 5c       	JMP       LR

80003ba0 <xQueueIsQueueEmptyFromISR>:
##@@@F_:xQueueIsQueueEmptyFromISR():
##@@@P_:queue.c:2624
##@@@L2619_:    return xReturn;   
##@@@L2620_:}   
##@@@L2621_:/*-----------------------------------------------------------*/   
##@@@L2622_:
##@@@L2623_:BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )   
##@@@L2624_:{   
80003ba0:	2d 5d       	PUSH      LR
80003ba2:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:2630
##@@@L2625_:    BaseType_t xReturn;   
##@@@L2626_:    Queue_t * const pxQueue = xQueue;   
##@@@L2627_:
##@@@L2628_:    traceENTER_xQueueIsQueueEmptyFromISR( xQueue );   
##@@@L2629_:
##@@@L2630_:    configASSERT( pxQueue );   
80003ba4:	00 38       	CMP       R0, #0			;->0x00
80003ba6:	0a f0       	JZ        $+10                  ;->0x80003bba
##@@@P_:queue.c:2632
##@@@L2631_:
##@@@L2632_:    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )   
80003ba8:	a8 9b       	LD.W      R5, [R0 + #14]
80003baa:	50 38       	CMP       R5, #0			;->0x00
80003bac:	03 f0       	JZ        $+3                   ;->0x80003bb2
80003bae:	00 10       	MOV       R0, #0			;->0x0000
80003bb0:	02 04       	SJMP      $+2                   ;->0x80003bb4
80003bb2:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:queue.c:2643
##@@@L2638_:        xReturn = pdFALSE;   
##@@@L2639_:    }   
##@@@L2640_:
##@@@L2641_:    traceRETURN_xQueueIsQueueEmptyFromISR( xReturn );   
##@@@L2642_:
##@@@L2643_:    return xReturn;   
80003bb4:	e4 28       	ADD       SP, #4			;->0x04
80003bb6:	0d 5d       	POP       LR
80003bb8:	1d 5c       	JMP       LR
##@@@P_:queue.c:2630
##@@@L2625_:    BaseType_t xReturn;   
##@@@L2626_:    Queue_t * const pxQueue = xQueue;   
##@@@L2627_:
##@@@L2628_:    traceENTER_xQueueIsQueueEmptyFromISR( xQueue );   
##@@@L2629_:
##@@@L2630_:    configASSERT( pxQueue );   
80003bba:	20 5d       	PUSH      R0
80003bbc:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003bc0:	08 00       	SYNC     SYNC     
80003bc2:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003bc6:	08 00       	SYNC     SYNC     
80003bc8:	00 5d       	POP       R0
80003bca:	20 5d       	PUSH      R0
80003bcc:	21 5d       	PUSH      R1
80003bce:	0d 45       	LD        R5, [PC + #13]        ;->0x80003c00  :=0x1ff
80003bd0:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003bd4:	25 58       	MOV       R1, R5
80003bd6:	11 68       	NOT       R1, R1
80003bd8:	01 69       	ANL       R0, R1
80003bda:	5f 11       	MOV       R5, #31			;->0x001F
80003bdc:	25 58       	MOV       R1, R5
80003bde:	01 6a       	ORL       R0, R1
80003be0:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003be4:	08 00       	SYNC     SYNC     
80003be6:	01 5d       	POP       R1
80003be8:	00 5d       	POP       R0
80003bea:	20 5d       	PUSH      R0
80003bec:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003bf0:	08 00       	SYNC     SYNC     
80003bf2:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003bf6:	08 00       	SYNC     SYNC     
80003bf8:	00 5d       	POP       R0
80003bfa:	07 00       	BREAK    BREAK    
80003bfc:	02 45       	LD        R5, [PC + #2]         ;->0x80003c04  :=0x8000911c
80003bfe:	05 5c       	LJMP      R5
80003c00:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003c04:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003c08 <xQueueIsQueueFullFromISR>:
##@@@F_:xQueueIsQueueFullFromISR():
##@@@P_:queue.c:2669
##@@@L2664_:    return xReturn;   
##@@@L2665_:}   
##@@@L2666_:/*-----------------------------------------------------------*/   
##@@@L2667_:
##@@@L2668_:BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )   
##@@@L2669_:{   
80003c08:	2d 5d       	PUSH      LR
80003c0a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:queue.c:2675
##@@@L2670_:    BaseType_t xReturn;   
##@@@L2671_:    Queue_t * const pxQueue = xQueue;   
##@@@L2672_:
##@@@L2673_:    traceENTER_xQueueIsQueueFullFromISR( xQueue );   
##@@@L2674_:
##@@@L2675_:    configASSERT( pxQueue );   
80003c0c:	00 38       	CMP       R0, #0			;->0x00
80003c0e:	0b f0       	JZ        $+11                  ;->0x80003c24
##@@@P_:queue.c:2677
##@@@L2676_:
##@@@L2677_:    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )   
80003c10:	e8 9b       	LD.W      R5, [R0 + #15]
80003c12:	a0 9b       	LD.W      R4, [R0 + #14]
80003c14:	45 70       	CMP       R4, R5
80003c16:	03 f0       	JZ        $+3                   ;->0x80003c1c
80003c18:	00 10       	MOV       R0, #0			;->0x0000
80003c1a:	02 04       	SJMP      $+2                   ;->0x80003c1e
80003c1c:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:queue.c:2688
##@@@L2683_:        xReturn = pdFALSE;   
##@@@L2684_:    }   
##@@@L2685_:
##@@@L2686_:    traceRETURN_xQueueIsQueueFullFromISR( xReturn );   
##@@@L2687_:
##@@@L2688_:    return xReturn;   
80003c1e:	e4 28       	ADD       SP, #4			;->0x04
80003c20:	0d 5d       	POP       LR
80003c22:	1d 5c       	JMP       LR
##@@@P_:queue.c:2675
##@@@L2670_:    BaseType_t xReturn;   
##@@@L2671_:    Queue_t * const pxQueue = xQueue;   
##@@@L2672_:
##@@@L2673_:    traceENTER_xQueueIsQueueFullFromISR( xQueue );   
##@@@L2674_:
##@@@L2675_:    configASSERT( pxQueue );   
80003c24:	20 5d       	PUSH      R0
80003c26:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003c2a:	08 00       	SYNC     SYNC     
80003c2c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003c30:	08 00       	SYNC     SYNC     
80003c32:	00 5d       	POP       R0
80003c34:	20 5d       	PUSH      R0
80003c36:	21 5d       	PUSH      R1
80003c38:	0d 45       	LD        R5, [PC + #13]        ;->0x80003c6c  :=0x1ff
80003c3a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003c3e:	25 58       	MOV       R1, R5
80003c40:	11 68       	NOT       R1, R1
80003c42:	01 69       	ANL       R0, R1
80003c44:	5f 11       	MOV       R5, #31			;->0x001F
80003c46:	25 58       	MOV       R1, R5
80003c48:	01 6a       	ORL       R0, R1
80003c4a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003c4e:	08 00       	SYNC     SYNC     
80003c50:	01 5d       	POP       R1
80003c52:	00 5d       	POP       R0
80003c54:	20 5d       	PUSH      R0
80003c56:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003c5a:	08 00       	SYNC     SYNC     
80003c5c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003c60:	08 00       	SYNC     SYNC     
80003c62:	00 5d       	POP       R0
80003c64:	07 00       	BREAK    BREAK    
80003c66:	03 45       	LD        R5, [PC + #3]         ;->0x80003c70  :=0x8000911c
80003c68:	05 5c       	LJMP      R5
80003c6a:	00 00       	NOP      NOP      
80003c6c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003c70:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003c74 <xStreamBufferGenericCreate>:
##@@@F_:xStreamBufferGenericCreate():
##@@@P_:stream_buffer.c:324
##@@@L0319_:    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,   
##@@@L0320_:                                                     size_t xTriggerLevelBytes,   
##@@@L0321_:                                                     BaseType_t xIsMessageBuffer,   
##@@@L0322_:                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,   
##@@@L0323_:                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )   
##@@@L0324_:    {   
80003c74:	83 5f       	PUSH      {R6-R7,LR}
80003c76:	e0 31       	SUB       SP, #16			;->0x10
##@@@P_:stream_buffer.c:334
##@@@L0329_:
##@@@L0330_:        /* In case the stream buffer is going to be used as a message buffer   
##@@@L0331_:         * (that is, it will hold discrete messages with a little meta data that   
##@@@L0332_:         * says how big the next message is) check the buffer will be large enough   
##@@@L0333_:         * to hold at least one message. */   
##@@@L0334_:        if( xIsMessageBuffer == pdTRUE )   
80003c78:	21 38       	CMP       R2, #1			;->0x01
80003c7a:	e0 58       	MOV       R7, R0
80003c7c:	05 f1       	JNZ       $+5                   ;->0x80003c86
##@@@P_:stream_buffer.c:338
##@@@L0335_:        {   
##@@@L0336_:            /* Is a message buffer but not statically allocated. */   
##@@@L0337_:            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;   
##@@@L0338_:            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );   
80003c7e:	74 38       	CMP       R7, #4			;->0x04
80003c80:	5b f9       	JLS       $+91                  ;->0x80003d36
80003c82:	41 10       	MOV       R4, #1			;->0x0001
80003c84:	04 04       	SJMP      $+4                   ;->0x80003c8c
##@@@P_:stream_buffer.c:344
##@@@L0339_:        }   
##@@@L0340_:        else   
##@@@L0341_:        {   
##@@@L0342_:            /* Not a message buffer and not statically allocated. */   
##@@@L0343_:            ucFlags = 0;   
##@@@L0344_:            configASSERT( xBufferSizeBytes > 0 );   
80003c86:	70 38       	CMP       R7, #0			;->0x00
80003c88:	7a f0       	JZ        $+122                 ;->0x80003d7c
80003c8a:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:stream_buffer.c:347
##@@@L0345_:        }   
##@@@L0346_:
##@@@L0347_:        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );   
80003c8c:	17 70       	CMP       R1, R7
80003c8e:	31 f8       	JHI       $+49                  ;->0x80003cf0
##@@@P_:stream_buffer.c:351
##@@@L0348_:
##@@@L0349_:        /* A trigger level of 0 would cause a waiting task to unblock even when   
##@@@L0350_:         * the buffer was empty. */   
##@@@L0351_:        if( xTriggerLevelBytes == ( size_t ) 0 )   
80003c90:	10 38       	CMP       R1, #0			;->0x00
80003c92:	02 f1       	JNZ       $+2                   ;->0x80003c96
80003c94:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:stream_buffer.c:364
##@@@L0359_:         * and the buffer follows immediately after.  The requested size is   
##@@@L0360_:         * incremented so the free space is returned as the user would expect -   
##@@@L0361_:         * this is a quirk of the implementation that means otherwise the free   
##@@@L0362_:         * space would be reported as one byte smaller than would be logically   
##@@@L0363_:         * expected. */   
##@@@L0364_:        if( xBufferSizeBytes < ( xBufferSizeBytes + 1U + sizeof( StreamBuffer_t ) ) )   
80003c96:	14 45       	LD        R5, [PC + #20]        ;->0x80003ce4  :=0xffffffda
80003c98:	75 70       	CMP       R7, R5
80003c9a:	1f f8       	JHI       $+31                  ;->0x80003cd8
80003c9c:	02 24       	ST.W      [SP + #2], R4
80003c9e:	03 21       	ST.W      [SP + #3], R1
80003ca0:	07 58       	MOV       R0, R7
80003ca2:	05 2a       	ADD       R0, #37			;->0x25
##@@@P_:stream_buffer.c:367
##@@@L0365_:        {   
##@@@L0366_:            xBufferSizeBytes++;   
##@@@L0367_:            pvAllocatedMemory = pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) );   
80003ca4:	11 45       	LD        R5, [PC + #17]        ;->0x80003ce8  :=0x80008960
80003ca6:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:374
##@@@L0369_:        else   
##@@@L0370_:        {   
##@@@L0371_:            pvAllocatedMemory = NULL;   
##@@@L0372_:        }   
##@@@L0373_:
##@@@L0374_:        if( pvAllocatedMemory != NULL )   
80003ca8:	00 38       	CMP       R0, #0			;->0x00
80003caa:	17 f0       	JZ        $+23                  ;->0x80003cd8
80003cac:	c0 58       	MOV       R6, R0
80003cae:	57 c0       	ADD       R2, R7, #1
##@@@F_:prvInitialiseNewStreamBuffer():
##@@@P_:stream_buffer.c:1493
##@@@L1488_:    {   
##@@@L1489_:        /* The value written just has to be identifiable when looking at the   
##@@@L1490_:         * memory.  Don't use 0xA5 as that is the stack fill value and could   
##@@@L1491_:         * result in confusion as to what is actually being observed. */   
##@@@L1492_:    #define STREAM_BUFFER_BUFFER_WRITE_VALUE    ( 0x55 )   
##@@@L1493_:        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );   
80003cb0:	01 22       	ST.W      [SP + #1], R2
##@@@F_:xStreamBufferGenericCreate():
##@@@P_:stream_buffer.c:383
##@@@L0378_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0379_:            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pvAllocatedMemory,                         /* Structure at the start of the allocated memory. */   
##@@@L0380_:                                                                                                          /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L0381_:                                                                                                          /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0382_:                                                                                                          /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0383_:                                          ( ( uint8_t * ) pvAllocatedMemory ) + sizeof( StreamBuffer_t ), /* Storage area follows. */   
80003cb2:	e0 58       	MOV       R7, R0
80003cb4:	74 2a       	ADD       R7, #36			;->0x24
80003cb6:	15 15       	MOV       R1, #85			;->0x0055
##@@@F_:prvInitialiseNewStreamBuffer():
##@@@P_:stream_buffer.c:1493
##@@@L1488_:    {   
##@@@L1489_:        /* The value written just has to be identifiable when looking at the   
##@@@L1490_:         * memory.  Don't use 0xA5 as that is the stack fill value and could   
##@@@L1491_:         * result in confusion as to what is actually being observed. */   
##@@@L1492_:    #define STREAM_BUFFER_BUFFER_WRITE_VALUE    ( 0x55 )   
##@@@L1493_:        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );   
80003cb8:	07 58       	MOV       R0, R7
80003cba:	0d 45       	LD        R5, [PC + #13]        ;->0x80003cec  :=0x8000da04
80003cbc:	05 5c       	LJMP      R5
80003cbe:	10 10       	MOV       R1, #0			;->0x0000
80003cc0:	24 12       	MOV       R2, #36			;->0x0024
##@@@P_:stream_buffer.c:1497
##@@@L1494_:    }   
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
80003cc2:	06 58       	MOV       R0, R6
80003cc4:	0a 45       	LD        R5, [PC + #10]        ;->0x80003cec  :=0x8000da04
80003cc6:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1498
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
80003cc8:	b7 a1       	ST.W      [R6 + #6], R7
##@@@P_:stream_buffer.c:1501
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
##@@@L1500_:    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;   
##@@@L1501_:    pxStreamBuffer->ucFlags = ucFlags;   
80003cca:	02 0d       	LD.W      R5, [SP + #2]
80003ccc:	35 97       	ST.B      [R6 + #28], R5
##@@@P_:stream_buffer.c:1500
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
##@@@L1500_:    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;   
80003cce:	03 0d       	LD.W      R5, [SP + #3]
80003cd0:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:stream_buffer.c:1499
##@@@L1494_:    }   
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
80003cd2:	01 0d       	LD.W      R5, [SP + #1]
80003cd4:	b5 a0       	ST.W      [R6 + #2], R5
80003cd6:	02 04       	SJMP      $+2                   ;->0x80003cda
##@@@F_:xStreamBufferGenericCreate():
80003cd8:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:stream_buffer.c:402
##@@@L0397_:        traceRETURN_xStreamBufferGenericCreate( pvAllocatedMemory );   
##@@@L0398_:
##@@@L0399_:        /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L0400_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0401_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0402_:        return ( StreamBufferHandle_t ) pvAllocatedMemory;   
80003cda:	06 58       	MOV       R0, R6
80003cdc:	e0 29       	ADD       SP, #16			;->0x10
80003cde:	03 5e       	POP       {R6-R7}
80003ce0:	0d 5d       	POP       LR
80003ce2:	1d 5c       	JMP       LR
80003ce4:	da ff ff ff 	.long     0xffffffda ->-00000038 
80003ce8:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
80003cec:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:347
##@@@L0342_:            /* Not a message buffer and not statically allocated. */   
##@@@L0343_:            ucFlags = 0;   
##@@@L0344_:            configASSERT( xBufferSizeBytes > 0 );   
##@@@L0345_:        }   
##@@@L0346_:
##@@@L0347_:        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );   
80003cf0:	20 5d       	PUSH      R0
80003cf2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003cf6:	08 00       	SYNC     SYNC     
80003cf8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003cfc:	08 00       	SYNC     SYNC     
80003cfe:	00 5d       	POP       R0
80003d00:	20 5d       	PUSH      R0
80003d02:	21 5d       	PUSH      R1
80003d04:	30 45       	LD        R5, [PC + #48]        ;->0x80003dc4  :=0x1ff
80003d06:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003d0a:	25 58       	MOV       R1, R5
80003d0c:	11 68       	NOT       R1, R1
80003d0e:	01 69       	ANL       R0, R1
80003d10:	5f 11       	MOV       R5, #31			;->0x001F
80003d12:	25 58       	MOV       R1, R5
80003d14:	01 6a       	ORL       R0, R1
80003d16:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003d1a:	08 00       	SYNC     SYNC     
80003d1c:	01 5d       	POP       R1
80003d1e:	00 5d       	POP       R0
80003d20:	20 5d       	PUSH      R0
80003d22:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003d26:	08 00       	SYNC     SYNC     
80003d28:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003d2c:	08 00       	SYNC     SYNC     
80003d2e:	00 5d       	POP       R0
80003d30:	07 00       	BREAK    BREAK    
80003d32:	26 45       	LD        R5, [PC + #38]        ;->0x80003dc8  :=0x8000911c
80003d34:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:338
##@@@L0333_:         * to hold at least one message. */   
##@@@L0334_:        if( xIsMessageBuffer == pdTRUE )   
##@@@L0335_:        {   
##@@@L0336_:            /* Is a message buffer but not statically allocated. */   
##@@@L0337_:            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;   
##@@@L0338_:            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );   
80003d36:	20 5d       	PUSH      R0
80003d38:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003d3c:	08 00       	SYNC     SYNC     
80003d3e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003d42:	08 00       	SYNC     SYNC     
80003d44:	00 5d       	POP       R0
80003d46:	20 5d       	PUSH      R0
80003d48:	21 5d       	PUSH      R1
80003d4a:	1f 45       	LD        R5, [PC + #31]        ;->0x80003dc4  :=0x1ff
80003d4c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003d50:	25 58       	MOV       R1, R5
80003d52:	11 68       	NOT       R1, R1
80003d54:	01 69       	ANL       R0, R1
80003d56:	5f 11       	MOV       R5, #31			;->0x001F
80003d58:	25 58       	MOV       R1, R5
80003d5a:	01 6a       	ORL       R0, R1
80003d5c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003d60:	08 00       	SYNC     SYNC     
80003d62:	01 5d       	POP       R1
80003d64:	00 5d       	POP       R0
80003d66:	20 5d       	PUSH      R0
80003d68:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003d6c:	08 00       	SYNC     SYNC     
80003d6e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003d72:	08 00       	SYNC     SYNC     
80003d74:	00 5d       	POP       R0
80003d76:	07 00       	BREAK    BREAK    
80003d78:	14 45       	LD        R5, [PC + #20]        ;->0x80003dc8  :=0x8000911c
80003d7a:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:344
##@@@L0339_:        }   
##@@@L0340_:        else   
##@@@L0341_:        {   
##@@@L0342_:            /* Not a message buffer and not statically allocated. */   
##@@@L0343_:            ucFlags = 0;   
##@@@L0344_:            configASSERT( xBufferSizeBytes > 0 );   
80003d7c:	20 5d       	PUSH      R0
80003d7e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003d82:	08 00       	SYNC     SYNC     
80003d84:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003d88:	08 00       	SYNC     SYNC     
80003d8a:	00 5d       	POP       R0
80003d8c:	20 5d       	PUSH      R0
80003d8e:	21 5d       	PUSH      R1
80003d90:	0d 45       	LD        R5, [PC + #13]        ;->0x80003dc4  :=0x1ff
80003d92:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003d96:	25 58       	MOV       R1, R5
80003d98:	11 68       	NOT       R1, R1
80003d9a:	01 69       	ANL       R0, R1
80003d9c:	5f 11       	MOV       R5, #31			;->0x001F
80003d9e:	25 58       	MOV       R1, R5
80003da0:	01 6a       	ORL       R0, R1
80003da2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003da6:	08 00       	SYNC     SYNC     
80003da8:	01 5d       	POP       R1
80003daa:	00 5d       	POP       R0
80003dac:	20 5d       	PUSH      R0
80003dae:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003db2:	08 00       	SYNC     SYNC     
80003db4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003db8:	08 00       	SYNC     SYNC     
80003dba:	00 5d       	POP       R0
80003dbc:	07 00       	BREAK    BREAK    
80003dbe:	03 45       	LD        R5, [PC + #3]         ;->0x80003dc8  :=0x8000911c
80003dc0:	05 5c       	LJMP      R5
80003dc2:	00 00       	NOP      NOP      
80003dc4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003dc8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003dcc <xStreamBufferGenericCreateStatic>:
##@@@F_:xStreamBufferGenericCreateStatic():
##@@@P_:stream_buffer.c:416
##@@@L0411_:                                                           BaseType_t xIsMessageBuffer,   
##@@@L0412_:                                                           uint8_t * const pucStreamBufferStorageArea,   
##@@@L0413_:                                                           StaticStreamBuffer_t * const pxStaticStreamBuffer,   
##@@@L0414_:                                                           StreamBufferCallbackFunction_t pxSendCompletedCallback,   
##@@@L0415_:                                                           StreamBufferCallbackFunction_t pxReceiveCompletedCallback )   
##@@@L0416_:    {   
80003dcc:	83 5f       	PUSH      {R6-R7,LR}
80003dce:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:stream_buffer.c:426
##@@@L0421_:        StreamBufferHandle_t xReturn;   
##@@@L0422_:        uint8_t ucFlags;   
##@@@L0423_:
##@@@L0424_:        traceENTER_xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer, pxSendCompletedCallback, pxReceiveCompletedCallback );   
##@@@L0425_:
##@@@L0426_:        configASSERT( pucStreamBufferStorageArea );   
80003dd0:	30 38       	CMP       R3, #0			;->0x00
80003dd2:	35 f0       	JZ        $+53                  ;->0x80003e3c
80003dd4:	c4 58       	MOV       R6, R4
##@@@P_:stream_buffer.c:427
##@@@L0427_:        configASSERT( pxStaticStreamBuffer );   
80003dd6:	40 38       	CMP       R4, #0			;->0x00
80003dd8:	55 f0       	JZ        $+85                  ;->0x80003e82
80003dda:	80 58       	MOV       R4, R0
##@@@P_:stream_buffer.c:428
##@@@L0428_:        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );   
80003ddc:	10 70       	CMP       R1, R0
80003dde:	75 f8       	JHI       $+117                 ;->0x80003ec8
##@@@P_:stream_buffer.c:442
##@@@L0437_:        /* In case the stream buffer is going to be used as a message buffer   
##@@@L0438_:         * (that is, it will hold discrete messages with a little meta data that   
##@@@L0439_:         * says how big the next message is) check the buffer will be large enough   
##@@@L0440_:         * to hold at least one message. */   
##@@@L0441_:
##@@@L0442_:        if( xIsMessageBuffer != pdFALSE )   
80003de0:	20 38       	CMP       R2, #0			;->0x00
80003de2:	03 21       	ST.W      [SP + #3], R1
80003de4:	06 f0       	JZ        $+6                   ;->0x80003df0
##@@@P_:stream_buffer.c:446
##@@@L0443_:        {   
##@@@L0444_:            /* Statically allocated message buffer. */   
##@@@L0445_:            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;   
##@@@L0446_:            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );   
80003de6:	44 38       	CMP       R4, #4			;->0x04
80003de8:	02 f8       	JHI       $+2                   ;->0x80003dec
80003dea:	b5 04       	SJMP      $+181                 ;->0x80003f54
80003dec:	53 10       	MOV       R5, #3			;->0x0003
80003dee:	02 04       	SJMP      $+2                   ;->0x80003df2
80003df0:	52 10       	MOV       R5, #2			;->0x0002
80003df2:	02 25       	ST.W      [SP + #2], R5
80003df4:	54 12       	MOV       R5, #36			;->0x0024
##@@@P_:stream_buffer.c:459
##@@@L0454_:        #if ( configASSERT_DEFINED == 1 )   
##@@@L0455_:        {   
##@@@L0456_:            /* Sanity check that the size of the structure used to declare a   
##@@@L0457_:             * variable of type StaticStreamBuffer_t equals the size of the real   
##@@@L0458_:             * message buffer structure. */   
##@@@L0459_:            volatile size_t xSize = sizeof( StaticStreamBuffer_t );   
80003df6:	04 25       	ST.W      [SP + #4], R5
##@@@P_:stream_buffer.c:460
##@@@L0460_:            configASSERT( xSize == sizeof( StreamBuffer_t ) );   
80003df8:	04 0d       	LD.W      R5, [SP + #4]
80003dfa:	54 3a       	CMP       R5, #36			;->0x24
80003dfc:	02 f0       	JZ        $+2                   ;->0x80003e00
80003dfe:	88 04       	SJMP      $+136                 ;->0x80003f0e
80003e00:	15 15       	MOV       R1, #85			;->0x0055
##@@@F_:prvInitialiseNewStreamBuffer():
##@@@P_:stream_buffer.c:1493
##@@@L1488_:    {   
##@@@L1489_:        /* The value written just has to be identifiable when looking at the   
##@@@L1490_:         * memory.  Don't use 0xA5 as that is the stack fill value and could   
##@@@L1491_:         * result in confusion as to what is actually being observed. */   
##@@@L1492_:    #define STREAM_BUFFER_BUFFER_WRITE_VALUE    ( 0x55 )   
##@@@L1493_:        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );   
80003e02:	03 58       	MOV       R0, R3
80003e04:	01 24       	ST.W      [SP + #1], R4
80003e06:	44 58       	MOV       R2, R4
80003e08:	e3 58       	MOV       R7, R3
80003e0a:	0c 45       	LD        R5, [PC + #12]        ;->0x80003e38  :=0x8000da04
80003e0c:	05 5c       	LJMP      R5
80003e0e:	10 10       	MOV       R1, #0			;->0x0000
80003e10:	24 12       	MOV       R2, #36			;->0x0024
##@@@P_:stream_buffer.c:1497
##@@@L1494_:    }   
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
80003e12:	06 58       	MOV       R0, R6
80003e14:	09 45       	LD        R5, [PC + #9]         ;->0x80003e38  :=0x8000da04
80003e16:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1498
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
80003e18:	b7 a1       	ST.W      [R6 + #6], R7
##@@@F_:xStreamBufferGenericCreateStatic():
##@@@P_:stream_buffer.c:476
##@@@L0471_:                                          pxSendCompletedCallback,   
##@@@L0472_:                                          pxReceiveCompletedCallback );   
##@@@L0473_:
##@@@L0474_:            /* Remember this was statically allocated in case it is ever deleted   
##@@@L0475_:             * again. */   
##@@@L0476_:            pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;   
80003e1a:	02 0d       	LD.W      R5, [SP + #2]
80003e1c:	35 97       	ST.B      [R6 + #28], R5
80003e1e:	03 0d       	LD.W      R5, [SP + #3]
##@@@P_:stream_buffer.c:432
##@@@L0427_:        configASSERT( pxStaticStreamBuffer );   
##@@@L0428_:        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );   
##@@@L0429_:
##@@@L0430_:        /* A trigger level of 0 would cause a waiting task to unblock even when   
##@@@L0431_:         * the buffer was empty. */   
##@@@L0432_:        if( xTriggerLevelBytes == ( size_t ) 0 )   
80003e20:	50 38       	CMP       R5, #0			;->0x00
80003e22:	02 f1       	JNZ       $+2                   ;->0x80003e26
80003e24:	51 10       	MOV       R5, #1			;->0x0001
##@@@F_:prvInitialiseNewStreamBuffer():
##@@@P_:stream_buffer.c:1500
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
##@@@L1500_:    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;   
80003e26:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:stream_buffer.c:1499
##@@@L1494_:    }   
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
80003e28:	01 0d       	LD.W      R5, [SP + #1]
80003e2a:	b5 a0       	ST.W      [R6 + #2], R5
##@@@F_:xStreamBufferGenericCreateStatic():
##@@@P_:stream_buffer.c:493
##@@@L0488_:            traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );   
##@@@L0489_:        }   
##@@@L0490_:
##@@@L0491_:        traceRETURN_xStreamBufferGenericCreateStatic( xReturn );   
##@@@L0492_:
##@@@L0493_:        return xReturn;   
80003e2c:	06 58       	MOV       R0, R6
80003e2e:	e4 29       	ADD       SP, #20			;->0x14
80003e30:	03 5e       	POP       {R6-R7}
80003e32:	0d 5d       	POP       LR
80003e34:	1d 5c       	JMP       LR
80003e36:	00 00       	NOP      NOP      
80003e38:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:426
##@@@L0421_:        StreamBufferHandle_t xReturn;   
##@@@L0422_:        uint8_t ucFlags;   
##@@@L0423_:
##@@@L0424_:        traceENTER_xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer, pxSendCompletedCallback, pxReceiveCompletedCallback );   
##@@@L0425_:
##@@@L0426_:        configASSERT( pucStreamBufferStorageArea );   
80003e3c:	20 5d       	PUSH      R0
80003e3e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003e42:	08 00       	SYNC     SYNC     
80003e44:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003e48:	08 00       	SYNC     SYNC     
80003e4a:	00 5d       	POP       R0
80003e4c:	20 5d       	PUSH      R0
80003e4e:	21 5d       	PUSH      R1
80003e50:	53 45       	LD        R5, [PC + #83]        ;->0x80003f9c  :=0x1ff
80003e52:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003e56:	25 58       	MOV       R1, R5
80003e58:	11 68       	NOT       R1, R1
80003e5a:	01 69       	ANL       R0, R1
80003e5c:	5f 11       	MOV       R5, #31			;->0x001F
80003e5e:	25 58       	MOV       R1, R5
80003e60:	01 6a       	ORL       R0, R1
80003e62:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003e66:	08 00       	SYNC     SYNC     
80003e68:	01 5d       	POP       R1
80003e6a:	00 5d       	POP       R0
80003e6c:	20 5d       	PUSH      R0
80003e6e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003e72:	08 00       	SYNC     SYNC     
80003e74:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003e78:	08 00       	SYNC     SYNC     
80003e7a:	00 5d       	POP       R0
80003e7c:	07 00       	BREAK    BREAK    
80003e7e:	49 45       	LD        R5, [PC + #73]        ;->0x80003fa0  :=0x8000911c
80003e80:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:427
##@@@L0427_:        configASSERT( pxStaticStreamBuffer );   
80003e82:	20 5d       	PUSH      R0
80003e84:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003e88:	08 00       	SYNC     SYNC     
80003e8a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003e8e:	08 00       	SYNC     SYNC     
80003e90:	00 5d       	POP       R0
80003e92:	20 5d       	PUSH      R0
80003e94:	21 5d       	PUSH      R1
80003e96:	42 45       	LD        R5, [PC + #66]        ;->0x80003f9c  :=0x1ff
80003e98:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003e9c:	25 58       	MOV       R1, R5
80003e9e:	11 68       	NOT       R1, R1
80003ea0:	01 69       	ANL       R0, R1
80003ea2:	5f 11       	MOV       R5, #31			;->0x001F
80003ea4:	25 58       	MOV       R1, R5
80003ea6:	01 6a       	ORL       R0, R1
80003ea8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003eac:	08 00       	SYNC     SYNC     
80003eae:	01 5d       	POP       R1
80003eb0:	00 5d       	POP       R0
80003eb2:	20 5d       	PUSH      R0
80003eb4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003eb8:	08 00       	SYNC     SYNC     
80003eba:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003ebe:	08 00       	SYNC     SYNC     
80003ec0:	00 5d       	POP       R0
80003ec2:	07 00       	BREAK    BREAK    
80003ec4:	37 45       	LD        R5, [PC + #55]        ;->0x80003fa0  :=0x8000911c
80003ec6:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:428
##@@@L0428_:        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );   
80003ec8:	20 5d       	PUSH      R0
80003eca:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003ece:	08 00       	SYNC     SYNC     
80003ed0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003ed4:	08 00       	SYNC     SYNC     
80003ed6:	00 5d       	POP       R0
80003ed8:	20 5d       	PUSH      R0
80003eda:	21 5d       	PUSH      R1
80003edc:	30 45       	LD        R5, [PC + #48]        ;->0x80003f9c  :=0x1ff
80003ede:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003ee2:	25 58       	MOV       R1, R5
80003ee4:	11 68       	NOT       R1, R1
80003ee6:	01 69       	ANL       R0, R1
80003ee8:	5f 11       	MOV       R5, #31			;->0x001F
80003eea:	25 58       	MOV       R1, R5
80003eec:	01 6a       	ORL       R0, R1
80003eee:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003ef2:	08 00       	SYNC     SYNC     
80003ef4:	01 5d       	POP       R1
80003ef6:	00 5d       	POP       R0
80003ef8:	20 5d       	PUSH      R0
80003efa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003efe:	08 00       	SYNC     SYNC     
80003f00:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003f04:	08 00       	SYNC     SYNC     
80003f06:	00 5d       	POP       R0
80003f08:	07 00       	BREAK    BREAK    
80003f0a:	26 45       	LD        R5, [PC + #38]        ;->0x80003fa0  :=0x8000911c
80003f0c:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:460
##@@@L0455_:        {   
##@@@L0456_:            /* Sanity check that the size of the structure used to declare a   
##@@@L0457_:             * variable of type StaticStreamBuffer_t equals the size of the real   
##@@@L0458_:             * message buffer structure. */   
##@@@L0459_:            volatile size_t xSize = sizeof( StaticStreamBuffer_t );   
##@@@L0460_:            configASSERT( xSize == sizeof( StreamBuffer_t ) );   
80003f0e:	20 5d       	PUSH      R0
80003f10:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003f14:	08 00       	SYNC     SYNC     
80003f16:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003f1a:	08 00       	SYNC     SYNC     
80003f1c:	00 5d       	POP       R0
80003f1e:	20 5d       	PUSH      R0
80003f20:	21 5d       	PUSH      R1
80003f22:	1f 45       	LD        R5, [PC + #31]        ;->0x80003f9c  :=0x1ff
80003f24:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003f28:	25 58       	MOV       R1, R5
80003f2a:	11 68       	NOT       R1, R1
80003f2c:	01 69       	ANL       R0, R1
80003f2e:	5f 11       	MOV       R5, #31			;->0x001F
80003f30:	25 58       	MOV       R1, R5
80003f32:	01 6a       	ORL       R0, R1
80003f34:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003f38:	08 00       	SYNC     SYNC     
80003f3a:	01 5d       	POP       R1
80003f3c:	00 5d       	POP       R0
80003f3e:	20 5d       	PUSH      R0
80003f40:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003f44:	08 00       	SYNC     SYNC     
80003f46:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003f4a:	08 00       	SYNC     SYNC     
80003f4c:	00 5d       	POP       R0
80003f4e:	07 00       	BREAK    BREAK    
80003f50:	14 45       	LD        R5, [PC + #20]        ;->0x80003fa0  :=0x8000911c
80003f52:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:446
##@@@L0441_:
##@@@L0442_:        if( xIsMessageBuffer != pdFALSE )   
##@@@L0443_:        {   
##@@@L0444_:            /* Statically allocated message buffer. */   
##@@@L0445_:            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;   
##@@@L0446_:            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );   
80003f54:	20 5d       	PUSH      R0
80003f56:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003f5a:	08 00       	SYNC     SYNC     
80003f5c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003f60:	08 00       	SYNC     SYNC     
80003f62:	00 5d       	POP       R0
80003f64:	20 5d       	PUSH      R0
80003f66:	21 5d       	PUSH      R1
80003f68:	0d 45       	LD        R5, [PC + #13]        ;->0x80003f9c  :=0x1ff
80003f6a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003f6e:	25 58       	MOV       R1, R5
80003f70:	11 68       	NOT       R1, R1
80003f72:	01 69       	ANL       R0, R1
80003f74:	5f 11       	MOV       R5, #31			;->0x001F
80003f76:	25 58       	MOV       R1, R5
80003f78:	01 6a       	ORL       R0, R1
80003f7a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003f7e:	08 00       	SYNC     SYNC     
80003f80:	01 5d       	POP       R1
80003f82:	00 5d       	POP       R0
80003f84:	20 5d       	PUSH      R0
80003f86:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003f8a:	08 00       	SYNC     SYNC     
80003f8c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80003f90:	08 00       	SYNC     SYNC     
80003f92:	00 5d       	POP       R0
80003f94:	07 00       	BREAK    BREAK    
80003f96:	03 45       	LD        R5, [PC + #3]         ;->0x80003fa0  :=0x8000911c
80003f98:	05 5c       	LJMP      R5
80003f9a:	00 00       	NOP      NOP      
80003f9c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80003fa0:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80003fa4 <xStreamBufferGetStaticBuffers>:
##@@@F_:xStreamBufferGetStaticBuffers():
##@@@P_:stream_buffer.c:502
##@@@L0497_:
##@@@L0498_:#if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L0499_:    BaseType_t xStreamBufferGetStaticBuffers( StreamBufferHandle_t xStreamBuffer,   
##@@@L0500_:                                              uint8_t ** ppucStreamBufferStorageArea,   
##@@@L0501_:                                              StaticStreamBuffer_t ** ppxStaticStreamBuffer )   
##@@@L0502_:    {   
80003fa4:	2d 5d       	PUSH      LR
80003fa6:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:stream_buffer.c:508
##@@@L0503_:        BaseType_t xReturn;   
##@@@L0504_:        StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0505_:
##@@@L0506_:        traceENTER_xStreamBufferGetStaticBuffers( xStreamBuffer, ppucStreamBufferStorageArea, ppxStaticStreamBuffer );   
##@@@L0507_:
##@@@L0508_:        configASSERT( pxStreamBuffer );   
80003fa8:	00 38       	CMP       R0, #0			;->0x00
80003faa:	13 f0       	JZ        $+19                  ;->0x80003fd0
##@@@P_:stream_buffer.c:509
##@@@L0509_:        configASSERT( ppucStreamBufferStorageArea );   
80003fac:	10 38       	CMP       R1, #0			;->0x00
80003fae:	34 f0       	JZ        $+52                  ;->0x80004016
##@@@P_:stream_buffer.c:510
##@@@L0510_:        configASSERT( ppxStaticStreamBuffer );   
80003fb0:	20 38       	CMP       R2, #0			;->0x00
80003fb2:	55 f0       	JZ        $+85                  ;->0x8000405c
##@@@P_:stream_buffer.c:512
##@@@L0511_:
##@@@L0512_:        if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) != ( uint8_t ) 0 )   
80003fb4:	28 8f       	LD.B      R5, [R0 + #28]
80003fb6:	42 10       	MOV       R4, #2			;->0x0002
80003fb8:	54 69       	ANL       R5, R4
80003fba:	50 38       	CMP       R5, #0			;->0x00
80003fbc:	03 f1       	JNZ       $+3                   ;->0x80003fc2
80003fbe:	00 10       	MOV       R0, #0			;->0x0000
80003fc0:	05 04       	SJMP      $+5                   ;->0x80003fca
##@@@P_:stream_buffer.c:514
##@@@L0513_:        {   
##@@@L0514_:            *ppucStreamBufferStorageArea = pxStreamBuffer->pucBuffer;   
80003fc2:	a8 99       	LD.W      R5, [R0 + #6]
80003fc4:	15 85       	ST.W      [R1], R5
##@@@P_:stream_buffer.c:518
##@@@L0515_:            /* MISRA Ref 11.3.1 [Misaligned access] */   
##@@@L0516_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-113 */   
##@@@L0517_:            /* coverity[misra_c_2012_rule_11_3_violation] */   
##@@@L0518_:            *ppxStaticStreamBuffer = ( StaticStreamBuffer_t * ) pxStreamBuffer;   
80003fc6:	20 85       	ST.W      [R2], R0
80003fc8:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:stream_buffer.c:528
##@@@L0523_:            xReturn = pdFALSE;   
##@@@L0524_:        }   
##@@@L0525_:
##@@@L0526_:        traceRETURN_xStreamBufferGetStaticBuffers( xReturn );   
##@@@L0527_:
##@@@L0528_:        return xReturn;   
80003fca:	e4 28       	ADD       SP, #4			;->0x04
80003fcc:	0d 5d       	POP       LR
80003fce:	1d 5c       	JMP       LR
##@@@P_:stream_buffer.c:508
##@@@L0503_:        BaseType_t xReturn;   
##@@@L0504_:        StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0505_:
##@@@L0506_:        traceENTER_xStreamBufferGetStaticBuffers( xStreamBuffer, ppucStreamBufferStorageArea, ppxStaticStreamBuffer );   
##@@@L0507_:
##@@@L0508_:        configASSERT( pxStreamBuffer );   
80003fd0:	20 5d       	PUSH      R0
80003fd2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80003fd6:	08 00       	SYNC     SYNC     
80003fd8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80003fdc:	08 00       	SYNC     SYNC     
80003fde:	00 5d       	POP       R0
80003fe0:	20 5d       	PUSH      R0
80003fe2:	21 5d       	PUSH      R1
80003fe4:	30 45       	LD        R5, [PC + #48]        ;->0x800040a4  :=0x1ff
80003fe6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80003fea:	25 58       	MOV       R1, R5
80003fec:	11 68       	NOT       R1, R1
80003fee:	01 69       	ANL       R0, R1
80003ff0:	5f 11       	MOV       R5, #31			;->0x001F
80003ff2:	25 58       	MOV       R1, R5
80003ff4:	01 6a       	ORL       R0, R1
80003ff6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80003ffa:	08 00       	SYNC     SYNC     
80003ffc:	01 5d       	POP       R1
80003ffe:	00 5d       	POP       R0
80004000:	20 5d       	PUSH      R0
80004002:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004006:	08 00       	SYNC     SYNC     
80004008:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000400c:	08 00       	SYNC     SYNC     
8000400e:	00 5d       	POP       R0
80004010:	07 00       	BREAK    BREAK    
80004012:	26 45       	LD        R5, [PC + #38]        ;->0x800040a8  :=0x8000911c
80004014:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:509
##@@@L0509_:        configASSERT( ppucStreamBufferStorageArea );   
80004016:	20 5d       	PUSH      R0
80004018:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000401c:	08 00       	SYNC     SYNC     
8000401e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004022:	08 00       	SYNC     SYNC     
80004024:	00 5d       	POP       R0
80004026:	20 5d       	PUSH      R0
80004028:	21 5d       	PUSH      R1
8000402a:	1f 45       	LD        R5, [PC + #31]        ;->0x800040a4  :=0x1ff
8000402c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004030:	25 58       	MOV       R1, R5
80004032:	11 68       	NOT       R1, R1
80004034:	01 69       	ANL       R0, R1
80004036:	5f 11       	MOV       R5, #31			;->0x001F
80004038:	25 58       	MOV       R1, R5
8000403a:	01 6a       	ORL       R0, R1
8000403c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004040:	08 00       	SYNC     SYNC     
80004042:	01 5d       	POP       R1
80004044:	00 5d       	POP       R0
80004046:	20 5d       	PUSH      R0
80004048:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000404c:	08 00       	SYNC     SYNC     
8000404e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004052:	08 00       	SYNC     SYNC     
80004054:	00 5d       	POP       R0
80004056:	07 00       	BREAK    BREAK    
80004058:	14 45       	LD        R5, [PC + #20]        ;->0x800040a8  :=0x8000911c
8000405a:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:510
##@@@L0510_:        configASSERT( ppxStaticStreamBuffer );   
8000405c:	20 5d       	PUSH      R0
8000405e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004062:	08 00       	SYNC     SYNC     
80004064:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004068:	08 00       	SYNC     SYNC     
8000406a:	00 5d       	POP       R0
8000406c:	20 5d       	PUSH      R0
8000406e:	21 5d       	PUSH      R1
80004070:	0d 45       	LD        R5, [PC + #13]        ;->0x800040a4  :=0x1ff
80004072:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004076:	25 58       	MOV       R1, R5
80004078:	11 68       	NOT       R1, R1
8000407a:	01 69       	ANL       R0, R1
8000407c:	5f 11       	MOV       R5, #31			;->0x001F
8000407e:	25 58       	MOV       R1, R5
80004080:	01 6a       	ORL       R0, R1
80004082:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004086:	08 00       	SYNC     SYNC     
80004088:	01 5d       	POP       R1
8000408a:	00 5d       	POP       R0
8000408c:	20 5d       	PUSH      R0
8000408e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004092:	08 00       	SYNC     SYNC     
80004094:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004098:	08 00       	SYNC     SYNC     
8000409a:	00 5d       	POP       R0
8000409c:	07 00       	BREAK    BREAK    
8000409e:	03 45       	LD        R5, [PC + #3]         ;->0x800040a8  :=0x8000911c
800040a0:	05 5c       	LJMP      R5
800040a2:	00 00       	NOP      NOP      
800040a4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800040a8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800040ac <vStreamBufferDelete>:
##@@@F_:vStreamBufferDelete():
##@@@P_:stream_buffer.c:534
##@@@L0529_:    }   
##@@@L0530_:#endif /* configSUPPORT_STATIC_ALLOCATION */   
##@@@L0531_:/*-----------------------------------------------------------*/   
##@@@L0532_:
##@@@L0533_:void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )   
##@@@L0534_:{   
800040ac:	2d 5d       	PUSH      LR
800040ae:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:stream_buffer.c:539
##@@@L0535_:    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;   
##@@@L0536_:
##@@@L0537_:    traceENTER_vStreamBufferDelete( xStreamBuffer );   
##@@@L0538_:
##@@@L0539_:    configASSERT( pxStreamBuffer );   
800040b0:	00 38       	CMP       R0, #0			;->0x00
800040b2:	15 f0       	JZ        $+21                  ;->0x800040dc
##@@@P_:stream_buffer.c:543
##@@@L0540_:
##@@@L0541_:    traceSTREAM_BUFFER_DELETE( xStreamBuffer );   
##@@@L0542_:
##@@@L0543_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )   
800040b4:	28 8f       	LD.B      R5, [R0 + #28]
800040b6:	42 10       	MOV       R4, #2			;->0x0002
800040b8:	54 69       	ANL       R5, R4
800040ba:	50 38       	CMP       R5, #0			;->0x00
800040bc:	04 f1       	JNZ       $+4                   ;->0x800040c4
##@@@P_:stream_buffer.c:549
##@@@L0544_:    {   
##@@@L0545_:        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )   
##@@@L0546_:        {   
##@@@L0547_:            /* Both the structure and the buffer were allocated using a single call   
##@@@L0548_:            * to pvPortMalloc(), hence only one call to vPortFree() is required. */   
##@@@L0549_:            vPortFree( ( void * ) pxStreamBuffer );   
800040be:	06 45       	LD        R5, [PC + #6]         ;->0x800040d4  :=0x80008b9c
800040c0:	05 5c       	LJMP      R5
800040c2:	05 04       	SJMP      $+5                   ;->0x800040cc
800040c4:	10 10       	MOV       R1, #0			;->0x0000
800040c6:	24 12       	MOV       R2, #36			;->0x0024
##@@@P_:stream_buffer.c:563
##@@@L0558_:    }   
##@@@L0559_:    else   
##@@@L0560_:    {   
##@@@L0561_:        /* The structure and buffer were not allocated dynamically and cannot be   
##@@@L0562_:         * freed - just scrub the structure so future use will assert. */   
##@@@L0563_:        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
800040c8:	04 45       	LD        R5, [PC + #4]         ;->0x800040d8  :=0x8000da04
800040ca:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:567
##@@@L0564_:    }   
##@@@L0565_:
##@@@L0566_:    traceRETURN_vStreamBufferDelete();   
##@@@L0567_:}   
800040cc:	e4 28       	ADD       SP, #4			;->0x04
800040ce:	0d 5d       	POP       LR
800040d0:	1d 5c       	JMP       LR
800040d2:	00 00       	NOP      NOP      
800040d4:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]
800040d8:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:539
##@@@L0534_:{   
##@@@L0535_:    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;   
##@@@L0536_:
##@@@L0537_:    traceENTER_vStreamBufferDelete( xStreamBuffer );   
##@@@L0538_:
##@@@L0539_:    configASSERT( pxStreamBuffer );   
800040dc:	20 5d       	PUSH      R0
800040de:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800040e2:	08 00       	SYNC     SYNC     
800040e4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800040e8:	08 00       	SYNC     SYNC     
800040ea:	00 5d       	POP       R0
800040ec:	20 5d       	PUSH      R0
800040ee:	21 5d       	PUSH      R1
800040f0:	0d 45       	LD        R5, [PC + #13]        ;->0x80004124  :=0x1ff
800040f2:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800040f6:	25 58       	MOV       R1, R5
800040f8:	11 68       	NOT       R1, R1
800040fa:	01 69       	ANL       R0, R1
800040fc:	5f 11       	MOV       R5, #31			;->0x001F
800040fe:	25 58       	MOV       R1, R5
80004100:	01 6a       	ORL       R0, R1
80004102:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004106:	08 00       	SYNC     SYNC     
80004108:	01 5d       	POP       R1
8000410a:	00 5d       	POP       R0
8000410c:	20 5d       	PUSH      R0
8000410e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004112:	08 00       	SYNC     SYNC     
80004114:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004118:	08 00       	SYNC     SYNC     
8000411a:	00 5d       	POP       R0
8000411c:	07 00       	BREAK    BREAK    
8000411e:	03 45       	LD        R5, [PC + #3]         ;->0x80004128  :=0x8000911c
80004120:	05 5c       	LJMP      R5
80004122:	00 00       	NOP      NOP      
80004124:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004128:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

8000412c <xStreamBufferReset>:
##@@@F_:xStreamBufferReset():
##@@@P_:stream_buffer.c:571
##@@@L0566_:    traceRETURN_vStreamBufferDelete();   
##@@@L0567_:}   
##@@@L0568_:/*-----------------------------------------------------------*/   
##@@@L0569_:
##@@@L0570_:BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )   
##@@@L0571_:{   
8000412c:	83 5f       	PUSH      {R6-R7,LR}
8000412e:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:stream_buffer.c:582
##@@@L0577_:        UBaseType_t uxStreamBufferNumber;   
##@@@L0578_:    #endif   
##@@@L0579_:
##@@@L0580_:    traceENTER_xStreamBufferReset( xStreamBuffer );   
##@@@L0581_:
##@@@L0582_:    configASSERT( pxStreamBuffer );   
80004130:	00 38       	CMP       R0, #0			;->0x00
80004132:	32 f0       	JZ        $+50                  ;->0x80004196
80004134:	c0 58       	MOV       R6, R0
##@@@P_:stream_buffer.c:588
##@@@L0583_:
##@@@L0584_:    #if ( configUSE_TRACE_FACILITY == 1 )   
##@@@L0585_:    {   
##@@@L0586_:        /* Store the stream buffer number so it can be restored after the   
##@@@L0587_:         * reset. */   
##@@@L0588_:        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;   
80004136:	38 9a       	LD.W      R7, [R0 + #8]
##@@@P_:stream_buffer.c:593
##@@@L0589_:    }   
##@@@L0590_:    #endif   
##@@@L0591_:
##@@@L0592_:    /* Can only reset a message buffer if there are no tasks blocked on it. */   
##@@@L0593_:    taskENTER_CRITICAL();   
80004138:	08 45       	LD        R5, [PC + #8]         ;->0x80004158  :=0x800056cc
8000413a:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:595
##@@@L0594_:    {   
##@@@L0595_:        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )   
8000413c:	2e 99       	LD.W      R5, [R6 + #4]
8000413e:	50 38       	CMP       R5, #0			;->0x00
80004140:	04 f1       	JNZ       $+4                   ;->0x80004148
80004142:	6e 99       	LD.W      R5, [R6 + #5]
80004144:	50 38       	CMP       R5, #0			;->0x00
80004146:	0d f0       	JZ        $+13                  ;->0x80004160
80004148:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:stream_buffer.c:623
##@@@L0618_:            traceSTREAM_BUFFER_RESET( xStreamBuffer );   
##@@@L0619_:
##@@@L0620_:            xReturn = pdPASS;   
##@@@L0621_:        }   
##@@@L0622_:    }   
##@@@L0623_:    taskEXIT_CRITICAL();   
8000414a:	05 45       	LD        R5, [PC + #5]         ;->0x8000415c  :=0x80005730
8000414c:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:627
##@@@L0624_:
##@@@L0625_:    traceRETURN_xStreamBufferReset( xReturn );   
##@@@L0626_:
##@@@L0627_:    return xReturn;   
8000414e:	06 58       	MOV       R0, R6
80004150:	e4 29       	ADD       SP, #20			;->0x14
80004152:	03 5e       	POP       {R6-R7}
80004154:	0d 5d       	POP       LR
80004156:	1d 5c       	JMP       LR
80004158:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80004158
8000415c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x8000415c
##@@@P_:stream_buffer.c:607
##@@@L0602_:            #endif   
##@@@L0603_:
##@@@L0604_:            prvInitialiseNewStreamBuffer( pxStreamBuffer,   
##@@@L0605_:                                          pxStreamBuffer->pucBuffer,   
##@@@L0606_:                                          pxStreamBuffer->xLength,   
##@@@L0607_:                                          pxStreamBuffer->xTriggerLevelBytes,   
80004160:	ee 98       	LD.W      R5, [R6 + #3]
##@@@P_:stream_buffer.c:608
##@@@L0608_:                                          pxStreamBuffer->ucFlags,   
80004162:	04 25       	ST.W      [SP + #4], R5
80004164:	2e 8f       	LD.B      R5, [R6 + #28]
##@@@P_:stream_buffer.c:606
##@@@L0601_:            }   
##@@@L0602_:            #endif   
##@@@L0603_:
##@@@L0604_:            prvInitialiseNewStreamBuffer( pxStreamBuffer,   
##@@@L0605_:                                          pxStreamBuffer->pucBuffer,   
##@@@L0606_:                                          pxStreamBuffer->xLength,   
80004166:	03 25       	ST.W      [SP + #3], R5
80004168:	96 98       	LD.W      R2, [R6 + #2]
##@@@P_:stream_buffer.c:605
##@@@L0600_:                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;   
##@@@L0601_:            }   
##@@@L0602_:            #endif   
##@@@L0603_:
##@@@L0604_:            prvInitialiseNewStreamBuffer( pxStreamBuffer,   
##@@@L0605_:                                          pxStreamBuffer->pucBuffer,   
8000416a:	02 22       	ST.W      [SP + #2], R2
8000416c:	86 99       	LD.W      R0, [R6 + #6]
##@@@F_:prvInitialiseNewStreamBuffer():
##@@@P_:stream_buffer.c:1493
##@@@L1488_:    {   
##@@@L1489_:        /* The value written just has to be identifiable when looking at the   
##@@@L1490_:         * memory.  Don't use 0xA5 as that is the stack fill value and could   
##@@@L1491_:         * result in confusion as to what is actually being observed. */   
##@@@L1492_:    #define STREAM_BUFFER_BUFFER_WRITE_VALUE    ( 0x55 )   
##@@@L1493_:        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );   
8000416e:	01 20       	ST.W      [SP + #1], R0
80004170:	15 15       	MOV       R1, #85			;->0x0055
80004172:	1b 45       	LD        R5, [PC + #27]        ;->0x800041dc  :=0x8000da04
80004174:	05 5c       	LJMP      R5
80004176:	10 10       	MOV       R1, #0			;->0x0000
80004178:	20 12       	MOV       R2, #32			;->0x0020
##@@@P_:stream_buffer.c:1497
##@@@L1494_:    }   
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
8000417a:	06 58       	MOV       R0, R6
8000417c:	18 45       	LD        R5, [PC + #24]        ;->0x800041dc  :=0x8000da04
8000417e:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1498
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
80004180:	01 0d       	LD.W      R5, [SP + #1]
80004182:	b5 a1       	ST.W      [R6 + #6], R5
##@@@F_:xStreamBufferReset():
##@@@P_:stream_buffer.c:614
##@@@L0609_:                                          pxSendCallback,   
##@@@L0610_:                                          pxReceiveCallback );   
##@@@L0611_:
##@@@L0612_:            #if ( configUSE_TRACE_FACILITY == 1 )   
##@@@L0613_:            {   
##@@@L0614_:                pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;   
80004184:	37 a2       	ST.W      [R6 + #8], R7
##@@@F_:prvInitialiseNewStreamBuffer():
##@@@P_:stream_buffer.c:1501
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
##@@@L1500_:    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;   
##@@@L1501_:    pxStreamBuffer->ucFlags = ucFlags;   
80004186:	03 0d       	LD.W      R5, [SP + #3]
80004188:	35 97       	ST.B      [R6 + #28], R5
##@@@P_:stream_buffer.c:1500
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
##@@@L1500_:    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;   
8000418a:	04 0d       	LD.W      R5, [SP + #4]
8000418c:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:stream_buffer.c:1499
##@@@L1494_:    }   
##@@@L1495_:    #endif   
##@@@L1496_:
##@@@L1497_:    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );   
##@@@L1498_:    pxStreamBuffer->pucBuffer = pucBuffer;   
##@@@L1499_:    pxStreamBuffer->xLength = xBufferSizeBytes;   
8000418e:	02 0d       	LD.W      R5, [SP + #2]
80004190:	b5 a0       	ST.W      [R6 + #2], R5
80004192:	61 10       	MOV       R6, #1			;->0x0001
80004194:	db 07       	SJMP      $-37                  ;->0x8000414a
##@@@F_:xStreamBufferReset():
##@@@P_:stream_buffer.c:582
##@@@L0577_:        UBaseType_t uxStreamBufferNumber;   
##@@@L0578_:    #endif   
##@@@L0579_:
##@@@L0580_:    traceENTER_xStreamBufferReset( xStreamBuffer );   
##@@@L0581_:
##@@@L0582_:    configASSERT( pxStreamBuffer );   
80004196:	20 5d       	PUSH      R0
80004198:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000419c:	08 00       	SYNC     SYNC     
8000419e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800041a2:	08 00       	SYNC     SYNC     
800041a4:	00 5d       	POP       R0
800041a6:	20 5d       	PUSH      R0
800041a8:	21 5d       	PUSH      R1
800041aa:	0e 45       	LD        R5, [PC + #14]        ;->0x800041e0  :=0x1ff
800041ac:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800041b0:	25 58       	MOV       R1, R5
800041b2:	11 68       	NOT       R1, R1
800041b4:	01 69       	ANL       R0, R1
800041b6:	5f 11       	MOV       R5, #31			;->0x001F
800041b8:	25 58       	MOV       R1, R5
800041ba:	01 6a       	ORL       R0, R1
800041bc:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800041c0:	08 00       	SYNC     SYNC     
800041c2:	01 5d       	POP       R1
800041c4:	00 5d       	POP       R0
800041c6:	20 5d       	PUSH      R0
800041c8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800041cc:	08 00       	SYNC     SYNC     
800041ce:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800041d2:	08 00       	SYNC     SYNC     
800041d4:	00 5d       	POP       R0
800041d6:	07 00       	BREAK    BREAK    
800041d8:	03 45       	LD        R5, [PC + #3]         ;->0x800041e4  :=0x8000911c
800041da:	05 5c       	LJMP      R5
800041dc:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
800041e0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800041e4:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800041e8 <xStreamBufferSetTriggerLevel>:
##@@@F_:xStreamBufferSetTriggerLevel():
##@@@P_:stream_buffer.c:633
##@@@L0628_:}   
##@@@L0629_:/*-----------------------------------------------------------*/   
##@@@L0630_:
##@@@L0631_:BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,   
##@@@L0632_:                                         size_t xTriggerLevel )   
##@@@L0633_:{   
800041e8:	2d 5d       	PUSH      LR
800041ea:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:stream_buffer.c:639
##@@@L0634_:    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0635_:    BaseType_t xReturn;   
##@@@L0636_:
##@@@L0637_:    traceENTER_xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );   
##@@@L0638_:
##@@@L0639_:    configASSERT( pxStreamBuffer );   
800041ec:	00 38       	CMP       R0, #0			;->0x00
800041ee:	0e f0       	JZ        $+14                  ;->0x8000420a
##@@@P_:stream_buffer.c:642
##@@@L0640_:
##@@@L0641_:    /* It is not valid for the trigger level to be 0. */   
##@@@L0642_:    if( xTriggerLevel == ( size_t ) 0 )   
800041f0:	10 38       	CMP       R1, #0			;->0x00
800041f2:	02 f1       	JNZ       $+2                   ;->0x800041f6
800041f4:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:stream_buffer.c:649
##@@@L0644_:        xTriggerLevel = ( size_t ) 1;   
##@@@L0645_:    }   
##@@@L0646_:
##@@@L0647_:    /* The trigger level is the number of bytes that must be in the stream   
##@@@L0648_:     * buffer before a task that is waiting for data is unblocked. */   
##@@@L0649_:    if( xTriggerLevel < pxStreamBuffer->xLength )   
800041f6:	a8 98       	LD.W      R5, [R0 + #2]
800041f8:	15 70       	CMP       R1, R5
800041fa:	04 f2       	JC        $+4                   ;->0x80004202
##@@@P_:stream_buffer.c:651
##@@@L0650_:    {   
##@@@L0651_:        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;   
800041fc:	c1 a0       	ST.W      [R0 + #3], R1
800041fe:	01 10       	MOV       R0, #1			;->0x0001
80004200:	02 04       	SJMP      $+2                   ;->0x80004204
80004202:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:stream_buffer.c:661
##@@@L0656_:        xReturn = pdFALSE;   
##@@@L0657_:    }   
##@@@L0658_:
##@@@L0659_:    traceRETURN_xStreamBufferSetTriggerLevel( xReturn );   
##@@@L0660_:
##@@@L0661_:    return xReturn;   
80004204:	e4 28       	ADD       SP, #4			;->0x04
80004206:	0d 5d       	POP       LR
80004208:	1d 5c       	JMP       LR
##@@@P_:stream_buffer.c:639
##@@@L0634_:    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0635_:    BaseType_t xReturn;   
##@@@L0636_:
##@@@L0637_:    traceENTER_xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );   
##@@@L0638_:
##@@@L0639_:    configASSERT( pxStreamBuffer );   
8000420a:	20 5d       	PUSH      R0
8000420c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004210:	08 00       	SYNC     SYNC     
80004212:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004216:	08 00       	SYNC     SYNC     
80004218:	00 5d       	POP       R0
8000421a:	20 5d       	PUSH      R0
8000421c:	21 5d       	PUSH      R1
8000421e:	0d 45       	LD        R5, [PC + #13]        ;->0x80004250  :=0x1ff
80004220:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004224:	25 58       	MOV       R1, R5
80004226:	11 68       	NOT       R1, R1
80004228:	01 69       	ANL       R0, R1
8000422a:	5f 11       	MOV       R5, #31			;->0x001F
8000422c:	25 58       	MOV       R1, R5
8000422e:	01 6a       	ORL       R0, R1
80004230:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004234:	08 00       	SYNC     SYNC     
80004236:	01 5d       	POP       R1
80004238:	00 5d       	POP       R0
8000423a:	20 5d       	PUSH      R0
8000423c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004240:	08 00       	SYNC     SYNC     
80004242:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004246:	08 00       	SYNC     SYNC     
80004248:	00 5d       	POP       R0
8000424a:	07 00       	BREAK    BREAK    
8000424c:	02 45       	LD        R5, [PC + #2]         ;->0x80004254  :=0x8000911c
8000424e:	05 5c       	LJMP      R5
80004250:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004254:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004258 <xStreamBufferSpacesAvailable>:
##@@@F_:xStreamBufferSpacesAvailable():
##@@@P_:stream_buffer.c:666
##@@@L0661_:    return xReturn;   
##@@@L0662_:}   
##@@@L0663_:/*-----------------------------------------------------------*/   
##@@@L0664_:
##@@@L0665_:size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )   
##@@@L0666_:{   
80004258:	2d 5d       	PUSH      LR
8000425a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:stream_buffer.c:673
##@@@L0668_:    size_t xSpace;   
##@@@L0669_:    size_t xOriginalTail;   
##@@@L0670_:
##@@@L0671_:    traceENTER_xStreamBufferSpacesAvailable( xStreamBuffer );   
##@@@L0672_:
##@@@L0673_:    configASSERT( pxStreamBuffer );   
8000425c:	00 38       	CMP       R0, #0			;->0x00
8000425e:	12 f0       	JZ        $+18                  ;->0x80004282
80004260:	a8 98       	LD.W      R5, [R0 + #2]
##@@@P_:stream_buffer.c:680
##@@@L0675_:    /* The code below reads xTail and then xHead.  This is safe if the stream   
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
80004262:	20 82       	LD.W      R2, [R0]
##@@@P_:stream_buffer.c:681
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004264:	40 82       	LD.W      R4, [R0]
##@@@P_:stream_buffer.c:682
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
80004266:	58 98       	LD.W      R3, [R0 + #1]
##@@@P_:stream_buffer.c:683
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
80004268:	10 82       	LD.W      R1, [R0]
8000426a:	21 70       	CMP       R2, R1
8000426c:	fb f1       	JNZ       $-5                   ;->0x80004262
##@@@P_:stream_buffer.c:681
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
8000426e:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:685
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
##@@@L0684_:
##@@@L0685_:    xSpace -= ( size_t ) 1;   
80004270:	33 68       	NOT       R3, R3
80004272:	e4 c2       	ADD       R4, R4, R3
##@@@P_:stream_buffer.c:687
##@@@L0686_:
##@@@L0687_:    if( xSpace >= pxStreamBuffer->xLength )   
80004274:	45 70       	CMP       R4, R5
80004276:	02 f2       	JC        $+2                   ;->0x8000427a
80004278:	50 10       	MOV       R5, #0			;->0x0000
8000427a:	44 c7       	SUB       R0, R4, R5
##@@@P_:stream_buffer.c:698
##@@@L0693_:        mtCOVERAGE_TEST_MARKER();   
##@@@L0694_:    }   
##@@@L0695_:
##@@@L0696_:    traceRETURN_xStreamBufferSpacesAvailable( xSpace );   
##@@@L0697_:
##@@@L0698_:    return xSpace;   
8000427c:	e4 28       	ADD       SP, #4			;->0x04
8000427e:	0d 5d       	POP       LR
80004280:	1d 5c       	JMP       LR
##@@@P_:stream_buffer.c:673
##@@@L0668_:    size_t xSpace;   
##@@@L0669_:    size_t xOriginalTail;   
##@@@L0670_:
##@@@L0671_:    traceENTER_xStreamBufferSpacesAvailable( xStreamBuffer );   
##@@@L0672_:
##@@@L0673_:    configASSERT( pxStreamBuffer );   
80004282:	20 5d       	PUSH      R0
80004284:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004288:	08 00       	SYNC     SYNC     
8000428a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000428e:	08 00       	SYNC     SYNC     
80004290:	00 5d       	POP       R0
80004292:	20 5d       	PUSH      R0
80004294:	21 5d       	PUSH      R1
80004296:	0d 45       	LD        R5, [PC + #13]        ;->0x800042c8  :=0x1ff
80004298:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000429c:	25 58       	MOV       R1, R5
8000429e:	11 68       	NOT       R1, R1
800042a0:	01 69       	ANL       R0, R1
800042a2:	5f 11       	MOV       R5, #31			;->0x001F
800042a4:	25 58       	MOV       R1, R5
800042a6:	01 6a       	ORL       R0, R1
800042a8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800042ac:	08 00       	SYNC     SYNC     
800042ae:	01 5d       	POP       R1
800042b0:	00 5d       	POP       R0
800042b2:	20 5d       	PUSH      R0
800042b4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800042b8:	08 00       	SYNC     SYNC     
800042ba:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800042be:	08 00       	SYNC     SYNC     
800042c0:	00 5d       	POP       R0
800042c2:	07 00       	BREAK    BREAK    
800042c4:	02 45       	LD        R5, [PC + #2]         ;->0x800042cc  :=0x8000911c
800042c6:	05 5c       	LJMP      R5
800042c8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800042cc:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800042d0 <xStreamBufferBytesAvailable>:
##@@@F_:xStreamBufferBytesAvailable():
##@@@P_:stream_buffer.c:703
##@@@L0698_:    return xSpace;   
##@@@L0699_:}   
##@@@L0700_:/*-----------------------------------------------------------*/   
##@@@L0701_:
##@@@L0702_:size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )   
##@@@L0703_:{   
800042d0:	2d 5d       	PUSH      LR
800042d2:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:stream_buffer.c:709
##@@@L0704_:    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0705_:    size_t xReturn;   
##@@@L0706_:
##@@@L0707_:    traceENTER_xStreamBufferBytesAvailable( xStreamBuffer );   
##@@@L0708_:
##@@@L0709_:    configASSERT( pxStreamBuffer );   
800042d4:	00 38       	CMP       R0, #0			;->0x00
800042d6:	0d f0       	JZ        $+13                  ;->0x800042f0
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
800042d8:	a8 98       	LD.W      R5, [R0 + #2]
800042da:	60 98       	LD.W      R4, [R0 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
800042dc:	30 82       	LD.W      R3, [R0]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
800042de:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
800042e0:	e4 c6       	SUB       R4, R4, R3
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
800042e2:	45 70       	CMP       R4, R5
800042e4:	02 f2       	JC        $+2                   ;->0x800042e8
800042e6:	50 10       	MOV       R5, #0			;->0x0000
800042e8:	44 c7       	SUB       R0, R4, R5
##@@@F_:xStreamBufferBytesAvailable():
##@@@P_:stream_buffer.c:715
##@@@L0710_:
##@@@L0711_:    xReturn = prvBytesInBuffer( pxStreamBuffer );   
##@@@L0712_:
##@@@L0713_:    traceRETURN_xStreamBufferBytesAvailable( xReturn );   
##@@@L0714_:
##@@@L0715_:    return xReturn;   
800042ea:	e4 28       	ADD       SP, #4			;->0x04
800042ec:	0d 5d       	POP       LR
800042ee:	1d 5c       	JMP       LR
##@@@P_:stream_buffer.c:709
##@@@L0704_:    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0705_:    size_t xReturn;   
##@@@L0706_:
##@@@L0707_:    traceENTER_xStreamBufferBytesAvailable( xStreamBuffer );   
##@@@L0708_:
##@@@L0709_:    configASSERT( pxStreamBuffer );   
800042f0:	20 5d       	PUSH      R0
800042f2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800042f6:	08 00       	SYNC     SYNC     
800042f8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800042fc:	08 00       	SYNC     SYNC     
800042fe:	00 5d       	POP       R0
80004300:	20 5d       	PUSH      R0
80004302:	21 5d       	PUSH      R1
80004304:	0d 45       	LD        R5, [PC + #13]        ;->0x80004338  :=0x1ff
80004306:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000430a:	25 58       	MOV       R1, R5
8000430c:	11 68       	NOT       R1, R1
8000430e:	01 69       	ANL       R0, R1
80004310:	5f 11       	MOV       R5, #31			;->0x001F
80004312:	25 58       	MOV       R1, R5
80004314:	01 6a       	ORL       R0, R1
80004316:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000431a:	08 00       	SYNC     SYNC     
8000431c:	01 5d       	POP       R1
8000431e:	00 5d       	POP       R0
80004320:	20 5d       	PUSH      R0
80004322:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004326:	08 00       	SYNC     SYNC     
80004328:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000432c:	08 00       	SYNC     SYNC     
8000432e:	00 5d       	POP       R0
80004330:	07 00       	BREAK    BREAK    
80004332:	03 45       	LD        R5, [PC + #3]         ;->0x8000433c  :=0x8000911c
80004334:	05 5c       	LJMP      R5
80004336:	00 00       	NOP      NOP      
80004338:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000433c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004340 <xStreamBufferSend>:
##@@@F_:xStreamBufferSend():
##@@@P_:stream_buffer.c:723
##@@@L0718_:
##@@@L0719_:size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,   
##@@@L0720_:                          const void * pvTxData,   
##@@@L0721_:                          size_t xDataLengthBytes,   
##@@@L0722_:                          TickType_t xTicksToWait )   
##@@@L0723_:{   
80004340:	8f 5f       	PUSH      {R6-R9,LR}
80004342:	e0 32       	SUB       SP, #32			;->0x20
##@@@P_:stream_buffer.c:732
##@@@L0727_:    TimeOut_t xTimeOut;   
##@@@L0728_:    size_t xMaxReportedSpace = 0;   
##@@@L0729_:
##@@@L0730_:    traceENTER_xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );   
##@@@L0731_:
##@@@L0732_:    configASSERT( pvTxData );   
80004344:	10 38       	CMP       R1, #0			;->0x00
80004346:	06 23       	ST.W      [SP + #6], R3
80004348:	02 f1       	JNZ       $+2                   ;->0x8000434c
8000434a:	f6 04       	SJMP      $+246                 ;->0x80004536
8000434c:	e0 58       	MOV       R7, R0
##@@@P_:stream_buffer.c:733
##@@@L0733_:    configASSERT( pxStreamBuffer );   
8000434e:	00 38       	CMP       R0, #0			;->0x00
80004350:	02 f1       	JNZ       $+2                   ;->0x80004354
80004352:	15 05       	SJMP      $+277                 ;->0x8000457c
80004354:	c2 58       	MOV       R6, R2
80004356:	01 59       	MOV       R8, R1
##@@@P_:stream_buffer.c:743
##@@@L0738_:
##@@@L0739_:    /* This send function is used to write to both message buffers and stream   
##@@@L0740_:     * buffers.  If this is a message buffer then the space needed must be   
##@@@L0741_:     * increased by the amount of bytes needed to store the length of the   
##@@@L0742_:     * message. */   
##@@@L0743_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004358:	27 8f       	LD.B      R4, [R7 + #28]
8000435a:	91 10       	MOV       R9, #1			;->0x0001
##@@@P_:stream_buffer.c:737
##@@@L0732_:    configASSERT( pvTxData );   
##@@@L0733_:    configASSERT( pxStreamBuffer );   
##@@@L0734_:
##@@@L0735_:    /* The maximum amount of space a stream buffer will ever report is its length   
##@@@L0736_:     * minus 1. */   
##@@@L0737_:    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;   
8000435c:	af 98       	LD.W      R5, [R7 + #2]
##@@@P_:stream_buffer.c:743
##@@@L0738_:
##@@@L0739_:    /* This send function is used to write to both message buffers and stream   
##@@@L0740_:     * buffers.  If this is a message buffer then the space needed must be   
##@@@L0741_:     * increased by the amount of bytes needed to store the length of the   
##@@@L0742_:     * message. */   
##@@@L0743_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
8000435e:	49 69       	ANL       R4, R9
##@@@P_:stream_buffer.c:737
##@@@L0732_:    configASSERT( pvTxData );   
##@@@L0733_:    configASSERT( pxStreamBuffer );   
##@@@L0734_:
##@@@L0735_:    /* The maximum amount of space a stream buffer will ever report is its length   
##@@@L0736_:     * minus 1. */   
##@@@L0737_:    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;   
80004360:	55 cc       	SUB       R2, R5, #1
##@@@P_:stream_buffer.c:743
##@@@L0738_:
##@@@L0739_:    /* This send function is used to write to both message buffers and stream   
##@@@L0740_:     * buffers.  If this is a message buffer then the space needed must be   
##@@@L0741_:     * increased by the amount of bytes needed to store the length of the   
##@@@L0742_:     * message. */   
##@@@L0743_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004362:	40 38       	CMP       R4, #0			;->0x00
80004364:	40 f1       	JNZ       $+64                  ;->0x800043e4
##@@@P_:stream_buffer.c:768
##@@@L0763_:    else   
##@@@L0764_:    {   
##@@@L0765_:        /* If this is a stream buffer then it is acceptable to write only part   
##@@@L0766_:         * of the message to the buffer.  Cap the length to the total length of   
##@@@L0767_:         * the buffer. */   
##@@@L0768_:        if( xRequiredSpace > xMaxReportedSpace )   
80004366:	26 70       	CMP       R2, R6
80004368:	02 f3       	JNC       $+2                   ;->0x8000436c
8000436a:	46 58       	MOV       R2, R6
##@@@P_:stream_buffer.c:778
##@@@L0773_:        {   
##@@@L0774_:            mtCOVERAGE_TEST_MARKER();   
##@@@L0775_:        }   
##@@@L0776_:    }   
##@@@L0777_:
##@@@L0778_:    if( xTicksToWait != ( TickType_t ) 0 )   
8000436c:	30 38       	CMP       R3, #0			;->0x00
8000436e:	48 f0       	JZ        $+72                  ;->0x800043fe
80004370:	03 22       	ST.W      [SP + #3], R2
80004372:	01 26       	ST.W      [SP + #1], R6
80004374:	50 40       	LD        R0, [PC + #80]        ;->0x800044b4  :=0x10
80004376:	0e 64       	ADD       R0, SP
##@@@P_:stream_buffer.c:780
##@@@L0779_:    {   
##@@@L0780_:        vTaskSetTimeOutState( &xTimeOut );   
80004378:	50 45       	LD        R5, [PC + #80]        ;->0x800044b8  :=0x8000726c
8000437a:	05 5c       	LJMP      R5
8000437c:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:stream_buffer.c:786
##@@@L0781_:
##@@@L0782_:        do   
##@@@L0783_:        {   
##@@@L0784_:            /* Wait until the required number of bytes are free in the message   
##@@@L0785_:             * buffer. */   
##@@@L0786_:            taskENTER_CRITICAL();   
8000437e:	50 45       	LD        R5, [PC + #80]        ;->0x800044bc  :=0x800056cc
80004380:	05 5c       	LJMP      R5
80004382:	af 98       	LD.W      R5, [R7 + #2]
##@@@F_:xStreamBufferSpacesAvailable():
##@@@P_:stream_buffer.c:680
##@@@L0675_:    /* The code below reads xTail and then xHead.  This is safe if the stream   
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
80004384:	27 82       	LD.W      R2, [R7]
##@@@P_:stream_buffer.c:681
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004386:	47 82       	LD.W      R4, [R7]
##@@@P_:stream_buffer.c:682
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
80004388:	5f 98       	LD.W      R3, [R7 + #1]
##@@@P_:stream_buffer.c:683
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
8000438a:	17 82       	LD.W      R1, [R7]
8000438c:	21 70       	CMP       R2, R1
8000438e:	fb f1       	JNZ       $-5                   ;->0x80004384
##@@@P_:stream_buffer.c:681
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004390:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:685
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
##@@@L0684_:
##@@@L0685_:    xSpace -= ( size_t ) 1;   
80004392:	33 68       	NOT       R3, R3
80004394:	e4 c2       	ADD       R4, R4, R3
80004396:	66 58       	MOV       R3, R6
##@@@P_:stream_buffer.c:687
##@@@L0686_:
##@@@L0687_:    if( xSpace >= pxStreamBuffer->xLength )   
80004398:	45 70       	CMP       R4, R5
8000439a:	02 f3       	JNC       $+2                   ;->0x8000439e
8000439c:	65 58       	MOV       R3, R5
8000439e:	e4 c6       	SUB       R4, R4, R3
##@@@F_:xStreamBufferSend():
##@@@P_:stream_buffer.c:790
##@@@L0785_:             * buffer. */   
##@@@L0786_:            taskENTER_CRITICAL();   
##@@@L0787_:            {   
##@@@L0788_:                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );   
##@@@L0789_:
##@@@L0790_:                if( xSpace < xRequiredSpace )   
800043a0:	03 0d       	LD.W      R5, [SP + #3]
800043a2:	02 24       	ST.W      [SP + #2], R4
800043a4:	45 70       	CMP       R4, R5
800043a6:	2e f2       	JC        $+46                  ;->0x80004402
##@@@P_:stream_buffer.c:793
##@@@L0791_:                {   
##@@@L0792_:                    /* Clear notification state as going to wait for space. */   
##@@@L0793_:                    ( void ) xTaskNotifyStateClear( NULL );   
800043a8:	06 58       	MOV       R0, R6
800043aa:	26 58       	MOV       R1, R6
800043ac:	45 45       	LD        R5, [PC + #69]        ;->0x800044c0  :=0x800084a0
800043ae:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:796
##@@@L0794_:
##@@@L0795_:                    /* Should only be one writer. */   
##@@@L0796_:                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );   
800043b0:	6f 99       	LD.W      R5, [R7 + #5]
800043b2:	50 38       	CMP       R5, #0			;->0x00
800043b4:	02 f0       	JZ        $+2                   ;->0x800043b8
800043b6:	9d 04       	SJMP      $+157                 ;->0x800044f0
##@@@P_:stream_buffer.c:797
##@@@L0797_:                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();   
800043b8:	43 45       	LD        R5, [PC + #67]        ;->0x800044c4  :=0x80007610
800043ba:	05 5c       	LJMP      R5
800043bc:	78 a1       	ST.W      [R7 + #5], R0
##@@@P_:stream_buffer.c:805
##@@@L0800_:                {   
##@@@L0801_:                    taskEXIT_CRITICAL();   
##@@@L0802_:                    break;   
##@@@L0803_:                }   
##@@@L0804_:            }   
##@@@L0805_:            taskEXIT_CRITICAL();   
800043be:	43 45       	LD        R5, [PC + #67]        ;->0x800044c8  :=0x80005730
800043c0:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:808
##@@@L0806_:
##@@@L0807_:            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );   
##@@@L0808_:            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );   
800043c2:	06 0c       	LD.W      R4, [SP + #6]
800043c4:	06 58       	MOV       R0, R6
800043c6:	26 58       	MOV       R1, R6
800043c8:	46 58       	MOV       R2, R6
800043ca:	66 58       	MOV       R3, R6
800043cc:	40 45       	LD        R5, [PC + #64]        ;->0x800044cc  :=0x80007ce0
800043ce:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:809
##@@@L0809_:            pxStreamBuffer->xTaskWaitingToSend = NULL;   
800043d0:	7e a1       	ST.W      [R7 + #5], R6
800043d2:	39 40       	LD        R0, [PC + #57]        ;->0x800044b4  :=0x10
800043d4:	0e 64       	ADD       R0, SP
800043d6:	3f 41       	LD        R1, [PC + #63]        ;->0x800044d0  :=0x18
800043d8:	1e 64       	ADD       R1, SP
##@@@P_:stream_buffer.c:810
##@@@L0810_:        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );   
800043da:	3f 45       	LD        R5, [PC + #63]        ;->0x800044d4  :=0x8000731c
800043dc:	05 5c       	LJMP      R5
800043de:	00 38       	CMP       R0, #0			;->0x00
800043e0:	cf f0       	JZ        $-49                  ;->0x8000437e
800043e2:	12 04       	SJMP      $+18                  ;->0x80004406
##@@@P_:stream_buffer.c:748
##@@@L0743_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
##@@@L0744_:    {   
##@@@L0745_:        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;   
##@@@L0746_:
##@@@L0747_:        /* Overflow? */   
##@@@L0748_:        configASSERT( xRequiredSpace > xDataLengthBytes );   
800043e4:	3d 44       	LD        R4, [PC + #61]        ;->0x800044d8  :=0xfffffffc
800043e6:	64 70       	CMP       R6, R4
800043e8:	02 f3       	JNC       $+2                   ;->0x800043ec
800043ea:	ec 04       	SJMP      $+236                 ;->0x800045c2
800043ec:	26 c1       	ADD       R4, R6, #4
##@@@P_:stream_buffer.c:752
##@@@L0749_:
##@@@L0750_:        /* If this is a message buffer then it must be possible to write the   
##@@@L0751_:         * whole message. */   
##@@@L0752_:        if( xRequiredSpace > xMaxReportedSpace )   
800043ee:	42 70       	CMP       R4, R2
800043f0:	04 f9       	JLS       $+4                   ;->0x800043f8
800043f2:	30 10       	MOV       R3, #0			;->0x0000
##@@@P_:stream_buffer.c:756
##@@@L0753_:        {   
##@@@L0754_:            /* The message would not fit even if the entire buffer was empty,   
##@@@L0755_:             * so don't wait for space. */   
##@@@L0756_:            xTicksToWait = ( TickType_t ) 0;   
800043f4:	06 23       	ST.W      [SP + #6], R3
800043f6:	10 04       	SJMP      $+16                  ;->0x80004416
800043f8:	44 58       	MOV       R2, R4
##@@@P_:stream_buffer.c:778
##@@@L0773_:        {   
##@@@L0774_:            mtCOVERAGE_TEST_MARKER();   
##@@@L0775_:        }   
##@@@L0776_:    }   
##@@@L0777_:
##@@@L0778_:    if( xTicksToWait != ( TickType_t ) 0 )   
800043fa:	30 38       	CMP       R3, #0			;->0x00
800043fc:	ba f1       	JNZ       $-70                  ;->0x80004370
800043fe:	82 58       	MOV       R4, R2
80004400:	0b 04       	SJMP      $+11                  ;->0x80004416
##@@@P_:stream_buffer.c:801
##@@@L0796_:                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );   
##@@@L0797_:                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();   
##@@@L0798_:                }   
##@@@L0799_:                else   
##@@@L0800_:                {   
##@@@L0801_:                    taskEXIT_CRITICAL();   
80004402:	32 45       	LD        R5, [PC + #50]        ;->0x800044c8  :=0x80005730
80004404:	05 5c       	LJMP      R5
80004406:	02 0a       	LD.W      R2, [SP + #2]
##@@@P_:stream_buffer.c:817
##@@@L0812_:    else   
##@@@L0813_:    {   
##@@@L0814_:        mtCOVERAGE_TEST_MARKER();   
##@@@L0815_:    }   
##@@@L0816_:
##@@@L0817_:    if( xSpace == ( size_t ) 0 )   
80004408:	20 38       	CMP       R2, #0			;->0x00
8000440a:	01 0e       	LD.W      R6, [SP + #1]
8000440c:	03 f0       	JZ        $+3                   ;->0x80004412
8000440e:	03 0c       	LD.W      R4, [SP + #3]
80004410:	10 04       	SJMP      $+16                  ;->0x80004430
80004412:	af 98       	LD.W      R5, [R7 + #2]
80004414:	03 0c       	LD.W      R4, [SP + #3]
##@@@F_:xStreamBufferSpacesAvailable():
##@@@P_:stream_buffer.c:680
##@@@L0675_:    /* The code below reads xTail and then xHead.  This is safe if the stream   
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
80004416:	17 82       	LD.W      R1, [R7]
##@@@P_:stream_buffer.c:681
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004418:	37 82       	LD.W      R3, [R7]
##@@@P_:stream_buffer.c:682
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
8000441a:	57 98       	LD.W      R2, [R7 + #1]
##@@@P_:stream_buffer.c:683
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
8000441c:	07 82       	LD.W      R0, [R7]
8000441e:	10 70       	CMP       R1, R0
80004420:	fb f1       	JNZ       $-5                   ;->0x80004416
##@@@P_:stream_buffer.c:681
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004422:	5b c3       	ADD       R3, R3, R5
##@@@P_:stream_buffer.c:685
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
##@@@L0684_:
##@@@L0685_:    xSpace -= ( size_t ) 1;   
80004424:	22 68       	NOT       R2, R2
80004426:	9b c2       	ADD       R3, R3, R2
##@@@P_:stream_buffer.c:687
##@@@L0686_:
##@@@L0687_:    if( xSpace >= pxStreamBuffer->xLength )   
80004428:	35 70       	CMP       R3, R5
8000442a:	02 f2       	JC        $+2                   ;->0x8000442e
8000442c:	50 10       	MOV       R5, #0			;->0x0000
8000442e:	53 c7       	SUB       R2, R3, R5
##@@@F_:prvWriteMessageToBuffer():
##@@@P_:stream_buffer.c:914
##@@@L0909_:                                       const void * pvTxData,   
##@@@L0910_:                                       size_t xDataLengthBytes,   
##@@@L0911_:                                       size_t xSpace,   
##@@@L0912_:                                       size_t xRequiredSpace )   
##@@@L0913_:{   
##@@@L0914_:    size_t xNextHead = pxStreamBuffer->xHead;   
80004430:	5f 98       	LD.W      R3, [R7 + #1]
##@@@P_:stream_buffer.c:917
##@@@L0915_:    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;   
##@@@L0916_:
##@@@L0917_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004432:	2f 8f       	LD.B      R5, [R7 + #28]
80004434:	59 69       	ANL       R5, R9
80004436:	50 38       	CMP       R5, #0			;->0x00
80004438:	07 f1       	JNZ       $+7                   ;->0x80004446
##@@@P_:stream_buffer.c:945
##@@@L0940_:    else   
##@@@L0941_:    {   
##@@@L0942_:        /* This is a stream buffer, as opposed to a message buffer, so writing a   
##@@@L0943_:         * stream of bytes rather than discrete messages.  Plan to write as many   
##@@@L0944_:         * bytes as possible. */   
##@@@L0945_:        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );   
8000443a:	26 70       	CMP       R2, R6
8000443c:	02 f8       	JHI       $+2                   ;->0x80004440
8000443e:	c2 58       	MOV       R6, R2
##@@@P_:stream_buffer.c:948
##@@@L0946_:    }   
##@@@L0947_:
##@@@L0948_:    if( xDataLengthBytes != ( size_t ) 0 )   
80004440:	60 38       	CMP       R6, #0			;->0x00
80004442:	0e f1       	JNZ       $+14                  ;->0x8000445e
80004444:	32 04       	SJMP      $+50                  ;->0x800044a8
##@@@P_:stream_buffer.c:927
##@@@L0922_:        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;   
##@@@L0923_:
##@@@L0924_:        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */   
##@@@L0925_:        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );   
##@@@L0926_:
##@@@L0927_:        if( xSpace >= xRequiredSpace )   
80004446:	24 70       	CMP       R2, R4
##@@@P_:stream_buffer.c:922
##@@@L0917_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
##@@@L0918_:    {   
##@@@L0919_:        /* This is a message buffer, as opposed to a stream buffer. */   
##@@@L0920_:
##@@@L0921_:        /* Convert xDataLengthBytes to the message length type. */   
##@@@L0922_:        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;   
80004448:	07 26       	ST.W      [SP + #7], R6
##@@@P_:stream_buffer.c:927
##@@@L0923_:
##@@@L0924_:        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */   
##@@@L0925_:        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );   
##@@@L0926_:
##@@@L0927_:        if( xSpace >= xRequiredSpace )   
8000444a:	2f f3       	JNC       $+47                  ;->0x800044a8
8000444c:	24 41       	LD        R1, [PC + #36]        ;->0x800044dc  :=0x1c
8000444e:	1e 64       	ADD       R1, SP
80004450:	24 10       	MOV       R2, #4			;->0x0004
##@@@P_:stream_buffer.c:932
##@@@L0928_:        {   
##@@@L0929_:            /* There is enough space to write both the message length and the message   
##@@@L0930_:             * itself into the buffer.  Start by writing the length of the data, the data   
##@@@L0931_:             * itself will be written later in this function. */   
##@@@L0932_:            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );   
80004452:	07 58       	MOV       R0, R7
80004454:	23 45       	LD        R5, [PC + #35]        ;->0x800044e0  :=0x80004f94
80004456:	05 5c       	LJMP      R5
80004458:	60 58       	MOV       R3, R0
##@@@P_:stream_buffer.c:948
##@@@L0943_:         * stream of bytes rather than discrete messages.  Plan to write as many   
##@@@L0944_:         * bytes as possible. */   
##@@@L0945_:        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );   
##@@@L0946_:    }   
##@@@L0947_:
##@@@L0948_:    if( xDataLengthBytes != ( size_t ) 0 )   
8000445a:	60 38       	CMP       R6, #0			;->0x00
8000445c:	26 f0       	JZ        $+38                  ;->0x800044a8
##@@@P_:stream_buffer.c:954
##@@@L0949_:    {   
##@@@L0950_:        /* Write the data to the buffer. */   
##@@@L0951_:        /* MISRA Ref 11.5.5 [Void pointer assignment] */   
##@@@L0952_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0953_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0954_:        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead );   
8000445e:	07 58       	MOV       R0, R7
80004460:	28 58       	MOV       R1, R8
80004462:	46 58       	MOV       R2, R6
80004464:	1f 45       	LD        R5, [PC + #31]        ;->0x800044e0  :=0x80004f94
80004466:	05 5c       	LJMP      R5
80004468:	78 a0       	ST.W      [R7 + #1], R0
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
8000446a:	af 98       	LD.W      R5, [R7 + #2]
8000446c:	67 98       	LD.W      R4, [R7 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
8000446e:	37 82       	LD.W      R3, [R7]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004470:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
80004472:	e4 c6       	SUB       R4, R4, R3
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
80004474:	45 70       	CMP       R4, R5
80004476:	02 f2       	JC        $+2                   ;->0x8000447a
##@@@F_:xStreamBufferSend():
80004478:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:stream_buffer.c:833
##@@@L0828_:    if( xReturn > ( size_t ) 0 )   
##@@@L0829_:    {   
##@@@L0830_:        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );   
##@@@L0831_:
##@@@L0832_:        /* Was a task waiting for the data? */   
##@@@L0833_:        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )   
8000447a:	df 98       	LD.W      R3, [R7 + #3]
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1463
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
8000447c:	6c c7       	SUB       R5, R4, R5
##@@@F_:xStreamBufferSend():
##@@@P_:stream_buffer.c:833
##@@@L0828_:    if( xReturn > ( size_t ) 0 )   
##@@@L0829_:    {   
##@@@L0830_:        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );   
##@@@L0831_:
##@@@L0832_:        /* Was a task waiting for the data? */   
##@@@L0833_:        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )   
8000447e:	53 70       	CMP       R5, R3
80004480:	15 f3       	JNC       $+21                  ;->0x800044aa
##@@@P_:stream_buffer.c:835
##@@@L0834_:        {   
##@@@L0835_:            prvSEND_COMPLETED( pxStreamBuffer );   
80004482:	19 45       	LD        R5, [PC + #25]        ;->0x800044e4  :=0x800059b0
80004484:	05 5c       	LJMP      R5
80004486:	2f 99       	LD.W      R5, [R7 + #4]
80004488:	50 38       	CMP       R5, #0			;->0x00
8000448a:	0c f0       	JZ        $+12                  ;->0x800044a2
8000448c:	07 99       	LD.W      R0, [R7 + #4]
8000448e:	01 26       	ST.W      [SP + #1], R6
80004490:	60 10       	MOV       R6, #0			;->0x0000
80004492:	26 58       	MOV       R1, R6
80004494:	46 58       	MOV       R2, R6
80004496:	66 58       	MOV       R3, R6
80004498:	86 58       	MOV       R4, R6
8000449a:	14 45       	LD        R5, [PC + #20]        ;->0x800044e8  :=0x80007e44
8000449c:	05 5c       	LJMP      R5
8000449e:	3e a1       	ST.W      [R7 + #4], R6
800044a0:	01 0e       	LD.W      R6, [SP + #1]
800044a2:	13 45       	LD        R5, [PC + #19]        ;->0x800044ec  :=0x80005a70
800044a4:	05 5c       	LJMP      R5
800044a6:	02 04       	SJMP      $+2                   ;->0x800044aa
800044a8:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:stream_buffer.c:850
##@@@L0845_:        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );   
##@@@L0846_:    }   
##@@@L0847_:
##@@@L0848_:    traceRETURN_xStreamBufferSend( xReturn );   
##@@@L0849_:
##@@@L0850_:    return xReturn;   
800044aa:	06 58       	MOV       R0, R6
800044ac:	e0 2a       	ADD       SP, #32			;->0x20
800044ae:	0f 5e       	POP       {R6-R9}
800044b0:	0d 5d       	POP       LR
800044b2:	1d 5c       	JMP       LR
800044b4:	10 00 00 00 	.long     0x00000010 ->000000016  [!!!@4@:DMAC16LL  ACC0, ACC0, R0, R0
800044b8:	6c 72 00 80 	.long     0x8000726c ->-2147454356  [!!!@2@:LD.W      R6, [R12++]	@@: LD.B      R0, [R0]
800044bc:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x800044bc
800044c0:	a0 84 00 80 	.long     0x800084a0 ->-2147449696  [!!!@2@:ST.H      [R10], R0	@@: LD.B      R0, [R0]
800044c4:	10 76 00 80 	.long     0x80007610 ->-2147453424  [!!!@2@:LD.B      R1, [R0++]	@@: LD.B      R0, [R0]
800044c8:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x800044c8
800044cc:	e0 7c 00 80 	.long     0x80007ce0 ->-2147451680  [!!!@2@:LSR       R12, #8	@@: LD.B      R0, [R0]
800044d0:	18 00 00 00 	.long     0x00000018 ->000000024  [!!!@4@:MULS      R0, R0, R0
800044d4:	1c 73 00 80 	.long     0x8000731c ->-2147454180  [!!!@2@:ST.W      [R1++], R12	@@: LD.B      R0, [R0]
800044d8:	fc ff ff ff 	.long     0xfffffffc ->-00000004 
800044dc:	1c 00 00 00 	.long     0x0000001c ->000000028  [!!!@4@:DMAC16LL  ACC0, R0, R0
800044e0:	94 4f 00 80 	.long     0x80004f94 ->-2147463276  [!!!@2@:CLR       [R2], #28	@@: LD.B      R0, [R0]
800044e4:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
800044e8:	44 7e 00 80 	.long     0x80007e44 ->-2147451324  [!!!@2@:ROR       R8, #4	@@: LD.B      R0, [R0]
800044ec:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:796
##@@@L0791_:                {   
##@@@L0792_:                    /* Clear notification state as going to wait for space. */   
##@@@L0793_:                    ( void ) xTaskNotifyStateClear( NULL );   
##@@@L0794_:
##@@@L0795_:                    /* Should only be one writer. */   
##@@@L0796_:                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );   
800044f0:	20 5d       	PUSH      R0
800044f2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800044f6:	08 00       	SYNC     SYNC     
800044f8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800044fc:	08 00       	SYNC     SYNC     
800044fe:	00 5d       	POP       R0
80004500:	20 5d       	PUSH      R0
80004502:	21 5d       	PUSH      R1
80004504:	41 45       	LD        R5, [PC + #65]        ;->0x80004608  :=0x1ff
80004506:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000450a:	25 58       	MOV       R1, R5
8000450c:	11 68       	NOT       R1, R1
8000450e:	01 69       	ANL       R0, R1
80004510:	5f 11       	MOV       R5, #31			;->0x001F
80004512:	25 58       	MOV       R1, R5
80004514:	01 6a       	ORL       R0, R1
80004516:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000451a:	08 00       	SYNC     SYNC     
8000451c:	01 5d       	POP       R1
8000451e:	00 5d       	POP       R0
80004520:	20 5d       	PUSH      R0
80004522:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004526:	08 00       	SYNC     SYNC     
80004528:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000452c:	08 00       	SYNC     SYNC     
8000452e:	00 5d       	POP       R0
80004530:	07 00       	BREAK    BREAK    
80004532:	37 45       	LD        R5, [PC + #55]        ;->0x8000460c  :=0x8000911c
80004534:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:732
##@@@L0727_:    TimeOut_t xTimeOut;   
##@@@L0728_:    size_t xMaxReportedSpace = 0;   
##@@@L0729_:
##@@@L0730_:    traceENTER_xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );   
##@@@L0731_:
##@@@L0732_:    configASSERT( pvTxData );   
80004536:	20 5d       	PUSH      R0
80004538:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000453c:	08 00       	SYNC     SYNC     
8000453e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004542:	08 00       	SYNC     SYNC     
80004544:	00 5d       	POP       R0
80004546:	20 5d       	PUSH      R0
80004548:	21 5d       	PUSH      R1
8000454a:	30 45       	LD        R5, [PC + #48]        ;->0x80004608  :=0x1ff
8000454c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004550:	25 58       	MOV       R1, R5
80004552:	11 68       	NOT       R1, R1
80004554:	01 69       	ANL       R0, R1
80004556:	5f 11       	MOV       R5, #31			;->0x001F
80004558:	25 58       	MOV       R1, R5
8000455a:	01 6a       	ORL       R0, R1
8000455c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004560:	08 00       	SYNC     SYNC     
80004562:	01 5d       	POP       R1
80004564:	00 5d       	POP       R0
80004566:	20 5d       	PUSH      R0
80004568:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000456c:	08 00       	SYNC     SYNC     
8000456e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004572:	08 00       	SYNC     SYNC     
80004574:	00 5d       	POP       R0
80004576:	07 00       	BREAK    BREAK    
80004578:	25 45       	LD        R5, [PC + #37]        ;->0x8000460c  :=0x8000911c
8000457a:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:733
##@@@L0733_:    configASSERT( pxStreamBuffer );   
8000457c:	20 5d       	PUSH      R0
8000457e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004582:	08 00       	SYNC     SYNC     
80004584:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004588:	08 00       	SYNC     SYNC     
8000458a:	00 5d       	POP       R0
8000458c:	20 5d       	PUSH      R0
8000458e:	21 5d       	PUSH      R1
80004590:	1e 45       	LD        R5, [PC + #30]        ;->0x80004608  :=0x1ff
80004592:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004596:	25 58       	MOV       R1, R5
80004598:	11 68       	NOT       R1, R1
8000459a:	01 69       	ANL       R0, R1
8000459c:	5f 11       	MOV       R5, #31			;->0x001F
8000459e:	25 58       	MOV       R1, R5
800045a0:	01 6a       	ORL       R0, R1
800045a2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800045a6:	08 00       	SYNC     SYNC     
800045a8:	01 5d       	POP       R1
800045aa:	00 5d       	POP       R0
800045ac:	20 5d       	PUSH      R0
800045ae:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800045b2:	08 00       	SYNC     SYNC     
800045b4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800045b8:	08 00       	SYNC     SYNC     
800045ba:	00 5d       	POP       R0
800045bc:	07 00       	BREAK    BREAK    
800045be:	14 45       	LD        R5, [PC + #20]        ;->0x8000460c  :=0x8000911c
800045c0:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:748
##@@@L0743_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
##@@@L0744_:    {   
##@@@L0745_:        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;   
##@@@L0746_:
##@@@L0747_:        /* Overflow? */   
##@@@L0748_:        configASSERT( xRequiredSpace > xDataLengthBytes );   
800045c2:	20 5d       	PUSH      R0
800045c4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800045c8:	08 00       	SYNC     SYNC     
800045ca:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800045ce:	08 00       	SYNC     SYNC     
800045d0:	00 5d       	POP       R0
800045d2:	20 5d       	PUSH      R0
800045d4:	21 5d       	PUSH      R1
800045d6:	0d 45       	LD        R5, [PC + #13]        ;->0x80004608  :=0x1ff
800045d8:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800045dc:	25 58       	MOV       R1, R5
800045de:	11 68       	NOT       R1, R1
800045e0:	01 69       	ANL       R0, R1
800045e2:	5f 11       	MOV       R5, #31			;->0x001F
800045e4:	25 58       	MOV       R1, R5
800045e6:	01 6a       	ORL       R0, R1
800045e8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800045ec:	08 00       	SYNC     SYNC     
800045ee:	01 5d       	POP       R1
800045f0:	00 5d       	POP       R0
800045f2:	20 5d       	PUSH      R0
800045f4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800045f8:	08 00       	SYNC     SYNC     
800045fa:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800045fe:	08 00       	SYNC     SYNC     
80004600:	00 5d       	POP       R0
80004602:	07 00       	BREAK    BREAK    
80004604:	02 45       	LD        R5, [PC + #2]         ;->0x8000460c  :=0x8000911c
80004606:	05 5c       	LJMP      R5
80004608:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000460c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004610 <xStreamBufferSendFromISR>:
##@@@F_:xStreamBufferSendFromISR():
##@@@P_:stream_buffer.c:858
##@@@L0853_:
##@@@L0854_:size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,   
##@@@L0855_:                                 const void * pvTxData,   
##@@@L0856_:                                 size_t xDataLengthBytes,   
##@@@L0857_:                                 BaseType_t * const pxHigherPriorityTaskWoken )   
##@@@L0858_:{   
80004610:	9f 5f       	PUSH      {R6-R10,LR}
80004612:	e0 31       	SUB       SP, #16			;->0x10
##@@@P_:stream_buffer.c:865
##@@@L0860_:    size_t xReturn, xSpace;   
##@@@L0861_:    size_t xRequiredSpace = xDataLengthBytes;   
##@@@L0862_:
##@@@L0863_:    traceENTER_xStreamBufferSendFromISR( xStreamBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken );   
##@@@L0864_:
##@@@L0865_:    configASSERT( pvTxData );   
80004614:	10 38       	CMP       R1, #0			;->0x00
80004616:	02 f1       	JNZ       $+2                   ;->0x8000461a
80004618:	66 04       	SJMP      $+102                 ;->0x800046e4
8000461a:	e0 58       	MOV       R7, R0
##@@@P_:stream_buffer.c:866
##@@@L0866_:    configASSERT( pxStreamBuffer );   
8000461c:	00 38       	CMP       R0, #0			;->0x00
8000461e:	02 f1       	JNZ       $+2                   ;->0x80004622
80004620:	85 04       	SJMP      $+133                 ;->0x8000472a
80004622:	21 59       	MOV       R9, R1
80004624:	03 59       	MOV       R8, R3
80004626:	c2 58       	MOV       R6, R2
##@@@P_:stream_buffer.c:872
##@@@L0867_:
##@@@L0868_:    /* This send function is used to write to both message buffers and stream   
##@@@L0869_:     * buffers.  If this is a message buffer then the space needed must be   
##@@@L0870_:     * increased by the amount of bytes needed to store the length of the   
##@@@L0871_:     * message. */   
##@@@L0872_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004628:	2f 8f       	LD.B      R5, [R7 + #28]
8000462a:	41 10       	MOV       R4, #1			;->0x0001
8000462c:	54 69       	ANL       R5, R4
8000462e:	9f 98       	LD.W      R3, [R7 + #2]
80004630:	22 c1       	ADD       R4, R2, #4
##@@@F_:xStreamBufferSpacesAvailable():
##@@@P_:stream_buffer.c:680
##@@@L0675_:    /* The code below reads xTail and then xHead.  This is safe if the stream   
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
80004632:	07 82       	LD.W      R0, [R7]
##@@@P_:stream_buffer.c:681
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004634:	27 82       	LD.W      R2, [R7]
##@@@P_:stream_buffer.c:682
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
80004636:	4f 98       	LD.W      R1, [R7 + #1]
##@@@P_:stream_buffer.c:683
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
80004638:	a7 82       	LD.W      R10, [R7]
8000463a:	0a 70       	CMP       R0, R10
8000463c:	fb f1       	JNZ       $-5                   ;->0x80004632
##@@@P_:stream_buffer.c:681
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
8000463e:	d2 c2       	ADD       R2, R2, R3
##@@@P_:stream_buffer.c:685
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
##@@@L0684_:
##@@@L0685_:    xSpace -= ( size_t ) 1;   
80004640:	11 68       	NOT       R1, R1
80004642:	52 c2       	ADD       R2, R2, R1
##@@@P_:stream_buffer.c:687
##@@@L0686_:
##@@@L0687_:    if( xSpace >= pxStreamBuffer->xLength )   
80004644:	23 70       	CMP       R2, R3
80004646:	02 f2       	JC        $+2                   ;->0x8000464a
80004648:	30 10       	MOV       R3, #0			;->0x0000
8000464a:	d2 c6       	SUB       R2, R2, R3
##@@@F_:prvWriteMessageToBuffer():
##@@@P_:stream_buffer.c:914
##@@@L0909_:                                       const void * pvTxData,   
##@@@L0910_:                                       size_t xDataLengthBytes,   
##@@@L0911_:                                       size_t xSpace,   
##@@@L0912_:                                       size_t xRequiredSpace )   
##@@@L0913_:{   
##@@@L0914_:    size_t xNextHead = pxStreamBuffer->xHead;   
8000464c:	5f 98       	LD.W      R3, [R7 + #1]
##@@@P_:stream_buffer.c:917
##@@@L0915_:    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;   
##@@@L0916_:
##@@@L0917_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
8000464e:	50 38       	CMP       R5, #0			;->0x00
80004650:	07 f1       	JNZ       $+7                   ;->0x8000465e
##@@@P_:stream_buffer.c:945
##@@@L0940_:    else   
##@@@L0941_:    {   
##@@@L0942_:        /* This is a stream buffer, as opposed to a message buffer, so writing a   
##@@@L0943_:         * stream of bytes rather than discrete messages.  Plan to write as many   
##@@@L0944_:         * bytes as possible. */   
##@@@L0945_:        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );   
80004652:	26 70       	CMP       R2, R6
80004654:	02 f8       	JHI       $+2                   ;->0x80004658
80004656:	c2 58       	MOV       R6, R2
##@@@P_:stream_buffer.c:948
##@@@L0946_:    }   
##@@@L0947_:
##@@@L0948_:    if( xDataLengthBytes != ( size_t ) 0 )   
80004658:	60 38       	CMP       R6, #0			;->0x00
8000465a:	0e f1       	JNZ       $+14                  ;->0x80004676
8000465c:	34 04       	SJMP      $+52                  ;->0x800046c4
##@@@P_:stream_buffer.c:927
##@@@L0922_:        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;   
##@@@L0923_:
##@@@L0924_:        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */   
##@@@L0925_:        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );   
##@@@L0926_:
##@@@L0927_:        if( xSpace >= xRequiredSpace )   
8000465e:	24 70       	CMP       R2, R4
##@@@P_:stream_buffer.c:922
##@@@L0917_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
##@@@L0918_:    {   
##@@@L0919_:        /* This is a message buffer, as opposed to a stream buffer. */   
##@@@L0920_:
##@@@L0921_:        /* Convert xDataLengthBytes to the message length type. */   
##@@@L0922_:        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;   
80004660:	03 26       	ST.W      [SP + #3], R6
##@@@P_:stream_buffer.c:927
##@@@L0923_:
##@@@L0924_:        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */   
##@@@L0925_:        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );   
##@@@L0926_:
##@@@L0927_:        if( xSpace >= xRequiredSpace )   
80004662:	31 f3       	JNC       $+49                  ;->0x800046c4
80004664:	1b 41       	LD        R1, [PC + #27]        ;->0x800046d0  :=0xc
80004666:	1e 64       	ADD       R1, SP
80004668:	24 10       	MOV       R2, #4			;->0x0004
##@@@P_:stream_buffer.c:932
##@@@L0928_:        {   
##@@@L0929_:            /* There is enough space to write both the message length and the message   
##@@@L0930_:             * itself into the buffer.  Start by writing the length of the data, the data   
##@@@L0931_:             * itself will be written later in this function. */   
##@@@L0932_:            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );   
8000466a:	07 58       	MOV       R0, R7
8000466c:	1a 45       	LD        R5, [PC + #26]        ;->0x800046d4  :=0x80004f94
8000466e:	05 5c       	LJMP      R5
80004670:	60 58       	MOV       R3, R0
##@@@P_:stream_buffer.c:948
##@@@L0943_:         * stream of bytes rather than discrete messages.  Plan to write as many   
##@@@L0944_:         * bytes as possible. */   
##@@@L0945_:        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );   
##@@@L0946_:    }   
##@@@L0947_:
##@@@L0948_:    if( xDataLengthBytes != ( size_t ) 0 )   
80004672:	60 38       	CMP       R6, #0			;->0x00
80004674:	28 f0       	JZ        $+40                  ;->0x800046c4
##@@@P_:stream_buffer.c:954
##@@@L0949_:    {   
##@@@L0950_:        /* Write the data to the buffer. */   
##@@@L0951_:        /* MISRA Ref 11.5.5 [Void pointer assignment] */   
##@@@L0952_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L0953_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L0954_:        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead );   
80004676:	07 58       	MOV       R0, R7
80004678:	29 58       	MOV       R1, R9
8000467a:	46 58       	MOV       R2, R6
8000467c:	16 45       	LD        R5, [PC + #22]        ;->0x800046d4  :=0x80004f94
8000467e:	05 5c       	LJMP      R5
80004680:	78 a0       	ST.W      [R7 + #1], R0
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004682:	af 98       	LD.W      R5, [R7 + #2]
80004684:	67 98       	LD.W      R4, [R7 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
80004686:	37 82       	LD.W      R3, [R7]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004688:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
8000468a:	e4 c6       	SUB       R4, R4, R3
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
8000468c:	45 70       	CMP       R4, R5
8000468e:	02 f2       	JC        $+2                   ;->0x80004692
##@@@F_:xStreamBufferSendFromISR():
80004690:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:stream_buffer.c:887
##@@@L0882_:    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );   
##@@@L0883_:
##@@@L0884_:    if( xReturn > ( size_t ) 0 )   
##@@@L0885_:    {   
##@@@L0886_:        /* Was a task waiting for the data? */   
##@@@L0887_:        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )   
80004692:	df 98       	LD.W      R3, [R7 + #3]
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1463
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
80004694:	6c c7       	SUB       R5, R4, R5
##@@@F_:xStreamBufferSendFromISR():
##@@@P_:stream_buffer.c:887
##@@@L0882_:    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );   
##@@@L0883_:
##@@@L0884_:    if( xReturn > ( size_t ) 0 )   
##@@@L0885_:    {   
##@@@L0886_:        /* Was a task waiting for the data? */   
##@@@L0887_:        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )   
80004696:	53 70       	CMP       R5, R3
80004698:	17 f3       	JNC       $+23                  ;->0x800046c6
##@@@P_:stream_buffer.c:889
##@@@L0888_:        {   
##@@@L0889_:            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );   
8000469a:	10 45       	LD        R5, [PC + #16]        ;->0x800046d8  :=0x80008ff0
8000469c:	05 5c       	LJMP      R5
8000469e:	2f 99       	LD.W      R5, [R7 + #4]
800046a0:	50 38       	CMP       R5, #0			;->0x00
800046a2:	20 59       	MOV       R9, R0
800046a4:	0c f0       	JZ        $+12                  ;->0x800046bc
800046a6:	07 99       	LD.W      R0, [R7 + #4]
800046a8:	10 10       	MOV       R1, #0			;->0x0000
800046aa:	02 21       	ST.W      [SP + #2], R1
800046ac:	e8 85       	ST.W      [SP], R8
800046ae:	41 58       	MOV       R2, R1
800046b0:	61 58       	MOV       R3, R1
800046b2:	81 58       	MOV       R4, R1
800046b4:	0a 45       	LD        R5, [PC + #10]        ;->0x800046dc  :=0x80008070
800046b6:	05 5c       	LJMP      R5
800046b8:	02 0d       	LD.W      R5, [SP + #2]
800046ba:	3d a1       	ST.W      [R7 + #4], R5
800046bc:	09 58       	MOV       R0, R9
800046be:	09 45       	LD        R5, [PC + #9]         ;->0x800046e0  :=0x80009034
800046c0:	05 5c       	LJMP      R5
800046c2:	02 04       	SJMP      $+2                   ;->0x800046c6
800046c4:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:stream_buffer.c:904
##@@@L0899_:    }   
##@@@L0900_:
##@@@L0901_:    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );   
##@@@L0902_:    traceRETURN_xStreamBufferSendFromISR( xReturn );   
##@@@L0903_:
##@@@L0904_:    return xReturn;   
800046c6:	06 58       	MOV       R0, R6
800046c8:	e0 29       	ADD       SP, #16			;->0x10
800046ca:	1f 5e       	POP       {R6-R10}
800046cc:	0d 5d       	POP       LR
800046ce:	1d 5c       	JMP       LR
800046d0:	0c 00 00 00 	.long     0x0000000c ->000000012  [!!!@2@:MRET     	@@: NOP      
800046d4:	94 4f 00 80 	.long     0x80004f94 ->-2147463276  [!!!@2@:CLR       [R2], #28	@@: LD.B      R0, [R0]
800046d8:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
800046dc:	70 80 00 80 	.long     0x80008070 ->-2147450768  [!!!@2@:LD.B      R7, [R0]	@@: LD.B      R0, [R0]
800046e0:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:865
##@@@L0860_:    size_t xReturn, xSpace;   
##@@@L0861_:    size_t xRequiredSpace = xDataLengthBytes;   
##@@@L0862_:
##@@@L0863_:    traceENTER_xStreamBufferSendFromISR( xStreamBuffer, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken );   
##@@@L0864_:
##@@@L0865_:    configASSERT( pvTxData );   
800046e4:	20 5d       	PUSH      R0
800046e6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800046ea:	08 00       	SYNC     SYNC     
800046ec:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800046f0:	08 00       	SYNC     SYNC     
800046f2:	00 5d       	POP       R0
800046f4:	20 5d       	PUSH      R0
800046f6:	21 5d       	PUSH      R1
800046f8:	1e 45       	LD        R5, [PC + #30]        ;->0x80004770  :=0x1ff
800046fa:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800046fe:	25 58       	MOV       R1, R5
80004700:	11 68       	NOT       R1, R1
80004702:	01 69       	ANL       R0, R1
80004704:	5f 11       	MOV       R5, #31			;->0x001F
80004706:	25 58       	MOV       R1, R5
80004708:	01 6a       	ORL       R0, R1
8000470a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000470e:	08 00       	SYNC     SYNC     
80004710:	01 5d       	POP       R1
80004712:	00 5d       	POP       R0
80004714:	20 5d       	PUSH      R0
80004716:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000471a:	08 00       	SYNC     SYNC     
8000471c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004720:	08 00       	SYNC     SYNC     
80004722:	00 5d       	POP       R0
80004724:	07 00       	BREAK    BREAK    
80004726:	14 45       	LD        R5, [PC + #20]        ;->0x80004774  :=0x8000911c
80004728:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:866
##@@@L0866_:    configASSERT( pxStreamBuffer );   
8000472a:	20 5d       	PUSH      R0
8000472c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004730:	08 00       	SYNC     SYNC     
80004732:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004736:	08 00       	SYNC     SYNC     
80004738:	00 5d       	POP       R0
8000473a:	20 5d       	PUSH      R0
8000473c:	21 5d       	PUSH      R1
8000473e:	0d 45       	LD        R5, [PC + #13]        ;->0x80004770  :=0x1ff
80004740:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004744:	25 58       	MOV       R1, R5
80004746:	11 68       	NOT       R1, R1
80004748:	01 69       	ANL       R0, R1
8000474a:	5f 11       	MOV       R5, #31			;->0x001F
8000474c:	25 58       	MOV       R1, R5
8000474e:	01 6a       	ORL       R0, R1
80004750:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004754:	08 00       	SYNC     SYNC     
80004756:	01 5d       	POP       R1
80004758:	00 5d       	POP       R0
8000475a:	20 5d       	PUSH      R0
8000475c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004760:	08 00       	SYNC     SYNC     
80004762:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004766:	08 00       	SYNC     SYNC     
80004768:	00 5d       	POP       R0
8000476a:	07 00       	BREAK    BREAK    
8000476c:	02 45       	LD        R5, [PC + #2]         ;->0x80004774  :=0x8000911c
8000476e:	05 5c       	LJMP      R5
80004770:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004774:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004778 <xStreamBufferReceive>:
##@@@F_:xStreamBufferReceive():
##@@@P_:stream_buffer.c:965
##@@@L0960_:
##@@@L0961_:size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,   
##@@@L0962_:                             void * pvRxData,   
##@@@L0963_:                             size_t xBufferLengthBytes,   
##@@@L0964_:                             TickType_t xTicksToWait )   
##@@@L0965_:{   
80004778:	9f 5f       	PUSH      {R6-R10,LR}
8000477a:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:stream_buffer.c:971
##@@@L0966_:    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0967_:    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;   
##@@@L0968_:
##@@@L0969_:    traceENTER_xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );   
##@@@L0970_:
##@@@L0971_:    configASSERT( pvRxData );   
8000477c:	10 38       	CMP       R1, #0			;->0x00
8000477e:	02 f1       	JNZ       $+2                   ;->0x80004782
80004780:	84 04       	SJMP      $+132                 ;->0x80004888
80004782:	c0 58       	MOV       R6, R0
##@@@P_:stream_buffer.c:972
##@@@L0972_:    configASSERT( pxStreamBuffer );   
80004784:	00 38       	CMP       R0, #0			;->0x00
80004786:	02 f1       	JNZ       $+2                   ;->0x8000478a
80004788:	a3 04       	SJMP      $+163                 ;->0x800048ce
8000478a:	41 59       	MOV       R10, R1
8000478c:	23 59       	MOV       R9, R3
8000478e:	02 59       	MOV       R8, R2
##@@@P_:stream_buffer.c:979
##@@@L0974_:    /* This receive function is used by both message buffers, which store   
##@@@L0975_:     * discrete messages, and stream buffers, which store a continuous stream of   
##@@@L0976_:     * bytes.  Discrete messages include an additional   
##@@@L0977_:     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the   
##@@@L0978_:     * message. */   
##@@@L0979_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004790:	a6 58       	MOV       R5, R6
80004792:	5c 29       	ADD       R5, #28			;->0x1C
80004794:	95 b8       	LDP.B     R2, [R5] << #2
80004796:	54 10       	MOV       R5, #4			;->0x0004
80004798:	25 69       	ANL       R2, R5
##@@@P_:stream_buffer.c:988
##@@@L0983_:    else   
##@@@L0984_:    {   
##@@@L0985_:        xBytesToStoreMessageLength = 0;   
##@@@L0986_:    }   
##@@@L0987_:
##@@@L0988_:    if( xTicksToWait != ( TickType_t ) 0 )   
8000479a:	30 38       	CMP       R3, #0			;->0x00
8000479c:	13 f0       	JZ        $+19                  ;->0x800047c2
8000479e:	01 22       	ST.W      [SP + #1], R2
##@@@P_:stream_buffer.c:992
##@@@L0989_:    {   
##@@@L0990_:        /* Checking if there is data and clearing the notification state must be   
##@@@L0991_:         * performed atomically. */   
##@@@L0992_:        taskENTER_CRITICAL();   
800047a0:	31 45       	LD        R5, [PC + #49]        ;->0x80004864  :=0x800056cc
800047a2:	05 5c       	LJMP      R5
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
800047a4:	ae 98       	LD.W      R5, [R6 + #2]
800047a6:	66 98       	LD.W      R4, [R6 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
800047a8:	36 82       	LD.W      R3, [R6]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
800047aa:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
800047ac:	e4 c6       	SUB       R4, R4, R3
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
800047ae:	45 70       	CMP       R4, R5
800047b0:	02 f2       	JC        $+2                   ;->0x800047b4
800047b2:	50 10       	MOV       R5, #0			;->0x0000
800047b4:	01 0b       	LD.W      R3, [SP + #1]
800047b6:	7c c7       	SUB       R7, R4, R5
##@@@F_:xStreamBufferReceive():
##@@@P_:stream_buffer.c:1001
##@@@L0996_:            /* If this function was invoked by a message buffer read then   
##@@@L0997_:             * xBytesToStoreMessageLength holds the number of bytes used to hold   
##@@@L0998_:             * the length of the next discrete message.  If this function was   
##@@@L0999_:             * invoked by a stream buffer read then xBytesToStoreMessageLength will   
##@@@L1000_:             * be 0. */   
##@@@L1001_:            if( xBytesAvailable <= xBytesToStoreMessageLength )   
800047b8:	73 70       	CMP       R7, R3
800047ba:	11 f9       	JLS       $+17                  ;->0x800047dc
##@@@P_:stream_buffer.c:1015
##@@@L1010_:            else   
##@@@L1011_:            {   
##@@@L1012_:                mtCOVERAGE_TEST_MARKER();   
##@@@L1013_:            }   
##@@@L1014_:        }   
##@@@L1015_:        taskEXIT_CRITICAL();   
800047bc:	2b 45       	LD        R5, [PC + #43]        ;->0x80004868  :=0x80005730
800047be:	05 5c       	LJMP      R5
800047c0:	2d 04       	SJMP      $+45                  ;->0x8000481a
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
800047c2:	ae 98       	LD.W      R5, [R6 + #2]
800047c4:	66 98       	LD.W      R4, [R6 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
800047c6:	36 82       	LD.W      R3, [R6]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
800047c8:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
800047ca:	e4 c6       	SUB       R4, R4, R3
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
800047cc:	45 70       	CMP       R4, R5
800047ce:	02 f2       	JC        $+2                   ;->0x800047d2
800047d0:	50 10       	MOV       R5, #0			;->0x0000
800047d2:	7c c7       	SUB       R7, R4, R5
##@@@F_:xStreamBufferReceive():
##@@@P_:stream_buffer.c:1042
##@@@L1037_:    /* Whether receiving a discrete message (where xBytesToStoreMessageLength   
##@@@L1038_:     * holds the number of bytes used to store the message length) or a stream of   
##@@@L1039_:     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes   
##@@@L1040_:     * available must be greater than xBytesToStoreMessageLength to be able to   
##@@@L1041_:     * read bytes from the buffer. */   
##@@@L1042_:    if( xBytesAvailable > xBytesToStoreMessageLength )   
800047d4:	72 70       	CMP       R7, R2
800047d6:	25 f8       	JHI       $+37                  ;->0x80004820
800047d8:	70 10       	MOV       R7, #0			;->0x0000
800047da:	40 04       	SJMP      $+64                  ;->0x8000485a
800047dc:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:stream_buffer.c:1004
##@@@L0999_:             * invoked by a stream buffer read then xBytesToStoreMessageLength will   
##@@@L1000_:             * be 0. */   
##@@@L1001_:            if( xBytesAvailable <= xBytesToStoreMessageLength )   
##@@@L1002_:            {   
##@@@L1003_:                /* Clear notification state as going to wait for data. */   
##@@@L1004_:                ( void ) xTaskNotifyStateClear( NULL );   
800047de:	07 58       	MOV       R0, R7
800047e0:	27 58       	MOV       R1, R7
800047e2:	23 45       	LD        R5, [PC + #35]        ;->0x8000486c  :=0x800084a0
800047e4:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1007
##@@@L1005_:
##@@@L1006_:                /* Should only be one reader. */   
##@@@L1007_:                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );   
800047e6:	2e 99       	LD.W      R5, [R6 + #4]
800047e8:	50 38       	CMP       R5, #0			;->0x00
800047ea:	02 f0       	JZ        $+2                   ;->0x800047ee
800047ec:	94 04       	SJMP      $+148                 ;->0x80004914
##@@@P_:stream_buffer.c:1008
##@@@L1008_:                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();   
800047ee:	21 45       	LD        R5, [PC + #33]        ;->0x80004870  :=0x80007610
800047f0:	05 5c       	LJMP      R5
800047f2:	30 a1       	ST.W      [R6 + #4], R0
##@@@P_:stream_buffer.c:1015
##@@@L1010_:            else   
##@@@L1011_:            {   
##@@@L1012_:                mtCOVERAGE_TEST_MARKER();   
##@@@L1013_:            }   
##@@@L1014_:        }   
##@@@L1015_:        taskEXIT_CRITICAL();   
800047f4:	1d 45       	LD        R5, [PC + #29]        ;->0x80004868  :=0x80005730
800047f6:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1021
##@@@L1016_:
##@@@L1017_:        if( xBytesAvailable <= xBytesToStoreMessageLength )   
##@@@L1018_:        {   
##@@@L1019_:            /* Wait for data to be available. */   
##@@@L1020_:            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );   
##@@@L1021_:            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );   
800047f8:	07 58       	MOV       R0, R7
800047fa:	27 58       	MOV       R1, R7
800047fc:	47 58       	MOV       R2, R7
800047fe:	67 58       	MOV       R3, R7
80004800:	89 58       	MOV       R4, R9
80004802:	1d 45       	LD        R5, [PC + #29]        ;->0x80004874  :=0x80007ce0
80004804:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1022
##@@@L1022_:            pxStreamBuffer->xTaskWaitingToReceive = NULL;   
80004806:	37 a1       	ST.W      [R6 + #4], R7
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004808:	ae 98       	LD.W      R5, [R6 + #2]
8000480a:	66 98       	LD.W      R4, [R6 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
8000480c:	36 82       	LD.W      R3, [R6]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
8000480e:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
80004810:	e4 c6       	SUB       R4, R4, R3
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
80004812:	45 70       	CMP       R4, R5
80004814:	02 f3       	JNC       $+2                   ;->0x80004818
80004816:	e5 58       	MOV       R7, R5
80004818:	fc c7       	SUB       R7, R4, R7
##@@@F_:xStreamBufferReceive():
8000481a:	01 0a       	LD.W      R2, [SP + #1]
##@@@P_:stream_buffer.c:1042
##@@@L1037_:    /* Whether receiving a discrete message (where xBytesToStoreMessageLength   
##@@@L1038_:     * holds the number of bytes used to store the message length) or a stream of   
##@@@L1039_:     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes   
##@@@L1040_:     * available must be greater than xBytesToStoreMessageLength to be able to   
##@@@L1041_:     * read bytes from the buffer. */   
##@@@L1042_:    if( xBytesAvailable > xBytesToStoreMessageLength )   
8000481c:	72 70       	CMP       R7, R2
8000481e:	dd f9       	JLS       $-35                  ;->0x800047d8
##@@@P_:stream_buffer.c:1044
##@@@L1043_:    {   
##@@@L1044_:        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );   
80004820:	06 58       	MOV       R0, R6
80004822:	2a 58       	MOV       R1, R10
80004824:	48 58       	MOV       R2, R8
80004826:	67 58       	MOV       R3, R7
80004828:	14 45       	LD        R5, [PC + #20]        ;->0x80004878  :=0x80004964
8000482a:	05 5c       	LJMP      R5
8000482c:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:stream_buffer.c:1047
##@@@L1045_:
##@@@L1046_:        /* Was a task waiting for space in the buffer? */   
##@@@L1047_:        if( xReceivedLength != ( size_t ) 0 )   
8000482e:	00 38       	CMP       R0, #0			;->0x00
80004830:	14 f0       	JZ        $+20                  ;->0x80004858
80004832:	e0 58       	MOV       R7, R0
80004834:	01 25       	ST.W      [SP + #1], R5
##@@@P_:stream_buffer.c:1050
##@@@L1048_:        {   
##@@@L1049_:            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );   
##@@@L1050_:            prvRECEIVE_COMPLETED( xStreamBuffer );   
80004836:	12 45       	LD        R5, [PC + #18]        ;->0x8000487c  :=0x800059b0
80004838:	05 5c       	LJMP      R5
8000483a:	6e 99       	LD.W      R5, [R6 + #5]
8000483c:	50 38       	CMP       R5, #0			;->0x00
8000483e:	0a f0       	JZ        $+10                  ;->0x80004852
80004840:	46 99       	LD.W      R0, [R6 + #5]
80004842:	01 09       	LD.W      R1, [SP + #1]
80004844:	41 58       	MOV       R2, R1
80004846:	61 58       	MOV       R3, R1
80004848:	81 58       	MOV       R4, R1
8000484a:	0e 45       	LD        R5, [PC + #14]        ;->0x80004880  :=0x80007e44
8000484c:	05 5c       	LJMP      R5
8000484e:	01 0d       	LD.W      R5, [SP + #1]
80004850:	75 a1       	ST.W      [R6 + #5], R5
80004852:	0d 45       	LD        R5, [PC + #13]        ;->0x80004884  :=0x80005a70
80004854:	05 5c       	LJMP      R5
80004856:	02 04       	SJMP      $+2                   ;->0x8000485a
80004858:	e5 58       	MOV       R7, R5
##@@@P_:stream_buffer.c:1065
##@@@L1060_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1061_:    }   
##@@@L1062_:
##@@@L1063_:    traceRETURN_xStreamBufferReceive( xReceivedLength );   
##@@@L1064_:
##@@@L1065_:    return xReceivedLength;   
8000485a:	07 58       	MOV       R0, R7
8000485c:	e8 28       	ADD       SP, #8			;->0x08
8000485e:	1f 5e       	POP       {R6-R10}
80004860:	0d 5d       	POP       LR
80004862:	1d 5c       	JMP       LR
80004864:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80004864
80004868:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80004868
8000486c:	a0 84 00 80 	.long     0x800084a0 ->-2147449696  [!!!@2@:ST.H      [R10], R0	@@: LD.B      R0, [R0]
80004870:	10 76 00 80 	.long     0x80007610 ->-2147453424  [!!!@2@:LD.B      R1, [R0++]	@@: LD.B      R0, [R0]
80004874:	e0 7c 00 80 	.long     0x80007ce0 ->-2147451680  [!!!@2@:LSR       R12, #8	@@: LD.B      R0, [R0]
80004878:	64 49 00 80 	.long     0x80004964 ->-2147464860  [!!!@2@:SET       R12, #20	@@: LD.B      R0, [R0]
8000487c:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80004880:	44 7e 00 80 	.long     0x80007e44 ->-2147451324  [!!!@2@:ROR       R8, #4	@@: LD.B      R0, [R0]
80004884:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:971
##@@@L0966_:    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L0967_:    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;   
##@@@L0968_:
##@@@L0969_:    traceENTER_xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );   
##@@@L0970_:
##@@@L0971_:    configASSERT( pvRxData );   
80004888:	20 5d       	PUSH      R0
8000488a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000488e:	08 00       	SYNC     SYNC     
80004890:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004894:	08 00       	SYNC     SYNC     
80004896:	00 5d       	POP       R0
80004898:	20 5d       	PUSH      R0
8000489a:	21 5d       	PUSH      R1
8000489c:	30 45       	LD        R5, [PC + #48]        ;->0x8000495c  :=0x1ff
8000489e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800048a2:	25 58       	MOV       R1, R5
800048a4:	11 68       	NOT       R1, R1
800048a6:	01 69       	ANL       R0, R1
800048a8:	5f 11       	MOV       R5, #31			;->0x001F
800048aa:	25 58       	MOV       R1, R5
800048ac:	01 6a       	ORL       R0, R1
800048ae:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800048b2:	08 00       	SYNC     SYNC     
800048b4:	01 5d       	POP       R1
800048b6:	00 5d       	POP       R0
800048b8:	20 5d       	PUSH      R0
800048ba:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800048be:	08 00       	SYNC     SYNC     
800048c0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800048c4:	08 00       	SYNC     SYNC     
800048c6:	00 5d       	POP       R0
800048c8:	07 00       	BREAK    BREAK    
800048ca:	26 45       	LD        R5, [PC + #38]        ;->0x80004960  :=0x8000911c
800048cc:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:972
##@@@L0972_:    configASSERT( pxStreamBuffer );   
800048ce:	20 5d       	PUSH      R0
800048d0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800048d4:	08 00       	SYNC     SYNC     
800048d6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800048da:	08 00       	SYNC     SYNC     
800048dc:	00 5d       	POP       R0
800048de:	20 5d       	PUSH      R0
800048e0:	21 5d       	PUSH      R1
800048e2:	1f 45       	LD        R5, [PC + #31]        ;->0x8000495c  :=0x1ff
800048e4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800048e8:	25 58       	MOV       R1, R5
800048ea:	11 68       	NOT       R1, R1
800048ec:	01 69       	ANL       R0, R1
800048ee:	5f 11       	MOV       R5, #31			;->0x001F
800048f0:	25 58       	MOV       R1, R5
800048f2:	01 6a       	ORL       R0, R1
800048f4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800048f8:	08 00       	SYNC     SYNC     
800048fa:	01 5d       	POP       R1
800048fc:	00 5d       	POP       R0
800048fe:	20 5d       	PUSH      R0
80004900:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004904:	08 00       	SYNC     SYNC     
80004906:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000490a:	08 00       	SYNC     SYNC     
8000490c:	00 5d       	POP       R0
8000490e:	07 00       	BREAK    BREAK    
80004910:	14 45       	LD        R5, [PC + #20]        ;->0x80004960  :=0x8000911c
80004912:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1007
##@@@L1002_:            {   
##@@@L1003_:                /* Clear notification state as going to wait for data. */   
##@@@L1004_:                ( void ) xTaskNotifyStateClear( NULL );   
##@@@L1005_:
##@@@L1006_:                /* Should only be one reader. */   
##@@@L1007_:                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );   
80004914:	20 5d       	PUSH      R0
80004916:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000491a:	08 00       	SYNC     SYNC     
8000491c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004920:	08 00       	SYNC     SYNC     
80004922:	00 5d       	POP       R0
80004924:	20 5d       	PUSH      R0
80004926:	21 5d       	PUSH      R1
80004928:	0d 45       	LD        R5, [PC + #13]        ;->0x8000495c  :=0x1ff
8000492a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000492e:	25 58       	MOV       R1, R5
80004930:	11 68       	NOT       R1, R1
80004932:	01 69       	ANL       R0, R1
80004934:	5f 11       	MOV       R5, #31			;->0x001F
80004936:	25 58       	MOV       R1, R5
80004938:	01 6a       	ORL       R0, R1
8000493a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000493e:	08 00       	SYNC     SYNC     
80004940:	01 5d       	POP       R1
80004942:	00 5d       	POP       R0
80004944:	20 5d       	PUSH      R0
80004946:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000494a:	08 00       	SYNC     SYNC     
8000494c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004950:	08 00       	SYNC     SYNC     
80004952:	00 5d       	POP       R0
80004954:	07 00       	BREAK    BREAK    
80004956:	03 45       	LD        R5, [PC + #3]         ;->0x80004960  :=0x8000911c
80004958:	05 5c       	LJMP      R5
8000495a:	00 00       	NOP      NOP      
8000495c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004960:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004964 <prvReadMessageFromBuffer>:
##@@@F_:prvReadMessageFromBuffer():
##@@@P_:stream_buffer.c:1177
##@@@L1172_:
##@@@L1173_:static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,   
##@@@L1174_:                                        void * pvRxData,   
##@@@L1175_:                                        size_t xBufferLengthBytes,   
##@@@L1176_:                                        size_t xBytesAvailable )   
##@@@L1177_:{   
80004964:	87 5f       	PUSH      {R6-R8,LR}
80004966:	e0 32       	SUB       SP, #32			;->0x20
##@@@P_:stream_buffer.c:1182
##@@@L1178_:    size_t xCount, xNextMessageLength;   
##@@@L1179_:    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;   
##@@@L1180_:    size_t xNextTail = pxStreamBuffer->xTail;   
##@@@L1181_:
##@@@L1182_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004968:	28 8f       	LD.B      R5, [R0 + #28]
8000496a:	41 10       	MOV       R4, #1			;->0x0001
8000496c:	54 69       	ANL       R5, R4
##@@@P_:stream_buffer.c:1180
##@@@L1175_:                                        size_t xBufferLengthBytes,   
##@@@L1176_:                                        size_t xBytesAvailable )   
##@@@L1177_:{   
##@@@L1178_:    size_t xCount, xNextMessageLength;   
##@@@L1179_:    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;   
##@@@L1180_:    size_t xNextTail = pxStreamBuffer->xTail;   
8000496e:	40 82       	LD.W      R4, [R0]
##@@@P_:stream_buffer.c:1182
##@@@L1181_:
##@@@L1182_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004970:	50 38       	CMP       R5, #0			;->0x00
80004972:	02 59       	MOV       R8, R2
80004974:	06 20       	ST.W      [SP + #6], R0
80004976:	04 21       	ST.W      [SP + #4], R1
80004978:	36 f1       	JNZ       $+54                  ;->0x800049e4
8000497a:	41 58       	MOV       R2, R1
8000497c:	e8 58       	MOV       R7, R8
##@@@P_:stream_buffer.c:1213
##@@@L1208_:         * message), so read as many bytes as possible. */   
##@@@L1209_:        xNextMessageLength = xBufferLengthBytes;   
##@@@L1210_:    }   
##@@@L1211_:
##@@@L1212_:    /* Use the minimum of the wanted bytes and the available bytes. */   
##@@@L1213_:    xCount = configMIN( xNextMessageLength, xBytesAvailable );   
8000497e:	73 70       	CMP       R7, R3
80004980:	02 f3       	JNC       $+2                   ;->0x80004984
80004982:	e3 58       	MOV       R7, R3
##@@@P_:stream_buffer.c:1215
##@@@L1214_:
##@@@L1215_:    if( xCount != ( size_t ) 0 )   
80004984:	70 38       	CMP       R7, #0			;->0x00
80004986:	27 f0       	JZ        $+39                  ;->0x800049d4
##@@@F_:prvReadBytesFromBuffer():
##@@@P_:stream_buffer.c:1423
##@@@L1418_:    configASSERT( xCount != ( size_t ) 0 );   
##@@@L1419_:
##@@@L1420_:    /* Calculate the number of bytes that can be read - which may be   
##@@@L1421_:     * less than the number wanted if the data wraps around to the start of   
##@@@L1422_:     * the buffer. */   
##@@@L1423_:    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );   
80004988:	a8 98       	LD.W      R5, [R0 + #2]
8000498a:	1d c7       	SUB       R3, R5, R4
8000498c:	c3 58       	MOV       R6, R3
8000498e:	03 23       	ST.W      [SP + #3], R3
80004990:	37 70       	CMP       R3, R7
80004992:	02 f3       	JNC       $+2                   ;->0x80004996
80004994:	c7 58       	MOV       R6, R7
80004996:	64 58       	MOV       R3, R4
##@@@P_:stream_buffer.c:1428
##@@@L1424_:
##@@@L1425_:    /* Obtain the number of bytes it is possible to obtain in the first   
##@@@L1426_:     * read.  Asserts check bounds of read and write. */   
##@@@L1427_:    configASSERT( xFirstLength <= xCount );   
##@@@L1428_:    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );   
80004998:	26 c3       	ADD       R4, R6, R4
8000499a:	45 70       	CMP       R4, R5
8000499c:	02 f9       	JLS       $+2                   ;->0x800049a0
8000499e:	55 04       	SJMP      $+85                  ;->0x80004a48
##@@@P_:stream_buffer.c:1429
##@@@L1429_:    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength );   
800049a0:	a8 99       	LD.W      R5, [R0 + #6]
800049a2:	05 23       	ST.W      [SP + #5], R3
800049a4:	cd c2       	ADD       R1, R5, R3
800049a6:	02 58       	MOV       R0, R2
800049a8:	46 58       	MOV       R2, R6
800049aa:	0e 45       	LD        R5, [PC + #14]        ;->0x800049e0  :=0x8000d9ec
800049ac:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1433
##@@@L1430_:
##@@@L1431_:    /* If the total number of wanted bytes is greater than the number   
##@@@L1432_:     * that could be read in the first read... */   
##@@@L1433_:    if( xCount > xFirstLength )   
800049ae:	03 0d       	LD.W      R5, [SP + #3]
800049b0:	57 70       	CMP       R5, R7
800049b2:	08 f2       	JC        $+8                   ;->0x800049c2
##@@@P_:stream_buffer.c:1436
##@@@L1434_:    {   
##@@@L1435_:        /* ...then read the remaining bytes from the start of the buffer. */   
##@@@L1436_:        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength );   
800049b4:	04 0d       	LD.W      R5, [SP + #4]
800049b6:	85 c3       	ADD       R0, R5, R6
800049b8:	06 0d       	LD.W      R5, [SP + #6]
800049ba:	8d 99       	LD.W      R1, [R5 + #6]
800049bc:	97 c7       	SUB       R2, R7, R6
800049be:	09 45       	LD        R5, [PC + #9]         ;->0x800049e0  :=0x8000d9ec
800049c0:	05 5c       	LJMP      R5
800049c2:	06 0b       	LD.W      R3, [SP + #6]
##@@@P_:stream_buffer.c:1446
##@@@L1441_:    }   
##@@@L1442_:
##@@@L1443_:    /* Move the tail pointer to effectively remove the data read from the buffer. */   
##@@@L1444_:    xTail += xCount;   
##@@@L1445_:
##@@@L1446_:    if( xTail >= pxStreamBuffer->xLength )   
800049c4:	a3 98       	LD.W      R4, [R3 + #2]
##@@@P_:stream_buffer.c:1444
##@@@L1439_:    {   
##@@@L1440_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1441_:    }   
##@@@L1442_:
##@@@L1443_:    /* Move the tail pointer to effectively remove the data read from the buffer. */   
##@@@L1444_:    xTail += xCount;   
800049c6:	05 0d       	LD.W      R5, [SP + #5]
800049c8:	6f c3       	ADD       R5, R7, R5
##@@@P_:stream_buffer.c:1446
##@@@L1445_:
##@@@L1446_:    if( xTail >= pxStreamBuffer->xLength )   
800049ca:	54 70       	CMP       R5, R4
800049cc:	02 f2       	JC        $+2                   ;->0x800049d0
800049ce:	40 10       	MOV       R4, #0			;->0x0000
800049d0:	2d c7       	SUB       R5, R5, R4
##@@@F_:prvReadMessageFromBuffer():
##@@@P_:stream_buffer.c:1221
##@@@L1216_:    {   
##@@@L1217_:        /* Read the actual data and update the tail to mark the data as officially consumed. */   
##@@@L1218_:        /* MISRA Ref 11.5.5 [Void pointer assignment] */   
##@@@L1219_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L1220_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L1221_:        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail );   
800049d2:	35 85       	ST.W      [R3], R5
##@@@P_:stream_buffer.c:1224
##@@@L1222_:    }   
##@@@L1223_:
##@@@L1224_:    return xCount;   
800049d4:	07 58       	MOV       R0, R7
800049d6:	e0 2a       	ADD       SP, #32			;->0x20
800049d8:	07 5e       	POP       {R6-R8}
800049da:	0d 5d       	POP       LR
800049dc:	1d 5c       	JMP       LR
800049de:	00 00       	NOP      NOP      
800049e0:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
##@@@F_:prvReadBytesFromBuffer():
##@@@P_:stream_buffer.c:1423
##@@@L1418_:    configASSERT( xCount != ( size_t ) 0 );   
##@@@L1419_:
##@@@L1420_:    /* Calculate the number of bytes that can be read - which may be   
##@@@L1421_:     * less than the number wanted if the data wraps around to the start of   
##@@@L1422_:     * the buffer. */   
##@@@L1423_:    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );   
800049e4:	88 98       	LD.W      R1, [R0 + #2]
800049e6:	31 c7       	SUB       R6, R1, R4
800049e8:	e6 58       	MOV       R7, R6
800049ea:	64 38       	CMP       R6, #4			;->0x04
800049ec:	02 f3       	JNC       $+2                   ;->0x800049f0
800049ee:	74 10       	MOV       R7, #4			;->0x0004
800049f0:	03 23       	ST.W      [SP + #3], R3
##@@@P_:stream_buffer.c:1428
##@@@L1424_:
##@@@L1425_:    /* Obtain the number of bytes it is possible to obtain in the first   
##@@@L1426_:     * read.  Asserts check bounds of read and write. */   
##@@@L1427_:    configASSERT( xFirstLength <= xCount );   
##@@@L1428_:    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );   
800049f2:	2f c3       	ADD       R5, R7, R4
800049f4:	02 21       	ST.W      [SP + #2], R1
800049f6:	51 70       	CMP       R5, R1
800049f8:	4b f8       	JHI       $+75                  ;->0x80004a8e
##@@@P_:stream_buffer.c:1429
##@@@L1429_:    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength );   
800049fa:	a8 99       	LD.W      R5, [R0 + #6]
800049fc:	05 24       	ST.W      [SP + #5], R4
800049fe:	01 25       	ST.W      [SP + #1], R5
80004a00:	0d c3       	ADD       R1, R5, R4
80004a02:	35 40       	LD        R0, [PC + #53]        ;->0x80004ad4  :=0x1c
80004a04:	0e 64       	ADD       R0, SP
80004a06:	47 58       	MOV       R2, R7
80004a08:	34 45       	LD        R5, [PC + #52]        ;->0x80004ad8  :=0x8000d9ec
80004a0a:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1433
##@@@L1430_:
##@@@L1431_:    /* If the total number of wanted bytes is greater than the number   
##@@@L1432_:     * that could be read in the first read... */   
##@@@L1433_:    if( xCount > xFirstLength )   
80004a0c:	63 38       	CMP       R6, #3			;->0x03
80004a0e:	09 f8       	JHI       $+9                   ;->0x80004a20
80004a10:	31 45       	LD        R5, [PC + #49]        ;->0x80004ad4  :=0x1c
80004a12:	5e 64       	ADD       R5, SP
##@@@P_:stream_buffer.c:1436
##@@@L1434_:    {   
##@@@L1435_:        /* ...then read the remaining bytes from the start of the buffer. */   
##@@@L1436_:        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength );   
80004a14:	c5 c3       	ADD       R0, R5, R7
80004a16:	54 10       	MOV       R5, #4			;->0x0004
80004a18:	d5 c7       	SUB       R2, R5, R7
80004a1a:	01 09       	LD.W      R1, [SP + #1]
80004a1c:	2f 45       	LD        R5, [PC + #47]        ;->0x80004ad8  :=0x8000d9ec
80004a1e:	05 5c       	LJMP      R5
##@@@F_:prvReadMessageFromBuffer():
##@@@P_:stream_buffer.c:1187
##@@@L1182_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
##@@@L1183_:    {   
##@@@L1184_:        /* A discrete message is being received.  First receive the length   
##@@@L1185_:         * of the message. */   
##@@@L1186_:        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );   
##@@@L1187_:        xNextMessageLength = ( size_t ) xTempNextMessageLength;   
80004a20:	07 0c       	LD.W      R4, [SP + #7]
80004a22:	50 10       	MOV       R5, #0			;->0x0000
80004a24:	e5 58       	MOV       R7, R5
80004a26:	02 09       	LD.W      R1, [SP + #2]
##@@@P_:stream_buffer.c:1195
##@@@L1190_:         * read out. */   
##@@@L1191_:        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;   
##@@@L1192_:
##@@@L1193_:        /* Check there is enough space in the buffer provided by the   
##@@@L1194_:         * user. */   
##@@@L1195_:        if( xNextMessageLength > xBufferLengthBytes )   
80004a28:	48 70       	CMP       R4, R8
80004a2a:	02 f8       	JHI       $+2                   ;->0x80004a2e
80004a2c:	e4 58       	MOV       R7, R4
##@@@F_:prvReadBytesFromBuffer():
##@@@P_:stream_buffer.c:1444
##@@@L1439_:    {   
##@@@L1440_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1441_:    }   
##@@@L1442_:
##@@@L1443_:    /* Move the tail pointer to effectively remove the data read from the buffer. */   
##@@@L1444_:    xTail += xCount;   
80004a2e:	05 0c       	LD.W      R4, [SP + #5]
80004a30:	24 c1       	ADD       R4, R4, #4
80004a32:	06 08       	LD.W      R0, [SP + #6]
80004a34:	04 0a       	LD.W      R2, [SP + #4]
80004a36:	03 0b       	LD.W      R3, [SP + #3]
##@@@P_:stream_buffer.c:1446
##@@@L1445_:
##@@@L1446_:    if( xTail >= pxStreamBuffer->xLength )   
80004a38:	41 70       	CMP       R4, R1
80004a3a:	02 f3       	JNC       $+2                   ;->0x80004a3e
80004a3c:	a1 58       	MOV       R5, R1
80004a3e:	64 c7       	SUB       R4, R4, R5
##@@@F_:prvReadMessageFromBuffer():
##@@@P_:stream_buffer.c:1191
##@@@L1186_:        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );   
##@@@L1187_:        xNextMessageLength = ( size_t ) xTempNextMessageLength;   
##@@@L1188_:
##@@@L1189_:        /* Reduce the number of bytes available by the number of bytes just   
##@@@L1190_:         * read out. */   
##@@@L1191_:        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;   
80004a40:	1b cd       	SUB       R3, R3, #4
##@@@P_:stream_buffer.c:1213
##@@@L1208_:         * message), so read as many bytes as possible. */   
##@@@L1209_:        xNextMessageLength = xBufferLengthBytes;   
##@@@L1210_:    }   
##@@@L1211_:
##@@@L1212_:    /* Use the minimum of the wanted bytes and the available bytes. */   
##@@@L1213_:    xCount = configMIN( xNextMessageLength, xBytesAvailable );   
80004a42:	73 70       	CMP       R7, R3
80004a44:	9f f2       	JC        $-97                  ;->0x80004982
80004a46:	9f 07       	SJMP      $-97                  ;->0x80004984
##@@@F_:prvReadBytesFromBuffer():
##@@@P_:stream_buffer.c:1428
##@@@L1423_:    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );   
##@@@L1424_:
##@@@L1425_:    /* Obtain the number of bytes it is possible to obtain in the first   
##@@@L1426_:     * read.  Asserts check bounds of read and write. */   
##@@@L1427_:    configASSERT( xFirstLength <= xCount );   
##@@@L1428_:    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );   
80004a48:	20 5d       	PUSH      R0
80004a4a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004a4e:	08 00       	SYNC     SYNC     
80004a50:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004a54:	08 00       	SYNC     SYNC     
80004a56:	00 5d       	POP       R0
80004a58:	20 5d       	PUSH      R0
80004a5a:	21 5d       	PUSH      R1
80004a5c:	20 45       	LD        R5, [PC + #32]        ;->0x80004adc  :=0x1ff
80004a5e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004a62:	25 58       	MOV       R1, R5
80004a64:	11 68       	NOT       R1, R1
80004a66:	01 69       	ANL       R0, R1
80004a68:	5f 11       	MOV       R5, #31			;->0x001F
80004a6a:	25 58       	MOV       R1, R5
80004a6c:	01 6a       	ORL       R0, R1
80004a6e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004a72:	08 00       	SYNC     SYNC     
80004a74:	01 5d       	POP       R1
80004a76:	00 5d       	POP       R0
80004a78:	20 5d       	PUSH      R0
80004a7a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004a7e:	08 00       	SYNC     SYNC     
80004a80:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004a84:	08 00       	SYNC     SYNC     
80004a86:	00 5d       	POP       R0
80004a88:	07 00       	BREAK    BREAK    
80004a8a:	16 45       	LD        R5, [PC + #22]        ;->0x80004ae0  :=0x8000911c
80004a8c:	05 5c       	LJMP      R5
80004a8e:	20 5d       	PUSH      R0
80004a90:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004a94:	08 00       	SYNC     SYNC     
80004a96:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004a9a:	08 00       	SYNC     SYNC     
80004a9c:	00 5d       	POP       R0
80004a9e:	20 5d       	PUSH      R0
80004aa0:	21 5d       	PUSH      R1
80004aa2:	0f 45       	LD        R5, [PC + #15]        ;->0x80004adc  :=0x1ff
80004aa4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004aa8:	25 58       	MOV       R1, R5
80004aaa:	11 68       	NOT       R1, R1
80004aac:	01 69       	ANL       R0, R1
80004aae:	5f 11       	MOV       R5, #31			;->0x001F
80004ab0:	25 58       	MOV       R1, R5
80004ab2:	01 6a       	ORL       R0, R1
80004ab4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004ab8:	08 00       	SYNC     SYNC     
80004aba:	01 5d       	POP       R1
80004abc:	00 5d       	POP       R0
80004abe:	20 5d       	PUSH      R0
80004ac0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004ac4:	08 00       	SYNC     SYNC     
80004ac6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004aca:	08 00       	SYNC     SYNC     
80004acc:	00 5d       	POP       R0
80004ace:	07 00       	BREAK    BREAK    
80004ad0:	04 45       	LD        R5, [PC + #4]         ;->0x80004ae0  :=0x8000911c
80004ad2:	05 5c       	LJMP      R5
##@@@F_:prvReadMessageFromBuffer():
80004ad4:	1c 00 00 00 	.long     0x0000001c ->000000028  [!!!@4@:DMAC16LL  ACC0, R0, R0
80004ad8:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
80004adc:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004ae0:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004ae4 <xStreamBufferNextMessageLengthBytes>:
##@@@F_:xStreamBufferNextMessageLengthBytes():
##@@@P_:stream_buffer.c:1070
##@@@L1065_:    return xReceivedLength;   
##@@@L1066_:}   
##@@@L1067_:/*-----------------------------------------------------------*/   
##@@@L1068_:
##@@@L1069_:size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )   
##@@@L1070_:{   
80004ae4:	83 5f       	PUSH      {R6-R7,LR}
80004ae6:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:stream_buffer.c:1077
##@@@L1072_:    size_t xReturn, xBytesAvailable;   
##@@@L1073_:    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;   
##@@@L1074_:
##@@@L1075_:    traceENTER_xStreamBufferNextMessageLengthBytes( xStreamBuffer );   
##@@@L1076_:
##@@@L1077_:    configASSERT( pxStreamBuffer );   
80004ae8:	00 38       	CMP       R0, #0			;->0x00
80004aea:	3b f0       	JZ        $+59                  ;->0x80004b60
##@@@P_:stream_buffer.c:1080
##@@@L1078_:
##@@@L1079_:    /* Ensure the stream buffer is being used as a message buffer. */   
##@@@L1080_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004aec:	20 8f       	LD.B      R4, [R0 + #28]
80004aee:	51 10       	MOV       R5, #1			;->0x0001
80004af0:	45 69       	ANL       R4, R5
80004af2:	50 10       	MOV       R5, #0			;->0x0000
80004af4:	40 38       	CMP       R4, #0			;->0x00
80004af6:	2c f0       	JZ        $+44                  ;->0x80004b4e
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004af8:	a0 98       	LD.W      R4, [R0 + #2]
80004afa:	58 98       	LD.W      R3, [R0 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
80004afc:	20 82       	LD.W      R2, [R0]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004afe:	1b c3       	ADD       R3, R3, R4
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
80004b00:	9b c6       	SUB       R3, R3, R2
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
80004b02:	34 70       	CMP       R3, R4
80004b04:	02 f3       	JNC       $+2                   ;->0x80004b08
80004b06:	a4 58       	MOV       R5, R4
80004b08:	6b c7       	SUB       R5, R3, R5
##@@@F_:xStreamBufferNextMessageLengthBytes():
##@@@P_:stream_buffer.c:1084
##@@@L1079_:    /* Ensure the stream buffer is being used as a message buffer. */   
##@@@L1080_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
##@@@L1081_:    {   
##@@@L1082_:        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );   
##@@@L1083_:
##@@@L1084_:        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )   
80004b0a:	55 38       	CMP       R5, #5			;->0x05
80004b0c:	1e f3       	JNC       $+30                  ;->0x80004b48
##@@@P_:stream_buffer.c:1089
##@@@L1085_:        {   
##@@@L1086_:            /* The number of bytes available is greater than the number of bytes   
##@@@L1087_:             * required to hold the length of the next message, so another message   
##@@@L1088_:             * is available. */   
##@@@L1089_:            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );   
80004b0e:	50 82       	LD.W      R5, [R0]
##@@@F_:prvReadBytesFromBuffer():
##@@@P_:stream_buffer.c:1423
##@@@L1418_:    configASSERT( xCount != ( size_t ) 0 );   
##@@@L1419_:
##@@@L1420_:    /* Calculate the number of bytes that can be read - which may be   
##@@@L1421_:     * less than the number wanted if the data wraps around to the start of   
##@@@L1422_:     * the buffer. */   
##@@@L1423_:    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );   
80004b10:	7c c7       	SUB       R7, R4, R5
80004b12:	c7 58       	MOV       R6, R7
80004b14:	74 38       	CMP       R7, #4			;->0x04
80004b16:	02 f3       	JNC       $+2                   ;->0x80004b1a
80004b18:	64 10       	MOV       R6, #4			;->0x0004
##@@@P_:stream_buffer.c:1428
##@@@L1424_:
##@@@L1425_:    /* Obtain the number of bytes it is possible to obtain in the first   
##@@@L1426_:     * read.  Asserts check bounds of read and write. */   
##@@@L1427_:    configASSERT( xFirstLength <= xCount );   
##@@@L1428_:    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );   
80004b1a:	5e c3       	ADD       R3, R6, R5
80004b1c:	34 70       	CMP       R3, R4
80004b1e:	44 f8       	JHI       $+68                  ;->0x80004ba6
##@@@P_:stream_buffer.c:1429
##@@@L1429_:    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength );   
80004b20:	a0 99       	LD.W      R4, [R0 + #6]
80004b22:	01 24       	ST.W      [SP + #1], R4
80004b24:	4c c3       	ADD       R1, R4, R5
80004b26:	0d 40       	LD        R0, [PC + #13]        ;->0x80004b58  :=0x8
80004b28:	0e 64       	ADD       R0, SP
80004b2a:	46 58       	MOV       R2, R6
80004b2c:	0c 45       	LD        R5, [PC + #12]        ;->0x80004b5c  :=0x8000d9ec
80004b2e:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1433
##@@@L1430_:
##@@@L1431_:    /* If the total number of wanted bytes is greater than the number   
##@@@L1432_:     * that could be read in the first read... */   
##@@@L1433_:    if( xCount > xFirstLength )   
80004b30:	73 38       	CMP       R7, #3			;->0x03
80004b32:	09 f8       	JHI       $+9                   ;->0x80004b44
80004b34:	09 45       	LD        R5, [PC + #9]         ;->0x80004b58  :=0x8
80004b36:	5e 64       	ADD       R5, SP
##@@@P_:stream_buffer.c:1436
##@@@L1434_:    {   
##@@@L1435_:        /* ...then read the remaining bytes from the start of the buffer. */   
##@@@L1436_:        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength );   
80004b38:	85 c3       	ADD       R0, R5, R6
80004b3a:	54 10       	MOV       R5, #4			;->0x0004
80004b3c:	95 c7       	SUB       R2, R5, R6
80004b3e:	01 09       	LD.W      R1, [SP + #1]
80004b40:	07 45       	LD        R5, [PC + #7]         ;->0x80004b5c  :=0x8000d9ec
80004b42:	05 5c       	LJMP      R5
##@@@F_:xStreamBufferNextMessageLengthBytes():
##@@@P_:stream_buffer.c:1090
##@@@L1085_:        {   
##@@@L1086_:            /* The number of bytes available is greater than the number of bytes   
##@@@L1087_:             * required to hold the length of the next message, so another message   
##@@@L1088_:             * is available. */   
##@@@L1089_:            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );   
##@@@L1090_:            xReturn = ( size_t ) xTempReturn;   
80004b44:	02 0d       	LD.W      R5, [SP + #2]
80004b46:	04 04       	SJMP      $+4                   ;->0x80004b4e
##@@@P_:stream_buffer.c:1098
##@@@L1093_:        {   
##@@@L1094_:            /* The minimum amount of bytes in a message buffer is   
##@@@L1095_:             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is   
##@@@L1096_:             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid   
##@@@L1097_:             * value is 0. */   
##@@@L1098_:            configASSERT( xBytesAvailable == 0 );   
80004b48:	50 38       	CMP       R5, #0			;->0x00
80004b4a:	51 f1       	JNZ       $+81                  ;->0x80004bec
80004b4c:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:stream_buffer.c:1109
##@@@L1104_:        xReturn = 0;   
##@@@L1105_:    }   
##@@@L1106_:
##@@@L1107_:    traceRETURN_xStreamBufferNextMessageLengthBytes( xReturn );   
##@@@L1108_:
##@@@L1109_:    return xReturn;   
80004b4e:	05 58       	MOV       R0, R5
80004b50:	ec 28       	ADD       SP, #12			;->0x0C
80004b52:	03 5e       	POP       {R6-R7}
80004b54:	0d 5d       	POP       LR
80004b56:	1d 5c       	JMP       LR
80004b58:	08 00 00 00 	.long     0x00000008 ->000000008  [!!!@2@:SYNC     	@@: NOP      
80004b5c:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:1077
##@@@L1072_:    size_t xReturn, xBytesAvailable;   
##@@@L1073_:    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;   
##@@@L1074_:
##@@@L1075_:    traceENTER_xStreamBufferNextMessageLengthBytes( xStreamBuffer );   
##@@@L1076_:
##@@@L1077_:    configASSERT( pxStreamBuffer );   
80004b60:	20 5d       	PUSH      R0
80004b62:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004b66:	08 00       	SYNC     SYNC     
80004b68:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004b6c:	08 00       	SYNC     SYNC     
80004b6e:	00 5d       	POP       R0
80004b70:	20 5d       	PUSH      R0
80004b72:	21 5d       	PUSH      R1
80004b74:	30 45       	LD        R5, [PC + #48]        ;->0x80004c34  :=0x1ff
80004b76:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004b7a:	25 58       	MOV       R1, R5
80004b7c:	11 68       	NOT       R1, R1
80004b7e:	01 69       	ANL       R0, R1
80004b80:	5f 11       	MOV       R5, #31			;->0x001F
80004b82:	25 58       	MOV       R1, R5
80004b84:	01 6a       	ORL       R0, R1
80004b86:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004b8a:	08 00       	SYNC     SYNC     
80004b8c:	01 5d       	POP       R1
80004b8e:	00 5d       	POP       R0
80004b90:	20 5d       	PUSH      R0
80004b92:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004b96:	08 00       	SYNC     SYNC     
80004b98:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004b9c:	08 00       	SYNC     SYNC     
80004b9e:	00 5d       	POP       R0
80004ba0:	07 00       	BREAK    BREAK    
80004ba2:	26 45       	LD        R5, [PC + #38]        ;->0x80004c38  :=0x8000911c
80004ba4:	05 5c       	LJMP      R5
##@@@F_:prvReadBytesFromBuffer():
##@@@P_:stream_buffer.c:1428
##@@@L1423_:    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );   
##@@@L1424_:
##@@@L1425_:    /* Obtain the number of bytes it is possible to obtain in the first   
##@@@L1426_:     * read.  Asserts check bounds of read and write. */   
##@@@L1427_:    configASSERT( xFirstLength <= xCount );   
##@@@L1428_:    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );   
80004ba6:	20 5d       	PUSH      R0
80004ba8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004bac:	08 00       	SYNC     SYNC     
80004bae:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004bb2:	08 00       	SYNC     SYNC     
80004bb4:	00 5d       	POP       R0
80004bb6:	20 5d       	PUSH      R0
80004bb8:	21 5d       	PUSH      R1
80004bba:	1f 45       	LD        R5, [PC + #31]        ;->0x80004c34  :=0x1ff
80004bbc:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004bc0:	25 58       	MOV       R1, R5
80004bc2:	11 68       	NOT       R1, R1
80004bc4:	01 69       	ANL       R0, R1
80004bc6:	5f 11       	MOV       R5, #31			;->0x001F
80004bc8:	25 58       	MOV       R1, R5
80004bca:	01 6a       	ORL       R0, R1
80004bcc:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004bd0:	08 00       	SYNC     SYNC     
80004bd2:	01 5d       	POP       R1
80004bd4:	00 5d       	POP       R0
80004bd6:	20 5d       	PUSH      R0
80004bd8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004bdc:	08 00       	SYNC     SYNC     
80004bde:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004be2:	08 00       	SYNC     SYNC     
80004be4:	00 5d       	POP       R0
80004be6:	07 00       	BREAK    BREAK    
80004be8:	14 45       	LD        R5, [PC + #20]        ;->0x80004c38  :=0x8000911c
80004bea:	05 5c       	LJMP      R5
##@@@F_:xStreamBufferNextMessageLengthBytes():
##@@@P_:stream_buffer.c:1098
##@@@L1093_:        {   
##@@@L1094_:            /* The minimum amount of bytes in a message buffer is   
##@@@L1095_:             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is   
##@@@L1096_:             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid   
##@@@L1097_:             * value is 0. */   
##@@@L1098_:            configASSERT( xBytesAvailable == 0 );   
80004bec:	20 5d       	PUSH      R0
80004bee:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004bf2:	08 00       	SYNC     SYNC     
80004bf4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004bf8:	08 00       	SYNC     SYNC     
80004bfa:	00 5d       	POP       R0
80004bfc:	20 5d       	PUSH      R0
80004bfe:	21 5d       	PUSH      R1
80004c00:	0d 45       	LD        R5, [PC + #13]        ;->0x80004c34  :=0x1ff
80004c02:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004c06:	25 58       	MOV       R1, R5
80004c08:	11 68       	NOT       R1, R1
80004c0a:	01 69       	ANL       R0, R1
80004c0c:	5f 11       	MOV       R5, #31			;->0x001F
80004c0e:	25 58       	MOV       R1, R5
80004c10:	01 6a       	ORL       R0, R1
80004c12:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004c16:	08 00       	SYNC     SYNC     
80004c18:	01 5d       	POP       R1
80004c1a:	00 5d       	POP       R0
80004c1c:	20 5d       	PUSH      R0
80004c1e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004c22:	08 00       	SYNC     SYNC     
80004c24:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004c28:	08 00       	SYNC     SYNC     
80004c2a:	00 5d       	POP       R0
80004c2c:	07 00       	BREAK    BREAK    
80004c2e:	03 45       	LD        R5, [PC + #3]         ;->0x80004c38  :=0x8000911c
80004c30:	05 5c       	LJMP      R5
80004c32:	00 00       	NOP      NOP      
80004c34:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004c38:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004c3c <xStreamBufferReceiveFromISR>:
##@@@F_:xStreamBufferReceiveFromISR():
##@@@P_:stream_buffer.c:1117
##@@@L1112_:
##@@@L1113_:size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,   
##@@@L1114_:                                    void * pvRxData,   
##@@@L1115_:                                    size_t xBufferLengthBytes,   
##@@@L1116_:                                    BaseType_t * const pxHigherPriorityTaskWoken )   
##@@@L1117_:{   
80004c3c:	9f 5f       	PUSH      {R6-R10,LR}
80004c3e:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:stream_buffer.c:1123
##@@@L1118_:    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L1119_:    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;   
##@@@L1120_:
##@@@L1121_:    traceENTER_xStreamBufferReceiveFromISR( xStreamBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken );   
##@@@L1122_:
##@@@L1123_:    configASSERT( pvRxData );   
80004c40:	10 38       	CMP       R1, #0			;->0x00
80004c42:	3f f0       	JZ        $+63                  ;->0x80004cc0
80004c44:	c0 58       	MOV       R6, R0
##@@@P_:stream_buffer.c:1124
##@@@L1124_:    configASSERT( pxStreamBuffer );   
80004c46:	00 38       	CMP       R0, #0			;->0x00
80004c48:	5f f0       	JZ        $+95                  ;->0x80004d06
80004c4a:	23 59       	MOV       R9, R3
##@@@F_:prvBytesInBuffer():
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004c4c:	ae 98       	LD.W      R5, [R6 + #2]
80004c4e:	66 98       	LD.W      R4, [R6 + #1]
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
80004c50:	36 82       	LD.W      R3, [R6]
##@@@P_:stream_buffer.c:1460
##@@@L1455_:static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )   
##@@@L1456_:{   
##@@@L1457_:/* Returns the distance between xTail and xHead. */   
##@@@L1458_:    size_t xCount;   
##@@@L1459_:
##@@@L1460_:    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;   
80004c52:	64 c3       	ADD       R4, R4, R5
##@@@P_:stream_buffer.c:1461
##@@@L1461_:    xCount -= pxStreamBuffer->xTail;   
80004c54:	e4 c6       	SUB       R4, R4, R3
80004c56:	80 10       	MOV       R8, #0			;->0x0000
80004c58:	68 58       	MOV       R3, R8
##@@@P_:stream_buffer.c:1463
##@@@L1462_:
##@@@L1463_:    if( xCount >= pxStreamBuffer->xLength )   
80004c5a:	45 70       	CMP       R4, R5
80004c5c:	02 f3       	JNC       $+2                   ;->0x80004c60
80004c5e:	65 58       	MOV       R3, R5
80004c60:	dc c6       	SUB       R3, R4, R3
##@@@F_:xStreamBufferReceiveFromISR():
##@@@P_:stream_buffer.c:1131
##@@@L1126_:    /* This receive function is used by both message buffers, which store   
##@@@L1127_:     * discrete messages, and stream buffers, which store a continuous stream of   
##@@@L1128_:     * bytes.  Discrete messages include an additional   
##@@@L1129_:     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the   
##@@@L1130_:     * message. */   
##@@@L1131_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004c62:	a6 58       	MOV       R5, R6
80004c64:	5c 29       	ADD       R5, #28			;->0x1C
80004c66:	ad b8       	LDP.B     R5, [R5] << #2
80004c68:	44 10       	MOV       R4, #4			;->0x0004
80004c6a:	54 69       	ANL       R5, R4
##@@@P_:stream_buffer.c:1147
##@@@L1142_:    /* Whether receiving a discrete message (where xBytesToStoreMessageLength   
##@@@L1143_:     * holds the number of bytes used to store the message length) or a stream of   
##@@@L1144_:     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes   
##@@@L1145_:     * available must be greater than xBytesToStoreMessageLength to be able to   
##@@@L1146_:     * read bytes from the buffer. */   
##@@@L1147_:    if( xBytesAvailable > xBytesToStoreMessageLength )   
80004c6c:	35 70       	CMP       R3, R5
80004c6e:	1c f9       	JLS       $+28                  ;->0x80004ca6
##@@@P_:stream_buffer.c:1149
##@@@L1148_:    {   
##@@@L1149_:        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );   
80004c70:	06 58       	MOV       R0, R6
80004c72:	10 45       	LD        R5, [PC + #16]        ;->0x80004cb0  :=0x80004964
80004c74:	05 5c       	LJMP      R5
80004c76:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:stream_buffer.c:1152
##@@@L1150_:
##@@@L1151_:        /* Was a task waiting for space in the buffer? */   
##@@@L1152_:        if( xReceivedLength != ( size_t ) 0 )   
80004c78:	00 38       	CMP       R0, #0			;->0x00
80004c7a:	15 f0       	JZ        $+21                  ;->0x80004ca4
80004c7c:	00 59       	MOV       R8, R0
##@@@P_:stream_buffer.c:1154
##@@@L1153_:        {   
##@@@L1154_:            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );   
80004c7e:	0e 45       	LD        R5, [PC + #14]        ;->0x80004cb4  :=0x80008ff0
80004c80:	05 5c       	LJMP      R5
80004c82:	6e 99       	LD.W      R5, [R6 + #5]
80004c84:	50 38       	CMP       R5, #0			;->0x00
80004c86:	40 59       	MOV       R10, R0
80004c88:	0a f0       	JZ        $+10                  ;->0x80004c9c
80004c8a:	46 99       	LD.W      R0, [R6 + #5]
80004c8c:	e9 85       	ST.W      [SP], R9
80004c8e:	27 58       	MOV       R1, R7
80004c90:	47 58       	MOV       R2, R7
80004c92:	67 58       	MOV       R3, R7
80004c94:	87 58       	MOV       R4, R7
80004c96:	09 45       	LD        R5, [PC + #9]         ;->0x80004cb8  :=0x80008070
80004c98:	05 5c       	LJMP      R5
80004c9a:	77 a1       	ST.W      [R6 + #5], R7
80004c9c:	0a 58       	MOV       R0, R10
80004c9e:	08 45       	LD        R5, [PC + #8]         ;->0x80004cbc  :=0x80009034
80004ca0:	05 5c       	LJMP      R5
80004ca2:	02 04       	SJMP      $+2                   ;->0x80004ca6
80004ca4:	07 59       	MOV       R8, R7
##@@@P_:stream_buffer.c:1169
##@@@L1164_:    }   
##@@@L1165_:
##@@@L1166_:    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );   
##@@@L1167_:    traceRETURN_xStreamBufferReceiveFromISR( xReceivedLength );   
##@@@L1168_:
##@@@L1169_:    return xReceivedLength;   
80004ca6:	08 58       	MOV       R0, R8
80004ca8:	e8 28       	ADD       SP, #8			;->0x08
80004caa:	1f 5e       	POP       {R6-R10}
80004cac:	0d 5d       	POP       LR
80004cae:	1d 5c       	JMP       LR
80004cb0:	64 49 00 80 	.long     0x80004964 ->-2147464860  [!!!@2@:SET       R12, #20	@@: LD.B      R0, [R0]
80004cb4:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
80004cb8:	70 80 00 80 	.long     0x80008070 ->-2147450768  [!!!@2@:LD.B      R7, [R0]	@@: LD.B      R0, [R0]
80004cbc:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:1123
##@@@L1118_:    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L1119_:    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;   
##@@@L1120_:
##@@@L1121_:    traceENTER_xStreamBufferReceiveFromISR( xStreamBuffer, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken );   
##@@@L1122_:
##@@@L1123_:    configASSERT( pvRxData );   
80004cc0:	20 5d       	PUSH      R0
80004cc2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004cc6:	08 00       	SYNC     SYNC     
80004cc8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004ccc:	08 00       	SYNC     SYNC     
80004cce:	00 5d       	POP       R0
80004cd0:	20 5d       	PUSH      R0
80004cd2:	21 5d       	PUSH      R1
80004cd4:	1e 45       	LD        R5, [PC + #30]        ;->0x80004d4c  :=0x1ff
80004cd6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004cda:	25 58       	MOV       R1, R5
80004cdc:	11 68       	NOT       R1, R1
80004cde:	01 69       	ANL       R0, R1
80004ce0:	5f 11       	MOV       R5, #31			;->0x001F
80004ce2:	25 58       	MOV       R1, R5
80004ce4:	01 6a       	ORL       R0, R1
80004ce6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004cea:	08 00       	SYNC     SYNC     
80004cec:	01 5d       	POP       R1
80004cee:	00 5d       	POP       R0
80004cf0:	20 5d       	PUSH      R0
80004cf2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004cf6:	08 00       	SYNC     SYNC     
80004cf8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004cfc:	08 00       	SYNC     SYNC     
80004cfe:	00 5d       	POP       R0
80004d00:	07 00       	BREAK    BREAK    
80004d02:	14 45       	LD        R5, [PC + #20]        ;->0x80004d50  :=0x8000911c
80004d04:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1124
##@@@L1124_:    configASSERT( pxStreamBuffer );   
80004d06:	20 5d       	PUSH      R0
80004d08:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004d0c:	08 00       	SYNC     SYNC     
80004d0e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004d12:	08 00       	SYNC     SYNC     
80004d14:	00 5d       	POP       R0
80004d16:	20 5d       	PUSH      R0
80004d18:	21 5d       	PUSH      R1
80004d1a:	0d 45       	LD        R5, [PC + #13]        ;->0x80004d4c  :=0x1ff
80004d1c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004d20:	25 58       	MOV       R1, R5
80004d22:	11 68       	NOT       R1, R1
80004d24:	01 69       	ANL       R0, R1
80004d26:	5f 11       	MOV       R5, #31			;->0x001F
80004d28:	25 58       	MOV       R1, R5
80004d2a:	01 6a       	ORL       R0, R1
80004d2c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004d30:	08 00       	SYNC     SYNC     
80004d32:	01 5d       	POP       R1
80004d34:	00 5d       	POP       R0
80004d36:	20 5d       	PUSH      R0
80004d38:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004d3c:	08 00       	SYNC     SYNC     
80004d3e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004d42:	08 00       	SYNC     SYNC     
80004d44:	00 5d       	POP       R0
80004d46:	07 00       	BREAK    BREAK    
80004d48:	02 45       	LD        R5, [PC + #2]         ;->0x80004d50  :=0x8000911c
80004d4a:	05 5c       	LJMP      R5
80004d4c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004d50:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004d54 <xStreamBufferIsEmpty>:
##@@@F_:xStreamBufferIsEmpty():
##@@@P_:stream_buffer.c:1229
##@@@L1224_:    return xCount;   
##@@@L1225_:}   
##@@@L1226_:/*-----------------------------------------------------------*/   
##@@@L1227_:
##@@@L1228_:BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )   
##@@@L1229_:{   
80004d54:	2d 5d       	PUSH      LR
80004d56:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:stream_buffer.c:1236
##@@@L1231_:    BaseType_t xReturn;   
##@@@L1232_:    size_t xTail;   
##@@@L1233_:
##@@@L1234_:    traceENTER_xStreamBufferIsEmpty( xStreamBuffer );   
##@@@L1235_:
##@@@L1236_:    configASSERT( pxStreamBuffer );   
80004d58:	00 38       	CMP       R0, #0			;->0x00
80004d5a:	0b f0       	JZ        $+11                  ;->0x80004d70
##@@@P_:stream_buffer.c:1239
##@@@L1237_:
##@@@L1238_:    /* True if no bytes are available. */   
##@@@L1239_:    xTail = pxStreamBuffer->xTail;   
80004d5c:	50 82       	LD.W      R5, [R0]
##@@@P_:stream_buffer.c:1241
##@@@L1240_:
##@@@L1241_:    if( pxStreamBuffer->xHead == xTail )   
80004d5e:	60 98       	LD.W      R4, [R0 + #1]
80004d60:	45 70       	CMP       R4, R5
80004d62:	03 f0       	JZ        $+3                   ;->0x80004d68
80004d64:	00 10       	MOV       R0, #0			;->0x0000
80004d66:	02 04       	SJMP      $+2                   ;->0x80004d6a
80004d68:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:stream_buffer.c:1252
##@@@L1247_:        xReturn = pdFALSE;   
##@@@L1248_:    }   
##@@@L1249_:
##@@@L1250_:    traceRETURN_xStreamBufferIsEmpty( xReturn );   
##@@@L1251_:
##@@@L1252_:    return xReturn;   
80004d6a:	e4 28       	ADD       SP, #4			;->0x04
80004d6c:	0d 5d       	POP       LR
80004d6e:	1d 5c       	JMP       LR
##@@@P_:stream_buffer.c:1236
##@@@L1231_:    BaseType_t xReturn;   
##@@@L1232_:    size_t xTail;   
##@@@L1233_:
##@@@L1234_:    traceENTER_xStreamBufferIsEmpty( xStreamBuffer );   
##@@@L1235_:
##@@@L1236_:    configASSERT( pxStreamBuffer );   
80004d70:	20 5d       	PUSH      R0
80004d72:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004d76:	08 00       	SYNC     SYNC     
80004d78:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004d7c:	08 00       	SYNC     SYNC     
80004d7e:	00 5d       	POP       R0
80004d80:	20 5d       	PUSH      R0
80004d82:	21 5d       	PUSH      R1
80004d84:	0d 45       	LD        R5, [PC + #13]        ;->0x80004db8  :=0x1ff
80004d86:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004d8a:	25 58       	MOV       R1, R5
80004d8c:	11 68       	NOT       R1, R1
80004d8e:	01 69       	ANL       R0, R1
80004d90:	5f 11       	MOV       R5, #31			;->0x001F
80004d92:	25 58       	MOV       R1, R5
80004d94:	01 6a       	ORL       R0, R1
80004d96:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004d9a:	08 00       	SYNC     SYNC     
80004d9c:	01 5d       	POP       R1
80004d9e:	00 5d       	POP       R0
80004da0:	20 5d       	PUSH      R0
80004da2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004da6:	08 00       	SYNC     SYNC     
80004da8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004dac:	08 00       	SYNC     SYNC     
80004dae:	00 5d       	POP       R0
80004db0:	07 00       	BREAK    BREAK    
80004db2:	03 45       	LD        R5, [PC + #3]         ;->0x80004dbc  :=0x8000911c
80004db4:	05 5c       	LJMP      R5
80004db6:	00 00       	NOP      NOP      
80004db8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004dbc:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004dc0 <xStreamBufferIsFull>:
##@@@F_:xStreamBufferIsFull():
##@@@P_:stream_buffer.c:1257
##@@@L1252_:    return xReturn;   
##@@@L1253_:}   
##@@@L1254_:/*-----------------------------------------------------------*/   
##@@@L1255_:
##@@@L1256_:BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )   
##@@@L1257_:{   
80004dc0:	81 5f       	PUSH      {R6,LR}
80004dc2:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:stream_buffer.c:1264
##@@@L1259_:    size_t xBytesToStoreMessageLength;   
##@@@L1260_:    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L1261_:
##@@@L1262_:    traceENTER_xStreamBufferIsFull( xStreamBuffer );   
##@@@L1263_:
##@@@L1264_:    configASSERT( pxStreamBuffer );   
80004dc4:	00 38       	CMP       R0, #0			;->0x00
80004dc6:	1c f0       	JZ        $+28                  ;->0x80004dfe
80004dc8:	a0 98       	LD.W      R4, [R0 + #2]
##@@@P_:stream_buffer.c:1270
##@@@L1265_:
##@@@L1266_:    /* This generic version of the receive function is used by both message   
##@@@L1267_:     * buffers, which store discrete messages, and stream buffers, which store a   
##@@@L1268_:     * continuous stream of bytes.  Discrete messages include an additional   
##@@@L1269_:     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */   
##@@@L1270_:    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )   
80004dca:	28 8f       	LD.B      R5, [R0 + #28]
##@@@F_:xStreamBufferSpacesAvailable():
##@@@P_:stream_buffer.c:680
##@@@L0675_:    /* The code below reads xTail and then xHead.  This is safe if the stream   
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
80004dcc:	10 82       	LD.W      R1, [R0]
##@@@P_:stream_buffer.c:681
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004dce:	30 82       	LD.W      R3, [R0]
##@@@P_:stream_buffer.c:682
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
80004dd0:	50 98       	LD.W      R2, [R0 + #1]
##@@@P_:stream_buffer.c:683
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
80004dd2:	60 82       	LD.W      R6, [R0]
80004dd4:	16 70       	CMP       R1, R6
80004dd6:	fb f1       	JNZ       $-5                   ;->0x80004dcc
##@@@P_:stream_buffer.c:681
##@@@L0676_:     * buffer is updated once between the two reads - but not if the stream buffer   
##@@@L0677_:     * is updated more than once between the two reads - hence the loop. */   
##@@@L0678_:    do   
##@@@L0679_:    {   
##@@@L0680_:        xOriginalTail = pxStreamBuffer->xTail;   
##@@@L0681_:        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;   
80004dd8:	1b c3       	ADD       R3, R3, R4
##@@@P_:stream_buffer.c:685
##@@@L0682_:        xSpace -= pxStreamBuffer->xHead;   
##@@@L0683_:    } while( xOriginalTail != pxStreamBuffer->xTail );   
##@@@L0684_:
##@@@L0685_:    xSpace -= ( size_t ) 1;   
80004dda:	22 68       	NOT       R2, R2
80004ddc:	9b c2       	ADD       R3, R3, R2
80004dde:	00 10       	MOV       R0, #0			;->0x0000
80004de0:	40 58       	MOV       R2, R0
##@@@P_:stream_buffer.c:687
##@@@L0686_:
##@@@L0687_:    if( xSpace >= pxStreamBuffer->xLength )   
80004de2:	34 70       	CMP       R3, R4
80004de4:	02 f3       	JNC       $+2                   ;->0x80004de8
80004de6:	44 58       	MOV       R2, R4
80004de8:	a3 c6       	SUB       R4, R3, R2
80004dea:	2a 7a       	LSL       R5, #2			;->0x02
80004dec:	34 10       	MOV       R3, #4			;->0x0004
80004dee:	53 69       	ANL       R5, R3
##@@@F_:xStreamBufferIsFull():
##@@@P_:stream_buffer.c:1280
##@@@L1275_:    {   
##@@@L1276_:        xBytesToStoreMessageLength = 0;   
##@@@L1277_:    }   
##@@@L1278_:
##@@@L1279_:    /* True if the available space equals zero. */   
##@@@L1280_:    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )   
80004df0:	45 70       	CMP       R4, R5
80004df2:	02 f8       	JHI       $+2                   ;->0x80004df6
80004df4:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:stream_buffer.c:1291
##@@@L1286_:        xReturn = pdFALSE;   
##@@@L1287_:    }   
##@@@L1288_:
##@@@L1289_:    traceRETURN_xStreamBufferIsFull( xReturn );   
##@@@L1290_:
##@@@L1291_:    return xReturn;   
80004df6:	e4 28       	ADD       SP, #4			;->0x04
80004df8:	06 5d       	POP       R6
80004dfa:	0d 5d       	POP       LR
80004dfc:	1d 5c       	JMP       LR
##@@@P_:stream_buffer.c:1264
##@@@L1259_:    size_t xBytesToStoreMessageLength;   
##@@@L1260_:    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;   
##@@@L1261_:
##@@@L1262_:    traceENTER_xStreamBufferIsFull( xStreamBuffer );   
##@@@L1263_:
##@@@L1264_:    configASSERT( pxStreamBuffer );   
80004dfe:	20 5d       	PUSH      R0
80004e00:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004e04:	08 00       	SYNC     SYNC     
80004e06:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004e0a:	08 00       	SYNC     SYNC     
80004e0c:	00 5d       	POP       R0
80004e0e:	20 5d       	PUSH      R0
80004e10:	21 5d       	PUSH      R1
80004e12:	0d 45       	LD        R5, [PC + #13]        ;->0x80004e44  :=0x1ff
80004e14:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004e18:	25 58       	MOV       R1, R5
80004e1a:	11 68       	NOT       R1, R1
80004e1c:	01 69       	ANL       R0, R1
80004e1e:	5f 11       	MOV       R5, #31			;->0x001F
80004e20:	25 58       	MOV       R1, R5
80004e22:	01 6a       	ORL       R0, R1
80004e24:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004e28:	08 00       	SYNC     SYNC     
80004e2a:	01 5d       	POP       R1
80004e2c:	00 5d       	POP       R0
80004e2e:	20 5d       	PUSH      R0
80004e30:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004e34:	08 00       	SYNC     SYNC     
80004e36:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004e3a:	08 00       	SYNC     SYNC     
80004e3c:	00 5d       	POP       R0
80004e3e:	07 00       	BREAK    BREAK    
80004e40:	02 45       	LD        R5, [PC + #2]         ;->0x80004e48  :=0x8000911c
80004e42:	05 5c       	LJMP      R5
80004e44:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004e48:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004e4c <xStreamBufferSendCompletedFromISR>:
##@@@F_:xStreamBufferSendCompletedFromISR():
##@@@P_:stream_buffer.c:1297
##@@@L1292_:}   
##@@@L1293_:/*-----------------------------------------------------------*/   
##@@@L1294_:
##@@@L1295_:BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,   
##@@@L1296_:                                              BaseType_t * pxHigherPriorityTaskWoken )   
##@@@L1297_:{   
80004e4c:	8f 5f       	PUSH      {R6-R9,LR}
80004e4e:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:stream_buffer.c:1304
##@@@L1299_:    BaseType_t xReturn;   
##@@@L1300_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L1301_:
##@@@L1302_:    traceENTER_xStreamBufferSendCompletedFromISR( xStreamBuffer, pxHigherPriorityTaskWoken );   
##@@@L1303_:
##@@@L1304_:    configASSERT( pxStreamBuffer );   
80004e50:	00 38       	CMP       R0, #0			;->0x00
80004e52:	23 f0       	JZ        $+35                  ;->0x80004e98
80004e54:	e0 58       	MOV       R7, R0
80004e56:	21 59       	MOV       R9, R1
##@@@P_:stream_buffer.c:1306
##@@@L1305_:
##@@@L1306_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80004e58:	0d 45       	LD        R5, [PC + #13]        ;->0x80004e8c  :=0x80008ff0
80004e5a:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1308
##@@@L1307_:    {   
##@@@L1308_:        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )   
80004e5c:	2f 99       	LD.W      R5, [R7 + #4]
80004e5e:	60 10       	MOV       R6, #0			;->0x0000
80004e60:	50 38       	CMP       R5, #0			;->0x00
##@@@P_:stream_buffer.c:1306
##@@@L1301_:
##@@@L1302_:    traceENTER_xStreamBufferSendCompletedFromISR( xStreamBuffer, pxHigherPriorityTaskWoken );   
##@@@L1303_:
##@@@L1304_:    configASSERT( pxStreamBuffer );   
##@@@L1305_:
##@@@L1306_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80004e62:	00 59       	MOV       R8, R0
##@@@P_:stream_buffer.c:1308
##@@@L1307_:    {   
##@@@L1308_:        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )   
80004e64:	0b f0       	JZ        $+11                  ;->0x80004e7a
##@@@P_:stream_buffer.c:1310
##@@@L1309_:        {   
##@@@L1310_:            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,   
80004e66:	07 99       	LD.W      R0, [R7 + #4]
80004e68:	e9 85       	ST.W      [SP], R9
80004e6a:	26 58       	MOV       R1, R6
80004e6c:	46 58       	MOV       R2, R6
80004e6e:	66 58       	MOV       R3, R6
80004e70:	86 58       	MOV       R4, R6
80004e72:	08 45       	LD        R5, [PC + #8]         ;->0x80004e90  :=0x80008070
80004e74:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1314
##@@@L1311_:                                         ( uint32_t ) 0,   
##@@@L1312_:                                         eNoAction,   
##@@@L1313_:                                         pxHigherPriorityTaskWoken );   
##@@@L1314_:            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;   
80004e76:	3e a1       	ST.W      [R7 + #4], R6
80004e78:	61 10       	MOV       R6, #1			;->0x0001
##@@@P_:stream_buffer.c:1322
##@@@L1317_:        else   
##@@@L1318_:        {   
##@@@L1319_:            xReturn = pdFALSE;   
##@@@L1320_:        }   
##@@@L1321_:    }   
##@@@L1322_:    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80004e7a:	08 58       	MOV       R0, R8
80004e7c:	06 45       	LD        R5, [PC + #6]         ;->0x80004e94  :=0x80009034
80004e7e:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1326
##@@@L1323_:
##@@@L1324_:    traceRETURN_xStreamBufferSendCompletedFromISR( xReturn );   
##@@@L1325_:
##@@@L1326_:    return xReturn;   
80004e80:	06 58       	MOV       R0, R6
80004e82:	e8 28       	ADD       SP, #8			;->0x08
80004e84:	0f 5e       	POP       {R6-R9}
80004e86:	0d 5d       	POP       LR
80004e88:	1d 5c       	JMP       LR
80004e8a:	00 00       	NOP      NOP      
80004e8c:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
80004e90:	70 80 00 80 	.long     0x80008070 ->-2147450768  [!!!@2@:LD.B      R7, [R0]	@@: LD.B      R0, [R0]
80004e94:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:1304
##@@@L1299_:    BaseType_t xReturn;   
##@@@L1300_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L1301_:
##@@@L1302_:    traceENTER_xStreamBufferSendCompletedFromISR( xStreamBuffer, pxHigherPriorityTaskWoken );   
##@@@L1303_:
##@@@L1304_:    configASSERT( pxStreamBuffer );   
80004e98:	20 5d       	PUSH      R0
80004e9a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004e9e:	08 00       	SYNC     SYNC     
80004ea0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004ea4:	08 00       	SYNC     SYNC     
80004ea6:	00 5d       	POP       R0
80004ea8:	20 5d       	PUSH      R0
80004eaa:	21 5d       	PUSH      R1
80004eac:	0d 45       	LD        R5, [PC + #13]        ;->0x80004ee0  :=0x1ff
80004eae:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004eb2:	25 58       	MOV       R1, R5
80004eb4:	11 68       	NOT       R1, R1
80004eb6:	01 69       	ANL       R0, R1
80004eb8:	5f 11       	MOV       R5, #31			;->0x001F
80004eba:	25 58       	MOV       R1, R5
80004ebc:	01 6a       	ORL       R0, R1
80004ebe:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004ec2:	08 00       	SYNC     SYNC     
80004ec4:	01 5d       	POP       R1
80004ec6:	00 5d       	POP       R0
80004ec8:	20 5d       	PUSH      R0
80004eca:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004ece:	08 00       	SYNC     SYNC     
80004ed0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004ed4:	08 00       	SYNC     SYNC     
80004ed6:	00 5d       	POP       R0
80004ed8:	07 00       	BREAK    BREAK    
80004eda:	03 45       	LD        R5, [PC + #3]         ;->0x80004ee4  :=0x8000911c
80004edc:	05 5c       	LJMP      R5
80004ede:	00 00       	NOP      NOP      
80004ee0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004ee4:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004ee8 <xStreamBufferReceiveCompletedFromISR>:
##@@@F_:xStreamBufferReceiveCompletedFromISR():
##@@@P_:stream_buffer.c:1332
##@@@L1327_:}   
##@@@L1328_:/*-----------------------------------------------------------*/   
##@@@L1329_:
##@@@L1330_:BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,   
##@@@L1331_:                                                 BaseType_t * pxHigherPriorityTaskWoken )   
##@@@L1332_:{   
80004ee8:	8f 5f       	PUSH      {R6-R9,LR}
80004eea:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:stream_buffer.c:1339
##@@@L1334_:    BaseType_t xReturn;   
##@@@L1335_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L1336_:
##@@@L1337_:    traceENTER_xStreamBufferReceiveCompletedFromISR( xStreamBuffer, pxHigherPriorityTaskWoken );   
##@@@L1338_:
##@@@L1339_:    configASSERT( pxStreamBuffer );   
80004eec:	00 38       	CMP       R0, #0			;->0x00
80004eee:	23 f0       	JZ        $+35                  ;->0x80004f34
80004ef0:	e0 58       	MOV       R7, R0
80004ef2:	21 59       	MOV       R9, R1
##@@@P_:stream_buffer.c:1341
##@@@L1340_:
##@@@L1341_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80004ef4:	0d 45       	LD        R5, [PC + #13]        ;->0x80004f28  :=0x80008ff0
80004ef6:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1343
##@@@L1342_:    {   
##@@@L1343_:        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )   
80004ef8:	6f 99       	LD.W      R5, [R7 + #5]
80004efa:	60 10       	MOV       R6, #0			;->0x0000
80004efc:	50 38       	CMP       R5, #0			;->0x00
##@@@P_:stream_buffer.c:1341
##@@@L1336_:
##@@@L1337_:    traceENTER_xStreamBufferReceiveCompletedFromISR( xStreamBuffer, pxHigherPriorityTaskWoken );   
##@@@L1338_:
##@@@L1339_:    configASSERT( pxStreamBuffer );   
##@@@L1340_:
##@@@L1341_:    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80004efe:	00 59       	MOV       R8, R0
##@@@P_:stream_buffer.c:1343
##@@@L1342_:    {   
##@@@L1343_:        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )   
80004f00:	0b f0       	JZ        $+11                  ;->0x80004f16
##@@@P_:stream_buffer.c:1345
##@@@L1344_:        {   
##@@@L1345_:            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,   
80004f02:	47 99       	LD.W      R0, [R7 + #5]
80004f04:	e9 85       	ST.W      [SP], R9
80004f06:	26 58       	MOV       R1, R6
80004f08:	46 58       	MOV       R2, R6
80004f0a:	66 58       	MOV       R3, R6
80004f0c:	86 58       	MOV       R4, R6
80004f0e:	08 45       	LD        R5, [PC + #8]         ;->0x80004f2c  :=0x80008070
80004f10:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1349
##@@@L1346_:                                         ( uint32_t ) 0,   
##@@@L1347_:                                         eNoAction,   
##@@@L1348_:                                         pxHigherPriorityTaskWoken );   
##@@@L1349_:            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;   
80004f12:	7e a1       	ST.W      [R7 + #5], R6
80004f14:	61 10       	MOV       R6, #1			;->0x0001
##@@@P_:stream_buffer.c:1357
##@@@L1352_:        else   
##@@@L1353_:        {   
##@@@L1354_:            xReturn = pdFALSE;   
##@@@L1355_:        }   
##@@@L1356_:    }   
##@@@L1357_:    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80004f16:	08 58       	MOV       R0, R8
80004f18:	06 45       	LD        R5, [PC + #6]         ;->0x80004f30  :=0x80009034
80004f1a:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1361
##@@@L1358_:
##@@@L1359_:    traceRETURN_xStreamBufferReceiveCompletedFromISR( xReturn );   
##@@@L1360_:
##@@@L1361_:    return xReturn;   
80004f1c:	06 58       	MOV       R0, R6
80004f1e:	e8 28       	ADD       SP, #8			;->0x08
80004f20:	0f 5e       	POP       {R6-R9}
80004f22:	0d 5d       	POP       LR
80004f24:	1d 5c       	JMP       LR
80004f26:	00 00       	NOP      NOP      
80004f28:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
80004f2c:	70 80 00 80 	.long     0x80008070 ->-2147450768  [!!!@2@:LD.B      R7, [R0]	@@: LD.B      R0, [R0]
80004f30:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:1339
##@@@L1334_:    BaseType_t xReturn;   
##@@@L1335_:    UBaseType_t uxSavedInterruptStatus;   
##@@@L1336_:
##@@@L1337_:    traceENTER_xStreamBufferReceiveCompletedFromISR( xStreamBuffer, pxHigherPriorityTaskWoken );   
##@@@L1338_:
##@@@L1339_:    configASSERT( pxStreamBuffer );   
80004f34:	20 5d       	PUSH      R0
80004f36:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004f3a:	08 00       	SYNC     SYNC     
80004f3c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80004f40:	08 00       	SYNC     SYNC     
80004f42:	00 5d       	POP       R0
80004f44:	20 5d       	PUSH      R0
80004f46:	21 5d       	PUSH      R1
80004f48:	0d 45       	LD        R5, [PC + #13]        ;->0x80004f7c  :=0x1ff
80004f4a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80004f4e:	25 58       	MOV       R1, R5
80004f50:	11 68       	NOT       R1, R1
80004f52:	01 69       	ANL       R0, R1
80004f54:	5f 11       	MOV       R5, #31			;->0x001F
80004f56:	25 58       	MOV       R1, R5
80004f58:	01 6a       	ORL       R0, R1
80004f5a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80004f5e:	08 00       	SYNC     SYNC     
80004f60:	01 5d       	POP       R1
80004f62:	00 5d       	POP       R0
80004f64:	20 5d       	PUSH      R0
80004f66:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004f6a:	08 00       	SYNC     SYNC     
80004f6c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80004f70:	08 00       	SYNC     SYNC     
80004f72:	00 5d       	POP       R0
80004f74:	07 00       	BREAK    BREAK    
80004f76:	03 45       	LD        R5, [PC + #3]         ;->0x80004f80  :=0x8000911c
80004f78:	05 5c       	LJMP      R5
80004f7a:	00 00       	NOP      NOP      
80004f7c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80004f80:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80004f84 <uxStreamBufferGetStreamBufferNumber>:
##@@@F_:uxStreamBufferGetStreamBufferNumber():
##@@@P_:stream_buffer.c:1530
##@@@L1525_:    {   
##@@@L1526_:        traceENTER_uxStreamBufferGetStreamBufferNumber( xStreamBuffer );   
##@@@L1527_:
##@@@L1528_:        traceRETURN_uxStreamBufferGetStreamBufferNumber( xStreamBuffer->uxStreamBufferNumber );   
##@@@L1529_:
##@@@L1530_:        return xStreamBuffer->uxStreamBufferNumber;   
80004f84:	00 9a       	LD.W      R0, [R0 + #8]
80004f86:	1d 5c       	JMP       LR

80004f88 <vStreamBufferSetStreamBufferNumber>:
##@@@F_:vStreamBufferSetStreamBufferNumber():
##@@@P_:stream_buffer.c:1543
##@@@L1538_:    void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,   
##@@@L1539_:                                             UBaseType_t uxStreamBufferNumber )   
##@@@L1540_:    {   
##@@@L1541_:        traceENTER_vStreamBufferSetStreamBufferNumber( xStreamBuffer, uxStreamBufferNumber );   
##@@@L1542_:
##@@@L1543_:        xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;   
80004f88:	01 a2       	ST.W      [R0 + #8], R1
##@@@P_:stream_buffer.c:1546
##@@@L1544_:
##@@@L1545_:        traceRETURN_vStreamBufferSetStreamBufferNumber();   
##@@@L1546_:    }   
80004f8a:	1d 5c       	JMP       LR

80004f8c <ucStreamBufferGetStreamBufferType>:
##@@@F_:ucStreamBufferGetStreamBufferType():
##@@@P_:stream_buffer.c:1559
##@@@L1554_:    {   
##@@@L1555_:        traceENTER_ucStreamBufferGetStreamBufferType( xStreamBuffer );   
##@@@L1556_:
##@@@L1557_:        traceRETURN_ucStreamBufferGetStreamBufferType( ( uint8_t ) ( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) );   
##@@@L1558_:
##@@@L1559_:        return( ( uint8_t ) ( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) );   
80004f8c:	00 8f       	LD.B      R0, [R0 + #28]
80004f8e:	51 10       	MOV       R5, #1			;->0x0001
80004f90:	05 69       	ANL       R0, R5
80004f92:	1d 5c       	JMP       LR

80004f94 <prvWriteBytesToBuffer>:
##@@@F_:prvWriteBytesToBuffer():
##@@@P_:stream_buffer.c:1369
##@@@L1364_:
##@@@L1365_:static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,   
##@@@L1366_:                                     const uint8_t * pucData,   
##@@@L1367_:                                     size_t xCount,   
##@@@L1368_:                                     size_t xHead )   
##@@@L1369_:{   
80004f94:	83 5f       	PUSH      {R6-R7,LR}
80004f96:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:stream_buffer.c:1377
##@@@L1372_:    configASSERT( xCount > ( size_t ) 0 );   
##@@@L1373_:
##@@@L1374_:    /* Calculate the number of bytes that can be added in the first write -   
##@@@L1375_:     * which may be less than the total number of bytes that need to be added if   
##@@@L1376_:     * the buffer will wrap back to the beginning. */   
##@@@L1377_:    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );   
80004f98:	a8 98       	LD.W      R5, [R0 + #2]
80004f9a:	f5 c6       	SUB       R6, R5, R3
80004f9c:	86 58       	MOV       R4, R6
80004f9e:	62 70       	CMP       R6, R2
80004fa0:	02 f3       	JNC       $+2                   ;->0x80004fa4
80004fa2:	82 58       	MOV       R4, R2
80004fa4:	03 22       	ST.W      [SP + #3], R2
80004fa6:	04 24       	ST.W      [SP + #4], R4
##@@@P_:stream_buffer.c:1380
##@@@L1378_:
##@@@L1379_:    /* Write as many bytes as can be written in the first write. */   
##@@@L1380_:    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );   
80004fa8:	e4 c2       	ADD       R4, R4, R3
80004faa:	45 70       	CMP       R4, R5
80004fac:	24 f8       	JHI       $+36                  ;->0x80004ff4
##@@@P_:stream_buffer.c:1381
##@@@L1381_:    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength );   
80004fae:	a8 99       	LD.W      R5, [R0 + #6]
80004fb0:	e0 58       	MOV       R7, R0
80004fb2:	02 23       	ST.W      [SP + #2], R3
80004fb4:	c5 c2       	ADD       R0, R5, R3
80004fb6:	01 21       	ST.W      [SP + #1], R1
80004fb8:	04 0a       	LD.W      R2, [SP + #4]
80004fba:	0e 45       	LD        R5, [PC + #14]        ;->0x80004ff0  :=0x8000d9ec
80004fbc:	05 5c       	LJMP      R5
80004fbe:	03 0b       	LD.W      R3, [SP + #3]
##@@@P_:stream_buffer.c:1385
##@@@L1382_:
##@@@L1383_:    /* If the number of bytes written was less than the number that could be   
##@@@L1384_:     * written in the first write... */   
##@@@L1385_:    if( xCount > xFirstLength )   
80004fc0:	63 70       	CMP       R6, R3
80004fc2:	0c f2       	JC        $+12                  ;->0x80004fda
##@@@P_:stream_buffer.c:1388
##@@@L1386_:    {   
##@@@L1387_:        /* ...then write the remaining bytes to the start of the buffer. */   
##@@@L1388_:        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );   
80004fc4:	af 98       	LD.W      R5, [R7 + #2]
80004fc6:	04 0c       	LD.W      R4, [SP + #4]
80004fc8:	13 c7       	SUB       R2, R3, R4
80004fca:	25 70       	CMP       R2, R5
80004fcc:	37 f8       	JHI       $+55                  ;->0x8000503a
##@@@P_:stream_buffer.c:1389
##@@@L1389_:        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength );   
80004fce:	87 99       	LD.W      R0, [R7 + #6]
80004fd0:	01 0d       	LD.W      R5, [SP + #1]
80004fd2:	0d c3       	ADD       R1, R5, R4
80004fd4:	07 45       	LD        R5, [PC + #7]         ;->0x80004ff0  :=0x8000d9ec
80004fd6:	05 5c       	LJMP      R5
80004fd8:	03 0b       	LD.W      R3, [SP + #3]
##@@@P_:stream_buffer.c:1398
##@@@L1393_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1394_:    }   
##@@@L1395_:
##@@@L1396_:    xHead += xCount;   
##@@@L1397_:
##@@@L1398_:    if( xHead >= pxStreamBuffer->xLength )   
80004fda:	a7 98       	LD.W      R4, [R7 + #2]
##@@@P_:stream_buffer.c:1396
##@@@L1391_:    else   
##@@@L1392_:    {   
##@@@L1393_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1394_:    }   
##@@@L1395_:
##@@@L1396_:    xHead += xCount;   
80004fdc:	02 0d       	LD.W      R5, [SP + #2]
80004fde:	ed c2       	ADD       R5, R5, R3
##@@@P_:stream_buffer.c:1398
##@@@L1397_:
##@@@L1398_:    if( xHead >= pxStreamBuffer->xLength )   
80004fe0:	54 70       	CMP       R5, R4
80004fe2:	02 f2       	JC        $+2                   ;->0x80004fe6
80004fe4:	40 10       	MOV       R4, #0			;->0x0000
80004fe6:	05 c7       	SUB       R0, R5, R4
##@@@P_:stream_buffer.c:1407
##@@@L1402_:    else   
##@@@L1403_:    {   
##@@@L1404_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1405_:    }   
##@@@L1406_:
##@@@L1407_:    return xHead;   
80004fe8:	e4 29       	ADD       SP, #20			;->0x14
80004fea:	03 5e       	POP       {R6-R7}
80004fec:	0d 5d       	POP       LR
80004fee:	1d 5c       	JMP       LR
80004ff0:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]
##@@@P_:stream_buffer.c:1380
##@@@L1375_:     * which may be less than the total number of bytes that need to be added if   
##@@@L1376_:     * the buffer will wrap back to the beginning. */   
##@@@L1377_:    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );   
##@@@L1378_:
##@@@L1379_:    /* Write as many bytes as can be written in the first write. */   
##@@@L1380_:    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );   
80004ff4:	20 5d       	PUSH      R0
80004ff6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80004ffa:	08 00       	SYNC     SYNC     
80004ffc:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005000:	08 00       	SYNC     SYNC     
80005002:	00 5d       	POP       R0
80005004:	20 5d       	PUSH      R0
80005006:	21 5d       	PUSH      R1
80005008:	1e 45       	LD        R5, [PC + #30]        ;->0x80005080  :=0x1ff
8000500a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000500e:	25 58       	MOV       R1, R5
80005010:	11 68       	NOT       R1, R1
80005012:	01 69       	ANL       R0, R1
80005014:	5f 11       	MOV       R5, #31			;->0x001F
80005016:	25 58       	MOV       R1, R5
80005018:	01 6a       	ORL       R0, R1
8000501a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000501e:	08 00       	SYNC     SYNC     
80005020:	01 5d       	POP       R1
80005022:	00 5d       	POP       R0
80005024:	20 5d       	PUSH      R0
80005026:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000502a:	08 00       	SYNC     SYNC     
8000502c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005030:	08 00       	SYNC     SYNC     
80005032:	00 5d       	POP       R0
80005034:	07 00       	BREAK    BREAK    
80005036:	14 45       	LD        R5, [PC + #20]        ;->0x80005084  :=0x8000911c
80005038:	05 5c       	LJMP      R5
##@@@P_:stream_buffer.c:1388
##@@@L1383_:    /* If the number of bytes written was less than the number that could be   
##@@@L1384_:     * written in the first write... */   
##@@@L1385_:    if( xCount > xFirstLength )   
##@@@L1386_:    {   
##@@@L1387_:        /* ...then write the remaining bytes to the start of the buffer. */   
##@@@L1388_:        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );   
8000503a:	20 5d       	PUSH      R0
8000503c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005040:	08 00       	SYNC     SYNC     
80005042:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005046:	08 00       	SYNC     SYNC     
80005048:	00 5d       	POP       R0
8000504a:	20 5d       	PUSH      R0
8000504c:	21 5d       	PUSH      R1
8000504e:	0d 45       	LD        R5, [PC + #13]        ;->0x80005080  :=0x1ff
80005050:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005054:	25 58       	MOV       R1, R5
80005056:	11 68       	NOT       R1, R1
80005058:	01 69       	ANL       R0, R1
8000505a:	5f 11       	MOV       R5, #31			;->0x001F
8000505c:	25 58       	MOV       R1, R5
8000505e:	01 6a       	ORL       R0, R1
80005060:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005064:	08 00       	SYNC     SYNC     
80005066:	01 5d       	POP       R1
80005068:	00 5d       	POP       R0
8000506a:	20 5d       	PUSH      R0
8000506c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005070:	08 00       	SYNC     SYNC     
80005072:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005076:	08 00       	SYNC     SYNC     
80005078:	00 5d       	POP       R0
8000507a:	07 00       	BREAK    BREAK    
8000507c:	02 45       	LD        R5, [PC + #2]         ;->0x80005084  :=0x8000911c
8000507e:	05 5c       	LJMP      R5
80005080:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005084:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80005088 <xTaskCreateStatic>:
##@@@F_:xTaskCreateStatic():
##@@@P_:tasks.c:1308
##@@@L1303_:                                    const uint32_t ulStackDepth,   
##@@@L1304_:                                    void * const pvParameters,   
##@@@L1305_:                                    UBaseType_t uxPriority,   
##@@@L1306_:                                    StackType_t * const puxStackBuffer,   
##@@@L1307_:                                    StaticTask_t * const pxTaskBuffer )   
##@@@L1308_:    {   
80005088:	ff 5f       	PUSH      {R6-R12,LR}
8000508a:	e4 31       	SUB       SP, #20			;->0x14
8000508c:	0d 0f       	LD.W      R7, [SP + #13]
8000508e:	50 10       	MOV       R5, #0			;->0x0000
##@@@F_:prvCreateStaticTask():
##@@@P_:tasks.c:1257
##@@@L1252_:                                        StaticTask_t * const pxTaskBuffer,   
##@@@L1253_:                                        TaskHandle_t * const pxCreatedTask )   
##@@@L1254_:    {   
##@@@L1255_:        TCB_t * pxNewTCB;   
##@@@L1256_:
##@@@L1257_:        configASSERT( puxStackBuffer != NULL );   
80005090:	70 38       	CMP       R7, #0			;->0x00
##@@@F_:xTaskCreateStatic():
##@@@P_:tasks.c:1309
##@@@L1304_:                                    void * const pvParameters,   
##@@@L1305_:                                    UBaseType_t uxPriority,   
##@@@L1306_:                                    StackType_t * const puxStackBuffer,   
##@@@L1307_:                                    StaticTask_t * const pxTaskBuffer )   
##@@@L1308_:    {   
##@@@L1309_:        TaskHandle_t xReturn = NULL;   
80005092:	03 25       	ST.W      [SP + #3], R5
##@@@F_:prvCreateStaticTask():
##@@@P_:tasks.c:1257
##@@@L1252_:                                        StaticTask_t * const pxTaskBuffer,   
##@@@L1253_:                                        TaskHandle_t * const pxCreatedTask )   
##@@@L1254_:    {   
##@@@L1255_:        TCB_t * pxNewTCB;   
##@@@L1256_:
##@@@L1257_:        configASSERT( puxStackBuffer != NULL );   
80005094:	34 f0       	JZ        $+52                  ;->0x800050fc
80005096:	0e 0e       	LD.W      R6, [SP + #14]
##@@@P_:tasks.c:1258
##@@@L1258_:        configASSERT( pxTaskBuffer != NULL );   
80005098:	60 38       	CMP       R6, #0			;->0x00
8000509a:	54 f0       	JZ        $+84                  ;->0x80005142
8000509c:	58 17       	MOV       R5, #120			;->0x0078
##@@@P_:tasks.c:1265
##@@@L1260_:        #if ( configASSERT_DEFINED == 1 )   
##@@@L1261_:        {   
##@@@L1262_:            /* Sanity check that the size of the structure used to declare a   
##@@@L1263_:             * variable of type StaticTask_t equals the size of the real task   
##@@@L1264_:             * structure. */   
##@@@L1265_:            volatile size_t xSize = sizeof( StaticTask_t );   
8000509e:	04 25       	ST.W      [SP + #4], R5
##@@@P_:tasks.c:1266
##@@@L1266_:            configASSERT( xSize == sizeof( TCB_t ) );   
800050a0:	04 0d       	LD.W      R5, [SP + #4]
800050a2:	58 3f       	CMP       R5, #120			;->0x78
800050a4:	72 f1       	JNZ       $+114                 ;->0x80005188
800050a6:	64 59       	MOV       R11, R4
800050a8:	83 59       	MOV       R12, R3
800050aa:	02 59       	MOV       R8, R2
800050ac:	21 59       	MOV       R9, R1
800050ae:	40 59       	MOV       R10, R0
##@@@P_:tasks.c:1267
##@@@L1267_:            ( void ) xSize; /* Prevent unused variable warning when configASSERT() is not used. */   
800050b0:	04 0d       	LD.W      R5, [SP + #4]
800050b2:	10 10       	MOV       R1, #0			;->0x0000
800050b4:	28 17       	MOV       R2, #120			;->0x0078
##@@@P_:tasks.c:1279
##@@@L1274_:             * function - use them. */   
##@@@L1275_:            /* MISRA Ref 11.3.1 [Misaligned access] */   
##@@@L1276_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-113 */   
##@@@L1277_:            /* coverity[misra_c_2012_rule_11_3_violation] */   
##@@@L1278_:            pxNewTCB = ( TCB_t * ) pxTaskBuffer;   
##@@@L1279_:            ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );   
800050b6:	06 58       	MOV       R0, R6
800050b8:	0d 45       	LD        R5, [PC + #13]        ;->0x800050ec  :=0x8000da04
800050ba:	05 5c       	LJMP      R5
800050bc:	52 10       	MOV       R5, #2			;->0x0002
800050be:	79 00 c5 d4 	ST.B      [R6 + #117], R5			;->0x75
##@@@P_:tasks.c:1280
##@@@L1280_:            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;   
800050c2:	37 a3       	ST.W      [R6 + #12], R7
800050c4:	0b 45       	LD        R5, [PC + #11]        ;->0x800050f0  :=0xc
800050c6:	5e 64       	ADD       R5, SP
##@@@P_:tasks.c:1290
##@@@L1285_:                 * task was created statically in case the task is later deleted. */   
##@@@L1286_:                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;   
##@@@L1287_:            }   
##@@@L1288_:            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */   
##@@@L1289_:
##@@@L1290_:            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );   
800050c8:	8e 58       	MOV       R4, SP
800050ca:	45 85       	ST.W      [R4], R5
800050cc:	66 a0       	ST.W      [R4 + #1], R6
800050ce:	0a 58       	MOV       R0, R10
800050d0:	29 58       	MOV       R1, R9
800050d2:	48 58       	MOV       R2, R8
800050d4:	6c 58       	MOV       R3, R12
800050d6:	8b 58       	MOV       R4, R11
800050d8:	07 45       	LD        R5, [PC + #7]         ;->0x800050f4  :=0x800086a0
800050da:	05 5c       	LJMP      R5
##@@@F_:xTaskCreateStatic():
##@@@P_:tasks.c:1325
##@@@L1320_:                /* Set the task's affinity before scheduling it. */   
##@@@L1321_:                pxNewTCB->uxCoreAffinityMask = tskNO_AFFINITY;   
##@@@L1322_:            }   
##@@@L1323_:            #endif   
##@@@L1324_:
##@@@L1325_:            prvAddNewTaskToReadyList( pxNewTCB );   
800050dc:	06 58       	MOV       R0, R6
800050de:	07 45       	LD        R5, [PC + #7]         ;->0x800050f8  :=0x800051d8
800050e0:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1334
##@@@L1329_:            mtCOVERAGE_TEST_MARKER();   
##@@@L1330_:        }   
##@@@L1331_:
##@@@L1332_:        traceRETURN_xTaskCreateStatic( xReturn );   
##@@@L1333_:
##@@@L1334_:        return xReturn;   
800050e2:	03 08       	LD.W      R0, [SP + #3]
800050e4:	e4 29       	ADD       SP, #20			;->0x14
800050e6:	7f 5e       	POP       {R6-R12}
800050e8:	0d 5d       	POP       LR
800050ea:	1d 5c       	JMP       LR
800050ec:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
800050f0:	0c 00 00 00 	.long     0x0000000c ->000000012  [!!!@2@:MRET     	@@: NOP      
800050f4:	a0 86 00 80 	.long     0x800086a0 ->-2147449184  [!!!@2@:LDS.H     R10, [R0]	@@: LD.B      R0, [R0]
800050f8:	d8 51 00 80 	.long     0x800051d8 ->-2147462696 
##@@@F_:prvCreateStaticTask():
##@@@P_:tasks.c:1257
##@@@L1252_:                                        StaticTask_t * const pxTaskBuffer,   
##@@@L1253_:                                        TaskHandle_t * const pxCreatedTask )   
##@@@L1254_:    {   
##@@@L1255_:        TCB_t * pxNewTCB;   
##@@@L1256_:
##@@@L1257_:        configASSERT( puxStackBuffer != NULL );   
800050fc:	20 5d       	PUSH      R0
800050fe:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005102:	08 00       	SYNC     SYNC     
80005104:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005108:	08 00       	SYNC     SYNC     
8000510a:	00 5d       	POP       R0
8000510c:	20 5d       	PUSH      R0
8000510e:	21 5d       	PUSH      R1
80005110:	30 45       	LD        R5, [PC + #48]        ;->0x800051d0  :=0x1ff
80005112:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005116:	25 58       	MOV       R1, R5
80005118:	11 68       	NOT       R1, R1
8000511a:	01 69       	ANL       R0, R1
8000511c:	5f 11       	MOV       R5, #31			;->0x001F
8000511e:	25 58       	MOV       R1, R5
80005120:	01 6a       	ORL       R0, R1
80005122:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005126:	08 00       	SYNC     SYNC     
80005128:	01 5d       	POP       R1
8000512a:	00 5d       	POP       R0
8000512c:	20 5d       	PUSH      R0
8000512e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005132:	08 00       	SYNC     SYNC     
80005134:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005138:	08 00       	SYNC     SYNC     
8000513a:	00 5d       	POP       R0
8000513c:	07 00       	BREAK    BREAK    
8000513e:	26 45       	LD        R5, [PC + #38]        ;->0x800051d4  :=0x8000911c
80005140:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1258
##@@@L1258_:        configASSERT( pxTaskBuffer != NULL );   
80005142:	20 5d       	PUSH      R0
80005144:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005148:	08 00       	SYNC     SYNC     
8000514a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000514e:	08 00       	SYNC     SYNC     
80005150:	00 5d       	POP       R0
80005152:	20 5d       	PUSH      R0
80005154:	21 5d       	PUSH      R1
80005156:	1f 45       	LD        R5, [PC + #31]        ;->0x800051d0  :=0x1ff
80005158:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000515c:	25 58       	MOV       R1, R5
8000515e:	11 68       	NOT       R1, R1
80005160:	01 69       	ANL       R0, R1
80005162:	5f 11       	MOV       R5, #31			;->0x001F
80005164:	25 58       	MOV       R1, R5
80005166:	01 6a       	ORL       R0, R1
80005168:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000516c:	08 00       	SYNC     SYNC     
8000516e:	01 5d       	POP       R1
80005170:	00 5d       	POP       R0
80005172:	20 5d       	PUSH      R0
80005174:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005178:	08 00       	SYNC     SYNC     
8000517a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000517e:	08 00       	SYNC     SYNC     
80005180:	00 5d       	POP       R0
80005182:	07 00       	BREAK    BREAK    
80005184:	14 45       	LD        R5, [PC + #20]        ;->0x800051d4  :=0x8000911c
80005186:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1266
##@@@L1261_:        {   
##@@@L1262_:            /* Sanity check that the size of the structure used to declare a   
##@@@L1263_:             * variable of type StaticTask_t equals the size of the real task   
##@@@L1264_:             * structure. */   
##@@@L1265_:            volatile size_t xSize = sizeof( StaticTask_t );   
##@@@L1266_:            configASSERT( xSize == sizeof( TCB_t ) );   
80005188:	20 5d       	PUSH      R0
8000518a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000518e:	08 00       	SYNC     SYNC     
80005190:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005194:	08 00       	SYNC     SYNC     
80005196:	00 5d       	POP       R0
80005198:	20 5d       	PUSH      R0
8000519a:	21 5d       	PUSH      R1
8000519c:	0d 45       	LD        R5, [PC + #13]        ;->0x800051d0  :=0x1ff
8000519e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800051a2:	25 58       	MOV       R1, R5
800051a4:	11 68       	NOT       R1, R1
800051a6:	01 69       	ANL       R0, R1
800051a8:	5f 11       	MOV       R5, #31			;->0x001F
800051aa:	25 58       	MOV       R1, R5
800051ac:	01 6a       	ORL       R0, R1
800051ae:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800051b2:	08 00       	SYNC     SYNC     
800051b4:	01 5d       	POP       R1
800051b6:	00 5d       	POP       R0
800051b8:	20 5d       	PUSH      R0
800051ba:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800051be:	08 00       	SYNC     SYNC     
800051c0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800051c4:	08 00       	SYNC     SYNC     
800051c6:	00 5d       	POP       R0
800051c8:	07 00       	BREAK    BREAK    
800051ca:	03 45       	LD        R5, [PC + #3]         ;->0x800051d4  :=0x8000911c
800051cc:	05 5c       	LJMP      R5
##@@@F_:xTaskCreateStatic():
800051ce:	00 00       	NOP      NOP      
800051d0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800051d4:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800051d8 <prvAddNewTaskToReadyList>:
##@@@F_:prvAddNewTaskToReadyList():
##@@@P_:tasks.c:2012
##@@@L2007_:/*-----------------------------------------------------------*/   
##@@@L2008_:
##@@@L2009_:#if ( configNUMBER_OF_CORES == 1 )   
##@@@L2010_:
##@@@L2011_:    static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )   
##@@@L2012_:    {   
800051d8:	83 5f       	PUSH      {R6-R7,LR}
800051da:	e0 31       	SUB       SP, #16			;->0x10
800051dc:	c0 58       	MOV       R6, R0
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800051de:	20 5d       	PUSH      R0
800051e0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800051e4:	08 00       	SYNC     SYNC     
800051e6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800051ea:	08 00       	SYNC     SYNC     
800051ec:	00 5d       	POP       R0
800051ee:	20 5d       	PUSH      R0
800051f0:	21 5d       	PUSH      R1
800051f2:	7d 45       	LD        R5, [PC + #125]       ;->0x800053e4  :=0x1ff
800051f4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800051f8:	25 58       	MOV       R1, R5
800051fa:	11 68       	NOT       R1, R1
800051fc:	01 69       	ANL       R0, R1
800051fe:	5f 11       	MOV       R5, #31			;->0x001F
80005200:	25 58       	MOV       R1, R5
80005202:	01 6a       	ORL       R0, R1
80005204:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005208:	08 00       	SYNC     SYNC     
8000520a:	01 5d       	POP       R1
8000520c:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
8000520e:	77 42       	LD        R2, [PC + #119]       ;->0x800053e8  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005210:	20 5d       	PUSH      R0
80005212:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005216:	08 00       	SYNC     SYNC     
80005218:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000521c:	08 00       	SYNC     SYNC     
8000521e:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005220:	52 82       	LD.W      R5, [R2]
80005222:	50 38       	CMP       R5, #0			;->0x00
80005224:	07 f0       	JZ        $+7                   ;->0x80005232
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80005226:	72 45       	LD        R5, [PC + #114]       ;->0x800053ec  :=0xd0000040
80005228:	45 82       	LD.W      R4, [R5]
8000522a:	5c 9c       	LD.W      R3, [R4 + #17]
8000522c:	5b c0       	ADD       R3, R3, #1
8000522e:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80005230:	55 82       	LD.W      R5, [R5]
##@@@F_:prvAddNewTaskToReadyList():
##@@@P_:tasks.c:2017
##@@@L2012_:    {   
##@@@L2013_:        /* Ensure interrupts don't access the task lists while the lists are being   
##@@@L2014_:         * updated. */   
##@@@L2015_:        taskENTER_CRITICAL();   
##@@@L2016_:        {   
##@@@L2017_:            uxCurrentNumberOfTasks++;   
80005232:	70 45       	LD        R5, [PC + #112]       ;->0x800053f0  :=0xd0000060
80005234:	45 82       	LD.W      R4, [R5]
80005236:	64 c0       	ADD       R4, R4, #1
##@@@P_:tasks.c:2019
##@@@L2018_:
##@@@L2019_:            if( pxCurrentTCB == NULL )   
80005238:	6d 43       	LD        R3, [PC + #109]       ;->0x800053ec  :=0xd0000040
##@@@P_:tasks.c:2017
##@@@L2012_:    {   
##@@@L2013_:        /* Ensure interrupts don't access the task lists while the lists are being   
##@@@L2014_:         * updated. */   
##@@@L2015_:        taskENTER_CRITICAL();   
##@@@L2016_:        {   
##@@@L2017_:            uxCurrentNumberOfTasks++;   
8000523a:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:2019
##@@@L2018_:
##@@@L2019_:            if( pxCurrentTCB == NULL )   
8000523c:	43 82       	LD.W      R4, [R3]
8000523e:	40 38       	CMP       R4, #0			;->0x00
80005240:	03 22       	ST.W      [SP + #3], R2
80005242:	02 23       	ST.W      [SP + #2], R3
80005244:	0d f0       	JZ        $+13                  ;->0x8000525e
##@@@P_:tasks.c:2042
##@@@L2037_:            else   
##@@@L2038_:            {   
##@@@L2039_:                /* If the scheduler is not already running, make this task the   
##@@@L2040_:                 * current task if it is the highest priority task to be created   
##@@@L2041_:                 * so far. */   
##@@@L2042_:                if( xSchedulerRunning == pdFALSE )   
80005246:	52 82       	LD.W      R5, [R2]
80005248:	50 38       	CMP       R5, #0			;->0x00
8000524a:	02 f0       	JZ        $+2                   ;->0x8000524e
8000524c:	9c 04       	SJMP      $+156                 ;->0x80005384
##@@@P_:tasks.c:2044
##@@@L2043_:                {   
##@@@L2044_:                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )   
8000524e:	53 82       	LD.W      R5, [R3]
80005250:	e6 9a       	LD.W      R4, [R6 + #11]
80005252:	ed 9a       	LD.W      R5, [R5 + #11]
80005254:	54 70       	CMP       R5, R4
80005256:	02 f9       	JLS       $+2                   ;->0x8000525a
80005258:	96 04       	SJMP      $+150                 ;->0x80005384
##@@@P_:tasks.c:2046
##@@@L2045_:                    {   
##@@@L2046_:                        pxCurrentTCB = pxNewTCB;   
8000525a:	36 85       	ST.W      [R3], R6
8000525c:	94 04       	SJMP      $+148                 ;->0x80005384
##@@@P_:tasks.c:2023
##@@@L2018_:
##@@@L2019_:            if( pxCurrentTCB == NULL )   
##@@@L2020_:            {   
##@@@L2021_:                /* There are no other tasks, or all the other tasks are in   
##@@@L2022_:                 * the suspended state - make this the current task. */   
##@@@L2023_:                pxCurrentTCB = pxNewTCB;   
8000525e:	36 85       	ST.W      [R3], R6
##@@@P_:tasks.c:2025
##@@@L2024_:
##@@@L2025_:                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )   
80005260:	55 82       	LD.W      R5, [R5]
80005262:	51 38       	CMP       R5, #1			;->0x01
80005264:	02 f0       	JZ        $+2                   ;->0x80005268
80005266:	8f 04       	SJMP      $+143                 ;->0x80005384
##@@@F_:prvInitialiseTaskLists():
##@@@P_:tasks.c:6056
##@@@L6051_:{   
##@@@L6052_:    UBaseType_t uxPriority;   
##@@@L6053_:
##@@@L6054_:    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )   
##@@@L6055_:    {   
##@@@L6056_:        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );   
80005268:	63 47       	LD        R7, [PC + #99]        ;->0x800053f4  :=0xd00000a0
8000526a:	07 58       	MOV       R0, R7
8000526c:	63 45       	LD        R5, [PC + #99]        ;->0x800053f8  :=0x80002224
8000526e:	05 5c       	LJMP      R5
80005270:	07 58       	MOV       R0, R7
80005272:	04 29       	ADD       R0, #20			;->0x14
80005274:	61 45       	LD        R5, [PC + #97]        ;->0x800053f8  :=0x80002224
80005276:	05 5c       	LJMP      R5
80005278:	07 58       	MOV       R0, R7
8000527a:	08 2a       	ADD       R0, #40			;->0x28
8000527c:	5f 45       	LD        R5, [PC + #95]        ;->0x800053f8  :=0x80002224
8000527e:	05 5c       	LJMP      R5
80005280:	07 58       	MOV       R0, R7
80005282:	0c 2b       	ADD       R0, #60			;->0x3C
80005284:	5d 45       	LD        R5, [PC + #93]        ;->0x800053f8  :=0x80002224
80005286:	05 5c       	LJMP      R5
80005288:	07 58       	MOV       R0, R7
8000528a:	00 2d       	ADD       R0, #80			;->0x50
8000528c:	5b 45       	LD        R5, [PC + #91]        ;->0x800053f8  :=0x80002224
8000528e:	05 5c       	LJMP      R5
80005290:	07 58       	MOV       R0, R7
80005292:	04 2e       	ADD       R0, #100			;->0x64
80005294:	59 45       	LD        R5, [PC + #89]        ;->0x800053f8  :=0x80002224
80005296:	05 5c       	LJMP      R5
80005298:	07 58       	MOV       R0, R7
8000529a:	08 2f       	ADD       R0, #120			;->0x78
8000529c:	57 45       	LD        R5, [PC + #87]        ;->0x800053f8  :=0x80002224
8000529e:	05 5c       	LJMP      R5
800052a0:	5c 18       	MOV       R5, #140			;->0x008C
800052a2:	47 c3       	ADD       R0, R7, R5
800052a4:	55 45       	LD        R5, [PC + #85]        ;->0x800053f8  :=0x80002224
800052a6:	05 5c       	LJMP      R5
800052a8:	50 1a       	MOV       R5, #160			;->0x00A0
800052aa:	47 c3       	ADD       R0, R7, R5
800052ac:	53 45       	LD        R5, [PC + #83]        ;->0x800053f8  :=0x80002224
800052ae:	05 5c       	LJMP      R5
800052b0:	54 1b       	MOV       R5, #180			;->0x00B4
800052b2:	47 c3       	ADD       R0, R7, R5
800052b4:	51 45       	LD        R5, [PC + #81]        ;->0x800053f8  :=0x80002224
800052b6:	05 5c       	LJMP      R5
800052b8:	58 1c       	MOV       R5, #200			;->0x00C8
800052ba:	47 c3       	ADD       R0, R7, R5
800052bc:	4f 45       	LD        R5, [PC + #79]        ;->0x800053f8  :=0x80002224
800052be:	05 5c       	LJMP      R5
800052c0:	5c 1d       	MOV       R5, #220			;->0x00DC
800052c2:	47 c3       	ADD       R0, R7, R5
800052c4:	4d 45       	LD        R5, [PC + #77]        ;->0x800053f8  :=0x80002224
800052c6:	05 5c       	LJMP      R5
800052c8:	50 1f       	MOV       R5, #240			;->0x00F0
800052ca:	47 c3       	ADD       R0, R7, R5
800052cc:	4b 45       	LD        R5, [PC + #75]        ;->0x800053f8  :=0x80002224
800052ce:	05 5c       	LJMP      R5
800052d0:	4b 45       	LD        R5, [PC + #75]        ;->0x800053fc  :=0x104
800052d2:	47 c3       	ADD       R0, R7, R5
800052d4:	49 45       	LD        R5, [PC + #73]        ;->0x800053f8  :=0x80002224
800052d6:	05 5c       	LJMP      R5
800052d8:	4a 45       	LD        R5, [PC + #74]        ;->0x80005400  :=0x118
800052da:	47 c3       	ADD       R0, R7, R5
800052dc:	47 45       	LD        R5, [PC + #71]        ;->0x800053f8  :=0x80002224
800052de:	05 5c       	LJMP      R5
800052e0:	49 45       	LD        R5, [PC + #73]        ;->0x80005404  :=0x12c
800052e2:	47 c3       	ADD       R0, R7, R5
800052e4:	45 45       	LD        R5, [PC + #69]        ;->0x800053f8  :=0x80002224
800052e6:	05 5c       	LJMP      R5
800052e8:	48 45       	LD        R5, [PC + #72]        ;->0x80005408  :=0x140
800052ea:	47 c3       	ADD       R0, R7, R5
800052ec:	43 45       	LD        R5, [PC + #67]        ;->0x800053f8  :=0x80002224
800052ee:	05 5c       	LJMP      R5
800052f0:	47 45       	LD        R5, [PC + #71]        ;->0x8000540c  :=0x154
800052f2:	47 c3       	ADD       R0, R7, R5
800052f4:	41 45       	LD        R5, [PC + #65]        ;->0x800053f8  :=0x80002224
800052f6:	05 5c       	LJMP      R5
800052f8:	46 45       	LD        R5, [PC + #70]        ;->0x80005410  :=0x168
800052fa:	47 c3       	ADD       R0, R7, R5
800052fc:	3f 45       	LD        R5, [PC + #63]        ;->0x800053f8  :=0x80002224
800052fe:	05 5c       	LJMP      R5
80005300:	45 45       	LD        R5, [PC + #69]        ;->0x80005414  :=0x17c
80005302:	47 c3       	ADD       R0, R7, R5
80005304:	3d 45       	LD        R5, [PC + #61]        ;->0x800053f8  :=0x80002224
80005306:	05 5c       	LJMP      R5
80005308:	44 45       	LD        R5, [PC + #68]        ;->0x80005418  :=0x190
8000530a:	47 c3       	ADD       R0, R7, R5
8000530c:	3b 45       	LD        R5, [PC + #59]        ;->0x800053f8  :=0x80002224
8000530e:	05 5c       	LJMP      R5
80005310:	43 45       	LD        R5, [PC + #67]        ;->0x8000541c  :=0x1a4
80005312:	47 c3       	ADD       R0, R7, R5
80005314:	39 45       	LD        R5, [PC + #57]        ;->0x800053f8  :=0x80002224
80005316:	05 5c       	LJMP      R5
80005318:	42 45       	LD        R5, [PC + #66]        ;->0x80005420  :=0x1b8
8000531a:	47 c3       	ADD       R0, R7, R5
8000531c:	37 45       	LD        R5, [PC + #55]        ;->0x800053f8  :=0x80002224
8000531e:	05 5c       	LJMP      R5
80005320:	41 45       	LD        R5, [PC + #65]        ;->0x80005424  :=0x1cc
80005322:	47 c3       	ADD       R0, R7, R5
80005324:	35 45       	LD        R5, [PC + #53]        ;->0x800053f8  :=0x80002224
80005326:	05 5c       	LJMP      R5
80005328:	40 45       	LD        R5, [PC + #64]        ;->0x80005428  :=0x1e0
8000532a:	47 c3       	ADD       R0, R7, R5
8000532c:	33 45       	LD        R5, [PC + #51]        ;->0x800053f8  :=0x80002224
8000532e:	05 5c       	LJMP      R5
80005330:	3f 45       	LD        R5, [PC + #63]        ;->0x8000542c  :=0x1f4
80005332:	47 c3       	ADD       R0, R7, R5
80005334:	31 45       	LD        R5, [PC + #49]        ;->0x800053f8  :=0x80002224
80005336:	05 5c       	LJMP      R5
80005338:	3e 45       	LD        R5, [PC + #62]        ;->0x80005430  :=0x208
8000533a:	47 c3       	ADD       R0, R7, R5
8000533c:	2f 45       	LD        R5, [PC + #47]        ;->0x800053f8  :=0x80002224
8000533e:	05 5c       	LJMP      R5
80005340:	3d 45       	LD        R5, [PC + #61]        ;->0x80005434  :=0x21c
80005342:	47 c3       	ADD       R0, R7, R5
80005344:	2d 45       	LD        R5, [PC + #45]        ;->0x800053f8  :=0x80002224
80005346:	05 5c       	LJMP      R5
80005348:	3c 45       	LD        R5, [PC + #60]        ;->0x80005438  :=0x230
8000534a:	47 c3       	ADD       R0, R7, R5
8000534c:	2b 45       	LD        R5, [PC + #43]        ;->0x800053f8  :=0x80002224
8000534e:	05 5c       	LJMP      R5
80005350:	3b 45       	LD        R5, [PC + #59]        ;->0x8000543c  :=0x244
80005352:	47 c3       	ADD       R0, R7, R5
80005354:	29 45       	LD        R5, [PC + #41]        ;->0x800053f8  :=0x80002224
80005356:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6059
##@@@L6057_:    }   
##@@@L6058_:
##@@@L6059_:    vListInitialise( &xDelayedTaskList1 );   
80005358:	3a 40       	LD        R0, [PC + #58]        ;->0x80005440  :=0xd0000318
8000535a:	01 20       	ST.W      [SP + #1], R0
8000535c:	27 45       	LD        R5, [PC + #39]        ;->0x800053f8  :=0x80002224
8000535e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6060
##@@@L6060_:    vListInitialise( &xDelayedTaskList2 );   
80005360:	39 47       	LD        R7, [PC + #57]        ;->0x80005444  :=0xd000032c
80005362:	07 58       	MOV       R0, R7
80005364:	25 45       	LD        R5, [PC + #37]        ;->0x800053f8  :=0x80002224
80005366:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6061
##@@@L6061_:    vListInitialise( &xPendingReadyList );   
80005368:	38 40       	LD        R0, [PC + #56]        ;->0x80005448  :=0xd0000078
8000536a:	24 45       	LD        R5, [PC + #36]        ;->0x800053f8  :=0x80002224
8000536c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6065
##@@@L6062_:
##@@@L6063_:    #if ( INCLUDE_vTaskDelete == 1 )   
##@@@L6064_:    {   
##@@@L6065_:        vListInitialise( &xTasksWaitingTermination );   
8000536e:	38 40       	LD        R0, [PC + #56]        ;->0x8000544c  :=0xd0000048
80005370:	22 45       	LD        R5, [PC + #34]        ;->0x800053f8  :=0x80002224
80005372:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6071
##@@@L6066_:    }   
##@@@L6067_:    #endif /* INCLUDE_vTaskDelete */   
##@@@L6068_:
##@@@L6069_:    #if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L6070_:    {   
##@@@L6071_:        vListInitialise( &xSuspendedTaskList );   
80005374:	37 40       	LD        R0, [PC + #55]        ;->0x80005450  :=0xd000008c
80005376:	21 45       	LD        R5, [PC + #33]        ;->0x800053f8  :=0x80002224
80005378:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6077
##@@@L6072_:    }   
##@@@L6073_:    #endif /* INCLUDE_vTaskSuspend */   
##@@@L6074_:
##@@@L6075_:    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList   
##@@@L6076_:     * using list2. */   
##@@@L6077_:    pxDelayedTaskList = &xDelayedTaskList1;   
8000537a:	37 45       	LD        R5, [PC + #55]        ;->0x80005454  :=0xd0000070
##@@@P_:tasks.c:6078
##@@@L6078_:    pxOverflowDelayedTaskList = &xDelayedTaskList2;   
8000537c:	37 44       	LD        R4, [PC + #55]        ;->0x80005458  :=0xd0000074
##@@@P_:tasks.c:6077
##@@@L6072_:    }   
##@@@L6073_:    #endif /* INCLUDE_vTaskSuspend */   
##@@@L6074_:
##@@@L6075_:    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList   
##@@@L6076_:     * using list2. */   
##@@@L6077_:    pxDelayedTaskList = &xDelayedTaskList1;   
8000537e:	01 0b       	LD.W      R3, [SP + #1]
80005380:	53 85       	ST.W      [R5], R3
##@@@P_:tasks.c:6078
##@@@L6078_:    pxOverflowDelayedTaskList = &xDelayedTaskList2;   
80005382:	47 85       	ST.W      [R4], R7
##@@@F_:prvAddNewTaskToReadyList():
##@@@P_:tasks.c:2059
##@@@L2054_:                {   
##@@@L2055_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L2056_:                }   
##@@@L2057_:            }   
##@@@L2058_:
##@@@L2059_:            uxTaskNumber++;   
80005384:	36 45       	LD        R5, [PC + #54]        ;->0x8000545c  :=0xd0000044
80005386:	45 82       	LD.W      R4, [R5]
80005388:	64 c0       	ADD       R4, R4, #1
8000538a:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:2064
##@@@L2060_:
##@@@L2061_:            #if ( configUSE_TRACE_FACILITY == 1 )   
##@@@L2062_:            {   
##@@@L2063_:                /* Add a counter into the TCB for tracing only. */   
##@@@L2064_:                pxNewTCB->uxTCBNumber = uxTaskNumber;   
8000538c:	b4 a4       	ST.W      [R6 + #18], R4
##@@@P_:tasks.c:2069
##@@@L2065_:            }   
##@@@L2066_:            #endif /* configUSE_TRACE_FACILITY */   
##@@@L2067_:            traceTASK_CREATE( pxNewTCB );   
##@@@L2068_:
##@@@L2069_:            prvAddTaskToReadyList( pxNewTCB );   
8000538e:	35 44       	LD        R4, [PC + #53]        ;->0x80005460  :=0xd00002f8
80005390:	ee 9a       	LD.W      R5, [R6 + #11]
80005392:	34 82       	LD.W      R3, [R4]
80005394:	53 70       	CMP       R5, R3
80005396:	02 f9       	JLS       $+2                   ;->0x8000539a
80005398:	45 85       	ST.W      [R4], R5
8000539a:	17 44       	LD        R4, [PC + #23]        ;->0x800053f4  :=0xd00000a0
8000539c:	34 11       	MOV       R3, #20			;->0x0014
8000539e:	44 58       	MOV       R2, R4
800053a0:	19 00 a3 08 	MADD32    R2, R5, R3
800053a4:	4a 98       	LD.W      R1, [R2 + #1]
800053a6:	b1 a0       	ST.W      [R6 + #2], R1
800053a8:	81 98       	LD.W      R0, [R1 + #2]
800053aa:	f0 a0       	ST.W      [R6 + #3], R0
800053ac:	81 98       	LD.W      R0, [R1 + #2]
800053ae:	3e c1       	ADD       R7, R6, #4
800053b0:	47 a0       	ST.W      [R0 + #1], R7
800053b2:	8f a0       	ST.W      [R1 + #2], R7
800053b4:	72 a1       	ST.W      [R6 + #5], R2
800053b6:	ed ca       	MULS      R5, R5, R3
800053b8:	5c e9       	LD.W      R3, [R4 + R5]
800053ba:	5b c0       	ADD       R3, R3, #1
800053bc:	63 ef       	ST.W      [R4 + R5], R3
##@@@P_:tasks.c:2073
##@@@L2070_:
##@@@L2071_:            portSETUP_TCB( pxNewTCB );   
##@@@L2072_:        }   
##@@@L2073_:        taskEXIT_CRITICAL();   
800053be:	2a 45       	LD        R5, [PC + #42]        ;->0x80005464  :=0x80005730
800053c0:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2075
##@@@L2074_:
##@@@L2075_:        if( xSchedulerRunning != pdFALSE )   
800053c2:	03 0d       	LD.W      R5, [SP + #3]
800053c4:	55 82       	LD.W      R5, [R5]
800053c6:	50 38       	CMP       R5, #0			;->0x00
800053c8:	09 f0       	JZ        $+9                   ;->0x800053da
##@@@P_:tasks.c:2079
##@@@L2076_:        {   
##@@@L2077_:            /* If the created task is of a higher priority than the current task   
##@@@L2078_:             * then it should run now. */   
##@@@L2079_:            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );   
800053ca:	02 0d       	LD.W      R5, [SP + #2]
800053cc:	55 82       	LD.W      R5, [R5]
800053ce:	e6 9a       	LD.W      R4, [R6 + #11]
800053d0:	ed 9a       	LD.W      R5, [R5 + #11]
800053d2:	54 70       	CMP       R5, R4
800053d4:	03 f2       	JC        $+3                   ;->0x800053da
800053d6:	25 45       	LD        R5, [PC + #37]        ;->0x80005468  :=0x80008f64
800053d8:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2085
##@@@L2080_:        }   
##@@@L2081_:        else   
##@@@L2082_:        {   
##@@@L2083_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2084_:        }   
##@@@L2085_:    }   
800053da:	e0 29       	ADD       SP, #16			;->0x10
800053dc:	03 5e       	POP       {R6-R7}
800053de:	0d 5d       	POP       LR
800053e0:	1d 5c       	JMP       LR
800053e2:	00 00       	NOP      NOP      
800053e4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800053e8:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
800053ec:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800053f0:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
800053f4:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
800053f8:	24 22 00 80 	.long     0x80002224 ->-2147474908  [!!!@2@:ST.W      [SP + #36], R2	@@: LD.B      R0, [R0]
800053fc:	04 01 00 00 	.long     0x00000104 ->000000260  [!!!@2@:CMN       R0, R4	@@: NOP      
80005400:	18 01 00 00 	.long     0x00000118 ->000000280  [!!!@2@:CMN       R1, R8	@@: NOP      
80005404:	2c 01 00 00 	.long     0x0000012c ->000000300  [!!!@2@:CMN       R2, R12	@@: NOP      
80005408:	40 01 00 00 	.long     0x00000140 ->000000320  [!!!@2@:CMN       R4, R0	@@: NOP      
8000540c:	54 01 00 00 	.long     0x00000154 ->000000340  [!!!@2@:CMN       R5, R4	@@: NOP      
80005410:	68 01 00 00 	.long     0x00000168 ->000000360  [!!!@2@:CMN       R6, R8	@@: NOP      
80005414:	7c 01 00 00 	.long     0x0000017c ->000000380  [!!!@2@:CMN       R7, R12	@@: NOP      
80005418:	90 01 00 00 	.long     0x00000190 ->000000400  [!!!@2@:CMN       R9, R0	@@: NOP      
8000541c:	a4 01 00 00 	.long     0x000001a4 ->000000420  [!!!@2@:CMN       R10, R4	@@: NOP      
80005420:	b8 01 00 00 	.long     0x000001b8 ->000000440  [!!!@2@:CMN       R11, R8	@@: NOP      
80005424:	cc 01 00 00 	.long     0x000001cc ->000000460  [!!!@2@:CMN       R12, R12	@@: NOP      
80005428:	e0 01 00 00 	.long     0x000001e0 ->000000480  [!!!@2@:CMN       SP, R0	@@: NOP      
8000542c:	f4 01 00 00 	.long     0x000001f4 ->000000500  [!!!@2@:CMN       PC, R4	@@: NOP      
80005430:	08 02 00 00 	.long     0x00000208 ->000000520 
80005434:	1c 02 00 00 	.long     0x0000021c ->000000540 
80005438:	30 02 00 00 	.long     0x00000230 ->000000560 
8000543c:	44 02 00 00 	.long     0x00000244 ->000000580 
80005440:	18 03 00 d0 	.long     0xd0000318 ->-805305576  [!!!@4@:JMP       $+1626112             ;->0x8031f440
80005444:	2c 03 00 d0 	.long     0xd000032c ->-805305556  [!!!@4@:JMP       $+2936832             ;->0x8059f444
80005448:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
8000544c:	48 00 00 d0 	.long     0xd0000048 ->-805306296  [!!!@4@:LD.H      R0, [R0 + #52]
80005450:	8c 00 00 d0 	.long     0xd000008c ->-805306228  [!!!@4@:LJMP      $+839680              ;->0x8019f450
80005454:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80005458:	74 00 00 d0 	.long     0xd0000074 ->-805306252  [!!!@4@:ST.H      [R0 + #-204], R0
8000545c:	44 00 00 d0 	.long     0xd0000044 ->-805306300  [!!!@4@:LD.W      R0, [R0 + #-204]
80005460:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
80005464:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80005464
80005468:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]

8000546c <xTaskCreate>:
##@@@F_:xTaskCreate():
##@@@P_:tasks.c:1716
##@@@L1711_:                            const char * const pcName,   
##@@@L1712_:                            const configSTACK_DEPTH_TYPE usStackDepth,   
##@@@L1713_:                            void * const pvParameters,   
##@@@L1714_:                            UBaseType_t uxPriority,   
##@@@L1715_:                            TaskHandle_t * const pxCreatedTask )   
##@@@L1716_:    {   
8000546c:	ff 5f       	PUSH      {R6-R12,LR}
8000546e:	e0 31       	SUB       SP, #16			;->0x10
80005470:	64 59       	MOV       R11, R4
80005472:	83 59       	MOV       R12, R3
80005474:	02 59       	MOV       R8, R2
80005476:	21 59       	MOV       R9, R1
80005478:	40 59       	MOV       R10, R0
##@@@F_:prvCreateTask():
##@@@P_:tasks.c:1662
##@@@L1657_:
##@@@L1658_:            /* Allocate space for the stack used by the task being created. */   
##@@@L1659_:            /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L1660_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L1661_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L1662_:            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) );   
8000547a:	02 58       	MOV       R0, R2
8000547c:	02 7a       	LSL       R0, #2			;->0x02
8000547e:	16 45       	LD        R5, [PC + #22]        ;->0x800054d4  :=0x80008960
80005480:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1664
##@@@L1663_:
##@@@L1664_:            if( pxStack != NULL )   
80005482:	00 38       	CMP       R0, #0			;->0x00
80005484:	22 f0       	JZ        $+34                  ;->0x800054c8
80005486:	e0 58       	MOV       R7, R0
80005488:	08 17       	MOV       R0, #120			;->0x0078
##@@@P_:tasks.c:1670
##@@@L1665_:            {   
##@@@L1666_:                /* Allocate space for the TCB. */   
##@@@L1667_:                /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L1668_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L1669_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L1670_:                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );   
8000548a:	13 45       	LD        R5, [PC + #19]        ;->0x800054d4  :=0x80008960
8000548c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1672
##@@@L1671_:
##@@@L1672_:                if( pxNewTCB != NULL )   
8000548e:	00 38       	CMP       R0, #0			;->0x00
80005490:	19 f0       	JZ        $+25                  ;->0x800054c2
80005492:	c0 58       	MOV       R6, R0
80005494:	0c 0d       	LD.W      R5, [SP + #12]
##@@@P_:tasks.c:1674
##@@@L1673_:                {   
##@@@L1674_:                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );   
80005496:	03 25       	ST.W      [SP + #3], R5
80005498:	10 10       	MOV       R1, #0			;->0x0000
8000549a:	28 17       	MOV       R2, #120			;->0x0078
8000549c:	0f 45       	LD        R5, [PC + #15]        ;->0x800054d8  :=0x8000da04
8000549e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1677
##@@@L1675_:
##@@@L1676_:                    /* Store the stack location in the TCB. */   
##@@@L1677_:                    pxNewTCB->pxStack = pxStack;   
800054a0:	37 a3       	ST.W      [R6 + #12], R7
##@@@P_:tasks.c:1703
##@@@L1698_:                 * task was created dynamically in case it is later deleted. */   
##@@@L1699_:                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;   
##@@@L1700_:            }   
##@@@L1701_:            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */   
##@@@L1702_:
##@@@L1703_:            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );   
800054a2:	ae 58       	MOV       R5, SP
800054a4:	03 0c       	LD.W      R4, [SP + #3]
800054a6:	54 85       	ST.W      [R5], R4
800054a8:	6e a0       	ST.W      [R5 + #1], R6
800054aa:	0a 58       	MOV       R0, R10
800054ac:	29 58       	MOV       R1, R9
800054ae:	48 58       	MOV       R2, R8
800054b0:	6c 58       	MOV       R3, R12
800054b2:	8b 58       	MOV       R4, R11
800054b4:	0a 45       	LD        R5, [PC + #10]        ;->0x800054dc  :=0x800086a0
800054b6:	05 5c       	LJMP      R5
##@@@F_:xTaskCreate():
##@@@P_:tasks.c:1733
##@@@L1728_:                /* Set the task's affinity before scheduling it. */   
##@@@L1729_:                pxNewTCB->uxCoreAffinityMask = tskNO_AFFINITY;   
##@@@L1730_:            }   
##@@@L1731_:            #endif   
##@@@L1732_:
##@@@L1733_:            prvAddNewTaskToReadyList( pxNewTCB );   
800054b8:	06 58       	MOV       R0, R6
800054ba:	0a 45       	LD        R5, [PC + #10]        ;->0x800054e0  :=0x800051d8
800054bc:	05 5c       	LJMP      R5
800054be:	01 10       	MOV       R0, #1			;->0x0001
800054c0:	05 04       	SJMP      $+5                   ;->0x800054ca
##@@@F_:prvCreateTask():
##@@@P_:tasks.c:1683
##@@@L1678_:                }   
##@@@L1679_:                else   
##@@@L1680_:                {   
##@@@L1681_:                    /* The stack cannot be used as the TCB was not created.  Free   
##@@@L1682_:                     * it again. */   
##@@@L1683_:                    vPortFreeStack( pxStack );   
800054c2:	07 58       	MOV       R0, R7
800054c4:	08 45       	LD        R5, [PC + #8]         ;->0x800054e4  :=0x80008b9c
800054c6:	05 5c       	LJMP      R5
##@@@F_:xTaskCreate():
800054c8:	08 40       	LD        R0, [PC + #8]         ;->0x800054e8  :=0xffffffff
##@@@P_:tasks.c:1743
##@@@L1738_:            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;   
##@@@L1739_:        }   
##@@@L1740_:
##@@@L1741_:        traceRETURN_xTaskCreate( xReturn );   
##@@@L1742_:
##@@@L1743_:        return xReturn;   
800054ca:	e0 29       	ADD       SP, #16			;->0x10
800054cc:	7f 5e       	POP       {R6-R12}
800054ce:	0d 5d       	POP       LR
800054d0:	1d 5c       	JMP       LR
800054d2:	00 00       	NOP      NOP      
800054d4:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
800054d8:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
800054dc:	a0 86 00 80 	.long     0x800086a0 ->-2147449184  [!!!@2@:LDS.H     R10, [R0]	@@: LD.B      R0, [R0]
800054e0:	d8 51 00 80 	.long     0x800051d8 ->-2147462696 
800054e4:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]
800054e8:	ff ff ff ff 	.long     0xffffffff ->-00000001 

800054ec <vTaskDelete>:
##@@@F_:vTaskDelete():
##@@@P_:tasks.c:2204
##@@@L2199_:/*-----------------------------------------------------------*/   
##@@@L2200_:
##@@@L2201_:#if ( INCLUDE_vTaskDelete == 1 )   
##@@@L2202_:
##@@@L2203_:    void vTaskDelete( TaskHandle_t xTaskToDelete )   
##@@@L2204_:    {   
800054ec:	83 5f       	PUSH      {R6-R7,LR}
800054ee:	ec 30       	SUB       SP, #12			;->0x0C
800054f0:	c0 58       	MOV       R6, R0
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800054f2:	20 5d       	PUSH      R0
800054f4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800054f8:	08 00       	SYNC     SYNC     
800054fa:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800054fe:	08 00       	SYNC     SYNC     
80005500:	00 5d       	POP       R0
80005502:	20 5d       	PUSH      R0
80005504:	21 5d       	PUSH      R1
80005506:	3d 45       	LD        R5, [PC + #61]        ;->0x800055f8  :=0x1ff
80005508:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000550c:	25 58       	MOV       R1, R5
8000550e:	11 68       	NOT       R1, R1
80005510:	01 69       	ANL       R0, R1
80005512:	5f 11       	MOV       R5, #31			;->0x001F
80005514:	25 58       	MOV       R1, R5
80005516:	01 6a       	ORL       R0, R1
80005518:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000551c:	08 00       	SYNC     SYNC     
8000551e:	01 5d       	POP       R1
80005520:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005522:	37 45       	LD        R5, [PC + #55]        ;->0x800055fc  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005524:	20 5d       	PUSH      R0
80005526:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000552a:	08 00       	SYNC     SYNC     
8000552c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005530:	08 00       	SYNC     SYNC     
80005532:	00 5d       	POP       R0
80005534:	01 25       	ST.W      [SP + #1], R5
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005536:	55 82       	LD.W      R5, [R5]
80005538:	50 38       	CMP       R5, #0			;->0x00
8000553a:	07 f0       	JZ        $+7                   ;->0x80005548
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
8000553c:	31 45       	LD        R5, [PC + #49]        ;->0x80005600  :=0xd0000040
8000553e:	45 82       	LD.W      R4, [R5]
80005540:	5c 9c       	LD.W      R3, [R4 + #17]
80005542:	5b c0       	ADD       R3, R3, #1
80005544:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80005546:	55 82       	LD.W      R5, [R5]
##@@@F_:vTaskDelete():
##@@@P_:tasks.c:2213
##@@@L2208_:
##@@@L2209_:        taskENTER_CRITICAL();   
##@@@L2210_:        {   
##@@@L2211_:            /* If null is passed in here then it is the calling task that is   
##@@@L2212_:             * being deleted. */   
##@@@L2213_:            pxTCB = prvGetTCBFromHandle( xTaskToDelete );   
80005548:	60 38       	CMP       R6, #0			;->0x00
8000554a:	03 f1       	JNZ       $+3                   ;->0x80005550
8000554c:	2d 45       	LD        R5, [PC + #45]        ;->0x80005600  :=0xd0000040
8000554e:	65 82       	LD.W      R6, [R5]
##@@@P_:tasks.c:2216
##@@@L2214_:
##@@@L2215_:            /* Remove task from the ready/delayed list. */   
##@@@L2216_:            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
80005550:	3e c1       	ADD       R7, R6, #4
80005552:	07 58       	MOV       R0, R7
80005554:	2c 45       	LD        R5, [PC + #44]        ;->0x80005604  :=0x80002290
80005556:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2226
##@@@L2221_:            {   
##@@@L2222_:                mtCOVERAGE_TEST_MARKER();   
##@@@L2223_:            }   
##@@@L2224_:
##@@@L2225_:            /* Is the task waiting on an event also? */   
##@@@L2226_:            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )   
80005558:	ae 9a       	LD.W      R5, [R6 + #10]
8000555a:	50 38       	CMP       R5, #0			;->0x00
8000555c:	05 f0       	JZ        $+5                   ;->0x80005566
8000555e:	06 58       	MOV       R0, R6
80005560:	08 29       	ADD       R0, #24			;->0x18
##@@@P_:tasks.c:2228
##@@@L2227_:            {   
##@@@L2228_:                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );   
80005562:	29 45       	LD        R5, [PC + #41]        ;->0x80005604  :=0x80002290
80005564:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2239
##@@@L2234_:
##@@@L2235_:            /* Increment the uxTaskNumber also so kernel aware debuggers can   
##@@@L2236_:             * detect that the task lists need re-generating.  This is done before   
##@@@L2237_:             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will   
##@@@L2238_:             * not return. */   
##@@@L2239_:            uxTaskNumber++;   
80005566:	29 45       	LD        R5, [PC + #41]        ;->0x80005608  :=0xd0000044
80005568:	45 82       	LD.W      R4, [R5]
8000556a:	64 c0       	ADD       R4, R4, #1
##@@@P_:tasks.c:2244
##@@@L2240_:
##@@@L2241_:            /* If the task is running (or yielding), we must add it to the   
##@@@L2242_:             * termination list so that an idle task can delete it when it is   
##@@@L2243_:             * no longer running. */   
##@@@L2244_:            if( taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB ) != pdFALSE )   
8000556c:	25 43       	LD        R3, [PC + #37]        ;->0x80005600  :=0xd0000040
##@@@P_:tasks.c:2239
##@@@L2234_:
##@@@L2235_:            /* Increment the uxTaskNumber also so kernel aware debuggers can   
##@@@L2236_:             * detect that the task lists need re-generating.  This is done before   
##@@@L2237_:             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will   
##@@@L2238_:             * not return. */   
##@@@L2239_:            uxTaskNumber++;   
8000556e:	54 85       	ST.W      [R5], R4
80005570:	02 23       	ST.W      [SP + #2], R3
##@@@P_:tasks.c:2244
##@@@L2240_:
##@@@L2241_:            /* If the task is running (or yielding), we must add it to the   
##@@@L2242_:             * termination list so that an idle task can delete it when it is   
##@@@L2243_:             * no longer running. */   
##@@@L2244_:            if( taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB ) != pdFALSE )   
80005572:	53 82       	LD.W      R5, [R3]
80005574:	65 70       	CMP       R6, R5
80005576:	0e f0       	JZ        $+14                  ;->0x80005592
##@@@P_:tasks.c:2276
##@@@L2271_:                    portPRE_TASK_DELETE_HOOK( pxTCB, &( xYieldPendings[ pxTCB->xTaskRunState ] ) );   
##@@@L2272_:                #endif   
##@@@L2273_:            }   
##@@@L2274_:            else   
##@@@L2275_:            {   
##@@@L2276_:                --uxCurrentNumberOfTasks;   
80005578:	25 44       	LD        R4, [PC + #37]        ;->0x8000560c  :=0xd0000060
8000557a:	54 82       	LD.W      R5, [R4]
8000557c:	5d cc       	SUB       R3, R5, #1
##@@@F_:prvResetNextTaskUnblockTime():
##@@@P_:tasks.c:6496
##@@@L6491_:#endif /* INCLUDE_vTaskDelete */   
##@@@L6492_:/*-----------------------------------------------------------*/   
##@@@L6493_:
##@@@L6494_:static void prvResetNextTaskUnblockTime( void )   
##@@@L6495_:{   
##@@@L6496_:    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )   
8000557e:	25 45       	LD        R5, [PC + #37]        ;->0x80005610  :=0xd0000070
##@@@F_:vTaskDelete():
##@@@P_:tasks.c:2276
##@@@L2271_:                    portPRE_TASK_DELETE_HOOK( pxTCB, &( xYieldPendings[ pxTCB->xTaskRunState ] ) );   
##@@@L2272_:                #endif   
##@@@L2273_:            }   
##@@@L2274_:            else   
##@@@L2275_:            {   
##@@@L2276_:                --uxCurrentNumberOfTasks;   
80005580:	43 85       	ST.W      [R4], R3
##@@@F_:prvResetNextTaskUnblockTime():
##@@@P_:tasks.c:6496
##@@@L6491_:#endif /* INCLUDE_vTaskDelete */   
##@@@L6492_:/*-----------------------------------------------------------*/   
##@@@L6493_:
##@@@L6494_:static void prvResetNextTaskUnblockTime( void )   
##@@@L6495_:{   
##@@@L6496_:    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )   
80005582:	45 82       	LD.W      R4, [R5]
80005584:	44 82       	LD.W      R4, [R4]
80005586:	40 38       	CMP       R4, #0			;->0x00
80005588:	0f f0       	JZ        $+15                  ;->0x800055a6
##@@@P_:tasks.c:6510
##@@@L6505_:    {   
##@@@L6506_:        /* The new current delayed list is not empty, get the value of   
##@@@L6507_:         * the item at the head of the delayed list.  This is the time at   
##@@@L6508_:         * which the task at the head of the delayed list should be removed   
##@@@L6509_:         * from the Blocked state. */   
##@@@L6510_:        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );   
8000558a:	55 82       	LD.W      R5, [R5]
8000558c:	ed 98       	LD.W      R5, [R5 + #3]
8000558e:	55 82       	LD.W      R5, [R5]
80005590:	0c 04       	SJMP      $+12                  ;->0x800055a8
##@@@F_:vTaskDelete():
##@@@P_:tasks.c:2252
##@@@L2247_:                 * deleted. This cannot complete when the task is still running   
##@@@L2248_:                 * on a core, as a context switch to another task is required.   
##@@@L2249_:                 * Place the task in the termination list. The idle task will check   
##@@@L2250_:                 * the termination list and free up any memory allocated by the   
##@@@L2251_:                 * scheduler for the TCB and stack of the deleted task. */   
##@@@L2252_:                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );   
80005592:	21 40       	LD        R0, [PC + #33]        ;->0x80005614  :=0xd0000048
80005594:	27 58       	MOV       R1, R7
80005596:	21 45       	LD        R5, [PC + #33]        ;->0x80005618  :=0x80002244
80005598:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2257
##@@@L2253_:
##@@@L2254_:                /* Increment the ucTasksDeleted variable so the idle task knows   
##@@@L2255_:                 * there is a task that has been deleted and that it should therefore   
##@@@L2256_:                 * check the xTasksWaitingTermination list. */   
##@@@L2257_:                ++uxDeletedTasksWaitingCleanUp;   
8000559a:	21 45       	LD        R5, [PC + #33]        ;->0x8000561c  :=0xd000005c
8000559c:	45 82       	LD.W      R4, [R5]
8000559e:	64 c0       	ADD       R4, R4, #1
800055a0:	54 85       	ST.W      [R5], R4
800055a2:	02 0f       	LD.W      R7, [SP + #2]
800055a4:	05 04       	SJMP      $+5                   ;->0x800055ae
800055a6:	1f 45       	LD        R5, [PC + #31]        ;->0x80005620  :=0xffffffff
800055a8:	02 0f       	LD.W      R7, [SP + #2]
##@@@F_:prvResetNextTaskUnblockTime():
800055aa:	1f 44       	LD        R4, [PC + #31]        ;->0x80005624  :=0xd0000300
800055ac:	45 85       	ST.W      [R4], R5
##@@@F_:vTaskDelete():
##@@@P_:tasks.c:2287
##@@@L2282_:            }   
##@@@L2283_:        }   
##@@@L2284_:
##@@@L2285_:        #if ( configNUMBER_OF_CORES == 1 )   
##@@@L2286_:        {   
##@@@L2287_:            taskEXIT_CRITICAL();   
800055ae:	1f 45       	LD        R5, [PC + #31]        ;->0x80005628  :=0x80005730
800055b0:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2292
##@@@L2288_:
##@@@L2289_:            /* If the task is not deleting itself, call prvDeleteTCB from outside of   
##@@@L2290_:             * critical section. If a task deletes itself, prvDeleteTCB is called   
##@@@L2291_:             * from prvCheckTasksWaitingTermination which is called from Idle task. */   
##@@@L2292_:            if( pxTCB != pxCurrentTCB )   
800055b2:	57 82       	LD.W      R5, [R7]
800055b4:	65 70       	CMP       R6, R5
800055b6:	0f f0       	JZ        $+15                  ;->0x800055d4
##@@@F_:prvDeleteTCB():
800055b8:	51 00 c5 d4 	LD.B      R5, [R6 + #117]			;->0x75
##@@@P_:tasks.c:6467
##@@@L6462_:        #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )   
##@@@L6463_:        {   
##@@@L6464_:            /* The task could have been allocated statically or dynamically, so   
##@@@L6465_:             * check what was statically allocated before trying to free the   
##@@@L6466_:             * memory. */   
##@@@L6467_:            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )   
800055bc:	52 38       	CMP       R5, #2			;->0x02
800055be:	0b f0       	JZ        $+11                  ;->0x800055d4
800055c0:	51 38       	CMP       R5, #1			;->0x01
800055c2:	06 f0       	JZ        $+6                   ;->0x800055ce
800055c4:	50 38       	CMP       R5, #0			;->0x00
800055c6:	5c f1       	JNZ       $+92                  ;->0x8000567e
##@@@P_:tasks.c:6471
##@@@L6468_:            {   
##@@@L6469_:                /* Both the stack and TCB were allocated dynamically, so both   
##@@@L6470_:                 * must be freed. */   
##@@@L6471_:                vPortFreeStack( pxTCB->pxStack );   
800055c8:	06 9b       	LD.W      R0, [R6 + #12]
800055ca:	19 45       	LD        R5, [PC + #25]        ;->0x8000562c  :=0x80008b9c
800055cc:	05 5c       	LJMP      R5
800055ce:	06 58       	MOV       R0, R6
800055d0:	17 45       	LD        R5, [PC + #23]        ;->0x8000562c  :=0x80008b9c
800055d2:	05 5c       	LJMP      R5
##@@@F_:vTaskDelete():
##@@@P_:tasks.c:2299
##@@@L2294_:                prvDeleteTCB( pxTCB );   
##@@@L2295_:            }   
##@@@L2296_:
##@@@L2297_:            /* Force a reschedule if it is the currently running task that has just   
##@@@L2298_:             * been deleted. */   
##@@@L2299_:            if( xSchedulerRunning != pdFALSE )   
800055d4:	01 0d       	LD.W      R5, [SP + #1]
800055d6:	55 82       	LD.W      R5, [R5]
800055d8:	50 38       	CMP       R5, #0			;->0x00
800055da:	0a f0       	JZ        $+10                  ;->0x800055ee
##@@@P_:tasks.c:2301
##@@@L2300_:            {   
##@@@L2301_:                if( pxTCB == pxCurrentTCB )   
800055dc:	57 82       	LD.W      R5, [R7]
800055de:	65 70       	CMP       R6, R5
800055e0:	07 f1       	JNZ       $+7                   ;->0x800055ee
##@@@P_:tasks.c:2303
##@@@L2302_:                {   
##@@@L2303_:                    configASSERT( uxSchedulerSuspended == 0 );   
800055e2:	14 45       	LD        R5, [PC + #20]        ;->0x80005630  :=0xd0000068
800055e4:	55 82       	LD.W      R5, [R5]
800055e6:	50 38       	CMP       R5, #0			;->0x00
800055e8:	28 f1       	JNZ       $+40                  ;->0x80005638
##@@@P_:tasks.c:2304
##@@@L2304_:                    portYIELD_WITHIN_API();   
800055ea:	13 45       	LD        R5, [PC + #19]        ;->0x80005634  :=0x80008f64
800055ec:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2341
##@@@L2336_:            taskEXIT_CRITICAL();   
##@@@L2337_:        }   
##@@@L2338_:        #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L2339_:
##@@@L2340_:        traceRETURN_vTaskDelete();   
##@@@L2341_:    }   
800055ee:	ec 28       	ADD       SP, #12			;->0x0C
800055f0:	03 5e       	POP       {R6-R7}
800055f2:	0d 5d       	POP       LR
800055f4:	1d 5c       	JMP       LR
800055f6:	00 00       	NOP      NOP      
800055f8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800055fc:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80005600:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005604:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80005608:	44 00 00 d0 	.long     0xd0000044 ->-805306300  [!!!@4@:LD.W      R0, [R0 + #-204]
8000560c:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
80005610:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80005614:	48 00 00 d0 	.long     0xd0000048 ->-805306296  [!!!@4@:LD.H      R0, [R0 + #52]
80005618:	44 22 00 80 	.long     0x80002244 ->-2147474876  [!!!@2@:ST.W      [SP + #68], R2	@@: LD.B      R0, [R0]
8000561c:	5c 00 00 d0 	.long     0xd000005c ->-805306276  [!!!@4@:LDS.H     R0, [R0 + #-204]
80005620:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80005624:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x8001f624
80005628:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80005628
8000562c:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]
80005630:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80005634:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:2303
##@@@L2298_:             * been deleted. */   
##@@@L2299_:            if( xSchedulerRunning != pdFALSE )   
##@@@L2300_:            {   
##@@@L2301_:                if( pxTCB == pxCurrentTCB )   
##@@@L2302_:                {   
##@@@L2303_:                    configASSERT( uxSchedulerSuspended == 0 );   
80005638:	20 5d       	PUSH      R0
8000563a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000563e:	08 00       	SYNC     SYNC     
80005640:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005644:	08 00       	SYNC     SYNC     
80005646:	00 5d       	POP       R0
80005648:	20 5d       	PUSH      R0
8000564a:	21 5d       	PUSH      R1
8000564c:	1e 45       	LD        R5, [PC + #30]        ;->0x800056c4  :=0x1ff
8000564e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005652:	25 58       	MOV       R1, R5
80005654:	11 68       	NOT       R1, R1
80005656:	01 69       	ANL       R0, R1
80005658:	5f 11       	MOV       R5, #31			;->0x001F
8000565a:	25 58       	MOV       R1, R5
8000565c:	01 6a       	ORL       R0, R1
8000565e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005662:	08 00       	SYNC     SYNC     
80005664:	01 5d       	POP       R1
80005666:	00 5d       	POP       R0
80005668:	20 5d       	PUSH      R0
8000566a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000566e:	08 00       	SYNC     SYNC     
80005670:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005674:	08 00       	SYNC     SYNC     
80005676:	00 5d       	POP       R0
80005678:	07 00       	BREAK    BREAK    
8000567a:	14 45       	LD        R5, [PC + #20]        ;->0x800056c8  :=0x8000911c
8000567c:	05 5c       	LJMP      R5
##@@@F_:prvDeleteTCB():
##@@@P_:tasks.c:6484
##@@@L6479_:            }   
##@@@L6480_:            else   
##@@@L6481_:            {   
##@@@L6482_:                /* Neither the stack nor the TCB were allocated dynamically, so   
##@@@L6483_:                 * nothing needs to be freed. */   
##@@@L6484_:                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );   
8000567e:	20 5d       	PUSH      R0
80005680:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005684:	08 00       	SYNC     SYNC     
80005686:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000568a:	08 00       	SYNC     SYNC     
8000568c:	00 5d       	POP       R0
8000568e:	20 5d       	PUSH      R0
80005690:	21 5d       	PUSH      R1
80005692:	0d 45       	LD        R5, [PC + #13]        ;->0x800056c4  :=0x1ff
80005694:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005698:	25 58       	MOV       R1, R5
8000569a:	11 68       	NOT       R1, R1
8000569c:	01 69       	ANL       R0, R1
8000569e:	5f 11       	MOV       R5, #31			;->0x001F
800056a0:	25 58       	MOV       R1, R5
800056a2:	01 6a       	ORL       R0, R1
800056a4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800056a8:	08 00       	SYNC     SYNC     
800056aa:	01 5d       	POP       R1
800056ac:	00 5d       	POP       R0
800056ae:	20 5d       	PUSH      R0
800056b0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800056b4:	08 00       	SYNC     SYNC     
800056b6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800056ba:	08 00       	SYNC     SYNC     
800056bc:	00 5d       	POP       R0
800056be:	07 00       	BREAK    BREAK    
800056c0:	02 45       	LD        R5, [PC + #2]         ;->0x800056c8  :=0x8000911c
800056c2:	05 5c       	LJMP      R5
##@@@F_:vTaskDelete():
800056c4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800056c8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800056cc <vTaskEnterCritical>:
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800056cc:	20 5d       	PUSH      R0
800056ce:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800056d2:	08 00       	SYNC     SYNC     
800056d4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800056d8:	08 00       	SYNC     SYNC     
800056da:	00 5d       	POP       R0
800056dc:	20 5d       	PUSH      R0
800056de:	21 5d       	PUSH      R1
800056e0:	11 45       	LD        R5, [PC + #17]        ;->0x80005724  :=0x1ff
800056e2:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800056e6:	25 58       	MOV       R1, R5
800056e8:	11 68       	NOT       R1, R1
800056ea:	01 69       	ANL       R0, R1
800056ec:	5f 11       	MOV       R5, #31			;->0x001F
800056ee:	25 58       	MOV       R1, R5
800056f0:	01 6a       	ORL       R0, R1
800056f2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800056f6:	08 00       	SYNC     SYNC     
800056f8:	01 5d       	POP       R1
800056fa:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
800056fc:	0b 45       	LD        R5, [PC + #11]        ;->0x80005728  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800056fe:	20 5d       	PUSH      R0
80005700:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005704:	08 00       	SYNC     SYNC     
80005706:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000570a:	08 00       	SYNC     SYNC     
8000570c:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
8000570e:	55 82       	LD.W      R5, [R5]
80005710:	50 38       	CMP       R5, #0			;->0x00
80005712:	07 f0       	JZ        $+7                   ;->0x80005720
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80005714:	06 45       	LD        R5, [PC + #6]         ;->0x8000572c  :=0xd0000040
80005716:	45 82       	LD.W      R4, [R5]
80005718:	5c 9c       	LD.W      R3, [R4 + #17]
8000571a:	5b c0       	ADD       R3, R3, #1
8000571c:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
8000571e:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:6983
##@@@L6978_:        {   
##@@@L6979_:            mtCOVERAGE_TEST_MARKER();   
##@@@L6980_:        }   
##@@@L6981_:
##@@@L6982_:        traceRETURN_vTaskEnterCritical();   
##@@@L6983_:    }   
80005720:	1d 5c       	JMP       LR
80005722:	00 00       	NOP      NOP      
80005724:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005728:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
8000572c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]

80005730 <vTaskExitCritical>:
##@@@F_:vTaskExitCritical():
##@@@P_:tasks.c:7073
##@@@L7068_:/*-----------------------------------------------------------*/   
##@@@L7069_:
##@@@L7070_:#if ( ( portCRITICAL_NESTING_IN_TCB == 1 ) && ( configNUMBER_OF_CORES == 1 ) )   
##@@@L7071_:
##@@@L7072_:    void vTaskExitCritical( void )   
##@@@L7073_:    {   
80005730:	2d 5d       	PUSH      LR
80005732:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:7076
##@@@L7074_:        traceENTER_vTaskExitCritical();   
##@@@L7075_:
##@@@L7076_:        if( xSchedulerRunning != pdFALSE )   
80005734:	1b 45       	LD        R5, [PC + #27]        ;->0x800057a0  :=0xd0000064
80005736:	55 82       	LD.W      R5, [R5]
80005738:	50 38       	CMP       R5, #0			;->0x00
8000573a:	2f f0       	JZ        $+47                  ;->0x80005798
##@@@P_:tasks.c:7080
##@@@L7077_:        {   
##@@@L7078_:            /* If pxCurrentTCB->uxCriticalNesting is zero then this function   
##@@@L7079_:             * does not match a previous call to vTaskEnterCritical(). */   
##@@@L7080_:            configASSERT( pxCurrentTCB->uxCriticalNesting > 0U );   
8000573c:	1a 45       	LD        R5, [PC + #26]        ;->0x800057a4  :=0xd0000040
8000573e:	45 82       	LD.W      R4, [R5]
80005740:	64 9c       	LD.W      R4, [R4 + #17]
80005742:	40 38       	CMP       R4, #0			;->0x00
80005744:	34 f0       	JZ        $+52                  ;->0x800057ac
##@@@P_:tasks.c:7086
##@@@L7081_:
##@@@L7082_:            /* This function should not be called in ISR. Use vTaskExitCriticalFromISR   
##@@@L7083_:             * to exit critical section from ISR. */   
##@@@L7084_:            portASSERT_IF_IN_ISR();   
##@@@L7085_:
##@@@L7086_:            if( pxCurrentTCB->uxCriticalNesting > 0U )   
80005746:	45 82       	LD.W      R4, [R5]
80005748:	64 9c       	LD.W      R4, [R4 + #17]
8000574a:	40 38       	CMP       R4, #0			;->0x00
8000574c:	26 f0       	JZ        $+38                  ;->0x80005798
##@@@P_:tasks.c:7088
##@@@L7087_:            {   
##@@@L7088_:                ( pxCurrentTCB->uxCriticalNesting )--;   
8000574e:	45 82       	LD.W      R4, [R5]
80005750:	5c 9c       	LD.W      R3, [R4 + #17]
80005752:	5b cc       	SUB       R3, R3, #1
80005754:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:7090
##@@@L7089_:
##@@@L7090_:                if( pxCurrentTCB->uxCriticalNesting == 0U )   
80005756:	55 82       	LD.W      R5, [R5]
80005758:	6d 9c       	LD.W      R5, [R5 + #17]
8000575a:	50 38       	CMP       R5, #0			;->0x00
8000575c:	1e f1       	JNZ       $+30                  ;->0x80005798
##@@@P_:tasks.c:7092
##@@@L7091_:                {   
##@@@L7092_:                    portENABLE_INTERRUPTS();   
8000575e:	20 5d       	PUSH      R0
80005760:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005764:	08 00       	SYNC     SYNC     
80005766:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000576a:	08 00       	SYNC     SYNC     
8000576c:	00 5d       	POP       R0
8000576e:	20 5d       	PUSH      R0
80005770:	21 5d       	PUSH      R1
80005772:	0e 45       	LD        R5, [PC + #14]        ;->0x800057a8  :=0x1ff
80005774:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005778:	25 58       	MOV       R1, R5
8000577a:	11 68       	NOT       R1, R1
8000577c:	01 69       	ANL       R0, R1
8000577e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005782:	08 00       	SYNC     SYNC     
80005784:	01 5d       	POP       R1
80005786:	00 5d       	POP       R0
80005788:	20 5d       	PUSH      R0
8000578a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000578e:	08 00       	SYNC     SYNC     
80005790:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005794:	08 00       	SYNC     SYNC     
80005796:	00 5d       	POP       R0
##@@@P_:tasks.c:7110
##@@@L7105_:        {   
##@@@L7106_:            mtCOVERAGE_TEST_MARKER();   
##@@@L7107_:        }   
##@@@L7108_:
##@@@L7109_:        traceRETURN_vTaskExitCritical();   
##@@@L7110_:    }   
80005798:	e4 28       	ADD       SP, #4			;->0x04
8000579a:	0d 5d       	POP       LR
8000579c:	1d 5c       	JMP       LR
8000579e:	00 00       	NOP      NOP      
800057a0:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
800057a4:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800057a8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
##@@@P_:tasks.c:7080
##@@@L7075_:
##@@@L7076_:        if( xSchedulerRunning != pdFALSE )   
##@@@L7077_:        {   
##@@@L7078_:            /* If pxCurrentTCB->uxCriticalNesting is zero then this function   
##@@@L7079_:             * does not match a previous call to vTaskEnterCritical(). */   
##@@@L7080_:            configASSERT( pxCurrentTCB->uxCriticalNesting > 0U );   
800057ac:	20 5d       	PUSH      R0
800057ae:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800057b2:	08 00       	SYNC     SYNC     
800057b4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800057b8:	08 00       	SYNC     SYNC     
800057ba:	00 5d       	POP       R0
800057bc:	20 5d       	PUSH      R0
800057be:	21 5d       	PUSH      R1
800057c0:	0d 45       	LD        R5, [PC + #13]        ;->0x800057f4  :=0x1ff
800057c2:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800057c6:	25 58       	MOV       R1, R5
800057c8:	11 68       	NOT       R1, R1
800057ca:	01 69       	ANL       R0, R1
800057cc:	5f 11       	MOV       R5, #31			;->0x001F
800057ce:	25 58       	MOV       R1, R5
800057d0:	01 6a       	ORL       R0, R1
800057d2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800057d6:	08 00       	SYNC     SYNC     
800057d8:	01 5d       	POP       R1
800057da:	00 5d       	POP       R0
800057dc:	20 5d       	PUSH      R0
800057de:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800057e2:	08 00       	SYNC     SYNC     
800057e4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800057e8:	08 00       	SYNC     SYNC     
800057ea:	00 5d       	POP       R0
800057ec:	07 00       	BREAK    BREAK    
800057ee:	03 45       	LD        R5, [PC + #3]         ;->0x800057f8  :=0x8000911c
800057f0:	05 5c       	LJMP      R5
800057f2:	00 00       	NOP      NOP      
800057f4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800057f8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800057fc <xTaskDelayUntil>:
##@@@F_:xTaskDelayUntil():
##@@@P_:tasks.c:2350
##@@@L2345_:
##@@@L2346_:#if ( INCLUDE_xTaskDelayUntil == 1 )   
##@@@L2347_:
##@@@L2348_:    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,   
##@@@L2349_:                                const TickType_t xTimeIncrement )   
##@@@L2350_:    {   
800057fc:	8f 5f       	PUSH      {R6-R9,LR}
800057fe:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:tasks.c:2356
##@@@L2351_:        TickType_t xTimeToWake;   
##@@@L2352_:        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;   
##@@@L2353_:
##@@@L2354_:        traceENTER_xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );   
##@@@L2355_:
##@@@L2356_:        configASSERT( pxPreviousWakeTime );   
80005800:	00 38       	CMP       R0, #0			;->0x00
80005802:	02 f1       	JNZ       $+2                   ;->0x80005806
80005804:	68 04       	SJMP      $+104                 ;->0x800058d4
##@@@P_:tasks.c:2357
##@@@L2357_:        configASSERT( ( xTimeIncrement > 0U ) );   
80005806:	10 38       	CMP       R1, #0			;->0x00
80005808:	02 f1       	JNZ       $+2                   ;->0x8000580c
8000580a:	88 04       	SJMP      $+136                 ;->0x8000591a
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
8000580c:	28 44       	LD        R4, [PC + #40]        ;->0x800058ac  :=0xd0000068
8000580e:	54 82       	LD.W      R5, [R4]
80005810:	6d c0       	ADD       R5, R5, #1
80005812:	45 85       	ST.W      [R4], R5
##@@@F_:xTaskDelayUntil():
##@@@P_:tasks.c:2363
##@@@L2358_:
##@@@L2359_:        vTaskSuspendAll();   
##@@@L2360_:        {   
##@@@L2361_:            /* Minor optimisation.  The tick count cannot change in this   
##@@@L2362_:             * block. */   
##@@@L2363_:            const TickType_t xConstTickCount = xTickCount;   
80005814:	27 45       	LD        R5, [PC + #39]        ;->0x800058b0  :=0xd000006c
80005816:	75 82       	LD.W      R7, [R5]
##@@@P_:tasks.c:2365
##@@@L2364_:
##@@@L2365_:            configASSERT( uxSchedulerSuspended == 1U );   
80005818:	44 82       	LD.W      R4, [R4]
8000581a:	41 38       	CMP       R4, #1			;->0x01
8000581c:	02 f0       	JZ        $+2                   ;->0x80005820
8000581e:	a1 04       	SJMP      $+161                 ;->0x80005960
##@@@P_:tasks.c:2368
##@@@L2366_:
##@@@L2367_:            /* Generate the tick time at which the task wants to wake. */   
##@@@L2368_:            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;   
80005820:	40 82       	LD.W      R4, [R0]
80005822:	74 c2       	ADD       R6, R4, R1
##@@@P_:tasks.c:2370
##@@@L2369_:
##@@@L2370_:            if( xConstTickCount < *pxPreviousWakeTime )   
80005824:	74 70       	CMP       R7, R4
80005826:	08 f2       	JC        $+8                   ;->0x80005836
80005828:	80 10       	MOV       R8, #0			;->0x0000
##@@@P_:tasks.c:2404
##@@@L2399_:            }   
##@@@L2400_:
##@@@L2401_:            /* Update the wake time ready for the next call. */   
##@@@L2402_:            *pxPreviousWakeTime = xTimeToWake;   
##@@@L2403_:
##@@@L2404_:            if( xShouldDelay != pdFALSE )   
8000582a:	64 70       	CMP       R6, R4
##@@@P_:tasks.c:2402
##@@@L2397_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L2398_:                }   
##@@@L2399_:            }   
##@@@L2400_:
##@@@L2401_:            /* Update the wake time ready for the next call. */   
##@@@L2402_:            *pxPreviousWakeTime = xTimeToWake;   
8000582c:	06 85       	ST.W      [R0], R6
##@@@P_:tasks.c:2404
##@@@L2403_:
##@@@L2404_:            if( xShouldDelay != pdFALSE )   
8000582e:	33 f2       	JC        $+51                  ;->0x80005894
80005830:	67 70       	CMP       R6, R7
80005832:	09 f8       	JHI       $+9                   ;->0x80005844
80005834:	30 04       	SJMP      $+48                  ;->0x80005894
80005836:	64 70       	CMP       R6, R4
##@@@P_:tasks.c:2402
##@@@L2397_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L2398_:                }   
##@@@L2399_:            }   
##@@@L2400_:
##@@@L2401_:            /* Update the wake time ready for the next call. */   
##@@@L2402_:            *pxPreviousWakeTime = xTimeToWake;   
80005838:	06 85       	ST.W      [R0], R6
##@@@P_:tasks.c:2404
##@@@L2403_:
##@@@L2404_:            if( xShouldDelay != pdFALSE )   
8000583a:	05 f3       	JNC       $+5                   ;->0x80005844
8000583c:	67 70       	CMP       R6, R7
8000583e:	03 f8       	JHI       $+3                   ;->0x80005844
80005840:	80 10       	MOV       R8, #0			;->0x0000
80005842:	29 04       	SJMP      $+41                  ;->0x80005894
##@@@F_:prvAddCurrentTaskToDelayedList():
##@@@P_:tasks.c:8481
##@@@L8476_:static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,   
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
80005844:	1c 44       	LD        R4, [PC + #28]        ;->0x800058b4  :=0xd0000070
##@@@P_:tasks.c:8480
##@@@L8475_:
##@@@L8476_:static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,   
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
80005846:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:8481
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
80005848:	01 25       	ST.W      [SP + #1], R5
8000584a:	94 82       	LD.W      R9, [R4]
##@@@P_:tasks.c:8482
##@@@L8482_:    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;   
8000584c:	1b 45       	LD        R5, [PC + #27]        ;->0x800058b8  :=0xd0000074
##@@@P_:tasks.c:8495
##@@@L8490_:    }   
##@@@L8491_:    #endif   
##@@@L8492_:
##@@@L8493_:    /* Remove the task from the ready list before adding it to the blocked list   
##@@@L8494_:     * as the same list item is used for both lists. */   
##@@@L8495_:    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
8000584e:	1c 44       	LD        R4, [PC + #28]        ;->0x800058bc  :=0xd0000040
##@@@P_:tasks.c:8482
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
##@@@L8482_:    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;   
80005850:	85 82       	LD.W      R8, [R5]
80005852:	02 24       	ST.W      [SP + #2], R4
##@@@P_:tasks.c:8495
##@@@L8490_:    }   
##@@@L8491_:    #endif   
##@@@L8492_:
##@@@L8493_:    /* Remove the task from the ready list before adding it to the blocked list   
##@@@L8494_:     * as the same list item is used for both lists. */   
##@@@L8495_:    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
80005854:	54 82       	LD.W      R5, [R4]
80005856:	05 c1       	ADD       R0, R5, #4
80005858:	1a 45       	LD        R5, [PC + #26]        ;->0x800058c0  :=0x80002290
8000585a:	05 5c       	LJMP      R5
##@@@F_:xTaskDelayUntil():
##@@@P_:tasks.c:2410
##@@@L2405_:            {   
##@@@L2406_:                traceTASK_DELAY_UNTIL( xTimeToWake );   
##@@@L2407_:
##@@@L2408_:                /* prvAddCurrentTaskToDelayedList() needs the block time, not   
##@@@L2409_:                 * the time to wake, so subtract the current tick count. */   
##@@@L2410_:                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );   
8000585c:	ee c7       	SUB       R5, R6, R7
8000585e:	01 0c       	LD.W      R4, [SP + #1]
##@@@F_:prvAddCurrentTaskToDelayedList():
##@@@P_:tasks.c:8520
##@@@L8515_:        else   
##@@@L8516_:        {   
##@@@L8517_:            /* Calculate the time at which the task should be woken if the event   
##@@@L8518_:             * does not occur.  This may overflow but this doesn't matter, the   
##@@@L8519_:             * kernel will manage it correctly. */   
##@@@L8520_:            xTimeToWake = xConstTickCount + xTicksToWait;   
80005860:	74 c3       	ADD       R6, R4, R5
80005862:	64 70       	CMP       R6, R4
80005864:	03 f3       	JNC       $+3                   ;->0x8000586a
80005866:	50 10       	MOV       R5, #0			;->0x0000
80005868:	02 04       	SJMP      $+2                   ;->0x8000586c
8000586a:	51 10       	MOV       R5, #1			;->0x0001
8000586c:	02 0b       	LD.W      R3, [SP + #2]
##@@@P_:tasks.c:8523
##@@@L8521_:
##@@@L8522_:            /* The list item will be inserted in wake time order. */   
##@@@L8523_:            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );   
8000586e:	43 82       	LD.W      R4, [R3]
80005870:	66 a0       	ST.W      [R4 + #1], R6
80005872:	43 82       	LD.W      R4, [R3]
80005874:	0c c1       	ADD       R1, R4, #4
##@@@P_:tasks.c:8525
##@@@L8524_:
##@@@L8525_:            if( xTimeToWake < xConstTickCount )   
80005876:	51 38       	CMP       R5, #1			;->0x01
80005878:	05 f1       	JNZ       $+5                   ;->0x80005882
##@@@P_:tasks.c:8530
##@@@L8526_:            {   
##@@@L8527_:                /* Wake time has overflowed.  Place this item in the overflow   
##@@@L8528_:                 * list. */   
##@@@L8529_:                traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();   
##@@@L8530_:                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );   
8000587a:	08 58       	MOV       R0, R8
8000587c:	12 45       	LD        R5, [PC + #18]        ;->0x800058c4  :=0x8000225c
8000587e:	05 5c       	LJMP      R5
80005880:	09 04       	SJMP      $+9                   ;->0x80005892
##@@@P_:tasks.c:8537
##@@@L8532_:            else   
##@@@L8533_:            {   
##@@@L8534_:                /* The wake time has not overflowed, so the current block list   
##@@@L8535_:                 * is used. */   
##@@@L8536_:                traceMOVED_TASK_TO_DELAYED_LIST();   
##@@@L8537_:                vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );   
80005882:	09 58       	MOV       R0, R9
80005884:	10 45       	LD        R5, [PC + #16]        ;->0x800058c4  :=0x8000225c
80005886:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8542
##@@@L8538_:
##@@@L8539_:                /* If the task entering the blocked state was placed at the   
##@@@L8540_:                 * head of the list of blocked tasks then xNextTaskUnblockTime   
##@@@L8541_:                 * needs to be updated too. */   
##@@@L8542_:                if( xTimeToWake < xNextTaskUnblockTime )   
80005888:	10 45       	LD        R5, [PC + #16]        ;->0x800058c8  :=0xd0000300
8000588a:	45 82       	LD.W      R4, [R5]
8000588c:	64 70       	CMP       R6, R4
8000588e:	02 f2       	JC        $+2                   ;->0x80005892
##@@@P_:tasks.c:8544
##@@@L8543_:                {   
##@@@L8544_:                    xNextTaskUnblockTime = xTimeToWake;   
80005890:	56 85       	ST.W      [R5], R6
##@@@F_:xTaskDelayUntil():
80005892:	81 10       	MOV       R8, #1			;->0x0001
##@@@P_:tasks.c:2417
##@@@L2412_:            else   
##@@@L2413_:            {   
##@@@L2414_:                mtCOVERAGE_TEST_MARKER();   
##@@@L2415_:            }   
##@@@L2416_:        }   
##@@@L2417_:        xAlreadyYielded = xTaskResumeAll();   
80005894:	0e 45       	LD        R5, [PC + #14]        ;->0x800058cc  :=0x80005a70
80005896:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2421
##@@@L2418_:
##@@@L2419_:        /* Force a reschedule if xTaskResumeAll has not already done so, we may   
##@@@L2420_:         * have put ourselves to sleep. */   
##@@@L2421_:        if( xAlreadyYielded == pdFALSE )   
80005898:	00 38       	CMP       R0, #0			;->0x00
8000589a:	03 f1       	JNZ       $+3                   ;->0x800058a0
##@@@P_:tasks.c:2423
##@@@L2422_:        {   
##@@@L2423_:            taskYIELD_WITHIN_API();   
8000589c:	0d 45       	LD        R5, [PC + #13]        ;->0x800058d0  :=0x80008f64
8000589e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2432
##@@@L2427_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2428_:        }   
##@@@L2429_:
##@@@L2430_:        traceRETURN_xTaskDelayUntil( xShouldDelay );   
##@@@L2431_:
##@@@L2432_:        return xShouldDelay;   
800058a0:	08 58       	MOV       R0, R8
800058a2:	ec 28       	ADD       SP, #12			;->0x0C
800058a4:	0f 5e       	POP       {R6-R9}
800058a6:	0d 5d       	POP       LR
800058a8:	1d 5c       	JMP       LR
800058aa:	00 00       	NOP      NOP      
800058ac:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800058b0:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
800058b4:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
800058b8:	74 00 00 d0 	.long     0xd0000074 ->-805306252  [!!!@4@:ST.H      [R0 + #-204], R0
800058bc:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800058c0:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
800058c4:	5c 22 00 80 	.long     0x8000225c ->-2147474852  [!!!@2@:ST.W      [SP + #92], R2	@@: LD.B      R0, [R0]
800058c8:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x8001f8c8
800058cc:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
800058d0:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:2356
##@@@L2351_:        TickType_t xTimeToWake;   
##@@@L2352_:        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;   
##@@@L2353_:
##@@@L2354_:        traceENTER_xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );   
##@@@L2355_:
##@@@L2356_:        configASSERT( pxPreviousWakeTime );   
800058d4:	20 5d       	PUSH      R0
800058d6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800058da:	08 00       	SYNC     SYNC     
800058dc:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800058e0:	08 00       	SYNC     SYNC     
800058e2:	00 5d       	POP       R0
800058e4:	20 5d       	PUSH      R0
800058e6:	21 5d       	PUSH      R1
800058e8:	30 45       	LD        R5, [PC + #48]        ;->0x800059a8  :=0x1ff
800058ea:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800058ee:	25 58       	MOV       R1, R5
800058f0:	11 68       	NOT       R1, R1
800058f2:	01 69       	ANL       R0, R1
800058f4:	5f 11       	MOV       R5, #31			;->0x001F
800058f6:	25 58       	MOV       R1, R5
800058f8:	01 6a       	ORL       R0, R1
800058fa:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800058fe:	08 00       	SYNC     SYNC     
80005900:	01 5d       	POP       R1
80005902:	00 5d       	POP       R0
80005904:	20 5d       	PUSH      R0
80005906:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000590a:	08 00       	SYNC     SYNC     
8000590c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005910:	08 00       	SYNC     SYNC     
80005912:	00 5d       	POP       R0
80005914:	07 00       	BREAK    BREAK    
80005916:	26 45       	LD        R5, [PC + #38]        ;->0x800059ac  :=0x8000911c
80005918:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2357
##@@@L2357_:        configASSERT( ( xTimeIncrement > 0U ) );   
8000591a:	20 5d       	PUSH      R0
8000591c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005920:	08 00       	SYNC     SYNC     
80005922:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005926:	08 00       	SYNC     SYNC     
80005928:	00 5d       	POP       R0
8000592a:	20 5d       	PUSH      R0
8000592c:	21 5d       	PUSH      R1
8000592e:	1f 45       	LD        R5, [PC + #31]        ;->0x800059a8  :=0x1ff
80005930:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005934:	25 58       	MOV       R1, R5
80005936:	11 68       	NOT       R1, R1
80005938:	01 69       	ANL       R0, R1
8000593a:	5f 11       	MOV       R5, #31			;->0x001F
8000593c:	25 58       	MOV       R1, R5
8000593e:	01 6a       	ORL       R0, R1
80005940:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005944:	08 00       	SYNC     SYNC     
80005946:	01 5d       	POP       R1
80005948:	00 5d       	POP       R0
8000594a:	20 5d       	PUSH      R0
8000594c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005950:	08 00       	SYNC     SYNC     
80005952:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005956:	08 00       	SYNC     SYNC     
80005958:	00 5d       	POP       R0
8000595a:	07 00       	BREAK    BREAK    
8000595c:	14 45       	LD        R5, [PC + #20]        ;->0x800059ac  :=0x8000911c
8000595e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2365
##@@@L2360_:        {   
##@@@L2361_:            /* Minor optimisation.  The tick count cannot change in this   
##@@@L2362_:             * block. */   
##@@@L2363_:            const TickType_t xConstTickCount = xTickCount;   
##@@@L2364_:
##@@@L2365_:            configASSERT( uxSchedulerSuspended == 1U );   
80005960:	20 5d       	PUSH      R0
80005962:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005966:	08 00       	SYNC     SYNC     
80005968:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000596c:	08 00       	SYNC     SYNC     
8000596e:	00 5d       	POP       R0
80005970:	20 5d       	PUSH      R0
80005972:	21 5d       	PUSH      R1
80005974:	0d 45       	LD        R5, [PC + #13]        ;->0x800059a8  :=0x1ff
80005976:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000597a:	25 58       	MOV       R1, R5
8000597c:	11 68       	NOT       R1, R1
8000597e:	01 69       	ANL       R0, R1
80005980:	5f 11       	MOV       R5, #31			;->0x001F
80005982:	25 58       	MOV       R1, R5
80005984:	01 6a       	ORL       R0, R1
80005986:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000598a:	08 00       	SYNC     SYNC     
8000598c:	01 5d       	POP       R1
8000598e:	00 5d       	POP       R0
80005990:	20 5d       	PUSH      R0
80005992:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005996:	08 00       	SYNC     SYNC     
80005998:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000599c:	08 00       	SYNC     SYNC     
8000599e:	00 5d       	POP       R0
800059a0:	07 00       	BREAK    BREAK    
800059a2:	03 45       	LD        R5, [PC + #3]         ;->0x800059ac  :=0x8000911c
800059a4:	05 5c       	LJMP      R5
800059a6:	00 00       	NOP      NOP      
800059a8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800059ac:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800059b0 <vTaskSuspendAll>:
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
800059b0:	03 45       	LD        R5, [PC + #3]         ;->0x800059bc  :=0xd0000068
800059b2:	45 82       	LD.W      R4, [R5]
800059b4:	64 c0       	ADD       R4, R4, #1
800059b6:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:3856
##@@@L3851_:        }   
##@@@L3852_:    }   
##@@@L3853_:    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L3854_:
##@@@L3855_:    traceRETURN_vTaskSuspendAll();   
##@@@L3856_:}   
800059b8:	1d 5c       	JMP       LR
800059ba:	00 00       	NOP      NOP      
800059bc:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0

800059c0 <prvAddCurrentTaskToDelayedList>:
##@@@F_:prvAddCurrentTaskToDelayedList():
##@@@P_:tasks.c:8478
##@@@L8473_:#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */   
##@@@L8474_:/*-----------------------------------------------------------*/   
##@@@L8475_:
##@@@L8476_:static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,   
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
800059c0:	9f 5f       	PUSH      {R6-R10,LR}
800059c2:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:tasks.c:8480
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
800059c4:	22 45       	LD        R5, [PC + #34]        ;->0x80005a4c  :=0xd000006c
##@@@P_:tasks.c:8481
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
800059c6:	23 44       	LD        R4, [PC + #35]        ;->0x80005a50  :=0xd0000070
##@@@P_:tasks.c:8480
##@@@L8475_:
##@@@L8476_:static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,   
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
800059c8:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:8481
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
800059ca:	01 25       	ST.W      [SP + #1], R5
800059cc:	84 82       	LD.W      R8, [R4]
##@@@P_:tasks.c:8482
##@@@L8482_:    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;   
800059ce:	22 45       	LD        R5, [PC + #34]        ;->0x80005a54  :=0xd0000074
##@@@P_:tasks.c:8495
##@@@L8490_:    }   
##@@@L8491_:    #endif   
##@@@L8492_:
##@@@L8493_:    /* Remove the task from the ready list before adding it to the blocked list   
##@@@L8494_:     * as the same list item is used for both lists. */   
##@@@L8495_:    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
800059d0:	22 47       	LD        R7, [PC + #34]        ;->0x80005a58  :=0xd0000040
##@@@P_:tasks.c:8482
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
##@@@L8482_:    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;   
800059d2:	a5 82       	LD.W      R10, [R5]
##@@@P_:tasks.c:8495
##@@@L8490_:    }   
##@@@L8491_:    #endif   
##@@@L8492_:
##@@@L8493_:    /* Remove the task from the ready list before adding it to the blocked list   
##@@@L8494_:     * as the same list item is used for both lists. */   
##@@@L8495_:    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
800059d4:	57 82       	LD.W      R5, [R7]
800059d6:	21 59       	MOV       R9, R1
800059d8:	c0 58       	MOV       R6, R0
800059da:	05 c1       	ADD       R0, R5, #4
800059dc:	20 45       	LD        R5, [PC + #32]        ;->0x80005a5c  :=0x80002290
800059de:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8508
##@@@L8503_:        mtCOVERAGE_TEST_MARKER();   
##@@@L8504_:    }   
##@@@L8505_:
##@@@L8506_:    #if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L8507_:    {   
##@@@L8508_:        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )   
800059e0:	20 45       	LD        R5, [PC + #32]        ;->0x80005a60  :=0xffffffff
800059e2:	65 70       	CMP       R6, R5
800059e4:	17 f1       	JNZ       $+23                  ;->0x80005a12
800059e6:	90 38       	CMP       R9, #0			;->0x00
800059e8:	15 f0       	JZ        $+21                  ;->0x80005a12
##@@@P_:tasks.c:8513
##@@@L8509_:        {   
##@@@L8510_:            /* Add the task to the suspended task list instead of a delayed task   
##@@@L8511_:             * list to ensure it is not woken by a timing event.  It will block   
##@@@L8512_:             * indefinitely. */   
##@@@L8513_:            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );   
800059ea:	1f 45       	LD        R5, [PC + #31]        ;->0x80005a64  :=0xd000008c
800059ec:	47 82       	LD.W      R4, [R7]
800059ee:	5d 98       	LD.W      R3, [R5 + #1]
800059f0:	a3 a0       	ST.W      [R4 + #2], R3
800059f2:	a3 98       	LD.W      R4, [R3 + #2]
800059f4:	27 82       	LD.W      R2, [R7]
800059f6:	d4 a0       	ST.W      [R2 + #3], R4
800059f8:	47 82       	LD.W      R4, [R7]
800059fa:	93 98       	LD.W      R2, [R3 + #2]
800059fc:	24 c1       	ADD       R4, R4, #4
800059fe:	54 a0       	ST.W      [R2 + #1], R4
80005a00:	47 82       	LD.W      R4, [R7]
80005a02:	24 c1       	ADD       R4, R4, #4
80005a04:	9c a0       	ST.W      [R3 + #2], R4
80005a06:	47 82       	LD.W      R4, [R7]
80005a08:	65 a1       	ST.W      [R4 + #5], R5
80005a0a:	45 82       	LD.W      R4, [R5]
80005a0c:	64 c0       	ADD       R4, R4, #1
80005a0e:	54 85       	ST.W      [R5], R4
80005a10:	1a 04       	SJMP      $+26                  ;->0x80005a44
80005a12:	01 0d       	LD.W      R5, [SP + #1]
##@@@P_:tasks.c:8520
##@@@L8515_:        else   
##@@@L8516_:        {   
##@@@L8517_:            /* Calculate the time at which the task should be woken if the event   
##@@@L8518_:             * does not occur.  This may overflow but this doesn't matter, the   
##@@@L8519_:             * kernel will manage it correctly. */   
##@@@L8520_:            xTimeToWake = xConstTickCount + xTicksToWait;   
80005a14:	b5 c3       	ADD       R6, R5, R6
80005a16:	65 70       	CMP       R6, R5
80005a18:	03 f3       	JNC       $+3                   ;->0x80005a1e
80005a1a:	50 10       	MOV       R5, #0			;->0x0000
80005a1c:	02 04       	SJMP      $+2                   ;->0x80005a20
80005a1e:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:tasks.c:8523
##@@@L8521_:
##@@@L8522_:            /* The list item will be inserted in wake time order. */   
##@@@L8523_:            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );   
80005a20:	47 82       	LD.W      R4, [R7]
80005a22:	66 a0       	ST.W      [R4 + #1], R6
80005a24:	47 82       	LD.W      R4, [R7]
80005a26:	0c c1       	ADD       R1, R4, #4
##@@@P_:tasks.c:8525
##@@@L8524_:
##@@@L8525_:            if( xTimeToWake < xConstTickCount )   
80005a28:	51 38       	CMP       R5, #1			;->0x01
80005a2a:	05 f1       	JNZ       $+5                   ;->0x80005a34
##@@@P_:tasks.c:8530
##@@@L8526_:            {   
##@@@L8527_:                /* Wake time has overflowed.  Place this item in the overflow   
##@@@L8528_:                 * list. */   
##@@@L8529_:                traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();   
##@@@L8530_:                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );   
80005a2c:	0a 58       	MOV       R0, R10
80005a2e:	0f 45       	LD        R5, [PC + #15]        ;->0x80005a68  :=0x8000225c
80005a30:	05 5c       	LJMP      R5
80005a32:	09 04       	SJMP      $+9                   ;->0x80005a44
##@@@P_:tasks.c:8537
##@@@L8532_:            else   
##@@@L8533_:            {   
##@@@L8534_:                /* The wake time has not overflowed, so the current block list   
##@@@L8535_:                 * is used. */   
##@@@L8536_:                traceMOVED_TASK_TO_DELAYED_LIST();   
##@@@L8537_:                vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );   
80005a34:	08 58       	MOV       R0, R8
80005a36:	0d 45       	LD        R5, [PC + #13]        ;->0x80005a68  :=0x8000225c
80005a38:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8542
##@@@L8538_:
##@@@L8539_:                /* If the task entering the blocked state was placed at the   
##@@@L8540_:                 * head of the list of blocked tasks then xNextTaskUnblockTime   
##@@@L8541_:                 * needs to be updated too. */   
##@@@L8542_:                if( xTimeToWake < xNextTaskUnblockTime )   
80005a3a:	0d 45       	LD        R5, [PC + #13]        ;->0x80005a6c  :=0xd0000300
80005a3c:	45 82       	LD.W      R4, [R5]
80005a3e:	64 70       	CMP       R6, R4
80005a40:	02 f2       	JC        $+2                   ;->0x80005a44
##@@@P_:tasks.c:8544
##@@@L8543_:                {   
##@@@L8544_:                    xNextTaskUnblockTime = xTimeToWake;   
80005a42:	56 85       	ST.W      [R5], R6
##@@@P_:tasks.c:8592
##@@@L8587_:
##@@@L8588_:        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */   
##@@@L8589_:        ( void ) xCanBlockIndefinitely;   
##@@@L8590_:    }   
##@@@L8591_:    #endif /* INCLUDE_vTaskSuspend */   
##@@@L8592_:}   
80005a44:	e8 28       	ADD       SP, #8			;->0x08
80005a46:	1f 5e       	POP       {R6-R10}
80005a48:	0d 5d       	POP       LR
80005a4a:	1d 5c       	JMP       LR
80005a4c:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
80005a50:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80005a54:	74 00 00 d0 	.long     0xd0000074 ->-805306252  [!!!@4@:ST.H      [R0 + #-204], R0
80005a58:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005a5c:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80005a60:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80005a64:	8c 00 00 d0 	.long     0xd000008c ->-805306228  [!!!@4@:LJMP      $+839680              ;->0x8019fa64
80005a68:	5c 22 00 80 	.long     0x8000225c ->-2147474852  [!!!@2@:ST.W      [SP + #92], R2	@@: LD.B      R0, [R0]
80005a6c:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x8001fa6c

80005a70 <xTaskResumeAll>:
##@@@F_:xTaskResumeAll():
##@@@P_:tasks.c:3925
##@@@L3920_:
##@@@L3921_:#endif /* configUSE_TICKLESS_IDLE */   
##@@@L3922_:/*----------------------------------------------------------*/   
##@@@L3923_:
##@@@L3924_:BaseType_t xTaskResumeAll( void )   
##@@@L3925_:{   
80005a70:	87 5f       	PUSH      {R6-R8,LR}
80005a72:	ec 30       	SUB       SP, #12			;->0x0C
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005a74:	20 5d       	PUSH      R0
80005a76:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005a7a:	08 00       	SYNC     SYNC     
80005a7c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005a80:	08 00       	SYNC     SYNC     
80005a82:	00 5d       	POP       R0
80005a84:	20 5d       	PUSH      R0
80005a86:	21 5d       	PUSH      R1
80005a88:	1a 45       	LD        R5, [PC + #26]        ;->0x80005af0  :=0x1ff
80005a8a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005a8e:	25 58       	MOV       R1, R5
80005a90:	11 68       	NOT       R1, R1
80005a92:	01 69       	ANL       R0, R1
80005a94:	5f 11       	MOV       R5, #31			;->0x001F
80005a96:	25 58       	MOV       R1, R5
80005a98:	01 6a       	ORL       R0, R1
80005a9a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005a9e:	08 00       	SYNC     SYNC     
80005aa0:	01 5d       	POP       R1
80005aa2:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005aa4:	14 45       	LD        R5, [PC + #20]        ;->0x80005af4  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005aa6:	20 5d       	PUSH      R0
80005aa8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005aac:	08 00       	SYNC     SYNC     
80005aae:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005ab2:	08 00       	SYNC     SYNC     
80005ab4:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005ab6:	55 82       	LD.W      R5, [R5]
80005ab8:	50 38       	CMP       R5, #0			;->0x00
80005aba:	07 f0       	JZ        $+7                   ;->0x80005ac8
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80005abc:	0f 45       	LD        R5, [PC + #15]        ;->0x80005af8  :=0xd0000040
80005abe:	45 82       	LD.W      R4, [R5]
80005ac0:	5c 9c       	LD.W      R3, [R4 + #17]
80005ac2:	5b c0       	ADD       R3, R3, #1
80005ac4:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80005ac6:	55 82       	LD.W      R5, [R5]
##@@@F_:xTaskResumeAll():
##@@@P_:tasks.c:3947
##@@@L3942_:            BaseType_t xCoreID;   
##@@@L3943_:            xCoreID = ( BaseType_t ) portGET_CORE_ID();   
##@@@L3944_:
##@@@L3945_:            /* If uxSchedulerSuspended is zero then this function does not match a   
##@@@L3946_:             * previous call to vTaskSuspendAll(). */   
##@@@L3947_:            configASSERT( uxSchedulerSuspended != 0U );   
80005ac8:	0d 45       	LD        R5, [PC + #13]        ;->0x80005afc  :=0xd0000068
80005aca:	45 82       	LD.W      R4, [R5]
80005acc:	40 38       	CMP       R4, #0			;->0x00
80005ace:	02 f1       	JNZ       $+2                   ;->0x80005ad2
80005ad0:	99 04       	SJMP      $+153                 ;->0x80005c02
##@@@P_:tasks.c:3949
##@@@L3948_:
##@@@L3949_:            --uxSchedulerSuspended;   
80005ad2:	45 82       	LD.W      R4, [R5]
80005ad4:	64 cc       	SUB       R4, R4, #1
80005ad6:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:3952
##@@@L3950_:            portRELEASE_TASK_LOCK();   
##@@@L3951_:
##@@@L3952_:            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
80005ad8:	55 82       	LD.W      R5, [R5]
80005ada:	50 38       	CMP       R5, #0			;->0x00
80005adc:	14 f0       	JZ        $+20                  ;->0x80005b04
80005ade:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:tasks.c:4065
##@@@L4060_:            else   
##@@@L4061_:            {   
##@@@L4062_:                mtCOVERAGE_TEST_MARKER();   
##@@@L4063_:            }   
##@@@L4064_:        }   
##@@@L4065_:        taskEXIT_CRITICAL();   
80005ae0:	08 45       	LD        R5, [PC + #8]         ;->0x80005b00  :=0x80005730
80005ae2:	05 5c       	LJMP      R5
##@@@P_:tasks.c:4070
##@@@L4066_:    }   
##@@@L4067_:
##@@@L4068_:    traceRETURN_xTaskResumeAll( xAlreadyYielded );   
##@@@L4069_:
##@@@L4070_:    return xAlreadyYielded;   
80005ae4:	06 58       	MOV       R0, R6
80005ae6:	ec 28       	ADD       SP, #12			;->0x0C
80005ae8:	07 5e       	POP       {R6-R8}
80005aea:	0d 5d       	POP       LR
80005aec:	1d 5c       	JMP       LR
80005aee:	00 00       	NOP      NOP      
80005af0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005af4:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80005af8:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005afc:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80005b00:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80005b00
##@@@P_:tasks.c:3954
##@@@L3949_:            --uxSchedulerSuspended;   
##@@@L3950_:            portRELEASE_TASK_LOCK();   
##@@@L3951_:
##@@@L3952_:            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
##@@@L3953_:            {   
##@@@L3954_:                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )   
80005b04:	51 45       	LD        R5, [PC + #81]        ;->0x80005c48  :=0xd0000060
80005b06:	55 82       	LD.W      R5, [R5]
80005b08:	60 10       	MOV       R6, #0			;->0x0000
80005b0a:	50 38       	CMP       R5, #0			;->0x00
80005b0c:	ea f0       	JZ        $-22                  ;->0x80005ae0
##@@@P_:tasks.c:3958
##@@@L3955_:                {   
##@@@L3956_:                    /* Move any readied tasks from the pending list into the   
##@@@L3957_:                     * appropriate ready list. */   
##@@@L3958_:                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )   
80005b0e:	50 43       	LD        R3, [PC + #80]        ;->0x80005c4c  :=0xd0000078
80005b10:	43 82       	LD.W      R4, [R3]
80005b12:	40 38       	CMP       R4, #0			;->0x00
80005b14:	02 26       	ST.W      [SP + #2], R6
80005b16:	02 f1       	JNZ       $+2                   ;->0x80005b1a
80005b18:	56 04       	SJMP      $+86                  ;->0x80005bc4
80005b1a:	01 23       	ST.W      [SP + #1], R3
80005b1c:	07 04       	SJMP      $+7                   ;->0x80005b2a
80005b1e:	01 0b       	LD.W      R3, [SP + #1]
80005b20:	53 82       	LD.W      R5, [R3]
80005b22:	50 38       	CMP       R5, #0			;->0x00
80005b24:	02 0e       	LD.W      R6, [SP + #2]
80005b26:	02 f1       	JNZ       $+2                   ;->0x80005b2a
80005b28:	42 04       	SJMP      $+66                  ;->0x80005bac
##@@@P_:tasks.c:3963
##@@@L3959_:                    {   
##@@@L3960_:                        /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L3961_:                        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L3962_:                        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L3963_:                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );   
80005b2a:	e3 98       	LD.W      R4, [R3 + #3]
80005b2c:	e4 98       	LD.W      R4, [R4 + #3]
##@@@P_:tasks.c:3964
##@@@L3964_:                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );   
80005b2e:	cc 99       	LD.W      R1, [R4 + #7]
80005b30:	14 9a       	LD.W      R2, [R4 + #8]
80005b32:	9c 9a       	LD.W      R3, [R4 + #10]
80005b34:	8a a0       	ST.W      [R1 + #2], R2
80005b36:	14 9a       	LD.W      R2, [R4 + #8]
80005b38:	51 a0       	ST.W      [R2 + #1], R1
80005b3a:	24 58       	MOV       R1, R4
80005b3c:	43 98       	LD.W      R0, [R3 + #1]
80005b3e:	18 29       	ADD       R1, #24			;->0x18
80005b40:	01 70       	CMP       R0, R1
80005b42:	02 f1       	JNZ       $+2                   ;->0x80005b46
80005b44:	5a a0       	ST.W      [R3 + #1], R2
80005b46:	a6 a2       	ST.W      [R4 + #10], R6
80005b48:	23 82       	LD.W      R2, [R3]
80005b4a:	52 cc       	SUB       R2, R2, #1
80005b4c:	32 85       	ST.W      [R3], R2
##@@@P_:tasks.c:3966
##@@@L3965_:                        portMEMORY_BARRIER();   
##@@@L3966_:                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
80005b4e:	9c 98       	LD.W      R3, [R4 + #2]
80005b50:	cc 98       	LD.W      R1, [R4 + #3]
80005b52:	54 99       	LD.W      R2, [R4 + #5]
80005b54:	99 a0       	ST.W      [R3 + #2], R1
80005b56:	cc 98       	LD.W      R1, [R4 + #3]
80005b58:	4b a0       	ST.W      [R1 + #1], R3
80005b5a:	42 98       	LD.W      R0, [R2 + #1]
80005b5c:	1c c1       	ADD       R3, R4, #4
80005b5e:	03 70       	CMP       R0, R3
80005b60:	02 f1       	JNZ       $+2                   ;->0x80005b64
80005b62:	51 a0       	ST.W      [R2 + #1], R1
80005b64:	12 82       	LD.W      R1, [R2]
80005b66:	49 cc       	SUB       R1, R1, #1
80005b68:	21 85       	ST.W      [R2], R1
##@@@P_:tasks.c:3967
##@@@L3967_:                        prvAddTaskToReadyList( pxTCB );   
80005b6a:	3a 41       	LD        R1, [PC + #58]        ;->0x80005c50  :=0xd00002f8
80005b6c:	d4 9a       	LD.W      R2, [R4 + #11]
80005b6e:	01 82       	LD.W      R0, [R1]
80005b70:	20 70       	CMP       R2, R0
80005b72:	02 f9       	JLS       $+2                   ;->0x80005b76
80005b74:	12 85       	ST.W      [R1], R2
80005b76:	38 41       	LD        R1, [PC + #56]        ;->0x80005c54  :=0xd00000a0
80005b78:	04 11       	MOV       R0, #20			;->0x0014
80005b7a:	c1 58       	MOV       R6, R1
80005b7c:	19 00 40 18 	MADD32    R6, R2, R0
80005b80:	7e 98       	LD.W      R7, [R6 + #1]
80005b82:	a7 a0       	ST.W      [R4 + #2], R7
80005b84:	af 98       	LD.W      R5, [R7 + #2]
80005b86:	e5 a0       	ST.W      [R4 + #3], R5
80005b88:	af 98       	LD.W      R5, [R7 + #2]
80005b8a:	6b a0       	ST.W      [R5 + #1], R3
80005b8c:	bb a0       	ST.W      [R7 + #2], R3
80005b8e:	66 a1       	ST.W      [R4 + #5], R6
80005b90:	2a ca       	MULS      R5, R2, R0
80005b92:	61 e9       	LD.W      R4, [R1 + R5]
80005b94:	64 c0       	ADD       R4, R4, #1
##@@@P_:tasks.c:3973
##@@@L3968_:
##@@@L3969_:                        #if ( configNUMBER_OF_CORES == 1 )   
##@@@L3970_:                        {   
##@@@L3971_:                            /* If the moved task has a priority higher than the current   
##@@@L3972_:                             * task then a yield must be performed. */   
##@@@L3973_:                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
80005b96:	31 43       	LD        R3, [PC + #49]        ;->0x80005c58  :=0xd0000040
##@@@P_:tasks.c:3967
##@@@L3962_:                        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L3963_:                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );   
##@@@L3964_:                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );   
##@@@L3965_:                        portMEMORY_BARRIER();   
##@@@L3966_:                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
##@@@L3967_:                        prvAddTaskToReadyList( pxTCB );   
80005b98:	4c ef       	ST.W      [R1 + R5], R4
##@@@P_:tasks.c:3973
##@@@L3968_:
##@@@L3969_:                        #if ( configNUMBER_OF_CORES == 1 )   
##@@@L3970_:                        {   
##@@@L3971_:                            /* If the moved task has a priority higher than the current   
##@@@L3972_:                             * task then a yield must be performed. */   
##@@@L3973_:                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
80005b9a:	53 82       	LD.W      R5, [R3]
80005b9c:	ed 9a       	LD.W      R5, [R5 + #11]
80005b9e:	25 70       	CMP       R2, R5
80005ba0:	02 f8       	JHI       $+2                   ;->0x80005ba4
80005ba2:	be 07       	SJMP      $-66                  ;->0x80005b1e
##@@@P_:tasks.c:3975
##@@@L3974_:                            {   
##@@@L3975_:                                xYieldPendings[ xCoreID ] = pdTRUE;   
80005ba4:	2e 45       	LD        R5, [PC + #46]        ;->0x80005c5c  :=0xd00002fc
80005ba6:	41 10       	MOV       R4, #1			;->0x0001
80005ba8:	54 85       	ST.W      [R5], R4
80005baa:	ba 07       	SJMP      $-70                  ;->0x80005b1e
##@@@F_:prvResetNextTaskUnblockTime():
##@@@P_:tasks.c:6496
##@@@L6491_:#endif /* INCLUDE_vTaskDelete */   
##@@@L6492_:/*-----------------------------------------------------------*/   
##@@@L6493_:
##@@@L6494_:static void prvResetNextTaskUnblockTime( void )   
##@@@L6495_:{   
##@@@L6496_:    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )   
80005bac:	2d 45       	LD        R5, [PC + #45]        ;->0x80005c60  :=0xd0000070
80005bae:	45 82       	LD.W      R4, [R5]
80005bb0:	44 82       	LD.W      R4, [R4]
80005bb2:	40 38       	CMP       R4, #0			;->0x00
80005bb4:	05 f0       	JZ        $+5                   ;->0x80005bbe
##@@@P_:tasks.c:6510
##@@@L6505_:    {   
##@@@L6506_:        /* The new current delayed list is not empty, get the value of   
##@@@L6507_:         * the item at the head of the delayed list.  This is the time at   
##@@@L6508_:         * which the task at the head of the delayed list should be removed   
##@@@L6509_:         * from the Blocked state. */   
##@@@L6510_:        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );   
80005bb6:	55 82       	LD.W      R5, [R5]
80005bb8:	ed 98       	LD.W      R5, [R5 + #3]
80005bba:	55 82       	LD.W      R5, [R5]
80005bbc:	02 04       	SJMP      $+2                   ;->0x80005bc0
80005bbe:	2a 45       	LD        R5, [PC + #42]        ;->0x80005c64  :=0xffffffff
80005bc0:	2a 44       	LD        R4, [PC + #42]        ;->0x80005c68  :=0xd0000300
80005bc2:	45 85       	ST.W      [R4], R5
##@@@F_:xTaskResumeAll():
##@@@P_:tasks.c:4012
##@@@L4007_:                     * It should be safe to call xTaskIncrementTick here from any core   
##@@@L4008_:                     * since we are in a critical section and xTaskIncrementTick itself   
##@@@L4009_:                     * protects itself within a critical section. Suspending the scheduler   
##@@@L4010_:                     * from any core causes xTaskIncrementTick to increment uxPendedCounts. */   
##@@@L4011_:                    {   
##@@@L4012_:                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */   
80005bc4:	2a 45       	LD        R5, [PC + #42]        ;->0x80005c6c  :=0xd0000308
80005bc6:	75 82       	LD.W      R7, [R5]
##@@@P_:tasks.c:4014
##@@@L4013_:
##@@@L4014_:                        if( xPendedCounts > ( TickType_t ) 0U )   
80005bc8:	70 38       	CMP       R7, #0			;->0x00
80005bca:	11 f0       	JZ        $+17                  ;->0x80005bec
80005bcc:	01 25       	ST.W      [SP + #1], R5
80005bce:	24 46       	LD        R6, [PC + #36]        ;->0x80005c5c  :=0xd00002fc
80005bd0:	81 10       	MOV       R8, #1			;->0x0001
80005bd2:	04 04       	SJMP      $+4                   ;->0x80005bda
##@@@P_:tasks.c:4029
##@@@L4024_:                                else   
##@@@L4025_:                                {   
##@@@L4026_:                                    mtCOVERAGE_TEST_MARKER();   
##@@@L4027_:                                }   
##@@@L4028_:
##@@@L4029_:                                --xPendedCounts;   
80005bd4:	7f cc       	SUB       R7, R7, #1
##@@@P_:tasks.c:4030
##@@@L4030_:                            } while( xPendedCounts > ( TickType_t ) 0U );   
80005bd6:	70 38       	CMP       R7, #0			;->0x00
80005bd8:	07 f0       	JZ        $+7                   ;->0x80005be6
##@@@P_:tasks.c:4018
##@@@L4013_:
##@@@L4014_:                        if( xPendedCounts > ( TickType_t ) 0U )   
##@@@L4015_:                        {   
##@@@L4016_:                            do   
##@@@L4017_:                            {   
##@@@L4018_:                                if( xTaskIncrementTick() != pdFALSE )   
80005bda:	26 45       	LD        R5, [PC + #38]        ;->0x80005c70  :=0x800067d4
80005bdc:	05 5c       	LJMP      R5
80005bde:	00 38       	CMP       R0, #0			;->0x00
80005be0:	fa f0       	JZ        $-6                   ;->0x80005bd4
##@@@P_:tasks.c:4022
##@@@L4019_:                                {   
##@@@L4020_:                                    /* Other cores are interrupted from   
##@@@L4021_:                                     * within xTaskIncrementTick(). */   
##@@@L4022_:                                    xYieldPendings[ xCoreID ] = pdTRUE;   
80005be2:	68 85       	ST.W      [R6], R8
80005be4:	f8 07       	SJMP      $-8                   ;->0x80005bd4
##@@@P_:tasks.c:4032
##@@@L4027_:                                }   
##@@@L4028_:
##@@@L4029_:                                --xPendedCounts;   
##@@@L4030_:                            } while( xPendedCounts > ( TickType_t ) 0U );   
##@@@L4031_:
##@@@L4032_:                            xPendedTicks = 0;   
80005be6:	02 0d       	LD.W      R5, [SP + #2]
80005be8:	01 0c       	LD.W      R4, [SP + #1]
80005bea:	45 85       	ST.W      [R4], R5
##@@@P_:tasks.c:4040
##@@@L4035_:                        {   
##@@@L4036_:                            mtCOVERAGE_TEST_MARKER();   
##@@@L4037_:                        }   
##@@@L4038_:                    }   
##@@@L4039_:
##@@@L4040_:                    if( xYieldPendings[ xCoreID ] != pdFALSE )   
80005bec:	1c 45       	LD        R5, [PC + #28]        ;->0x80005c5c  :=0xd00002fc
80005bee:	55 82       	LD.W      R5, [R5]
80005bf0:	50 38       	CMP       R5, #0			;->0x00
80005bf2:	02 f1       	JNZ       $+2                   ;->0x80005bf6
80005bf4:	75 07       	SJMP      $-139                 ;->0x80005ade
##@@@P_:tasks.c:4050
##@@@L4045_:                        }   
##@@@L4046_:                        #endif /* #if ( configUSE_PREEMPTION != 0 ) */   
##@@@L4047_:
##@@@L4048_:                        #if ( configNUMBER_OF_CORES == 1 )   
##@@@L4049_:                        {   
##@@@L4050_:                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );   
80005bf6:	19 45       	LD        R5, [PC + #25]        ;->0x80005c58  :=0xd0000040
80005bf8:	55 82       	LD.W      R5, [R5]
80005bfa:	1f 45       	LD        R5, [PC + #31]        ;->0x80005c74  :=0x80008f64
80005bfc:	05 5c       	LJMP      R5
80005bfe:	61 10       	MOV       R6, #1			;->0x0001
80005c00:	70 07       	SJMP      $-144                 ;->0x80005ae0
##@@@P_:tasks.c:3947
##@@@L3942_:            BaseType_t xCoreID;   
##@@@L3943_:            xCoreID = ( BaseType_t ) portGET_CORE_ID();   
##@@@L3944_:
##@@@L3945_:            /* If uxSchedulerSuspended is zero then this function does not match a   
##@@@L3946_:             * previous call to vTaskSuspendAll(). */   
##@@@L3947_:            configASSERT( uxSchedulerSuspended != 0U );   
80005c02:	20 5d       	PUSH      R0
80005c04:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005c08:	08 00       	SYNC     SYNC     
80005c0a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005c0e:	08 00       	SYNC     SYNC     
80005c10:	00 5d       	POP       R0
80005c12:	20 5d       	PUSH      R0
80005c14:	21 5d       	PUSH      R1
80005c16:	19 45       	LD        R5, [PC + #25]        ;->0x80005c78  :=0x1ff
80005c18:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005c1c:	25 58       	MOV       R1, R5
80005c1e:	11 68       	NOT       R1, R1
80005c20:	01 69       	ANL       R0, R1
80005c22:	5f 11       	MOV       R5, #31			;->0x001F
80005c24:	25 58       	MOV       R1, R5
80005c26:	01 6a       	ORL       R0, R1
80005c28:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005c2c:	08 00       	SYNC     SYNC     
80005c2e:	01 5d       	POP       R1
80005c30:	00 5d       	POP       R0
80005c32:	20 5d       	PUSH      R0
80005c34:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005c38:	08 00       	SYNC     SYNC     
80005c3a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005c3e:	08 00       	SYNC     SYNC     
80005c40:	00 5d       	POP       R0
80005c42:	07 00       	BREAK    BREAK    
80005c44:	0e 45       	LD        R5, [PC + #14]        ;->0x80005c7c  :=0x8000911c
80005c46:	05 5c       	LJMP      R5
80005c48:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
80005c4c:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
80005c50:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
80005c54:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80005c58:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005c5c:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
80005c60:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80005c64:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80005c68:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x8001fc68
80005c6c:	08 03 00 d0 	.long     0xd0000308 ->-805305592  [!!!@4@:JMP       $+577536              ;->0x8011fc6c
80005c70:	d4 67 00 80 	.long     0x800067d4 ->-2147457068  [!!!@2@:SUBC      LR, R4	@@: LD.B      R0, [R0]
80005c74:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80005c78:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005c7c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80005c80 <vTaskDelay>:
##@@@F_:vTaskDelay():
##@@@P_:tasks.c:2441
##@@@L2436_:/*-----------------------------------------------------------*/   
##@@@L2437_:
##@@@L2438_:#if ( INCLUDE_vTaskDelay == 1 )   
##@@@L2439_:
##@@@L2440_:    void vTaskDelay( const TickType_t xTicksToDelay )   
##@@@L2441_:    {   
80005c80:	8f 5f       	PUSH      {R6-R9,LR}
80005c82:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:tasks.c:2447
##@@@L2442_:        BaseType_t xAlreadyYielded = pdFALSE;   
##@@@L2443_:
##@@@L2444_:        traceENTER_vTaskDelay( xTicksToDelay );   
##@@@L2445_:
##@@@L2446_:        /* A delay time of zero just forces a reschedule. */   
##@@@L2447_:        if( xTicksToDelay > ( TickType_t ) 0U )   
80005c84:	00 38       	CMP       R0, #0			;->0x00
80005c86:	33 f0       	JZ        $+51                  ;->0x80005cec
80005c88:	01 20       	ST.W      [SP + #1], R0
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
80005c8a:	1c 45       	LD        R5, [PC + #28]        ;->0x80005cf8  :=0xd0000068
80005c8c:	45 82       	LD.W      R4, [R5]
80005c8e:	64 c0       	ADD       R4, R4, #1
80005c90:	54 85       	ST.W      [R5], R4
##@@@F_:vTaskDelay():
##@@@P_:tasks.c:2451
##@@@L2446_:        /* A delay time of zero just forces a reschedule. */   
##@@@L2447_:        if( xTicksToDelay > ( TickType_t ) 0U )   
##@@@L2448_:        {   
##@@@L2449_:            vTaskSuspendAll();   
##@@@L2450_:            {   
##@@@L2451_:                configASSERT( uxSchedulerSuspended == 1U );   
80005c92:	55 82       	LD.W      R5, [R5]
80005c94:	51 38       	CMP       R5, #1			;->0x01
80005c96:	45 f1       	JNZ       $+69                  ;->0x80005d20
##@@@F_:prvAddCurrentTaskToDelayedList():
##@@@P_:tasks.c:8480
##@@@L8475_:
##@@@L8476_:static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,   
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
80005c98:	19 45       	LD        R5, [PC + #25]        ;->0x80005cfc  :=0xd000006c
##@@@P_:tasks.c:8481
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
80005c9a:	1a 44       	LD        R4, [PC + #26]        ;->0x80005d00  :=0xd0000070
##@@@P_:tasks.c:8480
##@@@L8475_:
##@@@L8476_:static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,   
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
80005c9c:	65 82       	LD.W      R6, [R5]
##@@@P_:tasks.c:8481
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
80005c9e:	84 82       	LD.W      R8, [R4]
##@@@P_:tasks.c:8482
##@@@L8482_:    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;   
80005ca0:	19 45       	LD        R5, [PC + #25]        ;->0x80005d04  :=0xd0000074
##@@@P_:tasks.c:8495
##@@@L8490_:    }   
##@@@L8491_:    #endif   
##@@@L8492_:
##@@@L8493_:    /* Remove the task from the ready list before adding it to the blocked list   
##@@@L8494_:     * as the same list item is used for both lists. */   
##@@@L8495_:    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
80005ca2:	1a 47       	LD        R7, [PC + #26]        ;->0x80005d08  :=0xd0000040
##@@@P_:tasks.c:8482
##@@@L8477_:                                            const BaseType_t xCanBlockIndefinitely )   
##@@@L8478_:{   
##@@@L8479_:    TickType_t xTimeToWake;   
##@@@L8480_:    const TickType_t xConstTickCount = xTickCount;   
##@@@L8481_:    List_t * const pxDelayedList = pxDelayedTaskList;   
##@@@L8482_:    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;   
80005ca4:	95 82       	LD.W      R9, [R5]
##@@@P_:tasks.c:8495
##@@@L8490_:    }   
##@@@L8491_:    #endif   
##@@@L8492_:
##@@@L8493_:    /* Remove the task from the ready list before adding it to the blocked list   
##@@@L8494_:     * as the same list item is used for both lists. */   
##@@@L8495_:    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
80005ca6:	57 82       	LD.W      R5, [R7]
80005ca8:	05 c1       	ADD       R0, R5, #4
80005caa:	19 45       	LD        R5, [PC + #25]        ;->0x80005d0c  :=0x80002290
80005cac:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8520
##@@@L8515_:        else   
##@@@L8516_:        {   
##@@@L8517_:            /* Calculate the time at which the task should be woken if the event   
##@@@L8518_:             * does not occur.  This may overflow but this doesn't matter, the   
##@@@L8519_:             * kernel will manage it correctly. */   
##@@@L8520_:            xTimeToWake = xConstTickCount + xTicksToWait;   
80005cae:	01 0d       	LD.W      R5, [SP + #1]
80005cb0:	5e c3       	ADD       R3, R6, R5
80005cb2:	36 70       	CMP       R3, R6
80005cb4:	03 f3       	JNC       $+3                   ;->0x80005cba
80005cb6:	50 10       	MOV       R5, #0			;->0x0000
80005cb8:	02 04       	SJMP      $+2                   ;->0x80005cbc
80005cba:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:tasks.c:8523
##@@@L8521_:
##@@@L8522_:            /* The list item will be inserted in wake time order. */   
##@@@L8523_:            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );   
80005cbc:	47 82       	LD.W      R4, [R7]
80005cbe:	63 a0       	ST.W      [R4 + #1], R3
80005cc0:	47 82       	LD.W      R4, [R7]
80005cc2:	0c c1       	ADD       R1, R4, #4
##@@@P_:tasks.c:8525
##@@@L8524_:
##@@@L8525_:            if( xTimeToWake < xConstTickCount )   
80005cc4:	51 38       	CMP       R5, #1			;->0x01
80005cc6:	05 f1       	JNZ       $+5                   ;->0x80005cd0
##@@@P_:tasks.c:8530
##@@@L8526_:            {   
##@@@L8527_:                /* Wake time has overflowed.  Place this item in the overflow   
##@@@L8528_:                 * list. */   
##@@@L8529_:                traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();   
##@@@L8530_:                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );   
80005cc8:	09 58       	MOV       R0, R9
80005cca:	12 45       	LD        R5, [PC + #18]        ;->0x80005d10  :=0x8000225c
80005ccc:	05 5c       	LJMP      R5
80005cce:	0b 04       	SJMP      $+11                  ;->0x80005ce4
##@@@P_:tasks.c:8537
##@@@L8532_:            else   
##@@@L8533_:            {   
##@@@L8534_:                /* The wake time has not overflowed, so the current block list   
##@@@L8535_:                 * is used. */   
##@@@L8536_:                traceMOVED_TASK_TO_DELAYED_LIST();   
##@@@L8537_:                vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );   
80005cd0:	08 58       	MOV       R0, R8
80005cd2:	c3 58       	MOV       R6, R3
80005cd4:	0f 45       	LD        R5, [PC + #15]        ;->0x80005d10  :=0x8000225c
80005cd6:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8542
##@@@L8538_:
##@@@L8539_:                /* If the task entering the blocked state was placed at the   
##@@@L8540_:                 * head of the list of blocked tasks then xNextTaskUnblockTime   
##@@@L8541_:                 * needs to be updated too. */   
##@@@L8542_:                if( xTimeToWake < xNextTaskUnblockTime )   
80005cd8:	0f 45       	LD        R5, [PC + #15]        ;->0x80005d14  :=0xd0000300
80005cda:	45 82       	LD.W      R4, [R5]
80005cdc:	64 70       	CMP       R6, R4
80005cde:	03 f2       	JC        $+3                   ;->0x80005ce4
80005ce0:	66 58       	MOV       R3, R6
##@@@P_:tasks.c:8544
##@@@L8543_:                {   
##@@@L8544_:                    xNextTaskUnblockTime = xTimeToWake;   
80005ce2:	56 85       	ST.W      [R5], R6
##@@@F_:vTaskDelay():
##@@@P_:tasks.c:2464
##@@@L2459_:                 *   
##@@@L2460_:                 * This task cannot be in an event list as it is the currently   
##@@@L2461_:                 * executing task. */   
##@@@L2462_:                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );   
##@@@L2463_:            }   
##@@@L2464_:            xAlreadyYielded = xTaskResumeAll();   
80005ce4:	0d 45       	LD        R5, [PC + #13]        ;->0x80005d18  :=0x80005a70
80005ce6:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2473
##@@@L2468_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2469_:        }   
##@@@L2470_:
##@@@L2471_:        /* Force a reschedule if xTaskResumeAll has not already done so, we may   
##@@@L2472_:         * have put ourselves to sleep. */   
##@@@L2473_:        if( xAlreadyYielded == pdFALSE )   
80005ce8:	00 38       	CMP       R0, #0			;->0x00
80005cea:	03 f1       	JNZ       $+3                   ;->0x80005cf0
##@@@P_:tasks.c:2475
##@@@L2474_:        {   
##@@@L2475_:            taskYIELD_WITHIN_API();   
80005cec:	0c 45       	LD        R5, [PC + #12]        ;->0x80005d1c  :=0x80008f64
80005cee:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2483
##@@@L2478_:        {   
##@@@L2479_:            mtCOVERAGE_TEST_MARKER();   
##@@@L2480_:        }   
##@@@L2481_:
##@@@L2482_:        traceRETURN_vTaskDelay();   
##@@@L2483_:    }   
80005cf0:	e8 28       	ADD       SP, #8			;->0x08
80005cf2:	0f 5e       	POP       {R6-R9}
80005cf4:	0d 5d       	POP       LR
80005cf6:	1d 5c       	JMP       LR
80005cf8:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80005cfc:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
80005d00:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80005d04:	74 00 00 d0 	.long     0xd0000074 ->-805306252  [!!!@4@:ST.H      [R0 + #-204], R0
80005d08:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005d0c:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80005d10:	5c 22 00 80 	.long     0x8000225c ->-2147474852  [!!!@2@:ST.W      [SP + #92], R2	@@: LD.B      R0, [R0]
80005d14:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x8001fd14
80005d18:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80005d1c:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:2451
##@@@L2446_:        /* A delay time of zero just forces a reschedule. */   
##@@@L2447_:        if( xTicksToDelay > ( TickType_t ) 0U )   
##@@@L2448_:        {   
##@@@L2449_:            vTaskSuspendAll();   
##@@@L2450_:            {   
##@@@L2451_:                configASSERT( uxSchedulerSuspended == 1U );   
80005d20:	20 5d       	PUSH      R0
80005d22:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005d26:	08 00       	SYNC     SYNC     
80005d28:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005d2c:	08 00       	SYNC     SYNC     
80005d2e:	00 5d       	POP       R0
80005d30:	20 5d       	PUSH      R0
80005d32:	21 5d       	PUSH      R1
80005d34:	0d 45       	LD        R5, [PC + #13]        ;->0x80005d68  :=0x1ff
80005d36:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005d3a:	25 58       	MOV       R1, R5
80005d3c:	11 68       	NOT       R1, R1
80005d3e:	01 69       	ANL       R0, R1
80005d40:	5f 11       	MOV       R5, #31			;->0x001F
80005d42:	25 58       	MOV       R1, R5
80005d44:	01 6a       	ORL       R0, R1
80005d46:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005d4a:	08 00       	SYNC     SYNC     
80005d4c:	01 5d       	POP       R1
80005d4e:	00 5d       	POP       R0
80005d50:	20 5d       	PUSH      R0
80005d52:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005d56:	08 00       	SYNC     SYNC     
80005d58:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005d5c:	08 00       	SYNC     SYNC     
80005d5e:	00 5d       	POP       R0
80005d60:	07 00       	BREAK    BREAK    
80005d62:	03 45       	LD        R5, [PC + #3]         ;->0x80005d6c  :=0x8000911c
80005d64:	05 5c       	LJMP      R5
80005d66:	00 00       	NOP      NOP      
80005d68:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005d6c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80005d70 <eTaskGetState>:
##@@@F_:eTaskGetState():
##@@@P_:tasks.c:2491
##@@@L2486_:/*-----------------------------------------------------------*/   
##@@@L2487_:
##@@@L2488_:#if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )   
##@@@L2489_:
##@@@L2490_:    eTaskState eTaskGetState( TaskHandle_t xTask )   
##@@@L2491_:    {   
80005d70:	8f 5f       	PUSH      {R6-R9,LR}
80005d72:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:tasks.c:2501
##@@@L2496_:        List_t const * pxOverflowedDelayedList;   
##@@@L2497_:        const TCB_t * const pxTCB = xTask;   
##@@@L2498_:
##@@@L2499_:        traceENTER_eTaskGetState( xTask );   
##@@@L2500_:
##@@@L2501_:        configASSERT( pxTCB );   
80005d74:	00 38       	CMP       R0, #0			;->0x00
80005d76:	73 f0       	JZ        $+115                 ;->0x80005e5c
80005d78:	c0 58       	MOV       R6, R0
##@@@P_:tasks.c:2504
##@@@L2502_:
##@@@L2503_:        #if ( configNUMBER_OF_CORES == 1 )   
##@@@L2504_:            if( pxTCB == pxCurrentTCB )   
80005d7a:	2b 45       	LD        R5, [PC + #43]        ;->0x80005e24  :=0xd0000040
80005d7c:	45 82       	LD.W      R4, [R5]
80005d7e:	40 70       	CMP       R4, R0
80005d80:	4a f0       	JZ        $+74                  ;->0x80005e14
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005d82:	20 5d       	PUSH      R0
80005d84:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005d88:	08 00       	SYNC     SYNC     
80005d8a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005d8e:	08 00       	SYNC     SYNC     
80005d90:	00 5d       	POP       R0
80005d92:	20 5d       	PUSH      R0
80005d94:	21 5d       	PUSH      R1
80005d96:	25 44       	LD        R4, [PC + #37]        ;->0x80005e28  :=0x1ff
80005d98:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005d9c:	24 58       	MOV       R1, R4
80005d9e:	11 68       	NOT       R1, R1
80005da0:	01 69       	ANL       R0, R1
80005da2:	4f 11       	MOV       R4, #31			;->0x001F
80005da4:	24 58       	MOV       R1, R4
80005da6:	01 6a       	ORL       R0, R1
80005da8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005dac:	08 00       	SYNC     SYNC     
80005dae:	01 5d       	POP       R1
80005db0:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005db2:	1f 44       	LD        R4, [PC + #31]        ;->0x80005e2c  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005db4:	20 5d       	PUSH      R0
80005db6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005dba:	08 00       	SYNC     SYNC     
80005dbc:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005dc0:	08 00       	SYNC     SYNC     
80005dc2:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005dc4:	44 82       	LD.W      R4, [R4]
80005dc6:	40 38       	CMP       R4, #0			;->0x00
80005dc8:	06 f0       	JZ        $+6                   ;->0x80005dd4
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80005dca:	45 82       	LD.W      R4, [R5]
80005dcc:	5c 9c       	LD.W      R3, [R4 + #17]
80005dce:	5b c0       	ADD       R3, R3, #1
80005dd0:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80005dd2:	55 82       	LD.W      R5, [R5]
##@@@F_:eTaskGetState():
##@@@P_:tasks.c:2515
##@@@L2510_:        #endif   
##@@@L2511_:        {   
##@@@L2512_:            taskENTER_CRITICAL();   
##@@@L2513_:            {   
##@@@L2514_:                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );   
##@@@L2515_:                pxEventList = listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) );   
80005dd4:	ae 9a       	LD.W      R5, [R6 + #10]
##@@@P_:tasks.c:2514
##@@@L2509_:            else   
##@@@L2510_:        #endif   
##@@@L2511_:        {   
##@@@L2512_:            taskENTER_CRITICAL();   
##@@@L2513_:            {   
##@@@L2514_:                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );   
80005dd6:	01 25       	ST.W      [SP + #1], R5
80005dd8:	7e 99       	LD.W      R7, [R6 + #5]
##@@@P_:tasks.c:2516
##@@@L2515_:                pxEventList = listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) );   
##@@@L2516_:                pxDelayedList = pxDelayedTaskList;   
80005dda:	16 45       	LD        R5, [PC + #22]        ;->0x80005e30  :=0xd0000070
##@@@P_:tasks.c:2517
##@@@L2517_:                pxOverflowedDelayedList = pxOverflowDelayedTaskList;   
80005ddc:	16 44       	LD        R4, [PC + #22]        ;->0x80005e34  :=0xd0000074
##@@@P_:tasks.c:2516
##@@@L2511_:        {   
##@@@L2512_:            taskENTER_CRITICAL();   
##@@@L2513_:            {   
##@@@L2514_:                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );   
##@@@L2515_:                pxEventList = listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) );   
##@@@L2516_:                pxDelayedList = pxDelayedTaskList;   
80005dde:	95 82       	LD.W      R9, [R5]
##@@@P_:tasks.c:2517
##@@@L2517_:                pxOverflowedDelayedList = pxOverflowDelayedTaskList;   
80005de0:	84 82       	LD.W      R8, [R4]
##@@@P_:tasks.c:2519
##@@@L2518_:            }   
##@@@L2519_:            taskEXIT_CRITICAL();   
80005de2:	16 45       	LD        R5, [PC + #22]        ;->0x80005e38  :=0x80005730
80005de4:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2521
##@@@L2520_:
##@@@L2521_:            if( pxEventList == &xPendingReadyList )   
80005de6:	16 44       	LD        R4, [PC + #22]        ;->0x80005e3c  :=0xd0000078
80005de8:	51 10       	MOV       R5, #1			;->0x0001
80005dea:	01 0b       	LD.W      R3, [SP + #1]
80005dec:	34 70       	CMP       R3, R4
80005dee:	15 f0       	JZ        $+21                  ;->0x80005e18
80005df0:	02 10       	MOV       R0, #2			;->0x0002
##@@@P_:tasks.c:2528
##@@@L2523_:                /* The task has been placed on the pending ready list, so its   
##@@@L2524_:                 * state is eReady regardless of what list the task's state list   
##@@@L2525_:                 * item is currently placed on. */   
##@@@L2526_:                eReturn = eReady;   
##@@@L2527_:            }   
##@@@L2528_:            else if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )   
80005df2:	79 70       	CMP       R7, R9
80005df4:	13 f0       	JZ        $+19                  ;->0x80005e1a
80005df6:	78 70       	CMP       R7, R8
80005df8:	11 f0       	JZ        $+17                  ;->0x80005e1a
##@@@P_:tasks.c:2536
##@@@L2531_:                 * lists. */   
##@@@L2532_:                eReturn = eBlocked;   
##@@@L2533_:            }   
##@@@L2534_:
##@@@L2535_:            #if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L2536_:                else if( pxStateList == &xSuspendedTaskList )   
80005dfa:	12 44       	LD        R4, [PC + #18]        ;->0x80005e40  :=0xd000008c
80005dfc:	74 70       	CMP       R7, R4
80005dfe:	25 f0       	JZ        $+37                  ;->0x80005e48
80005e00:	04 10       	MOV       R0, #4			;->0x0004
80005e02:	80 58       	MOV       R4, R0
80005e04:	70 38       	CMP       R7, #0			;->0x00
80005e06:	02 f0       	JZ        $+2                   ;->0x80005e0a
80005e08:	85 58       	MOV       R4, R5
##@@@P_:tasks.c:2577
##@@@L2572_:                    }   
##@@@L2573_:                }   
##@@@L2574_:            #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */   
##@@@L2575_:
##@@@L2576_:            #if ( INCLUDE_vTaskDelete == 1 )   
##@@@L2577_:                else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )   
80005e0a:	0f 45       	LD        R5, [PC + #15]        ;->0x80005e44  :=0xd0000048
80005e0c:	75 70       	CMP       R7, R5
80005e0e:	06 f0       	JZ        $+6                   ;->0x80005e1a
80005e10:	04 58       	MOV       R0, R4
80005e12:	04 04       	SJMP      $+4                   ;->0x80005e1a
80005e14:	00 10       	MOV       R0, #0			;->0x0000
80005e16:	02 04       	SJMP      $+2                   ;->0x80005e1a
80005e18:	05 58       	MOV       R0, R5
##@@@P_:tasks.c:2614
##@@@L2609_:            }   
##@@@L2610_:        }   
##@@@L2611_:
##@@@L2612_:        traceRETURN_eTaskGetState( eReturn );   
##@@@L2613_:
##@@@L2614_:        return eReturn;   
80005e1a:	e8 28       	ADD       SP, #8			;->0x08
80005e1c:	0f 5e       	POP       {R6-R9}
80005e1e:	0d 5d       	POP       LR
80005e20:	1d 5c       	JMP       LR
80005e22:	00 00       	NOP      NOP      
80005e24:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005e28:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005e2c:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80005e30:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80005e34:	74 00 00 d0 	.long     0xd0000074 ->-805306252  [!!!@4@:ST.H      [R0 + #-204], R0
80005e38:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80005e38
80005e3c:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
80005e40:	8c 00 00 d0 	.long     0xd000008c ->-805306228  [!!!@4@:LJMP      $+839680              ;->0x8019fe40
80005e44:	48 00 00 d0 	.long     0xd0000048 ->-805306296  [!!!@4@:LD.H      R0, [R0 + #52]
##@@@P_:tasks.c:2541
##@@@L2536_:                else if( pxStateList == &xSuspendedTaskList )   
##@@@L2537_:                {   
##@@@L2538_:                    /* The task being queried is referenced from the suspended   
##@@@L2539_:                     * list.  Is it genuinely suspended or is it blocked   
##@@@L2540_:                     * indefinitely? */   
##@@@L2541_:                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )   
80005e48:	ae 9a       	LD.W      R5, [R6 + #10]
80005e4a:	02 10       	MOV       R0, #2			;->0x0002
80005e4c:	50 38       	CMP       R5, #0			;->0x00
80005e4e:	e6 f1       	JNZ       $-26                  ;->0x80005e1a
80005e50:	51 00 c5 d0 	LD.B      R5, [R6 + #116]			;->0x74
##@@@P_:tasks.c:2556
##@@@L2551_:                             * suspended. */   
##@@@L2552_:                            eReturn = eSuspended;   
##@@@L2553_:
##@@@L2554_:                            for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )   
##@@@L2555_:                            {   
##@@@L2556_:                                if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )   
80005e54:	51 38       	CMP       R5, #1			;->0x01
80005e56:	e2 f0       	JZ        $-30                  ;->0x80005e1a
80005e58:	03 10       	MOV       R0, #3			;->0x0003
80005e5a:	e0 07       	SJMP      $-32                  ;->0x80005e1a
##@@@P_:tasks.c:2501
##@@@L2496_:        List_t const * pxOverflowedDelayedList;   
##@@@L2497_:        const TCB_t * const pxTCB = xTask;   
##@@@L2498_:
##@@@L2499_:        traceENTER_eTaskGetState( xTask );   
##@@@L2500_:
##@@@L2501_:        configASSERT( pxTCB );   
80005e5c:	20 5d       	PUSH      R0
80005e5e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005e62:	08 00       	SYNC     SYNC     
80005e64:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005e68:	08 00       	SYNC     SYNC     
80005e6a:	00 5d       	POP       R0
80005e6c:	20 5d       	PUSH      R0
80005e6e:	21 5d       	PUSH      R1
80005e70:	0d 45       	LD        R5, [PC + #13]        ;->0x80005ea4  :=0x1ff
80005e72:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005e76:	25 58       	MOV       R1, R5
80005e78:	11 68       	NOT       R1, R1
80005e7a:	01 69       	ANL       R0, R1
80005e7c:	5f 11       	MOV       R5, #31			;->0x001F
80005e7e:	25 58       	MOV       R1, R5
80005e80:	01 6a       	ORL       R0, R1
80005e82:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005e86:	08 00       	SYNC     SYNC     
80005e88:	01 5d       	POP       R1
80005e8a:	00 5d       	POP       R0
80005e8c:	20 5d       	PUSH      R0
80005e8e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005e92:	08 00       	SYNC     SYNC     
80005e94:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005e98:	08 00       	SYNC     SYNC     
80005e9a:	00 5d       	POP       R0
80005e9c:	07 00       	BREAK    BREAK    
80005e9e:	03 45       	LD        R5, [PC + #3]         ;->0x80005ea8  :=0x8000911c
80005ea0:	05 5c       	LJMP      R5
80005ea2:	00 00       	NOP      NOP      
80005ea4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005ea8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80005eac <uxTaskPriorityGet>:
##@@@F_:uxTaskPriorityGet():
##@@@P_:tasks.c:2623
##@@@L2618_:/*-----------------------------------------------------------*/   
##@@@L2619_:
##@@@L2620_:#if ( INCLUDE_uxTaskPriorityGet == 1 )   
##@@@L2621_:
##@@@L2622_:    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )   
##@@@L2623_:    {   
80005eac:	81 5f       	PUSH      {R6,LR}
80005eae:	e4 30       	SUB       SP, #4			;->0x04
80005eb0:	a0 58       	MOV       R5, R0
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005eb2:	20 5d       	PUSH      R0
80005eb4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005eb8:	08 00       	SYNC     SYNC     
80005eba:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005ebe:	08 00       	SYNC     SYNC     
80005ec0:	00 5d       	POP       R0
80005ec2:	20 5d       	PUSH      R0
80005ec4:	21 5d       	PUSH      R1
80005ec6:	17 44       	LD        R4, [PC + #23]        ;->0x80005f20  :=0x1ff
80005ec8:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005ecc:	24 58       	MOV       R1, R4
80005ece:	11 68       	NOT       R1, R1
80005ed0:	01 69       	ANL       R0, R1
80005ed2:	4f 11       	MOV       R4, #31			;->0x001F
80005ed4:	24 58       	MOV       R1, R4
80005ed6:	01 6a       	ORL       R0, R1
80005ed8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005edc:	08 00       	SYNC     SYNC     
80005ede:	01 5d       	POP       R1
80005ee0:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005ee2:	11 44       	LD        R4, [PC + #17]        ;->0x80005f24  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005ee4:	20 5d       	PUSH      R0
80005ee6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005eea:	08 00       	SYNC     SYNC     
80005eec:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005ef0:	08 00       	SYNC     SYNC     
80005ef2:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005ef4:	44 82       	LD.W      R4, [R4]
80005ef6:	40 38       	CMP       R4, #0			;->0x00
80005ef8:	07 f0       	JZ        $+7                   ;->0x80005f06
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80005efa:	0c 44       	LD        R4, [PC + #12]        ;->0x80005f28  :=0xd0000040
80005efc:	34 82       	LD.W      R3, [R4]
80005efe:	53 9c       	LD.W      R2, [R3 + #17]
80005f00:	52 c0       	ADD       R2, R2, #1
80005f02:	5a a4       	ST.W      [R3 + #17], R2
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80005f04:	44 82       	LD.W      R4, [R4]
##@@@F_:uxTaskPriorityGet():
##@@@P_:tasks.c:2633
##@@@L2628_:
##@@@L2629_:        taskENTER_CRITICAL();   
##@@@L2630_:        {   
##@@@L2631_:            /* If null is passed in here then it is the priority of the task   
##@@@L2632_:             * that called uxTaskPriorityGet() that is being queried. */   
##@@@L2633_:            pxTCB = prvGetTCBFromHandle( xTask );   
80005f06:	50 38       	CMP       R5, #0			;->0x00
80005f08:	03 f1       	JNZ       $+3                   ;->0x80005f0e
80005f0a:	08 45       	LD        R5, [PC + #8]         ;->0x80005f28  :=0xd0000040
80005f0c:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:2634
##@@@L2634_:            uxReturn = pxTCB->uxPriority;   
80005f0e:	f5 9a       	LD.W      R6, [R5 + #11]
##@@@P_:tasks.c:2636
##@@@L2635_:        }   
##@@@L2636_:        taskEXIT_CRITICAL();   
80005f10:	07 45       	LD        R5, [PC + #7]         ;->0x80005f2c  :=0x80005730
80005f12:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2640
##@@@L2637_:
##@@@L2638_:        traceRETURN_uxTaskPriorityGet( uxReturn );   
##@@@L2639_:
##@@@L2640_:        return uxReturn;   
80005f14:	06 58       	MOV       R0, R6
80005f16:	e4 28       	ADD       SP, #4			;->0x04
80005f18:	06 5d       	POP       R6
80005f1a:	0d 5d       	POP       LR
80005f1c:	1d 5c       	JMP       LR
80005f1e:	00 00       	NOP      NOP      
80005f20:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005f24:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80005f28:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005f2c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80005f2c

80005f30 <uxTaskPriorityGetFromISR>:
##@@@F_:uxTaskPriorityGetFromISR():
##@@@P_:tasks.c:2649
##@@@L2644_:/*-----------------------------------------------------------*/   
##@@@L2645_:
##@@@L2646_:#if ( INCLUDE_uxTaskPriorityGet == 1 )   
##@@@L2647_:
##@@@L2648_:    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )   
##@@@L2649_:    {   
80005f30:	81 5f       	PUSH      {R6,LR}
80005f32:	e4 30       	SUB       SP, #4			;->0x04
80005f34:	c0 58       	MOV       R6, R0
##@@@P_:tasks.c:2674
##@@@L2669_:         * simple as possible.  More information (albeit Cortex-M specific) is   
##@@@L2670_:         * provided on the following link:   
##@@@L2671_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L2672_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L2673_:
##@@@L2674_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80005f36:	08 45       	LD        R5, [PC + #8]         ;->0x80005f54  :=0x80008ff0
80005f38:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2678
##@@@L2675_:        {   
##@@@L2676_:            /* If null is passed in here then it is the priority of the calling   
##@@@L2677_:             * task that is being queried. */   
##@@@L2678_:            pxTCB = prvGetTCBFromHandle( xTask );   
80005f3a:	60 38       	CMP       R6, #0			;->0x00
80005f3c:	03 f1       	JNZ       $+3                   ;->0x80005f42
80005f3e:	07 45       	LD        R5, [PC + #7]         ;->0x80005f58  :=0xd0000040
80005f40:	65 82       	LD.W      R6, [R5]
##@@@P_:tasks.c:2679
##@@@L2679_:            uxReturn = pxTCB->uxPriority;   
80005f42:	f6 9a       	LD.W      R6, [R6 + #11]
##@@@P_:tasks.c:2681
##@@@L2680_:        }   
##@@@L2681_:        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80005f44:	06 45       	LD        R5, [PC + #6]         ;->0x80005f5c  :=0x80009034
80005f46:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2685
##@@@L2682_:
##@@@L2683_:        traceRETURN_uxTaskPriorityGetFromISR( uxReturn );   
##@@@L2684_:
##@@@L2685_:        return uxReturn;   
80005f48:	06 58       	MOV       R0, R6
80005f4a:	e4 28       	ADD       SP, #4			;->0x04
80005f4c:	06 5d       	POP       R6
80005f4e:	0d 5d       	POP       LR
80005f50:	1d 5c       	JMP       LR
80005f52:	00 00       	NOP      NOP      
80005f54:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
80005f58:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005f5c:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]

80005f60 <uxTaskBasePriorityGet>:
##@@@F_:uxTaskBasePriorityGet():
##@@@P_:tasks.c:2694
##@@@L2689_:/*-----------------------------------------------------------*/   
##@@@L2690_:
##@@@L2691_:#if ( ( INCLUDE_uxTaskPriorityGet == 1 ) && ( configUSE_MUTEXES == 1 ) )   
##@@@L2692_:
##@@@L2693_:    UBaseType_t uxTaskBasePriorityGet( const TaskHandle_t xTask )   
##@@@L2694_:    {   
80005f60:	81 5f       	PUSH      {R6,LR}
80005f62:	e4 30       	SUB       SP, #4			;->0x04
80005f64:	a0 58       	MOV       R5, R0
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005f66:	20 5d       	PUSH      R0
80005f68:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005f6c:	08 00       	SYNC     SYNC     
80005f6e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80005f72:	08 00       	SYNC     SYNC     
80005f74:	00 5d       	POP       R0
80005f76:	20 5d       	PUSH      R0
80005f78:	21 5d       	PUSH      R1
80005f7a:	17 44       	LD        R4, [PC + #23]        ;->0x80005fd4  :=0x1ff
80005f7c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80005f80:	24 58       	MOV       R1, R4
80005f82:	11 68       	NOT       R1, R1
80005f84:	01 69       	ANL       R0, R1
80005f86:	4f 11       	MOV       R4, #31			;->0x001F
80005f88:	24 58       	MOV       R1, R4
80005f8a:	01 6a       	ORL       R0, R1
80005f8c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80005f90:	08 00       	SYNC     SYNC     
80005f92:	01 5d       	POP       R1
80005f94:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005f96:	11 44       	LD        R4, [PC + #17]        ;->0x80005fd8  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80005f98:	20 5d       	PUSH      R0
80005f9a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80005f9e:	08 00       	SYNC     SYNC     
80005fa0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80005fa4:	08 00       	SYNC     SYNC     
80005fa6:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80005fa8:	44 82       	LD.W      R4, [R4]
80005faa:	40 38       	CMP       R4, #0			;->0x00
80005fac:	07 f0       	JZ        $+7                   ;->0x80005fba
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80005fae:	0c 44       	LD        R4, [PC + #12]        ;->0x80005fdc  :=0xd0000040
80005fb0:	34 82       	LD.W      R3, [R4]
80005fb2:	53 9c       	LD.W      R2, [R3 + #17]
80005fb4:	52 c0       	ADD       R2, R2, #1
80005fb6:	5a a4       	ST.W      [R3 + #17], R2
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80005fb8:	44 82       	LD.W      R4, [R4]
##@@@F_:uxTaskBasePriorityGet():
##@@@P_:tasks.c:2704
##@@@L2699_:
##@@@L2700_:        taskENTER_CRITICAL();   
##@@@L2701_:        {   
##@@@L2702_:            /* If null is passed in here then it is the base priority of the task   
##@@@L2703_:             * that called uxTaskBasePriorityGet() that is being queried. */   
##@@@L2704_:            pxTCB = prvGetTCBFromHandle( xTask );   
80005fba:	50 38       	CMP       R5, #0			;->0x00
80005fbc:	03 f1       	JNZ       $+3                   ;->0x80005fc2
80005fbe:	08 45       	LD        R5, [PC + #8]         ;->0x80005fdc  :=0xd0000040
80005fc0:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:2705
##@@@L2705_:            uxReturn = pxTCB->uxBasePriority;   
80005fc2:	35 9d       	LD.W      R6, [R5 + #20]
##@@@P_:tasks.c:2707
##@@@L2706_:        }   
##@@@L2707_:        taskEXIT_CRITICAL();   
80005fc4:	07 45       	LD        R5, [PC + #7]         ;->0x80005fe0  :=0x80005730
80005fc6:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2711
##@@@L2708_:
##@@@L2709_:        traceRETURN_uxTaskBasePriorityGet( uxReturn );   
##@@@L2710_:
##@@@L2711_:        return uxReturn;   
80005fc8:	06 58       	MOV       R0, R6
80005fca:	e4 28       	ADD       SP, #4			;->0x04
80005fcc:	06 5d       	POP       R6
80005fce:	0d 5d       	POP       LR
80005fd0:	1d 5c       	JMP       LR
80005fd2:	00 00       	NOP      NOP      
80005fd4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80005fd8:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80005fdc:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80005fe0:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80005fe0

80005fe4 <uxTaskBasePriorityGetFromISR>:
##@@@F_:uxTaskBasePriorityGetFromISR():
##@@@P_:tasks.c:2720
##@@@L2715_:/*-----------------------------------------------------------*/   
##@@@L2716_:
##@@@L2717_:#if ( ( INCLUDE_uxTaskPriorityGet == 1 ) && ( configUSE_MUTEXES == 1 ) )   
##@@@L2718_:
##@@@L2719_:    UBaseType_t uxTaskBasePriorityGetFromISR( const TaskHandle_t xTask )   
##@@@L2720_:    {   
80005fe4:	81 5f       	PUSH      {R6,LR}
80005fe6:	e4 30       	SUB       SP, #4			;->0x04
80005fe8:	c0 58       	MOV       R6, R0
##@@@P_:tasks.c:2745
##@@@L2740_:         * simple as possible.  More information (albeit Cortex-M specific) is   
##@@@L2741_:         * provided on the following link:   
##@@@L2742_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L2743_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L2744_:
##@@@L2745_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80005fea:	08 45       	LD        R5, [PC + #8]         ;->0x80006008  :=0x80008ff0
80005fec:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2749
##@@@L2746_:        {   
##@@@L2747_:            /* If null is passed in here then it is the base priority of the calling   
##@@@L2748_:             * task that is being queried. */   
##@@@L2749_:            pxTCB = prvGetTCBFromHandle( xTask );   
80005fee:	60 38       	CMP       R6, #0			;->0x00
80005ff0:	03 f1       	JNZ       $+3                   ;->0x80005ff6
80005ff2:	07 45       	LD        R5, [PC + #7]         ;->0x8000600c  :=0xd0000040
80005ff4:	65 82       	LD.W      R6, [R5]
##@@@P_:tasks.c:2750
##@@@L2750_:            uxReturn = pxTCB->uxBasePriority;   
80005ff6:	36 9d       	LD.W      R6, [R6 + #20]
##@@@P_:tasks.c:2752
##@@@L2751_:        }   
##@@@L2752_:        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80005ff8:	06 45       	LD        R5, [PC + #6]         ;->0x80006010  :=0x80009034
80005ffa:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2756
##@@@L2753_:
##@@@L2754_:        traceRETURN_uxTaskBasePriorityGetFromISR( uxReturn );   
##@@@L2755_:
##@@@L2756_:        return uxReturn;   
80005ffc:	06 58       	MOV       R0, R6
80005ffe:	e4 28       	ADD       SP, #4			;->0x04
80006000:	06 5d       	POP       R6
80006002:	0d 5d       	POP       LR
80006004:	1d 5c       	JMP       LR
80006006:	00 00       	NOP      NOP      
80006008:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
8000600c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80006010:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]

80006014 <vTaskPrioritySet>:
##@@@F_:vTaskPrioritySet():
##@@@P_:tasks.c:2766
##@@@L2761_:
##@@@L2762_:#if ( INCLUDE_vTaskPrioritySet == 1 )   
##@@@L2763_:
##@@@L2764_:    void vTaskPrioritySet( TaskHandle_t xTask,   
##@@@L2765_:                           UBaseType_t uxNewPriority )   
##@@@L2766_:    {   
80006014:	87 5f       	PUSH      {R6-R8,LR}
80006016:	ec 30       	SUB       SP, #12			;->0x0C
80006018:	a1 58       	MOV       R5, R1
8000601a:	c0 58       	MOV       R6, R0
8000601c:	20 5d       	PUSH      R0
8000601e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006022:	08 00       	SYNC     SYNC     
80006024:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006028:	08 00       	SYNC     SYNC     
8000602a:	00 5d       	POP       R0
8000602c:	20 5d       	PUSH      R0
8000602e:	21 5d       	PUSH      R1
80006030:	3d 44       	LD        R4, [PC + #61]        ;->0x80006124  :=0x1ff
80006032:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006036:	24 58       	MOV       R1, R4
80006038:	11 68       	NOT       R1, R1
8000603a:	01 69       	ANL       R0, R1
8000603c:	4f 11       	MOV       R4, #31			;->0x001F
8000603e:	24 58       	MOV       R1, R4
80006040:	01 6a       	ORL       R0, R1
80006042:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006046:	08 00       	SYNC     SYNC     
80006048:	01 5d       	POP       R1
8000604a:	00 5d       	POP       R0
##@@@P_:tasks.c:2777
##@@@L2772_:            BaseType_t xYieldForTask = pdFALSE;   
##@@@L2773_:        #endif   
##@@@L2774_:
##@@@L2775_:        traceENTER_vTaskPrioritySet( xTask, uxNewPriority );   
##@@@L2776_:
##@@@L2777_:        configASSERT( uxNewPriority < configMAX_PRIORITIES );   
8000604c:	5e 39       	CMP       R5, #30			;->0x1E
8000604e:	20 5d       	PUSH      R0
80006050:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006054:	08 00       	SYNC     SYNC     
80006056:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000605a:	08 00       	SYNC     SYNC     
8000605c:	00 5d       	POP       R0
8000605e:	02 f3       	JNC       $+2                   ;->0x80006062
80006060:	72 04       	SJMP      $+114                 ;->0x80006144
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6962
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80006062:	32 44       	LD        R4, [PC + #50]        ;->0x80006128  :=0xd0000064
80006064:	44 82       	LD.W      R4, [R4]
80006066:	40 38       	CMP       R4, #0			;->0x00
80006068:	07 f0       	JZ        $+7                   ;->0x80006076
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
8000606a:	31 44       	LD        R4, [PC + #49]        ;->0x8000612c  :=0xd0000040
8000606c:	34 82       	LD.W      R3, [R4]
8000606e:	53 9c       	LD.W      R2, [R3 + #17]
80006070:	52 c0       	ADD       R2, R2, #1
80006072:	5a a4       	ST.W      [R3 + #17], R2
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80006074:	44 82       	LD.W      R4, [R4]
##@@@F_:vTaskPrioritySet():
##@@@P_:tasks.c:2793
##@@@L2788_:
##@@@L2789_:        taskENTER_CRITICAL();   
##@@@L2790_:        {   
##@@@L2791_:            /* If null is passed in here then it is the priority of the calling   
##@@@L2792_:             * task that is being changed. */   
##@@@L2793_:            pxTCB = prvGetTCBFromHandle( xTask );   
80006076:	60 38       	CMP       R6, #0			;->0x00
80006078:	03 f1       	JNZ       $+3                   ;->0x8000607e
8000607a:	2d 44       	LD        R4, [PC + #45]        ;->0x8000612c  :=0xd0000040
8000607c:	64 82       	LD.W      R6, [R4]
##@@@P_:tasks.c:2799
##@@@L2794_:
##@@@L2795_:            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );   
##@@@L2796_:
##@@@L2797_:            #if ( configUSE_MUTEXES == 1 )   
##@@@L2798_:            {   
##@@@L2799_:                uxCurrentBasePriority = pxTCB->uxBasePriority;   
8000607e:	26 9d       	LD.W      R4, [R6 + #20]
##@@@P_:tasks.c:2807
##@@@L2802_:            {   
##@@@L2803_:                uxCurrentBasePriority = pxTCB->uxPriority;   
##@@@L2804_:            }   
##@@@L2805_:            #endif   
##@@@L2806_:
##@@@L2807_:            if( uxCurrentBasePriority != uxNewPriority )   
80006080:	45 70       	CMP       R4, R5
80006082:	02 f1       	JNZ       $+2                   ;->0x80006086
80006084:	49 04       	SJMP      $+73                  ;->0x80006116
80006086:	2a 43       	LD        R3, [PC + #42]        ;->0x8000612c  :=0xd0000040
80006088:	23 82       	LD.W      R2, [R3]
##@@@P_:tasks.c:2811
##@@@L2808_:            {   
##@@@L2809_:                /* The priority change may have readied a task of higher   
##@@@L2810_:                 * priority than a running task. */   
##@@@L2811_:                if( uxNewPriority > uxCurrentBasePriority )   
8000608a:	45 70       	CMP       R4, R5
8000608c:	09 f2       	JC        $+9                   ;->0x8000609e
8000608e:	81 10       	MOV       R8, #1			;->0x0001
##@@@P_:tasks.c:2815
##@@@L2812_:                {   
##@@@L2813_:                    #if ( configNUMBER_OF_CORES == 1 )   
##@@@L2814_:                    {   
##@@@L2815_:                        if( pxTCB != pxCurrentTCB )   
80006090:	62 70       	CMP       R6, R2
80006092:	0b f0       	JZ        $+11                  ;->0x800060a8
##@@@P_:tasks.c:2820
##@@@L2816_:                        {   
##@@@L2817_:                            /* The priority of a task other than the currently   
##@@@L2818_:                             * running task is being raised.  Is the priority being   
##@@@L2819_:                             * raised above that of the running task? */   
##@@@L2820_:                            if( uxNewPriority > pxCurrentTCB->uxPriority )   
80006094:	33 82       	LD.W      R3, [R3]
80006096:	db 9a       	LD.W      R3, [R3 + #11]
80006098:	35 70       	CMP       R3, R5
8000609a:	04 f3       	JNC       $+4                   ;->0x800060a2
8000609c:	06 04       	SJMP      $+6                   ;->0x800060a8
##@@@P_:tasks.c:2844
##@@@L2839_:                         * perform a yield for this task later. */   
##@@@L2840_:                        xYieldForTask = pdTRUE;   
##@@@L2841_:                    }   
##@@@L2842_:                    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L2843_:                }   
##@@@L2844_:                else if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )   
8000609e:	62 70       	CMP       R6, R2
800060a0:	03 f1       	JNZ       $+3                   ;->0x800060a6
800060a2:	80 10       	MOV       R8, #0			;->0x0000
800060a4:	02 04       	SJMP      $+2                   ;->0x800060a8
800060a6:	81 10       	MOV       R8, #1			;->0x0001
##@@@P_:tasks.c:2866
##@@@L2861_:                }   
##@@@L2862_:
##@@@L2863_:                /* Remember the ready list the task might be referenced from   
##@@@L2864_:                 * before its uxPriority member is changed so the   
##@@@L2865_:                 * taskRESET_READY_PRIORITY() macro can function correctly. */   
##@@@L2866_:                uxPriorityUsedOnEntry = pxTCB->uxPriority;   
800060a8:	de 9a       	LD.W      R3, [R6 + #11]
##@@@P_:tasks.c:2873
##@@@L2868_:                #if ( configUSE_MUTEXES == 1 )   
##@@@L2869_:                {   
##@@@L2870_:                    /* Only change the priority being used if the task is not   
##@@@L2871_:                     * currently using an inherited priority or the new priority   
##@@@L2872_:                     * is bigger than the inherited priority. */   
##@@@L2873_:                    if( ( pxTCB->uxBasePriority == pxTCB->uxPriority ) || ( uxNewPriority > pxTCB->uxPriority ) )   
800060aa:	43 70       	CMP       R4, R3
800060ac:	03 f0       	JZ        $+3                   ;->0x800060b2
800060ae:	35 70       	CMP       R3, R5
800060b0:	02 f2       	JC        $+2                   ;->0x800060b4
##@@@P_:tasks.c:2875
##@@@L2874_:                    {   
##@@@L2875_:                        pxTCB->uxPriority = uxNewPriority;   
800060b2:	f5 a2       	ST.W      [R6 + #11], R5
##@@@P_:tasks.c:2883
##@@@L2878_:                    {   
##@@@L2879_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L2880_:                    }   
##@@@L2881_:
##@@@L2882_:                    /* The base priority gets set whatever. */   
##@@@L2883_:                    pxTCB->uxBasePriority = uxNewPriority;   
800060b4:	35 a5       	ST.W      [R6 + #20], R5
##@@@P_:tasks.c:2893
##@@@L2888_:                }   
##@@@L2889_:                #endif /* if ( configUSE_MUTEXES == 1 ) */   
##@@@L2890_:
##@@@L2891_:                /* Only reset the event list item value if the value is not   
##@@@L2892_:                 * being used for anything else. */   
##@@@L2893_:                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0UL ) )   
800060b6:	a6 99       	LD.W      R4, [R6 + #6]
800060b8:	40 38       	CMP       R4, #0			;->0x00
800060ba:	04 fb       	JLT       $+4                   ;->0x800060c2
800060bc:	4e 11       	MOV       R4, #30			;->0x001E
##@@@P_:tasks.c:2895
##@@@L2894_:                {   
##@@@L2895_:                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) );   
800060be:	6c c7       	SUB       R5, R4, R5
800060c0:	b5 a1       	ST.W      [R6 + #6], R5
##@@@P_:tasks.c:2906
##@@@L2901_:
##@@@L2902_:                /* If the task is in the blocked or suspended list we need do   
##@@@L2903_:                 * nothing more than change its priority variable. However, if   
##@@@L2904_:                 * the task is in a ready list it needs to be removed and placed   
##@@@L2905_:                 * in the list appropriate to its new priority. */   
##@@@L2906_:                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )   
800060c2:	1c 47       	LD        R7, [PC + #28]        ;->0x80006130  :=0xd00000a0
800060c4:	24 11       	MOV       R2, #20			;->0x0014
800060c6:	a7 58       	MOV       R5, R7
800060c8:	66 99       	LD.W      R4, [R6 + #5]
800060ca:	19 00 62 14 	MADD32    R5, R3, R2
800060ce:	45 70       	CMP       R4, R5
800060d0:	1d f1       	JNZ       $+29                  ;->0x8000610a
800060d2:	02 22       	ST.W      [SP + #2], R2
800060d4:	06 c1       	ADD       R0, R6, #4
800060d6:	01 20       	ST.W      [SP + #1], R0
##@@@P_:tasks.c:2911
##@@@L2907_:                {   
##@@@L2908_:                    /* The task is currently in its ready list - remove before   
##@@@L2909_:                     * adding it to its new ready list.  As we are in a critical   
##@@@L2910_:                     * section we can do this even if the scheduler is suspended. */   
##@@@L2911_:                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
800060d8:	17 45       	LD        R5, [PC + #23]        ;->0x80006134  :=0x80002290
800060da:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2923
##@@@L2918_:                    else   
##@@@L2919_:                    {   
##@@@L2920_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L2921_:                    }   
##@@@L2922_:
##@@@L2923_:                    prvAddTaskToReadyList( pxTCB );   
800060dc:	17 44       	LD        R4, [PC + #23]        ;->0x80006138  :=0xd00002f8
800060de:	ee 9a       	LD.W      R5, [R6 + #11]
800060e0:	34 82       	LD.W      R3, [R4]
800060e2:	53 70       	CMP       R5, R3
800060e4:	02 f9       	JLS       $+2                   ;->0x800060e8
800060e6:	45 85       	ST.W      [R4], R5
800060e8:	87 58       	MOV       R4, R7
800060ea:	02 09       	LD.W      R1, [SP + #2]
800060ec:	19 00 a1 10 	MADD32    R4, R5, R1
800060f0:	5c 98       	LD.W      R3, [R4 + #1]
800060f2:	b3 a0       	ST.W      [R6 + #2], R3
800060f4:	93 98       	LD.W      R2, [R3 + #2]
800060f6:	f2 a0       	ST.W      [R6 + #3], R2
800060f8:	93 98       	LD.W      R2, [R3 + #2]
800060fa:	01 08       	LD.W      R0, [SP + #1]
800060fc:	50 a0       	ST.W      [R2 + #1], R0
800060fe:	98 a0       	ST.W      [R3 + #2], R0
80006100:	74 a1       	ST.W      [R6 + #5], R4
80006102:	6d ca       	MULS      R5, R5, R1
80006104:	67 e9       	LD.W      R4, [R7 + R5]
80006106:	64 c0       	ADD       R4, R4, #1
80006108:	7c ef       	ST.W      [R7 + R5], R4
8000610a:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:tasks.c:2941
##@@@L2936_:                        xYieldForTask = pdFALSE;   
##@@@L2937_:                    }   
##@@@L2938_:                    #endif   
##@@@L2939_:                }   
##@@@L2940_:
##@@@L2941_:                if( xYieldRequired != pdFALSE )   
8000610c:	85 69       	ANL       R8, R5
8000610e:	80 38       	CMP       R8, #0			;->0x00
80006110:	03 f1       	JNZ       $+3                   ;->0x80006116
##@@@P_:tasks.c:2944
##@@@L2942_:                {   
##@@@L2943_:                    /* The running task priority is set down. Request the task to yield. */   
##@@@L2944_:                    taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxTCB );   
80006112:	0b 45       	LD        R5, [PC + #11]        ;->0x8000613c  :=0x80008f64
80006114:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2968
##@@@L2963_:                /* Remove compiler warning about unused variables when the port   
##@@@L2964_:                 * optimised task selection is not being used. */   
##@@@L2965_:                ( void ) uxPriorityUsedOnEntry;   
##@@@L2966_:            }   
##@@@L2967_:        }   
##@@@L2968_:        taskEXIT_CRITICAL();   
80006116:	0b 45       	LD        R5, [PC + #11]        ;->0x80006140  :=0x80005730
80006118:	05 5c       	LJMP      R5
##@@@P_:tasks.c:2971
##@@@L2969_:
##@@@L2970_:        traceRETURN_vTaskPrioritySet();   
##@@@L2971_:    }   
8000611a:	ec 28       	ADD       SP, #12			;->0x0C
8000611c:	07 5e       	POP       {R6-R8}
8000611e:	0d 5d       	POP       LR
80006120:	1d 5c       	JMP       LR
80006122:	00 00       	NOP      NOP      
80006124:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006128:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
8000612c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80006130:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80006134:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80006138:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
8000613c:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80006140:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80006140
##@@@P_:tasks.c:2777
##@@@L2772_:            BaseType_t xYieldForTask = pdFALSE;   
##@@@L2773_:        #endif   
##@@@L2774_:
##@@@L2775_:        traceENTER_vTaskPrioritySet( xTask, uxNewPriority );   
##@@@L2776_:
##@@@L2777_:        configASSERT( uxNewPriority < configMAX_PRIORITIES );   
80006144:	07 00       	BREAK    BREAK    
80006146:	02 45       	LD        R5, [PC + #2]         ;->0x8000614c  :=0x8000911c
80006148:	05 5c       	LJMP      R5
8000614a:	00 00       	NOP      NOP      
8000614c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006150 <vTaskSuspend>:
##@@@F_:vTaskSuspend():
##@@@P_:tasks.c:3121
##@@@L3116_:/*-----------------------------------------------------------*/   
##@@@L3117_:
##@@@L3118_:#if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L3119_:
##@@@L3120_:    void vTaskSuspend( TaskHandle_t xTaskToSuspend )   
##@@@L3121_:    {   
80006150:	83 5f       	PUSH      {R6-R7,LR}
80006152:	ec 30       	SUB       SP, #12			;->0x0C
80006154:	c0 58       	MOV       R6, R0
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80006156:	20 5d       	PUSH      R0
80006158:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000615c:	08 00       	SYNC     SYNC     
8000615e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006162:	08 00       	SYNC     SYNC     
80006164:	00 5d       	POP       R0
80006166:	20 5d       	PUSH      R0
80006168:	21 5d       	PUSH      R1
8000616a:	4c 45       	LD        R5, [PC + #76]        ;->0x80006298  :=0x1ff
8000616c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006170:	25 58       	MOV       R1, R5
80006172:	11 68       	NOT       R1, R1
80006174:	01 69       	ANL       R0, R1
80006176:	5f 11       	MOV       R5, #31			;->0x001F
80006178:	25 58       	MOV       R1, R5
8000617a:	01 6a       	ORL       R0, R1
8000617c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006180:	08 00       	SYNC     SYNC     
80006182:	01 5d       	POP       R1
80006184:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80006186:	46 42       	LD        R2, [PC + #70]        ;->0x8000629c  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80006188:	20 5d       	PUSH      R0
8000618a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000618e:	08 00       	SYNC     SYNC     
80006190:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006194:	08 00       	SYNC     SYNC     
80006196:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80006198:	52 82       	LD.W      R5, [R2]
8000619a:	50 38       	CMP       R5, #0			;->0x00
8000619c:	07 f0       	JZ        $+7                   ;->0x800061aa
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
8000619e:	41 45       	LD        R5, [PC + #65]        ;->0x800062a0  :=0xd0000040
800061a0:	45 82       	LD.W      R4, [R5]
800061a2:	5c 9c       	LD.W      R3, [R4 + #17]
800061a4:	5b c0       	ADD       R3, R3, #1
800061a6:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
800061a8:	55 82       	LD.W      R5, [R5]
##@@@F_:vTaskSuspend():
800061aa:	02 22       	ST.W      [SP + #2], R2
##@@@P_:tasks.c:3134
##@@@L3129_:
##@@@L3130_:        taskENTER_CRITICAL();   
##@@@L3131_:        {   
##@@@L3132_:            /* If null is passed in here then it is the running task that is   
##@@@L3133_:             * being suspended. */   
##@@@L3134_:            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );   
800061ac:	60 38       	CMP       R6, #0			;->0x00
800061ae:	03 f1       	JNZ       $+3                   ;->0x800061b4
800061b0:	3c 45       	LD        R5, [PC + #60]        ;->0x800062a0  :=0xd0000040
800061b2:	65 82       	LD.W      R6, [R5]
##@@@P_:tasks.c:3144
##@@@L3139_:                xTaskRunningOnCore = pxTCB->xTaskRunState;   
##@@@L3140_:            #endif   
##@@@L3141_:
##@@@L3142_:            /* Remove task from the ready/delayed list and place in the   
##@@@L3143_:             * suspended list. */   
##@@@L3144_:            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
800061b4:	3e c1       	ADD       R7, R6, #4
800061b6:	07 58       	MOV       R0, R7
800061b8:	3b 45       	LD        R5, [PC + #59]        ;->0x800062a4  :=0x80002290
800061ba:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3154
##@@@L3149_:            {   
##@@@L3150_:                mtCOVERAGE_TEST_MARKER();   
##@@@L3151_:            }   
##@@@L3152_:
##@@@L3153_:            /* Is the task waiting on an event also? */   
##@@@L3154_:            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )   
800061bc:	ae 9a       	LD.W      R5, [R6 + #10]
800061be:	50 38       	CMP       R5, #0			;->0x00
800061c0:	05 f0       	JZ        $+5                   ;->0x800061ca
800061c2:	06 58       	MOV       R0, R6
800061c4:	08 29       	ADD       R0, #24			;->0x18
##@@@P_:tasks.c:3156
##@@@L3155_:            {   
##@@@L3156_:                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );   
800061c6:	38 45       	LD        R5, [PC + #56]        ;->0x800062a4  :=0x80002290
800061c8:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3163
##@@@L3158_:            else   
##@@@L3159_:            {   
##@@@L3160_:                mtCOVERAGE_TEST_MARKER();   
##@@@L3161_:            }   
##@@@L3162_:
##@@@L3163_:            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );   
800061ca:	38 40       	LD        R0, [PC + #56]        ;->0x800062a8  :=0xd000008c
800061cc:	01 20       	ST.W      [SP + #1], R0
800061ce:	27 58       	MOV       R1, R7
800061d0:	37 45       	LD        R5, [PC + #55]        ;->0x800062ac  :=0x80002244
800061d2:	05 5c       	LJMP      R5
800061d4:	51 00 c5 d0 	LD.B      R5, [R6 + #116]			;->0x74
##@@@P_:tasks.c:3171
##@@@L3166_:            {   
##@@@L3167_:                BaseType_t x;   
##@@@L3168_:
##@@@L3169_:                for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )   
##@@@L3170_:                {   
##@@@L3171_:                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )   
800061d8:	51 38       	CMP       R5, #1			;->0x01
800061da:	04 f1       	JNZ       $+4                   ;->0x800061e2
800061dc:	50 10       	MOV       R5, #0			;->0x0000
800061de:	79 00 c5 d0 	ST.B      [R6 + #116], R5			;->0x74
##@@@P_:tasks.c:3184
##@@@L3179_:            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */   
##@@@L3180_:        }   
##@@@L3181_:
##@@@L3182_:        #if ( configNUMBER_OF_CORES == 1 )   
##@@@L3183_:        {   
##@@@L3184_:            taskEXIT_CRITICAL();   
800061e2:	34 45       	LD        R5, [PC + #52]        ;->0x800062b0  :=0x80005730
800061e4:	05 5c       	LJMP      R5
800061e6:	02 0f       	LD.W      R7, [SP + #2]
##@@@P_:tasks.c:3186
##@@@L3185_:
##@@@L3186_:            if( xSchedulerRunning != pdFALSE )   
800061e8:	57 82       	LD.W      R5, [R7]
800061ea:	50 38       	CMP       R5, #0			;->0x00
800061ec:	38 f0       	JZ        $+56                  ;->0x8000625c
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800061ee:	20 5d       	PUSH      R0
800061f0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800061f4:	08 00       	SYNC     SYNC     
800061f6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800061fa:	08 00       	SYNC     SYNC     
800061fc:	00 5d       	POP       R0
800061fe:	20 5d       	PUSH      R0
80006200:	21 5d       	PUSH      R1
80006202:	26 45       	LD        R5, [PC + #38]        ;->0x80006298  :=0x1ff
80006204:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006208:	25 58       	MOV       R1, R5
8000620a:	11 68       	NOT       R1, R1
8000620c:	01 69       	ANL       R0, R1
8000620e:	5f 11       	MOV       R5, #31			;->0x001F
80006210:	25 58       	MOV       R1, R5
80006212:	01 6a       	ORL       R0, R1
80006214:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006218:	08 00       	SYNC     SYNC     
8000621a:	01 5d       	POP       R1
8000621c:	00 5d       	POP       R0
8000621e:	20 5d       	PUSH      R0
80006220:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006224:	08 00       	SYNC     SYNC     
80006226:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000622a:	08 00       	SYNC     SYNC     
8000622c:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
8000622e:	57 82       	LD.W      R5, [R7]
80006230:	50 38       	CMP       R5, #0			;->0x00
80006232:	07 f0       	JZ        $+7                   ;->0x80006240
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80006234:	1b 45       	LD        R5, [PC + #27]        ;->0x800062a0  :=0xd0000040
80006236:	45 82       	LD.W      R4, [R5]
80006238:	5c 9c       	LD.W      R3, [R4 + #17]
8000623a:	5b c0       	ADD       R3, R3, #1
8000623c:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
8000623e:	55 82       	LD.W      R5, [R5]
##@@@F_:prvResetNextTaskUnblockTime():
##@@@P_:tasks.c:6496
##@@@L6491_:#endif /* INCLUDE_vTaskDelete */   
##@@@L6492_:/*-----------------------------------------------------------*/   
##@@@L6493_:
##@@@L6494_:static void prvResetNextTaskUnblockTime( void )   
##@@@L6495_:{   
##@@@L6496_:    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )   
80006240:	1d 45       	LD        R5, [PC + #29]        ;->0x800062b4  :=0xd0000070
80006242:	45 82       	LD.W      R4, [R5]
80006244:	44 82       	LD.W      R4, [R4]
80006246:	40 38       	CMP       R4, #0			;->0x00
80006248:	05 f0       	JZ        $+5                   ;->0x80006252
##@@@P_:tasks.c:6510
##@@@L6505_:    {   
##@@@L6506_:        /* The new current delayed list is not empty, get the value of   
##@@@L6507_:         * the item at the head of the delayed list.  This is the time at   
##@@@L6508_:         * which the task at the head of the delayed list should be removed   
##@@@L6509_:         * from the Blocked state. */   
##@@@L6510_:        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );   
8000624a:	55 82       	LD.W      R5, [R5]
8000624c:	ed 98       	LD.W      R5, [R5 + #3]
8000624e:	55 82       	LD.W      R5, [R5]
80006250:	02 04       	SJMP      $+2                   ;->0x80006254
80006252:	1a 45       	LD        R5, [PC + #26]        ;->0x800062b8  :=0xffffffff
80006254:	1a 44       	LD        R4, [PC + #26]        ;->0x800062bc  :=0xd0000300
80006256:	45 85       	ST.W      [R4], R5
##@@@F_:vTaskSuspend():
##@@@P_:tasks.c:3194
##@@@L3189_:                 * task that is now in the Suspended state. */   
##@@@L3190_:                taskENTER_CRITICAL();   
##@@@L3191_:                {   
##@@@L3192_:                    prvResetNextTaskUnblockTime();   
##@@@L3193_:                }   
##@@@L3194_:                taskEXIT_CRITICAL();   
80006258:	16 45       	LD        R5, [PC + #22]        ;->0x800062b0  :=0x80005730
8000625a:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3201
##@@@L3196_:            else   
##@@@L3197_:            {   
##@@@L3198_:                mtCOVERAGE_TEST_MARKER();   
##@@@L3199_:            }   
##@@@L3200_:
##@@@L3201_:            if( pxTCB == pxCurrentTCB )   
8000625c:	11 45       	LD        R5, [PC + #17]        ;->0x800062a0  :=0xd0000040
8000625e:	45 82       	LD.W      R4, [R5]
80006260:	64 70       	CMP       R6, R4
80006262:	16 f1       	JNZ       $+22                  ;->0x8000628e
##@@@P_:tasks.c:3203
##@@@L3202_:            {   
##@@@L3203_:                if( xSchedulerRunning != pdFALSE )   
80006264:	47 82       	LD.W      R4, [R7]
80006266:	40 38       	CMP       R4, #0			;->0x00
80006268:	08 f0       	JZ        $+8                   ;->0x80006278
##@@@P_:tasks.c:3206
##@@@L3204_:                {   
##@@@L3205_:                    /* The current task has just been suspended. */   
##@@@L3206_:                    configASSERT( uxSchedulerSuspended == 0 );   
8000626a:	16 45       	LD        R5, [PC + #22]        ;->0x800062c0  :=0xd0000068
8000626c:	55 82       	LD.W      R5, [R5]
8000626e:	50 38       	CMP       R5, #0			;->0x00
80006270:	30 f1       	JNZ       $+48                  ;->0x800062d0
##@@@P_:tasks.c:3207
##@@@L3207_:                    portYIELD_WITHIN_API();   
80006272:	15 45       	LD        R5, [PC + #21]        ;->0x800062c4  :=0x80008f64
80006274:	05 5c       	LJMP      R5
80006276:	0c 04       	SJMP      $+12                  ;->0x8000628e
##@@@P_:tasks.c:3214
##@@@L3209_:                else   
##@@@L3210_:                {   
##@@@L3211_:                    /* The scheduler is not running, but the task that was pointed   
##@@@L3212_:                     * to by pxCurrentTCB has just been suspended and pxCurrentTCB   
##@@@L3213_:                     * must be adjusted to point to a different task. */   
##@@@L3214_:                    if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )   
80006278:	14 44       	LD        R4, [PC + #20]        ;->0x800062c8  :=0xd0000060
8000627a:	01 0b       	LD.W      R3, [SP + #1]
8000627c:	33 82       	LD.W      R3, [R3]
8000627e:	44 82       	LD.W      R4, [R4]
80006280:	34 70       	CMP       R3, R4
80006282:	04 f1       	JNZ       $+4                   ;->0x8000628a
80006284:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:tasks.c:3220
##@@@L3215_:                    {   
##@@@L3216_:                        /* No other tasks are ready, so set pxCurrentTCB back to   
##@@@L3217_:                         * NULL so when the next task is created pxCurrentTCB will   
##@@@L3218_:                         * be set to point to it no matter what its relative priority   
##@@@L3219_:                         * is. */   
##@@@L3220_:                        pxCurrentTCB = NULL;   
80006286:	54 85       	ST.W      [R5], R4
80006288:	03 04       	SJMP      $+3                   ;->0x8000628e
##@@@P_:tasks.c:3224
##@@@L3221_:                    }   
##@@@L3222_:                    else   
##@@@L3223_:                    {   
##@@@L3224_:                        vTaskSwitchContext();   
8000628a:	11 45       	LD        R5, [PC + #17]        ;->0x800062cc  :=0x80006320
8000628c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3281
##@@@L3276_:            taskEXIT_CRITICAL();   
##@@@L3277_:        }   
##@@@L3278_:        #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L3279_:
##@@@L3280_:        traceRETURN_vTaskSuspend();   
##@@@L3281_:    }   
8000628e:	ec 28       	ADD       SP, #12			;->0x0C
80006290:	03 5e       	POP       {R6-R7}
80006292:	0d 5d       	POP       LR
80006294:	1d 5c       	JMP       LR
80006296:	00 00       	NOP      NOP      
80006298:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000629c:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
800062a0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800062a4:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
800062a8:	8c 00 00 d0 	.long     0xd000008c ->-805306228  [!!!@4@:LJMP      $+839680              ;->0x801a02a8
800062ac:	44 22 00 80 	.long     0x80002244 ->-2147474876  [!!!@2@:ST.W      [SP + #68], R2	@@: LD.B      R0, [R0]
800062b0:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x800062b0
800062b4:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
800062b8:	ff ff ff ff 	.long     0xffffffff ->-00000001 
800062bc:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x800202bc
800062c0:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800062c4:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
800062c8:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
800062cc:	20 63 00 80 	.long     0x80006320 ->-2147458272  [!!!@2@:XCH       R2, R0	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:3206
##@@@L3201_:            if( pxTCB == pxCurrentTCB )   
##@@@L3202_:            {   
##@@@L3203_:                if( xSchedulerRunning != pdFALSE )   
##@@@L3204_:                {   
##@@@L3205_:                    /* The current task has just been suspended. */   
##@@@L3206_:                    configASSERT( uxSchedulerSuspended == 0 );   
800062d0:	20 5d       	PUSH      R0
800062d2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800062d6:	08 00       	SYNC     SYNC     
800062d8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800062dc:	08 00       	SYNC     SYNC     
800062de:	00 5d       	POP       R0
800062e0:	20 5d       	PUSH      R0
800062e2:	21 5d       	PUSH      R1
800062e4:	0d 45       	LD        R5, [PC + #13]        ;->0x80006318  :=0x1ff
800062e6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800062ea:	25 58       	MOV       R1, R5
800062ec:	11 68       	NOT       R1, R1
800062ee:	01 69       	ANL       R0, R1
800062f0:	5f 11       	MOV       R5, #31			;->0x001F
800062f2:	25 58       	MOV       R1, R5
800062f4:	01 6a       	ORL       R0, R1
800062f6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800062fa:	08 00       	SYNC     SYNC     
800062fc:	01 5d       	POP       R1
800062fe:	00 5d       	POP       R0
80006300:	20 5d       	PUSH      R0
80006302:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006306:	08 00       	SYNC     SYNC     
80006308:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000630c:	08 00       	SYNC     SYNC     
8000630e:	00 5d       	POP       R0
80006310:	07 00       	BREAK    BREAK    
80006312:	03 45       	LD        R5, [PC + #3]         ;->0x8000631c  :=0x8000911c
80006314:	05 5c       	LJMP      R5
80006316:	00 00       	NOP      NOP      
80006318:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000631c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006320 <vTaskSwitchContext>:
##@@@F_:vTaskSwitchContext():
##@@@P_:tasks.c:5096
##@@@L5091_:#endif /* configUSE_APPLICATION_TASK_TAG */   
##@@@L5092_:/*-----------------------------------------------------------*/   
##@@@L5093_:
##@@@L5094_:#if ( configNUMBER_OF_CORES == 1 )   
##@@@L5095_:    void vTaskSwitchContext( void )   
##@@@L5096_:    {   
80006320:	2d 5d       	PUSH      LR
80006322:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:5099
##@@@L5097_:        traceENTER_vTaskSwitchContext();   
##@@@L5098_:
##@@@L5099_:        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )   
80006324:	22 45       	LD        R5, [PC + #34]        ;->0x800063ac  :=0xd0000068
80006326:	55 82       	LD.W      R5, [R5]
80006328:	50 38       	CMP       R5, #0			;->0x00
8000632a:	05 f0       	JZ        $+5                   ;->0x80006334
##@@@P_:tasks.c:5103
##@@@L5100_:        {   
##@@@L5101_:            /* The scheduler is currently suspended - do not allow a context   
##@@@L5102_:             * switch. */   
##@@@L5103_:            xYieldPendings[ 0 ] = pdTRUE;   
8000632c:	21 45       	LD        R5, [PC + #33]        ;->0x800063b0  :=0xd00002fc
8000632e:	41 10       	MOV       R4, #1			;->0x0001
80006330:	54 85       	ST.W      [R5], R4
80006332:	3a 04       	SJMP      $+58                  ;->0x800063a6
##@@@P_:tasks.c:5107
##@@@L5104_:        }   
##@@@L5105_:        else   
##@@@L5106_:        {   
##@@@L5107_:            xYieldPendings[ 0 ] = pdFALSE;   
80006334:	1f 45       	LD        R5, [PC + #31]        ;->0x800063b0  :=0xd00002fc
80006336:	40 10       	MOV       R4, #0			;->0x0000
##@@@F_:xTaskGetTickCount():
##@@@P_:tasks.c:4083
##@@@L4078_:    traceENTER_xTaskGetTickCount();   
##@@@L4079_:
##@@@L4080_:    /* Critical section required if running on a 16 bit processor. */   
##@@@L4081_:    portTICK_TYPE_ENTER_CRITICAL();   
##@@@L4082_:    {   
##@@@L4083_:        xTicks = xTickCount;   
80006338:	1f 43       	LD        R3, [PC + #31]        ;->0x800063b4  :=0xd000006c
##@@@F_:vTaskSwitchContext():
##@@@P_:tasks.c:5107
##@@@L5102_:             * switch. */   
##@@@L5103_:            xYieldPendings[ 0 ] = pdTRUE;   
##@@@L5104_:        }   
##@@@L5105_:        else   
##@@@L5106_:        {   
##@@@L5107_:            xYieldPendings[ 0 ] = pdFALSE;   
8000633a:	54 85       	ST.W      [R5], R4
##@@@F_:xTaskGetTickCount():
##@@@P_:tasks.c:4083
##@@@L4078_:    traceENTER_xTaskGetTickCount();   
##@@@L4079_:
##@@@L4080_:    /* Critical section required if running on a 16 bit processor. */   
##@@@L4081_:    portTICK_TYPE_ENTER_CRITICAL();   
##@@@L4082_:    {   
##@@@L4083_:        xTicks = xTickCount;   
8000633c:	33 82       	LD.W      R3, [R3]
##@@@F_:vTaskSwitchContext():
##@@@P_:tasks.c:5115
##@@@L5110_:            #if ( configGENERATE_RUN_TIME_STATS == 1 )   
##@@@L5111_:            {   
##@@@L5112_:                #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE   
##@@@L5113_:                    portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime[ 0 ] );   
##@@@L5114_:                #else   
##@@@L5115_:                    ulTotalRunTime[ 0 ] = portGET_RUN_TIME_COUNTER_VALUE();   
8000633e:	1f 45       	LD        R5, [PC + #31]        ;->0x800063b8  :=0xd0000310
##@@@P_:tasks.c:5125
##@@@L5120_:                 * stored in ulTaskSwitchedInTime.  Note that there is no overflow   
##@@@L5121_:                 * protection here so count values are only valid until the timer   
##@@@L5122_:                 * overflows.  The guard against negative values is to protect   
##@@@L5123_:                 * against suspect run time stat counter implementations - which   
##@@@L5124_:                 * are provided by the application, not the kernel. */   
##@@@L5125_:                if( ulTotalRunTime[ 0 ] > ulTaskSwitchedInTime[ 0 ] )   
80006340:	1f 44       	LD        R4, [PC + #31]        ;->0x800063bc  :=0xd0000314
##@@@P_:tasks.c:5115
##@@@L5110_:            #if ( configGENERATE_RUN_TIME_STATS == 1 )   
##@@@L5111_:            {   
##@@@L5112_:                #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE   
##@@@L5113_:                    portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime[ 0 ] );   
##@@@L5114_:                #else   
##@@@L5115_:                    ulTotalRunTime[ 0 ] = portGET_RUN_TIME_COUNTER_VALUE();   
80006342:	53 85       	ST.W      [R5], R3
##@@@P_:tasks.c:5125
##@@@L5120_:                 * stored in ulTaskSwitchedInTime.  Note that there is no overflow   
##@@@L5121_:                 * protection here so count values are only valid until the timer   
##@@@L5122_:                 * overflows.  The guard against negative values is to protect   
##@@@L5123_:                 * against suspect run time stat counter implementations - which   
##@@@L5124_:                 * are provided by the application, not the kernel. */   
##@@@L5125_:                if( ulTotalRunTime[ 0 ] > ulTaskSwitchedInTime[ 0 ] )   
80006344:	34 82       	LD.W      R3, [R4]
80006346:	25 82       	LD.W      R2, [R5]
80006348:	23 70       	CMP       R2, R3
8000634a:	08 f9       	JLS       $+8                   ;->0x8000635a
##@@@P_:tasks.c:5127
##@@@L5126_:                {   
##@@@L5127_:                    pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime[ 0 ] - ulTaskSwitchedInTime[ 0 ] );   
8000634c:	1d 42       	LD        R2, [PC + #29]        ;->0x800063c0  :=0xd0000040
8000634e:	15 82       	LD.W      R1, [R5]
80006350:	22 82       	LD.W      R2, [R2]
80006352:	c2 9e       	LD.W      R0, [R2 + #27]
80006354:	d9 c6       	SUB       R3, R1, R3
80006356:	1b c2       	ADD       R3, R3, R0
80006358:	d3 a6       	ST.W      [R2 + #27], R3
##@@@P_:tasks.c:5134
##@@@L5129_:                else   
##@@@L5130_:                {   
##@@@L5131_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L5132_:                }   
##@@@L5133_:
##@@@L5134_:                ulTaskSwitchedInTime[ 0 ] = ulTotalRunTime[ 0 ];   
8000635a:	35 82       	LD.W      R3, [R5]
##@@@P_:tasks.c:5153
##@@@L5148_:            /* Select a new task to run using either the generic C or port   
##@@@L5149_:             * optimised asm code. */   
##@@@L5150_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5151_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5152_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5153_:            taskSELECT_HIGHEST_PRIORITY_TASK();   
8000635c:	1a 45       	LD        R5, [PC + #26]        ;->0x800063c4  :=0xd00002f8
##@@@P_:tasks.c:5134
##@@@L5129_:                else   
##@@@L5130_:                {   
##@@@L5131_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L5132_:                }   
##@@@L5133_:
##@@@L5134_:                ulTaskSwitchedInTime[ 0 ] = ulTotalRunTime[ 0 ];   
8000635e:	43 85       	ST.W      [R4], R3
##@@@P_:tasks.c:5153
##@@@L5148_:            /* Select a new task to run using either the generic C or port   
##@@@L5149_:             * optimised asm code. */   
##@@@L5150_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5151_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5152_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5153_:            taskSELECT_HIGHEST_PRIORITY_TASK();   
80006360:	45 82       	LD.W      R4, [R5]
80006362:	24 11       	MOV       R2, #20			;->0x0014
80006364:	19 43       	LD        R3, [PC + #25]        ;->0x800063c8  :=0xd00000a0
80006366:	8c ca       	MULS      R1, R4, R2
80006368:	4b e8       	LD.W      R1, [R3 + R1]
8000636a:	10 38       	CMP       R1, #0			;->0x00
8000636c:	0c f1       	JNZ       $+12                  ;->0x80006384
8000636e:	23 58       	MOV       R1, R3
80006370:	19 00 82 04 	MADD32    R1, R4, R2
80006374:	14 31       	SUB       R1, #20			;->0x14
80006376:	40 38       	CMP       R4, #0			;->0x00
80006378:	2a f0       	JZ        $+42                  ;->0x800063cc
8000637a:	64 cc       	SUB       R4, R4, #1
8000637c:	01 82       	LD.W      R0, [R1]
8000637e:	14 31       	SUB       R1, #20			;->0x14
80006380:	00 38       	CMP       R0, #0			;->0x00
80006382:	fa f0       	JZ        $-6                   ;->0x80006376
80006384:	19 00 82 0c 	MADD32    R3, R4, R2
80006388:	53 98       	LD.W      R2, [R3 + #1]
8000638a:	52 98       	LD.W      R2, [R2 + #1]
8000638c:	23 58       	MOV       R1, R3
8000638e:	18 28       	ADD       R1, #8			;->0x08
80006390:	21 70       	CMP       R2, R1
80006392:	5a a0       	ST.W      [R3 + #1], R2
80006394:	04 f1       	JNZ       $+4                   ;->0x8000639c
80006396:	d3 98       	LD.W      R2, [R3 + #3]
80006398:	1b c1       	ADD       R3, R3, #4
8000639a:	32 85       	ST.W      [R3], R2
8000639c:	da 98       	LD.W      R3, [R2 + #3]
8000639e:	09 42       	LD        R2, [PC + #9]         ;->0x800063c0  :=0xd0000040
800063a0:	23 85       	ST.W      [R2], R3
800063a2:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:5159
##@@@L5154_:            traceTASK_SWITCHED_IN();   
##@@@L5155_:
##@@@L5156_:            /* Macro to inject port specific behaviour immediately after   
##@@@L5157_:             * switching tasks, such as setting an end of stack watchpoint   
##@@@L5158_:             * or reconfiguring the MPU. */   
##@@@L5159_:            portTASK_SWITCH_HOOK( pxCurrentTCB );   
800063a4:	52 82       	LD.W      R5, [R2]
##@@@P_:tasks.c:5178
##@@@L5173_:            }   
##@@@L5174_:            #endif   
##@@@L5175_:        }   
##@@@L5176_:
##@@@L5177_:        traceRETURN_vTaskSwitchContext();   
##@@@L5178_:    }   
800063a6:	e4 28       	ADD       SP, #4			;->0x04
800063a8:	0d 5d       	POP       LR
800063aa:	1d 5c       	JMP       LR
800063ac:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800063b0:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
800063b4:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
800063b8:	10 03 00 d0 	.long     0xd0000310 ->-805305584  [!!!@4@:JMP       $+1101824             ;->0x802203b8
800063bc:	14 03 00 d0 	.long     0xd0000314 ->-805305580  [!!!@4@:JMP       $+1363968             ;->0x802a03bc
800063c0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800063c4:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
800063c8:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
##@@@P_:tasks.c:5153
##@@@L5148_:            /* Select a new task to run using either the generic C or port   
##@@@L5149_:             * optimised asm code. */   
##@@@L5150_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5151_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5152_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5153_:            taskSELECT_HIGHEST_PRIORITY_TASK();   
800063cc:	20 5d       	PUSH      R0
800063ce:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800063d2:	08 00       	SYNC     SYNC     
800063d4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800063d8:	08 00       	SYNC     SYNC     
800063da:	00 5d       	POP       R0
800063dc:	20 5d       	PUSH      R0
800063de:	21 5d       	PUSH      R1
800063e0:	0d 45       	LD        R5, [PC + #13]        ;->0x80006414  :=0x1ff
800063e2:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800063e6:	25 58       	MOV       R1, R5
800063e8:	11 68       	NOT       R1, R1
800063ea:	01 69       	ANL       R0, R1
800063ec:	5f 11       	MOV       R5, #31			;->0x001F
800063ee:	25 58       	MOV       R1, R5
800063f0:	01 6a       	ORL       R0, R1
800063f2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800063f6:	08 00       	SYNC     SYNC     
800063f8:	01 5d       	POP       R1
800063fa:	00 5d       	POP       R0
800063fc:	20 5d       	PUSH      R0
800063fe:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006402:	08 00       	SYNC     SYNC     
80006404:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006408:	08 00       	SYNC     SYNC     
8000640a:	00 5d       	POP       R0
8000640c:	07 00       	BREAK    BREAK    
8000640e:	03 45       	LD        R5, [PC + #3]         ;->0x80006418  :=0x8000911c
80006410:	05 5c       	LJMP      R5
80006412:	00 00       	NOP      NOP      
80006414:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006418:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

8000641c <vTaskResume>:
##@@@F_:vTaskResume():
##@@@P_:tasks.c:3359
##@@@L3354_:/*-----------------------------------------------------------*/   
##@@@L3355_:
##@@@L3356_:#if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L3357_:
##@@@L3358_:    void vTaskResume( TaskHandle_t xTaskToResume )   
##@@@L3359_:    {   
8000641c:	83 5f       	PUSH      {R6-R7,LR}
8000641e:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:tasks.c:3365
##@@@L3360_:        TCB_t * const pxTCB = xTaskToResume;   
##@@@L3361_:
##@@@L3362_:        traceENTER_vTaskResume( xTaskToResume );   
##@@@L3363_:
##@@@L3364_:        /* It does not make sense to resume the calling task. */   
##@@@L3365_:        configASSERT( xTaskToResume );   
80006420:	00 38       	CMP       R0, #0			;->0x00
80006422:	02 f1       	JNZ       $+2                   ;->0x80006426
80006424:	76 04       	SJMP      $+118                 ;->0x80006510
80006426:	c0 58       	MOV       R6, R0
##@@@P_:tasks.c:3371
##@@@L3366_:
##@@@L3367_:        #if ( configNUMBER_OF_CORES == 1 )   
##@@@L3368_:
##@@@L3369_:            /* The parameter cannot be NULL as it is impossible to resume the   
##@@@L3370_:             * currently executing task. */   
##@@@L3371_:            if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )   
80006428:	31 47       	LD        R7, [PC + #49]        ;->0x800064ec  :=0xd0000040
8000642a:	57 82       	LD.W      R5, [R7]
8000642c:	50 70       	CMP       R5, R0
8000642e:	5b f0       	JZ        $+91                  ;->0x800064e4
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80006430:	20 5d       	PUSH      R0
80006432:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006436:	08 00       	SYNC     SYNC     
80006438:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000643c:	08 00       	SYNC     SYNC     
8000643e:	00 5d       	POP       R0
80006440:	20 5d       	PUSH      R0
80006442:	21 5d       	PUSH      R1
80006444:	2b 45       	LD        R5, [PC + #43]        ;->0x800064f0  :=0x1ff
80006446:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000644a:	25 58       	MOV       R1, R5
8000644c:	11 68       	NOT       R1, R1
8000644e:	01 69       	ANL       R0, R1
80006450:	5f 11       	MOV       R5, #31			;->0x001F
80006452:	25 58       	MOV       R1, R5
80006454:	01 6a       	ORL       R0, R1
80006456:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000645a:	08 00       	SYNC     SYNC     
8000645c:	01 5d       	POP       R1
8000645e:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80006460:	25 45       	LD        R5, [PC + #37]        ;->0x800064f4  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80006462:	20 5d       	PUSH      R0
80006464:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006468:	08 00       	SYNC     SYNC     
8000646a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000646e:	08 00       	SYNC     SYNC     
80006470:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80006472:	55 82       	LD.W      R5, [R5]
80006474:	50 38       	CMP       R5, #0			;->0x00
80006476:	06 f0       	JZ        $+6                   ;->0x80006482
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80006478:	57 82       	LD.W      R5, [R7]
8000647a:	65 9c       	LD.W      R4, [R5 + #17]
8000647c:	64 c0       	ADD       R4, R4, #1
8000647e:	6c a4       	ST.W      [R5 + #17], R4
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80006480:	57 82       	LD.W      R5, [R7]
##@@@F_:prvTaskIsTaskSuspended():
##@@@P_:tasks.c:3300
##@@@L3295_:
##@@@L3296_:        /* It does not make sense to check if the calling task is suspended. */   
##@@@L3297_:        configASSERT( xTask );   
##@@@L3298_:
##@@@L3299_:        /* Is the task being resumed actually in the suspended list? */   
##@@@L3300_:        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )   
80006482:	6e 99       	LD.W      R5, [R6 + #5]
80006484:	1d 44       	LD        R4, [PC + #29]        ;->0x800064f8  :=0xd000008c
80006486:	54 70       	CMP       R5, R4
80006488:	2c f1       	JNZ       $+44                  ;->0x800064e0
##@@@P_:tasks.c:3303
##@@@L3301_:        {   
##@@@L3302_:            /* Has the task already been resumed from within an ISR? */   
##@@@L3303_:            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )   
8000648a:	ae 9a       	LD.W      R5, [R6 + #10]
8000648c:	50 38       	CMP       R5, #0			;->0x00
8000648e:	29 f1       	JNZ       $+41                  ;->0x800064e0
80006490:	51 00 c5 d0 	LD.B      R5, [R6 + #116]			;->0x74
##@@@F_:vTaskResume():
##@@@P_:tasks.c:3384
##@@@L3379_:            if( pxTCB != NULL )   
##@@@L3380_:        #endif   
##@@@L3381_:        {   
##@@@L3382_:            taskENTER_CRITICAL();   
##@@@L3383_:            {   
##@@@L3384_:                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )   
80006494:	51 38       	CMP       R5, #1			;->0x01
80006496:	25 f0       	JZ        $+37                  ;->0x800064e0
##@@@P_:tasks.c:3390
##@@@L3385_:                {   
##@@@L3386_:                    traceTASK_RESUME( pxTCB );   
##@@@L3387_:
##@@@L3388_:                    /* The ready list can be accessed even if the scheduler is   
##@@@L3389_:                     * suspended because this is inside a critical section. */   
##@@@L3390_:                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );   
80006498:	06 c1       	ADD       R0, R6, #4
8000649a:	02 20       	ST.W      [SP + #2], R0
8000649c:	18 45       	LD        R5, [PC + #24]        ;->0x800064fc  :=0x80002290
8000649e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3391
##@@@L3391_:                    prvAddTaskToReadyList( pxTCB );   
800064a0:	18 44       	LD        R4, [PC + #24]        ;->0x80006500  :=0xd00002f8
800064a2:	ee 9a       	LD.W      R5, [R6 + #11]
800064a4:	34 82       	LD.W      R3, [R4]
800064a6:	53 70       	CMP       R5, R3
800064a8:	02 f9       	JLS       $+2                   ;->0x800064ac
800064aa:	45 85       	ST.W      [R4], R5
800064ac:	16 44       	LD        R4, [PC + #22]        ;->0x80006504  :=0xd00000a0
800064ae:	34 11       	MOV       R3, #20			;->0x0014
800064b0:	44 58       	MOV       R2, R4
800064b2:	19 00 a3 08 	MADD32    R2, R5, R3
800064b6:	4a 98       	LD.W      R1, [R2 + #1]
800064b8:	b1 a0       	ST.W      [R6 + #2], R1
800064ba:	81 98       	LD.W      R0, [R1 + #2]
800064bc:	f0 a0       	ST.W      [R6 + #3], R0
800064be:	81 98       	LD.W      R0, [R1 + #2]
800064c0:	01 25       	ST.W      [SP + #1], R5
800064c2:	02 0d       	LD.W      R5, [SP + #2]
800064c4:	45 a0       	ST.W      [R0 + #1], R5
800064c6:	8d a0       	ST.W      [R1 + #2], R5
800064c8:	72 a1       	ST.W      [R6 + #5], R2
800064ca:	01 0d       	LD.W      R5, [SP + #1]
800064cc:	dd ca       	MULS      R3, R5, R3
800064ce:	d4 e8       	LD.W      R2, [R4 + R3]
800064d0:	52 c0       	ADD       R2, R2, #1
800064d2:	e2 ee       	ST.W      [R4 + R3], R2
##@@@P_:tasks.c:3396
##@@@L3392_:
##@@@L3393_:                    /* This yield may not cause the task just resumed to run,   
##@@@L3394_:                     * but will leave the lists in the correct state for the   
##@@@L3395_:                     * next yield. */   
##@@@L3396_:                    taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );   
800064d4:	47 82       	LD.W      R4, [R7]
800064d6:	e4 9a       	LD.W      R4, [R4 + #11]
800064d8:	45 70       	CMP       R4, R5
800064da:	03 f2       	JC        $+3                   ;->0x800064e0
800064dc:	0b 45       	LD        R5, [PC + #11]        ;->0x80006508  :=0x80008f64
800064de:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3403
##@@@L3398_:                else   
##@@@L3399_:                {   
##@@@L3400_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L3401_:                }   
##@@@L3402_:            }   
##@@@L3403_:            taskEXIT_CRITICAL();   
800064e0:	0b 45       	LD        R5, [PC + #11]        ;->0x8000650c  :=0x80005730
800064e2:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3411
##@@@L3406_:        {   
##@@@L3407_:            mtCOVERAGE_TEST_MARKER();   
##@@@L3408_:        }   
##@@@L3409_:
##@@@L3410_:        traceRETURN_vTaskResume();   
##@@@L3411_:    }   
800064e4:	ec 28       	ADD       SP, #12			;->0x0C
800064e6:	03 5e       	POP       {R6-R7}
800064e8:	0d 5d       	POP       LR
800064ea:	1d 5c       	JMP       LR
800064ec:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800064f0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800064f4:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
800064f8:	8c 00 00 d0 	.long     0xd000008c ->-805306228  [!!!@4@:LJMP      $+839680              ;->0x801a04f8
800064fc:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80006500:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
80006504:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80006508:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
8000650c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x8000650c
##@@@P_:tasks.c:3365
##@@@L3360_:        TCB_t * const pxTCB = xTaskToResume;   
##@@@L3361_:
##@@@L3362_:        traceENTER_vTaskResume( xTaskToResume );   
##@@@L3363_:
##@@@L3364_:        /* It does not make sense to resume the calling task. */   
##@@@L3365_:        configASSERT( xTaskToResume );   
80006510:	20 5d       	PUSH      R0
80006512:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006516:	08 00       	SYNC     SYNC     
80006518:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000651c:	08 00       	SYNC     SYNC     
8000651e:	00 5d       	POP       R0
80006520:	20 5d       	PUSH      R0
80006522:	21 5d       	PUSH      R1
80006524:	0d 45       	LD        R5, [PC + #13]        ;->0x80006558  :=0x1ff
80006526:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000652a:	25 58       	MOV       R1, R5
8000652c:	11 68       	NOT       R1, R1
8000652e:	01 69       	ANL       R0, R1
80006530:	5f 11       	MOV       R5, #31			;->0x001F
80006532:	25 58       	MOV       R1, R5
80006534:	01 6a       	ORL       R0, R1
80006536:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000653a:	08 00       	SYNC     SYNC     
8000653c:	01 5d       	POP       R1
8000653e:	00 5d       	POP       R0
80006540:	20 5d       	PUSH      R0
80006542:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006546:	08 00       	SYNC     SYNC     
80006548:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000654c:	08 00       	SYNC     SYNC     
8000654e:	00 5d       	POP       R0
80006550:	07 00       	BREAK    BREAK    
80006552:	03 45       	LD        R5, [PC + #3]         ;->0x8000655c  :=0x8000911c
80006554:	05 5c       	LJMP      R5
80006556:	00 00       	NOP      NOP      
80006558:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000655c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006560 <xTaskResumeFromISR>:
##@@@F_:xTaskResumeFromISR():
##@@@P_:tasks.c:3420
##@@@L3415_:/*-----------------------------------------------------------*/   
##@@@L3416_:
##@@@L3417_:#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )   
##@@@L3418_:
##@@@L3419_:    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )   
##@@@L3420_:    {   
80006560:	87 5f       	PUSH      {R6-R8,LR}
80006562:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:tasks.c:3427
##@@@L3422_:        TCB_t * const pxTCB = xTaskToResume;   
##@@@L3423_:        UBaseType_t uxSavedInterruptStatus;   
##@@@L3424_:
##@@@L3425_:        traceENTER_xTaskResumeFromISR( xTaskToResume );   
##@@@L3426_:
##@@@L3427_:        configASSERT( xTaskToResume );   
80006564:	00 38       	CMP       R0, #0			;->0x00
80006566:	02 f1       	JNZ       $+2                   ;->0x8000656a
80006568:	58 04       	SJMP      $+88                  ;->0x80006618
8000656a:	e0 58       	MOV       R7, R0
##@@@P_:tasks.c:3447
##@@@L3442_:         * simple as possible.  More information (albeit Cortex-M specific) is   
##@@@L3443_:         * provided on the following link:   
##@@@L3444_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L3445_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L3446_:
##@@@L3447_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
8000656c:	10 45       	LD        R5, [PC + #16]        ;->0x800065ac  :=0x80008ff0
8000656e:	05 5c       	LJMP      R5
##@@@F_:prvTaskIsTaskSuspended():
##@@@P_:tasks.c:3300
##@@@L3295_:
##@@@L3296_:        /* It does not make sense to check if the calling task is suspended. */   
##@@@L3297_:        configASSERT( xTask );   
##@@@L3298_:
##@@@L3299_:        /* Is the task being resumed actually in the suspended list? */   
##@@@L3300_:        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )   
80006570:	6f 99       	LD.W      R5, [R7 + #5]
80006572:	10 44       	LD        R4, [PC + #16]        ;->0x800065b0  :=0xd000008c
80006574:	54 70       	CMP       R5, R4
##@@@F_:xTaskResumeFromISR():
##@@@P_:tasks.c:3447
##@@@L3442_:         * simple as possible.  More information (albeit Cortex-M specific) is   
##@@@L3443_:         * provided on the following link:   
##@@@L3444_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L3445_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L3446_:
##@@@L3447_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80006576:	c0 58       	MOV       R6, R0
##@@@F_:prvTaskIsTaskSuspended():
##@@@P_:tasks.c:3300
##@@@L3295_:
##@@@L3296_:        /* It does not make sense to check if the calling task is suspended. */   
##@@@L3297_:        configASSERT( xTask );   
##@@@L3298_:
##@@@L3299_:        /* Is the task being resumed actually in the suspended list? */   
##@@@L3300_:        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )   
80006578:	11 f1       	JNZ       $+17                  ;->0x8000659a
##@@@P_:tasks.c:3303
##@@@L3301_:        {   
##@@@L3302_:            /* Has the task already been resumed from within an ISR? */   
##@@@L3303_:            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )   
8000657a:	af 9a       	LD.W      R5, [R7 + #10]
8000657c:	50 38       	CMP       R5, #0			;->0x00
8000657e:	0e f1       	JNZ       $+14                  ;->0x8000659a
80006580:	51 00 e5 d0 	LD.B      R5, [R7 + #116]			;->0x74
##@@@F_:xTaskResumeFromISR():
##@@@P_:tasks.c:3449
##@@@L3444_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L3445_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L3446_:
##@@@L3447_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
##@@@L3448_:        {   
##@@@L3449_:            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )   
80006584:	51 38       	CMP       R5, #1			;->0x01
80006586:	0a f0       	JZ        $+10                  ;->0x8000659a
##@@@P_:tasks.c:3454
##@@@L3450_:            {   
##@@@L3451_:                traceTASK_RESUME_FROM_ISR( pxTCB );   
##@@@L3452_:
##@@@L3453_:                /* Check the ready lists can be accessed. */   
##@@@L3454_:                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
80006588:	0b 45       	LD        R5, [PC + #11]        ;->0x800065b4  :=0xd0000068
8000658a:	55 82       	LD.W      R5, [R5]
8000658c:	50 38       	CMP       R5, #0			;->0x00
8000658e:	1b f0       	JZ        $+27                  ;->0x800065c4
##@@@P_:tasks.c:3484
##@@@L3479_:                else   
##@@@L3480_:                {   
##@@@L3481_:                    /* The delayed or ready lists cannot be accessed so the task   
##@@@L3482_:                     * is held in the pending ready list until the scheduler is   
##@@@L3483_:                     * unsuspended. */   
##@@@L3484_:                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );   
80006590:	0a 40       	LD        R0, [PC + #10]        ;->0x800065b8  :=0xd0000078
80006592:	78 29       	ADD       R7, #24			;->0x18
80006594:	27 58       	MOV       R1, R7
80006596:	0a 45       	LD        R5, [PC + #10]        ;->0x800065bc  :=0x80002244
80006598:	05 5c       	LJMP      R5
8000659a:	80 10       	MOV       R8, #0			;->0x0000
##@@@P_:tasks.c:3503
##@@@L3498_:            else   
##@@@L3499_:            {   
##@@@L3500_:                mtCOVERAGE_TEST_MARKER();   
##@@@L3501_:            }   
##@@@L3502_:        }   
##@@@L3503_:        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
8000659c:	06 58       	MOV       R0, R6
8000659e:	09 45       	LD        R5, [PC + #9]         ;->0x800065c0  :=0x80009034
800065a0:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3507
##@@@L3504_:
##@@@L3505_:        traceRETURN_xTaskResumeFromISR( xYieldRequired );   
##@@@L3506_:
##@@@L3507_:        return xYieldRequired;   
800065a2:	08 58       	MOV       R0, R8
800065a4:	ec 28       	ADD       SP, #12			;->0x0C
800065a6:	07 5e       	POP       {R6-R8}
800065a8:	0d 5d       	POP       LR
800065aa:	1d 5c       	JMP       LR
800065ac:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
800065b0:	8c 00 00 d0 	.long     0xd000008c ->-805306228  [!!!@4@:LJMP      $+839680              ;->0x801a05b0
800065b4:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800065b8:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
800065bc:	44 22 00 80 	.long     0x80002244 ->-2147474876  [!!!@2@:ST.W      [SP + #68], R2	@@: LD.B      R0, [R0]
800065c0:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:3460
##@@@L3455_:                {   
##@@@L3456_:                    #if ( configNUMBER_OF_CORES == 1 )   
##@@@L3457_:                    {   
##@@@L3458_:                        /* Ready lists can be accessed so move the task from the   
##@@@L3459_:                         * suspended list to the ready list directly. */   
##@@@L3460_:                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
800065c4:	27 45       	LD        R5, [PC + #39]        ;->0x80006660  :=0xd0000040
800065c6:	e7 9a       	LD.W      R4, [R7 + #11]
800065c8:	55 82       	LD.W      R5, [R5]
800065ca:	ed 9a       	LD.W      R5, [R5 + #11]
800065cc:	45 70       	CMP       R4, R5
800065ce:	05 f9       	JLS       $+5                   ;->0x800065d8
##@@@P_:tasks.c:3467
##@@@L3462_:                            xYieldRequired = pdTRUE;   
##@@@L3463_:
##@@@L3464_:                            /* Mark that a yield is pending in case the user is not   
##@@@L3465_:                             * using the return value to initiate a context switch   
##@@@L3466_:                             * from the ISR using the port specific portYIELD_FROM_ISR(). */   
##@@@L3467_:                            xYieldPendings[ 0 ] = pdTRUE;   
800065d0:	25 45       	LD        R5, [PC + #37]        ;->0x80006664  :=0xd00002fc
800065d2:	81 10       	MOV       R8, #1			;->0x0001
800065d4:	58 85       	ST.W      [R5], R8
800065d6:	02 04       	SJMP      $+2                   ;->0x800065da
800065d8:	80 10       	MOV       R8, #0			;->0x0000
##@@@P_:tasks.c:3476
##@@@L3471_:                            mtCOVERAGE_TEST_MARKER();   
##@@@L3472_:                        }   
##@@@L3473_:                    }   
##@@@L3474_:                    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L3475_:
##@@@L3476_:                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );   
800065da:	07 c1       	ADD       R0, R7, #4
800065dc:	02 20       	ST.W      [SP + #2], R0
800065de:	23 45       	LD        R5, [PC + #35]        ;->0x80006668  :=0x80002290
800065e0:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3477
##@@@L3477_:                    prvAddTaskToReadyList( pxTCB );   
800065e2:	23 44       	LD        R4, [PC + #35]        ;->0x8000666c  :=0xd00002f8
800065e4:	ef 9a       	LD.W      R5, [R7 + #11]
800065e6:	34 82       	LD.W      R3, [R4]
800065e8:	53 70       	CMP       R5, R3
800065ea:	02 f9       	JLS       $+2                   ;->0x800065ee
800065ec:	45 85       	ST.W      [R4], R5
800065ee:	21 44       	LD        R4, [PC + #33]        ;->0x80006670  :=0xd00000a0
800065f0:	34 11       	MOV       R3, #20			;->0x0014
800065f2:	44 58       	MOV       R2, R4
800065f4:	19 00 a3 08 	MADD32    R2, R5, R3
800065f8:	4a 98       	LD.W      R1, [R2 + #1]
800065fa:	b9 a0       	ST.W      [R7 + #2], R1
800065fc:	81 98       	LD.W      R0, [R1 + #2]
800065fe:	f8 a0       	ST.W      [R7 + #3], R0
80006600:	81 98       	LD.W      R0, [R1 + #2]
80006602:	01 25       	ST.W      [SP + #1], R5
80006604:	02 0d       	LD.W      R5, [SP + #2]
80006606:	45 a0       	ST.W      [R0 + #1], R5
80006608:	8d a0       	ST.W      [R1 + #2], R5
8000660a:	7a a1       	ST.W      [R7 + #5], R2
8000660c:	01 0d       	LD.W      R5, [SP + #1]
8000660e:	ed ca       	MULS      R5, R5, R3
80006610:	5c e9       	LD.W      R3, [R4 + R5]
80006612:	5b c0       	ADD       R3, R3, #1
80006614:	63 ef       	ST.W      [R4 + R5], R3
80006616:	c3 07       	SJMP      $-61                  ;->0x8000659c
##@@@P_:tasks.c:3427
##@@@L3422_:        TCB_t * const pxTCB = xTaskToResume;   
##@@@L3423_:        UBaseType_t uxSavedInterruptStatus;   
##@@@L3424_:
##@@@L3425_:        traceENTER_xTaskResumeFromISR( xTaskToResume );   
##@@@L3426_:
##@@@L3427_:        configASSERT( xTaskToResume );   
80006618:	20 5d       	PUSH      R0
8000661a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000661e:	08 00       	SYNC     SYNC     
80006620:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006624:	08 00       	SYNC     SYNC     
80006626:	00 5d       	POP       R0
80006628:	20 5d       	PUSH      R0
8000662a:	21 5d       	PUSH      R1
8000662c:	12 45       	LD        R5, [PC + #18]        ;->0x80006674  :=0x1ff
8000662e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006632:	25 58       	MOV       R1, R5
80006634:	11 68       	NOT       R1, R1
80006636:	01 69       	ANL       R0, R1
80006638:	5f 11       	MOV       R5, #31			;->0x001F
8000663a:	25 58       	MOV       R1, R5
8000663c:	01 6a       	ORL       R0, R1
8000663e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006642:	08 00       	SYNC     SYNC     
80006644:	01 5d       	POP       R1
80006646:	00 5d       	POP       R0
80006648:	20 5d       	PUSH      R0
8000664a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000664e:	08 00       	SYNC     SYNC     
80006650:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006654:	08 00       	SYNC     SYNC     
80006656:	00 5d       	POP       R0
80006658:	07 00       	BREAK    BREAK    
8000665a:	08 45       	LD        R5, [PC + #8]         ;->0x80006678  :=0x8000911c
8000665c:	05 5c       	LJMP      R5
8000665e:	00 00       	NOP      NOP      
80006660:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80006664:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
80006668:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
8000666c:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
80006670:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80006674:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006678:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

8000667c <vTaskStartScheduler>:
##@@@F_:vTaskStartScheduler():
##@@@P_:tasks.c:3658
##@@@L3653_:}   
##@@@L3654_:
##@@@L3655_:/*-----------------------------------------------------------*/   
##@@@L3656_:
##@@@L3657_:void vTaskStartScheduler( void )   
##@@@L3658_:{   
8000667c:	81 5f       	PUSH      {R6,LR}
8000667e:	e8 32       	SUB       SP, #40			;->0x28
##@@@F_:prvCreateIdleTasks():
##@@@P_:tasks.c:3523
##@@@L3518_:    TaskFunction_t pxIdleTaskFunction = NULL;   
##@@@L3519_:    BaseType_t xIdleTaskNameIndex;   
##@@@L3520_:
##@@@L3521_:    for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )   
##@@@L3522_:    {   
##@@@L3523_:        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];   
80006680:	2d 45       	LD        R5, [PC + #45]        ;->0x80006734  :=0x80000f93
80006682:	25 89       	LD.B      R4, [R5 + #4]
80006684:	9c e3       	ST.B      [SP + #28], R4
80006686:	65 88       	LD.B      R4, [R5 + #1]
80006688:	35 80       	LD.B      R3, [R5]
8000668a:	a0 7a       	LSL       R4, #8			;->0x08
8000668c:	43 6a       	ORL       R4, R3
8000668e:	dd 88       	LD.B      R3, [R5 + #3]
80006690:	ad 88       	LD.B      R5, [R5 + #2]
80006692:	98 7a       	LSL       R3, #8			;->0x08
80006694:	35 6a       	ORL       R3, R5
80006696:	18 7b       	LSL       R3, #16			;->0x10
80006698:	34 6a       	ORL       R3, R4
8000669a:	06 23       	ST.W      [SP + #6], R3
8000669c:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:tasks.c:3590
##@@@L3585_:        }   
##@@@L3586_:        #endif /* if ( configNUMBER_OF_CORES > 1 ) */   
##@@@L3587_:
##@@@L3588_:        #if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L3589_:        {   
##@@@L3590_:            StaticTask_t * pxIdleTaskTCBBuffer = NULL;   
8000669e:	05 26       	ST.W      [SP + #5], R6
##@@@P_:tasks.c:3591
##@@@L3591_:            StackType_t * pxIdleTaskStackBuffer = NULL;   
800066a0:	04 26       	ST.W      [SP + #4], R6
800066a2:	26 40       	LD        R0, [PC + #38]        ;->0x80006738  :=0x14
800066a4:	0e 64       	ADD       R0, SP
800066a6:	26 41       	LD        R1, [PC + #38]        ;->0x8000673c  :=0x10
800066a8:	1e 64       	ADD       R1, SP
800066aa:	26 42       	LD        R2, [PC + #38]        ;->0x80006740  :=0xc
800066ac:	2e 64       	ADD       R2, SP
##@@@P_:tasks.c:3598
##@@@L3593_:
##@@@L3594_:            /* The Idle task is created using user provided RAM - obtain the   
##@@@L3595_:             * address of the RAM then create the idle task. */   
##@@@L3596_:            #if ( configNUMBER_OF_CORES == 1 )   
##@@@L3597_:            {   
##@@@L3598_:                vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );   
800066ae:	26 45       	LD        R5, [PC + #38]        ;->0x80006744  :=0x80009120
800066b0:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3614
##@@@L3609_:                }   
##@@@L3610_:            }   
##@@@L3611_:            #endif /* if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L3612_:            xIdleTaskHandles[ xCoreID ] = xTaskCreateStatic( pxIdleTaskFunction,   
##@@@L3613_:                                                             cIdleName,   
##@@@L3614_:                                                             ulIdleTaskStackSize,   
800066b2:	03 0a       	LD.W      R2, [SP + #3]
##@@@P_:tasks.c:3617
##@@@L3615_:                                                             ( void * ) NULL,   
##@@@L3616_:                                                             portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */   
##@@@L3617_:                                                             pxIdleTaskStackBuffer,   
800066b4:	04 0d       	LD.W      R5, [SP + #4]
##@@@P_:tasks.c:3618
##@@@L3618_:                                                             pxIdleTaskTCBBuffer );   
800066b6:	05 0c       	LD.W      R4, [SP + #5]
##@@@P_:tasks.c:3612
##@@@L3607_:                {   
##@@@L3608_:                    vApplicationGetPassiveIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize, xCoreID - 1 );   
##@@@L3609_:                }   
##@@@L3610_:            }   
##@@@L3611_:            #endif /* if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L3612_:            xIdleTaskHandles[ xCoreID ] = xTaskCreateStatic( pxIdleTaskFunction,   
800066b8:	6e 58       	MOV       R3, SP
800066ba:	5c a0       	ST.W      [R3 + #1], R4
800066bc:	35 85       	ST.W      [R3], R5
800066be:	23 40       	LD        R0, [PC + #35]        ;->0x80006748  :=0x80008840
800066c0:	23 41       	LD        R1, [PC + #35]        ;->0x8000674c  :=0x18
800066c2:	1e 64       	ADD       R1, SP
800066c4:	66 58       	MOV       R3, R6
800066c6:	86 58       	MOV       R4, R6
800066c8:	22 45       	LD        R5, [PC + #34]        ;->0x80006750  :=0x80005088
800066ca:	05 5c       	LJMP      R5
800066cc:	22 45       	LD        R5, [PC + #34]        ;->0x80006754  :=0xd0000304
##@@@F_:vTaskStartScheduler():
##@@@P_:tasks.c:3686
##@@@L3681_:            mtCOVERAGE_TEST_MARKER();   
##@@@L3682_:        }   
##@@@L3683_:    }   
##@@@L3684_:    #endif /* configUSE_TIMERS */   
##@@@L3685_:
##@@@L3686_:    if( xReturn == pdPASS )   
800066ce:	00 38       	CMP       R0, #0			;->0x00
##@@@F_:prvCreateIdleTasks():
##@@@P_:tasks.c:3612
##@@@L3607_:                {   
##@@@L3608_:                    vApplicationGetPassiveIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize, xCoreID - 1 );   
##@@@L3609_:                }   
##@@@L3610_:            }   
##@@@L3611_:            #endif /* if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L3612_:            xIdleTaskHandles[ xCoreID ] = xTaskCreateStatic( pxIdleTaskFunction,   
800066d0:	50 85       	ST.W      [R5], R0
##@@@F_:vTaskStartScheduler():
##@@@P_:tasks.c:3686
##@@@L3681_:            mtCOVERAGE_TEST_MARKER();   
##@@@L3682_:        }   
##@@@L3683_:    }   
##@@@L3684_:    #endif /* configUSE_TIMERS */   
##@@@L3685_:
##@@@L3686_:    if( xReturn == pdPASS )   
800066d2:	2b f0       	JZ        $+43                  ;->0x80006728
##@@@P_:tasks.c:3702
##@@@L3697_:        /* Interrupts are turned off here, to ensure a tick does not occur   
##@@@L3698_:         * before or during the call to xPortStartScheduler().  The stacks of   
##@@@L3699_:         * the created tasks contain a status word with interrupts switched on   
##@@@L3700_:         * so interrupts will automatically get re-enabled when the first task   
##@@@L3701_:         * starts to run. */   
##@@@L3702_:        portDISABLE_INTERRUPTS();   
800066d4:	20 5d       	PUSH      R0
800066d6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800066da:	08 00       	SYNC     SYNC     
800066dc:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800066e0:	08 00       	SYNC     SYNC     
800066e2:	00 5d       	POP       R0
800066e4:	20 5d       	PUSH      R0
800066e6:	21 5d       	PUSH      R1
800066e8:	1c 45       	LD        R5, [PC + #28]        ;->0x80006758  :=0x1ff
800066ea:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800066ee:	25 58       	MOV       R1, R5
800066f0:	11 68       	NOT       R1, R1
800066f2:	01 69       	ANL       R0, R1
800066f4:	5f 11       	MOV       R5, #31			;->0x001F
800066f6:	25 58       	MOV       R1, R5
800066f8:	01 6a       	ORL       R0, R1
800066fa:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800066fe:	08 00       	SYNC     SYNC     
80006700:	01 5d       	POP       R1
80006702:	00 5d       	POP       R0
##@@@P_:tasks.c:3712
##@@@L3707_:             * block specific to the task that will run first. */   
##@@@L3708_:            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );   
##@@@L3709_:        }   
##@@@L3710_:        #endif   
##@@@L3711_:
##@@@L3712_:        xNextTaskUnblockTime = portMAX_DELAY;   
80006704:	16 45       	LD        R5, [PC + #22]        ;->0x8000675c  :=0xd0000300
80006706:	17 44       	LD        R4, [PC + #23]        ;->0x80006760  :=0xffffffff
##@@@P_:tasks.c:3702
##@@@L3697_:        /* Interrupts are turned off here, to ensure a tick does not occur   
##@@@L3698_:         * before or during the call to xPortStartScheduler().  The stacks of   
##@@@L3699_:         * the created tasks contain a status word with interrupts switched on   
##@@@L3700_:         * so interrupts will automatically get re-enabled when the first task   
##@@@L3701_:         * starts to run. */   
##@@@L3702_:        portDISABLE_INTERRUPTS();   
80006708:	20 5d       	PUSH      R0
8000670a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000670e:	08 00       	SYNC     SYNC     
80006710:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006714:	08 00       	SYNC     SYNC     
80006716:	00 5d       	POP       R0
##@@@P_:tasks.c:3712
##@@@L3707_:             * block specific to the task that will run first. */   
##@@@L3708_:            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );   
##@@@L3709_:        }   
##@@@L3710_:        #endif   
##@@@L3711_:
##@@@L3712_:        xNextTaskUnblockTime = portMAX_DELAY;   
80006718:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:3713
##@@@L3713_:        xSchedulerRunning = pdTRUE;   
8000671a:	13 45       	LD        R5, [PC + #19]        ;->0x80006764  :=0xd0000064
8000671c:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:tasks.c:3714
##@@@L3714_:        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;   
8000671e:	13 43       	LD        R3, [PC + #19]        ;->0x80006768  :=0xd000006c
##@@@P_:tasks.c:3713
##@@@L3708_:            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );   
##@@@L3709_:        }   
##@@@L3710_:        #endif   
##@@@L3711_:
##@@@L3712_:        xNextTaskUnblockTime = portMAX_DELAY;   
##@@@L3713_:        xSchedulerRunning = pdTRUE;   
80006720:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:3714
##@@@L3714_:        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;   
80006722:	36 85       	ST.W      [R3], R6
##@@@P_:tasks.c:3731
##@@@L3726_:        /* Setting up the timer tick is hardware specific and thus in the   
##@@@L3727_:         * portable interface. */   
##@@@L3728_:
##@@@L3729_:        /* The return value for xPortStartScheduler is not required   
##@@@L3730_:         * hence using a void datatype. */   
##@@@L3731_:        ( void ) xPortStartScheduler();   
80006724:	12 45       	LD        R5, [PC + #18]        ;->0x8000676c  :=0x80008e30
80006726:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3754
##@@@L3749_:     * meaning xIdleTaskHandles are not used anywhere else. */   
##@@@L3750_:    ( void ) xIdleTaskHandles;   
##@@@L3751_:
##@@@L3752_:    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority   
##@@@L3753_:     * from getting optimized out as it is no longer used by the kernel. */   
##@@@L3754_:    ( void ) uxTopUsedPriority;   
80006728:	12 45       	LD        R5, [PC + #18]        ;->0x80006770  :=0x80000f68
8000672a:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:3757
##@@@L3755_:
##@@@L3756_:    traceRETURN_vTaskStartScheduler();   
##@@@L3757_:}   
8000672c:	e8 2a       	ADD       SP, #40			;->0x28
8000672e:	06 5d       	POP       R6
80006730:	0d 5d       	POP       LR
80006732:	1d 5c       	JMP       LR
80006734:	93 0f 00 80 	.long     0x80000f93 ->-2147479661  [!!!@2@:LD.W      R7, [SP + #147]	@@: LD.B      R0, [R0]
80006738:	14 00 00 00 	.long     0x00000014 ->000000020  [!!!@4@:DMSC16LL  ACC0, ACC0, R0, R0
8000673c:	10 00 00 00 	.long     0x00000010 ->000000016  [!!!@4@:DMAC16LL  ACC0, ACC0, R0, R0
80006740:	0c 00 00 00 	.long     0x0000000c ->000000012  [!!!@2@:MRET     	@@: NOP      
80006744:	20 91 00 80 	.long     0x80009120 ->-2147446496  [!!!@2@:ST.B      [R4 + #4], R0	@@: LD.B      R0, [R0]
80006748:	40 88 00 80 	.long     0x80008840 ->-2147448768  [!!!@2@:LD.B      R0, [R0 + #1]	@@: LD.B      R0, [R0]
8000674c:	18 00 00 00 	.long     0x00000018 ->000000024  [!!!@4@:MULS      R0, R0, R0
80006750:	88 50 00 80 	.long     0x80005088 ->-2147463032 
80006754:	04 03 00 d0 	.long     0xd0000304 ->-805305596  [!!!@4@:JMP       $+315392              ;->0x800a0754
80006758:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000675c:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x8002075c
80006760:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80006764:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80006768:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
8000676c:	30 8e 00 80 	.long     0x80008e30 ->-2147447248  [!!!@2@:LD.B      R6, [R0 + #24]	@@: LD.B      R0, [R0]
80006770:	68 0f 00 80 	.long     0x80000f68 ->-2147479704  [!!!@2@:LD.W      R7, [SP + #104]	@@: LD.B      R0, [R0]

80006774 <vTaskEndScheduler>:
##@@@F_:vTaskEndScheduler():
##@@@P_:tasks.c:3761
##@@@L3758_:/*-----------------------------------------------------------*/   
##@@@L3759_:
##@@@L3760_:void vTaskEndScheduler( void )   
##@@@L3761_:{   
80006774:	2d 5d       	PUSH      LR
80006776:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:3767
##@@@L3762_:    traceENTER_vTaskEndScheduler();   
##@@@L3763_:
##@@@L3764_:    /* Stop the scheduler interrupts and call the portable scheduler end   
##@@@L3765_:     * routine so the original ISRs can be restored if necessary.  The port   
##@@@L3766_:     * layer must ensure interrupts enable  bit is left in the correct state. */   
##@@@L3767_:    portDISABLE_INTERRUPTS();   
80006778:	20 5d       	PUSH      R0
8000677a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000677e:	08 00       	SYNC     SYNC     
80006780:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006784:	08 00       	SYNC     SYNC     
80006786:	00 5d       	POP       R0
80006788:	20 5d       	PUSH      R0
8000678a:	21 5d       	PUSH      R1
8000678c:	0f 45       	LD        R5, [PC + #15]        ;->0x800067c8  :=0x1ff
8000678e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006792:	25 58       	MOV       R1, R5
80006794:	11 68       	NOT       R1, R1
80006796:	01 69       	ANL       R0, R1
80006798:	5f 11       	MOV       R5, #31			;->0x001F
8000679a:	25 58       	MOV       R1, R5
8000679c:	01 6a       	ORL       R0, R1
8000679e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800067a2:	08 00       	SYNC     SYNC     
800067a4:	01 5d       	POP       R1
800067a6:	00 5d       	POP       R0
800067a8:	20 5d       	PUSH      R0
800067aa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800067ae:	08 00       	SYNC     SYNC     
800067b0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800067b4:	08 00       	SYNC     SYNC     
800067b6:	00 5d       	POP       R0
##@@@P_:tasks.c:3768
##@@@L3768_:    xSchedulerRunning = pdFALSE;   
800067b8:	05 45       	LD        R5, [PC + #5]         ;->0x800067cc  :=0xd0000064
800067ba:	40 10       	MOV       R4, #0			;->0x0000
800067bc:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:3769
##@@@L3769_:    vPortEndScheduler();   
800067be:	05 45       	LD        R5, [PC + #5]         ;->0x800067d0  :=0x80009118
800067c0:	05 5c       	LJMP      R5
##@@@P_:tasks.c:3772
##@@@L3770_:
##@@@L3771_:    traceRETURN_vTaskEndScheduler();   
##@@@L3772_:}   
800067c2:	e4 28       	ADD       SP, #4			;->0x04
800067c4:	0d 5d       	POP       LR
800067c6:	1d 5c       	JMP       LR
800067c8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800067cc:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
800067d0:	18 91 00 80 	.long     0x80009118 ->-2147446504  [!!!@2@:ST.B      [R3 + #4], R0	@@: LD.B      R0, [R0]

800067d4 <xTaskIncrementTick>:
##@@@F_:xTaskIncrementTick():
##@@@P_:tasks.c:4713
##@@@L4708_:
##@@@L4709_:#endif /* INCLUDE_xTaskAbortDelay */   
##@@@L4710_:/*----------------------------------------------------------*/   
##@@@L4711_:
##@@@L4712_:BaseType_t xTaskIncrementTick( void )   
##@@@L4713_:{   
800067d4:	8f 5f       	PUSH      {R6-R9,LR}
800067d6:	e4 31       	SUB       SP, #20			;->0x14
##@@@P_:tasks.c:4733
##@@@L4728_:
##@@@L4729_:    /* Tick increment should occur on every kernel timer event. Core 0 has the   
##@@@L4730_:     * responsibility to increment the tick, or increment the pended ticks if the   
##@@@L4731_:     * scheduler is suspended.  If pended ticks is greater than zero, the core that   
##@@@L4732_:     * calls xTaskResumeAll has the responsibility to increment the tick. */   
##@@@L4733_:    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
800067d8:	58 45       	LD        R5, [PC + #88]        ;->0x80006938  :=0xd0000068
800067da:	55 82       	LD.W      R5, [R5]
800067dc:	50 38       	CMP       R5, #0			;->0x00
800067de:	07 f0       	JZ        $+7                   ;->0x800067ec
##@@@P_:tasks.c:4949
##@@@L4944_:        }   
##@@@L4945_:        #endif /* #if ( configUSE_PREEMPTION == 1 ) */   
##@@@L4946_:    }   
##@@@L4947_:    else   
##@@@L4948_:    {   
##@@@L4949_:        ++xPendedTicks;   
800067e0:	57 45       	LD        R5, [PC + #87]        ;->0x8000693c  :=0xd0000308
800067e2:	45 82       	LD.W      R4, [R5]
800067e4:	64 c0       	ADD       R4, R4, #1
800067e6:	54 85       	ST.W      [R5], R4
800067e8:	00 10       	MOV       R0, #0			;->0x0000
800067ea:	a3 04       	SJMP      $+163                 ;->0x80006930
##@@@P_:tasks.c:4737
##@@@L4732_:     * calls xTaskResumeAll has the responsibility to increment the tick. */   
##@@@L4733_:    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
##@@@L4734_:    {   
##@@@L4735_:        /* Minor optimisation.  The tick count cannot change in this   
##@@@L4736_:         * block. */   
##@@@L4737_:        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;   
800067ec:	55 44       	LD        R4, [PC + #85]        ;->0x80006940  :=0xd000006c
800067ee:	34 82       	LD.W      R3, [R4]
800067f0:	6b c0       	ADD       R5, R3, #1
800067f2:	04 25       	ST.W      [SP + #4], R5
800067f4:	53 70       	CMP       R5, R3
800067f6:	03 f3       	JNC       $+3                   ;->0x800067fc
800067f8:	30 10       	MOV       R3, #0			;->0x0000
800067fa:	02 04       	SJMP      $+2                   ;->0x800067fe
800067fc:	31 10       	MOV       R3, #1			;->0x0001
##@@@P_:tasks.c:4743
##@@@L4738_:
##@@@L4739_:        /* Increment the RTOS tick, switching the delayed and overflowed   
##@@@L4740_:         * delayed lists if it wraps to 0. */   
##@@@L4741_:        xTickCount = xConstTickCount;   
##@@@L4742_:
##@@@L4743_:        if( xConstTickCount == ( TickType_t ) 0U )   
800067fe:	31 38       	CMP       R3, #1			;->0x01
##@@@P_:tasks.c:4741
##@@@L4736_:         * block. */   
##@@@L4737_:        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;   
##@@@L4738_:
##@@@L4739_:        /* Increment the RTOS tick, switching the delayed and overflowed   
##@@@L4740_:         * delayed lists if it wraps to 0. */   
##@@@L4741_:        xTickCount = xConstTickCount;   
80006800:	04 0d       	LD.W      R5, [SP + #4]
80006802:	45 85       	ST.W      [R4], R5
##@@@P_:tasks.c:4743
##@@@L4742_:
##@@@L4743_:        if( xConstTickCount == ( TickType_t ) 0U )   
80006804:	1b f1       	JNZ       $+27                  ;->0x8000683a
##@@@P_:tasks.c:4745
##@@@L4744_:        {   
##@@@L4745_:            taskSWITCH_DELAYED_LISTS();   
80006806:	50 44       	LD        R4, [PC + #80]        ;->0x80006944  :=0xd0000070
80006808:	34 82       	LD.W      R3, [R4]
8000680a:	33 82       	LD.W      R3, [R3]
8000680c:	30 38       	CMP       R3, #0			;->0x00
8000680e:	02 f0       	JZ        $+2                   ;->0x80006812
80006810:	ac 04       	SJMP      $+172                 ;->0x80006968
80006812:	4e 43       	LD        R3, [PC + #78]        ;->0x80006948  :=0xd0000074
80006814:	24 82       	LD.W      R2, [R4]
80006816:	13 82       	LD.W      R1, [R3]
80006818:	41 85       	ST.W      [R4], R1
8000681a:	4d 41       	LD        R1, [PC + #77]        ;->0x8000694c  :=0xd000030c
8000681c:	32 85       	ST.W      [R3], R2
8000681e:	31 82       	LD.W      R3, [R1]
80006820:	5b c0       	ADD       R3, R3, #1
80006822:	13 85       	ST.W      [R1], R3
##@@@F_:prvResetNextTaskUnblockTime():
##@@@P_:tasks.c:6496
##@@@L6491_:#endif /* INCLUDE_vTaskDelete */   
##@@@L6492_:/*-----------------------------------------------------------*/   
##@@@L6493_:
##@@@L6494_:static void prvResetNextTaskUnblockTime( void )   
##@@@L6495_:{   
##@@@L6496_:    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )   
80006824:	34 82       	LD.W      R3, [R4]
80006826:	33 82       	LD.W      R3, [R3]
80006828:	30 38       	CMP       R3, #0			;->0x00
8000682a:	05 f0       	JZ        $+5                   ;->0x80006834
##@@@P_:tasks.c:6510
##@@@L6505_:    {   
##@@@L6506_:        /* The new current delayed list is not empty, get the value of   
##@@@L6507_:         * the item at the head of the delayed list.  This is the time at   
##@@@L6508_:         * which the task at the head of the delayed list should be removed   
##@@@L6509_:         * from the Blocked state. */   
##@@@L6510_:        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );   
8000682c:	44 82       	LD.W      R4, [R4]
8000682e:	e4 98       	LD.W      R4, [R4 + #3]
80006830:	44 82       	LD.W      R4, [R4]
80006832:	02 04       	SJMP      $+2                   ;->0x80006836
80006834:	47 44       	LD        R4, [PC + #71]        ;->0x80006950  :=0xffffffff
80006836:	48 43       	LD        R3, [PC + #72]        ;->0x80006954  :=0xd0000300
80006838:	34 85       	ST.W      [R3], R4
##@@@F_:xTaskIncrementTick():
##@@@P_:tasks.c:4756
##@@@L4751_:
##@@@L4752_:        /* See if this tick has made a timeout expire.  Tasks are stored in   
##@@@L4753_:         * the  queue in the order of their wake time - meaning once one task   
##@@@L4754_:         * has been found whose block time has not expired there is no need to   
##@@@L4755_:         * look any further down the list. */   
##@@@L4756_:        if( xConstTickCount >= xNextTaskUnblockTime )   
8000683a:	47 43       	LD        R3, [PC + #71]        ;->0x80006954  :=0xd0000300
8000683c:	43 82       	LD.W      R4, [R3]
8000683e:	04 0d       	LD.W      R5, [SP + #4]
80006840:	54 70       	CMP       R5, R4
80006842:	03 f2       	JC        $+3                   ;->0x80006848
80006844:	90 10       	MOV       R9, #0			;->0x0000
80006846:	64 04       	SJMP      $+100                 ;->0x8000690e
##@@@P_:tasks.c:4760
##@@@L4757_:        {   
##@@@L4758_:            for( ; ; )   
##@@@L4759_:            {   
##@@@L4760_:                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )   
80006848:	3f 42       	LD        R2, [PC + #63]        ;->0x80006944  :=0xd0000070
8000684a:	42 82       	LD.W      R4, [R2]
8000684c:	44 82       	LD.W      R4, [R4]
8000684e:	40 38       	CMP       R4, #0			;->0x00
80006850:	02 f1       	JNZ       $+2                   ;->0x80006854
80006852:	57 04       	SJMP      $+87                  ;->0x80006900
80006854:	01 23       	ST.W      [SP + #1], R3
80006856:	50 10       	MOV       R5, #0			;->0x0000
80006858:	81 10       	MOV       R8, #1			;->0x0001
8000685a:	02 25       	ST.W      [SP + #2], R5
8000685c:	25 59       	MOV       R9, R5
8000685e:	03 22       	ST.W      [SP + #3], R2
80006860:	08 04       	SJMP      $+8                   ;->0x80006870
80006862:	03 0a       	LD.W      R2, [SP + #3]
80006864:	52 82       	LD.W      R5, [R2]
80006866:	55 82       	LD.W      R5, [R5]
80006868:	50 38       	CMP       R5, #0			;->0x00
8000686a:	26 59       	MOV       R9, R6
8000686c:	02 f1       	JNZ       $+2                   ;->0x80006870
8000686e:	4c 04       	SJMP      $+76                  ;->0x80006906
##@@@P_:tasks.c:4779
##@@@L4774_:                     * at which the task at the head of the delayed list must   
##@@@L4775_:                     * be removed from the Blocked state. */   
##@@@L4776_:                    /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L4777_:                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L4778_:                    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L4779_:                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );   
80006870:	42 82       	LD.W      R4, [R2]
80006872:	e4 98       	LD.W      R4, [R4 + #3]
80006874:	f4 98       	LD.W      R6, [R4 + #3]
##@@@P_:tasks.c:4780
##@@@L4780_:                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );   
80006876:	66 98       	LD.W      R4, [R6 + #1]
##@@@P_:tasks.c:4782
##@@@L4781_:
##@@@L4782_:                    if( xConstTickCount < xItemValue )   
80006878:	04 0d       	LD.W      R5, [SP + #4]
8000687a:	54 70       	CMP       R5, R4
8000687c:	02 f2       	JC        $+2                   ;->0x80006880
8000687e:	46 04       	SJMP      $+70                  ;->0x8000690a
##@@@P_:tasks.c:4798
##@@@L4793_:                    {   
##@@@L4794_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L4795_:                    }   
##@@@L4796_:
##@@@L4797_:                    /* It is time to remove the item from the Blocked state. */   
##@@@L4798_:                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
80006880:	be 98       	LD.W      R7, [R6 + #2]
80006882:	ce 98       	LD.W      R1, [R6 + #3]
80006884:	66 99       	LD.W      R4, [R6 + #5]
80006886:	b9 a0       	ST.W      [R7 + #2], R1
80006888:	ce 98       	LD.W      R1, [R6 + #3]
8000688a:	4f a0       	ST.W      [R1 + #1], R7
8000688c:	44 98       	LD.W      R0, [R4 + #1]
8000688e:	3e c1       	ADD       R7, R6, #4
80006890:	07 70       	CMP       R0, R7
80006892:	02 f1       	JNZ       $+2                   ;->0x80006896
80006894:	61 a0       	ST.W      [R4 + #1], R1
80006896:	14 82       	LD.W      R1, [R4]
80006898:	49 cc       	SUB       R1, R1, #1
8000689a:	41 85       	ST.W      [R4], R1
##@@@P_:tasks.c:4802
##@@@L4799_:
##@@@L4800_:                    /* Is the task waiting on an event also?  If so remove   
##@@@L4801_:                     * it from the event list. */   
##@@@L4802_:                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )   
8000689c:	a6 9a       	LD.W      R4, [R6 + #10]
8000689e:	40 38       	CMP       R4, #0			;->0x00
800068a0:	11 f0       	JZ        $+17                  ;->0x800068c2
##@@@P_:tasks.c:4804
##@@@L4803_:                    {   
##@@@L4804_:                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );   
800068a2:	c6 99       	LD.W      R0, [R6 + #7]
800068a4:	0e 9a       	LD.W      R1, [R6 + #8]
800068a6:	81 a0       	ST.W      [R0 + #2], R1
800068a8:	0e 9a       	LD.W      R1, [R6 + #8]
800068aa:	48 a0       	ST.W      [R1 + #1], R0
##@@@P_:tasks.c:4802
##@@@L4797_:                    /* It is time to remove the item from the Blocked state. */   
##@@@L4798_:                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
##@@@L4799_:
##@@@L4800_:                    /* Is the task waiting on an event also?  If so remove   
##@@@L4801_:                     * it from the event list. */   
##@@@L4802_:                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )   
800068ac:	06 58       	MOV       R0, R6
##@@@P_:tasks.c:4804
##@@@L4803_:                    {   
##@@@L4804_:                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );   
800068ae:	6c 98       	LD.W      R5, [R4 + #1]
##@@@P_:tasks.c:4802
##@@@L4797_:                    /* It is time to remove the item from the Blocked state. */   
##@@@L4798_:                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
##@@@L4799_:
##@@@L4800_:                    /* Is the task waiting on an event also?  If so remove   
##@@@L4801_:                     * it from the event list. */   
##@@@L4802_:                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )   
800068b0:	08 29       	ADD       R0, #24			;->0x18
##@@@P_:tasks.c:4804
##@@@L4803_:                    {   
##@@@L4804_:                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );   
800068b2:	50 70       	CMP       R5, R0
800068b4:	02 f1       	JNZ       $+2                   ;->0x800068b8
800068b6:	61 a0       	ST.W      [R4 + #1], R1
800068b8:	02 0d       	LD.W      R5, [SP + #2]
800068ba:	b5 a2       	ST.W      [R6 + #10], R5
800068bc:	54 82       	LD.W      R5, [R4]
800068be:	6d cc       	SUB       R5, R5, #1
800068c0:	45 85       	ST.W      [R4], R5
##@@@P_:tasks.c:4813
##@@@L4808_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L4809_:                    }   
##@@@L4810_:
##@@@L4811_:                    /* Place the unblocked task into the appropriate ready   
##@@@L4812_:                     * list. */   
##@@@L4813_:                    prvAddTaskToReadyList( pxTCB );   
800068c2:	26 41       	LD        R1, [PC + #38]        ;->0x80006958  :=0xd00002f8
800068c4:	e6 9a       	LD.W      R4, [R6 + #11]
800068c6:	51 82       	LD.W      R5, [R1]
800068c8:	45 70       	CMP       R4, R5
800068ca:	02 f9       	JLS       $+2                   ;->0x800068ce
800068cc:	14 85       	ST.W      [R1], R4
800068ce:	24 45       	LD        R5, [PC + #36]        ;->0x8000695c  :=0xd00000a0
800068d0:	14 11       	MOV       R1, #20			;->0x0014
800068d2:	05 58       	MOV       R0, R5
800068d4:	19 00 81 00 	MADD32    R0, R4, R1
800068d8:	50 98       	LD.W      R2, [R0 + #1]
800068da:	b2 a0       	ST.W      [R6 + #2], R2
800068dc:	9a 98       	LD.W      R3, [R2 + #2]
800068de:	f3 a0       	ST.W      [R6 + #3], R3
800068e0:	9a 98       	LD.W      R3, [R2 + #2]
800068e2:	5f a0       	ST.W      [R3 + #1], R7
800068e4:	97 a0       	ST.W      [R2 + #2], R7
800068e6:	70 a1       	ST.W      [R6 + #5], R0
800068e8:	5c ca       	MULS      R3, R4, R1
800068ea:	d5 e8       	LD.W      R2, [R5 + R3]
800068ec:	52 c0       	ADD       R2, R2, #1
##@@@P_:tasks.c:4829
##@@@L4824_:                             * task.   
##@@@L4825_:                             * The case of equal priority tasks sharing   
##@@@L4826_:                             * processing time (which happens when both   
##@@@L4827_:                             * preemption and time slicing are on) is   
##@@@L4828_:                             * handled below.*/   
##@@@L4829_:                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
800068ee:	1d 41       	LD        R1, [PC + #29]        ;->0x80006960  :=0xd0000040
##@@@P_:tasks.c:4813
##@@@L4808_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L4809_:                    }   
##@@@L4810_:
##@@@L4811_:                    /* Place the unblocked task into the appropriate ready   
##@@@L4812_:                     * list. */   
##@@@L4813_:                    prvAddTaskToReadyList( pxTCB );   
800068f0:	ea ee       	ST.W      [R5 + R3], R2
##@@@P_:tasks.c:4829
##@@@L4824_:                             * task.   
##@@@L4825_:                             * The case of equal priority tasks sharing   
##@@@L4826_:                             * processing time (which happens when both   
##@@@L4827_:                             * preemption and time slicing are on) is   
##@@@L4828_:                             * handled below.*/   
##@@@L4829_:                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
800068f2:	51 82       	LD.W      R5, [R1]
800068f4:	ed 9a       	LD.W      R5, [R5 + #11]
800068f6:	c8 58       	MOV       R6, R8
800068f8:	45 70       	CMP       R4, R5
800068fa:	b4 f8       	JHI       $-76                  ;->0x80006862
800068fc:	c9 58       	MOV       R6, R9
800068fe:	b2 07       	SJMP      $-78                  ;->0x80006862
80006900:	14 44       	LD        R4, [PC + #20]        ;->0x80006950  :=0xffffffff
80006902:	90 10       	MOV       R9, #0			;->0x0000
80006904:	04 04       	SJMP      $+4                   ;->0x8000690c
80006906:	13 44       	LD        R4, [PC + #19]        ;->0x80006950  :=0xffffffff
80006908:	26 59       	MOV       R9, R6
8000690a:	01 0b       	LD.W      R3, [SP + #1]
8000690c:	34 85       	ST.W      [R3], R4
##@@@P_:tasks.c:4856
##@@@L4851_:         * writer has not explicitly turned time slicing off. */   
##@@@L4852_:        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )   
##@@@L4853_:        {   
##@@@L4854_:            #if ( configNUMBER_OF_CORES == 1 )   
##@@@L4855_:            {   
##@@@L4856_:                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )   
8000690e:	15 45       	LD        R5, [PC + #21]        ;->0x80006960  :=0xd0000040
80006910:	55 82       	LD.W      R5, [R5]
80006912:	ed 9a       	LD.W      R5, [R5 + #11]
80006914:	44 11       	MOV       R4, #20			;->0x0014
80006916:	12 43       	LD        R3, [PC + #18]        ;->0x8000695c  :=0xd00000a0
80006918:	2d cb       	MULS      R5, R5, R4
8000691a:	63 e9       	LD.W      R4, [R3 + R5]
8000691c:	51 10       	MOV       R5, #1			;->0x0001
8000691e:	05 58       	MOV       R0, R5
80006920:	41 38       	CMP       R4, #1			;->0x01
80006922:	02 f8       	JHI       $+2                   ;->0x80006926
80006924:	09 58       	MOV       R0, R9
##@@@P_:tasks.c:4905
##@@@L4900_:        #if ( configUSE_PREEMPTION == 1 )   
##@@@L4901_:        {   
##@@@L4902_:            #if ( configNUMBER_OF_CORES == 1 )   
##@@@L4903_:            {   
##@@@L4904_:                /* For single core the core ID is always 0. */   
##@@@L4905_:                if( xYieldPendings[ 0 ] != pdFALSE )   
80006926:	10 44       	LD        R4, [PC + #16]        ;->0x80006964  :=0xd00002fc
80006928:	44 82       	LD.W      R4, [R4]
8000692a:	40 38       	CMP       R4, #0			;->0x00
8000692c:	02 f0       	JZ        $+2                   ;->0x80006930
8000692e:	05 58       	MOV       R0, R5
##@@@P_:tasks.c:4962
##@@@L4957_:        #endif   
##@@@L4958_:    }   
##@@@L4959_:
##@@@L4960_:    traceRETURN_xTaskIncrementTick( xSwitchRequired );   
##@@@L4961_:
##@@@L4962_:    return xSwitchRequired;   
80006930:	e4 29       	ADD       SP, #20			;->0x14
80006932:	0f 5e       	POP       {R6-R9}
80006934:	0d 5d       	POP       LR
80006936:	1d 5c       	JMP       LR
80006938:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
8000693c:	08 03 00 d0 	.long     0xd0000308 ->-805305592  [!!!@4@:JMP       $+577536              ;->0x8012093c
80006940:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
80006944:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80006948:	74 00 00 d0 	.long     0xd0000074 ->-805306252  [!!!@4@:ST.H      [R0 + #-204], R0
8000694c:	0c 03 00 d0 	.long     0xd000030c ->-805305588  [!!!@4@:JMP       $+839680              ;->0x801a094c
80006950:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80006954:	00 03 00 d0 	.long     0xd0000300 ->-805305600  [!!!@4@:JMP       $+53248               ;->0x80020954
80006958:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
8000695c:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80006960:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80006964:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
##@@@P_:tasks.c:4745
##@@@L4740_:         * delayed lists if it wraps to 0. */   
##@@@L4741_:        xTickCount = xConstTickCount;   
##@@@L4742_:
##@@@L4743_:        if( xConstTickCount == ( TickType_t ) 0U )   
##@@@L4744_:        {   
##@@@L4745_:            taskSWITCH_DELAYED_LISTS();   
80006968:	20 5d       	PUSH      R0
8000696a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000696e:	08 00       	SYNC     SYNC     
80006970:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006974:	08 00       	SYNC     SYNC     
80006976:	00 5d       	POP       R0
80006978:	20 5d       	PUSH      R0
8000697a:	21 5d       	PUSH      R1
8000697c:	0d 45       	LD        R5, [PC + #13]        ;->0x800069b0  :=0x1ff
8000697e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006982:	25 58       	MOV       R1, R5
80006984:	11 68       	NOT       R1, R1
80006986:	01 69       	ANL       R0, R1
80006988:	5f 11       	MOV       R5, #31			;->0x001F
8000698a:	25 58       	MOV       R1, R5
8000698c:	01 6a       	ORL       R0, R1
8000698e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006992:	08 00       	SYNC     SYNC     
80006994:	01 5d       	POP       R1
80006996:	00 5d       	POP       R0
80006998:	20 5d       	PUSH      R0
8000699a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000699e:	08 00       	SYNC     SYNC     
800069a0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800069a4:	08 00       	SYNC     SYNC     
800069a6:	00 5d       	POP       R0
800069a8:	07 00       	BREAK    BREAK    
800069aa:	03 45       	LD        R5, [PC + #3]         ;->0x800069b4  :=0x8000911c
800069ac:	05 5c       	LJMP      R5
800069ae:	00 00       	NOP      NOP      
800069b0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800069b4:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800069b8 <xTaskGetTickCount>:
##@@@F_:xTaskGetTickCount():
##@@@P_:tasks.c:4083
##@@@L4078_:    traceENTER_xTaskGetTickCount();   
##@@@L4079_:
##@@@L4080_:    /* Critical section required if running on a 16 bit processor. */   
##@@@L4081_:    portTICK_TYPE_ENTER_CRITICAL();   
##@@@L4082_:    {   
##@@@L4083_:        xTicks = xTickCount;   
800069b8:	02 45       	LD        R5, [PC + #2]         ;->0x800069c0  :=0xd000006c
800069ba:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:4089
##@@@L4084_:    }   
##@@@L4085_:    portTICK_TYPE_EXIT_CRITICAL();   
##@@@L4086_:
##@@@L4087_:    traceRETURN_xTaskGetTickCount( xTicks );   
##@@@L4088_:
##@@@L4089_:    return xTicks;   
800069bc:	1d 5c       	JMP       LR
800069be:	00 00       	NOP      NOP      
800069c0:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0

800069c4 <xTaskGetTickCountFromISR>:
##@@@F_:xTaskGetTickCountFromISR():
##@@@P_:tasks.c:4118
##@@@L4113_:     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L4114_:    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L4115_:
##@@@L4116_:    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();   
##@@@L4117_:    {   
##@@@L4118_:        xReturn = xTickCount;   
800069c4:	02 45       	LD        R5, [PC + #2]         ;->0x800069cc  :=0xd000006c
800069c6:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:4124
##@@@L4119_:    }   
##@@@L4120_:    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );   
##@@@L4121_:
##@@@L4122_:    traceRETURN_xTaskGetTickCountFromISR( xReturn );   
##@@@L4123_:
##@@@L4124_:    return xReturn;   
800069c8:	1d 5c       	JMP       LR
800069ca:	00 00       	NOP      NOP      
800069cc:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0

800069d0 <uxTaskGetNumberOfTasks>:
##@@@F_:uxTaskGetNumberOfTasks():
##@@@P_:tasks.c:4136
##@@@L4131_:
##@@@L4132_:    /* A critical section is not required because the variables are of type   
##@@@L4133_:     * BaseType_t. */   
##@@@L4134_:    traceRETURN_uxTaskGetNumberOfTasks( uxCurrentNumberOfTasks );   
##@@@L4135_:
##@@@L4136_:    return uxCurrentNumberOfTasks;   
800069d0:	02 45       	LD        R5, [PC + #2]         ;->0x800069d8  :=0xd0000060
800069d2:	05 82       	LD.W      R0, [R5]
800069d4:	1d 5c       	JMP       LR
800069d6:	00 00       	NOP      NOP      
800069d8:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]

800069dc <pcTaskGetName>:
##@@@F_:pcTaskGetName():
##@@@P_:tasks.c:4141
##@@@L4137_:}   
##@@@L4138_:/*-----------------------------------------------------------*/   
##@@@L4139_:
##@@@L4140_:char * pcTaskGetName( TaskHandle_t xTaskToQuery )   
##@@@L4141_:{   
800069dc:	2d 5d       	PUSH      LR
800069de:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:4148
##@@@L4143_:
##@@@L4144_:    traceENTER_pcTaskGetName( xTaskToQuery );   
##@@@L4145_:
##@@@L4146_:    /* If null is passed in here then the name of the calling task is being   
##@@@L4147_:     * queried. */   
##@@@L4148_:    pxTCB = prvGetTCBFromHandle( xTaskToQuery );   
800069e0:	00 38       	CMP       R0, #0			;->0x00
800069e2:	05 f1       	JNZ       $+5                   ;->0x800069ec
800069e4:	04 45       	LD        R5, [PC + #4]         ;->0x800069f4  :=0xd0000040
800069e6:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:4149
##@@@L4149_:    configASSERT( pxTCB );   
800069e8:	00 38       	CMP       R0, #0			;->0x00
800069ea:	07 f0       	JZ        $+7                   ;->0x800069f8
##@@@P_:tasks.c:4153
##@@@L4150_:
##@@@L4151_:    traceRETURN_pcTaskGetName( &( pxTCB->pcTaskName[ 0 ] ) );   
##@@@L4152_:
##@@@L4153_:    return &( pxTCB->pcTaskName[ 0 ] );   
800069ec:	04 2b       	ADD       R0, #52			;->0x34
800069ee:	e4 28       	ADD       SP, #4			;->0x04
800069f0:	0d 5d       	POP       LR
800069f2:	1d 5c       	JMP       LR
800069f4:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
##@@@P_:tasks.c:4149
##@@@L4144_:    traceENTER_pcTaskGetName( xTaskToQuery );   
##@@@L4145_:
##@@@L4146_:    /* If null is passed in here then the name of the calling task is being   
##@@@L4147_:     * queried. */   
##@@@L4148_:    pxTCB = prvGetTCBFromHandle( xTaskToQuery );   
##@@@L4149_:    configASSERT( pxTCB );   
800069f8:	20 5d       	PUSH      R0
800069fa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800069fe:	08 00       	SYNC     SYNC     
80006a00:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006a04:	08 00       	SYNC     SYNC     
80006a06:	00 5d       	POP       R0
80006a08:	20 5d       	PUSH      R0
80006a0a:	21 5d       	PUSH      R1
80006a0c:	0d 45       	LD        R5, [PC + #13]        ;->0x80006a40  :=0x1ff
80006a0e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006a12:	25 58       	MOV       R1, R5
80006a14:	11 68       	NOT       R1, R1
80006a16:	01 69       	ANL       R0, R1
80006a18:	5f 11       	MOV       R5, #31			;->0x001F
80006a1a:	25 58       	MOV       R1, R5
80006a1c:	01 6a       	ORL       R0, R1
80006a1e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006a22:	08 00       	SYNC     SYNC     
80006a24:	01 5d       	POP       R1
80006a26:	00 5d       	POP       R0
80006a28:	20 5d       	PUSH      R0
80006a2a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006a2e:	08 00       	SYNC     SYNC     
80006a30:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006a34:	08 00       	SYNC     SYNC     
80006a36:	00 5d       	POP       R0
80006a38:	07 00       	BREAK    BREAK    
80006a3a:	03 45       	LD        R5, [PC + #3]         ;->0x80006a44  :=0x8000911c
80006a3c:	05 5c       	LJMP      R5
80006a3e:	00 00       	NOP      NOP      
80006a40:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006a44:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006a48 <xTaskGetStaticBuffers>:
##@@@F_:xTaskGetStaticBuffers():
##@@@P_:tasks.c:4376
##@@@L4371_:#if ( configSUPPORT_STATIC_ALLOCATION == 1 )   
##@@@L4372_:
##@@@L4373_:    BaseType_t xTaskGetStaticBuffers( TaskHandle_t xTask,   
##@@@L4374_:                                      StackType_t ** ppuxStackBuffer,   
##@@@L4375_:                                      StaticTask_t ** ppxTaskBuffer )   
##@@@L4376_:    {   
80006a48:	2d 5d       	PUSH      LR
80006a4a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:4382
##@@@L4377_:        BaseType_t xReturn;   
##@@@L4378_:        TCB_t * pxTCB;   
##@@@L4379_:
##@@@L4380_:        traceENTER_xTaskGetStaticBuffers( xTask, ppuxStackBuffer, ppxTaskBuffer );   
##@@@L4381_:
##@@@L4382_:        configASSERT( ppuxStackBuffer != NULL );   
80006a4c:	10 38       	CMP       R1, #0			;->0x00
80006a4e:	1d f0       	JZ        $+29                  ;->0x80006a88
##@@@P_:tasks.c:4383
##@@@L4383_:        configASSERT( ppxTaskBuffer != NULL );   
80006a50:	20 38       	CMP       R2, #0			;->0x00
80006a52:	3e f0       	JZ        $+62                  ;->0x80006ace
##@@@P_:tasks.c:4385
##@@@L4384_:
##@@@L4385_:        pxTCB = prvGetTCBFromHandle( xTask );   
80006a54:	00 38       	CMP       R0, #0			;->0x00
80006a56:	03 f1       	JNZ       $+3                   ;->0x80006a5c
80006a58:	0b 45       	LD        R5, [PC + #11]        ;->0x80006a84  :=0xd0000040
80006a5a:	05 82       	LD.W      R0, [R5]
80006a5c:	51 00 04 d4 	LD.B      R4, [R0 + #117]			;->0x75
##@@@P_:tasks.c:4389
##@@@L4386_:
##@@@L4387_:        #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )   
##@@@L4388_:        {   
##@@@L4389_:            if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB )   
80006a60:	50 10       	MOV       R5, #0			;->0x0000
80006a62:	41 38       	CMP       R4, #1			;->0x01
80006a64:	07 f0       	JZ        $+7                   ;->0x80006a72
80006a66:	42 38       	CMP       R4, #2			;->0x02
80006a68:	09 f1       	JNZ       $+9                   ;->0x80006a7a
##@@@P_:tasks.c:4391
##@@@L4390_:            {   
##@@@L4391_:                *ppuxStackBuffer = pxTCB->pxStack;   
80006a6a:	28 9b       	LD.W      R5, [R0 + #12]
80006a6c:	15 85       	ST.W      [R1], R5
##@@@P_:tasks.c:4395
##@@@L4392_:                /* MISRA Ref 11.3.1 [Misaligned access] */   
##@@@L4393_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-113 */   
##@@@L4394_:                /* coverity[misra_c_2012_rule_11_3_violation] */   
##@@@L4395_:                *ppxTaskBuffer = ( StaticTask_t * ) pxTCB;   
80006a6e:	20 85       	ST.W      [R2], R0
80006a70:	04 04       	SJMP      $+4                   ;->0x80006a78
##@@@P_:tasks.c:4400
##@@@L4396_:                xReturn = pdTRUE;   
##@@@L4397_:            }   
##@@@L4398_:            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )   
##@@@L4399_:            {   
##@@@L4400_:                *ppuxStackBuffer = pxTCB->pxStack;   
80006a72:	20 9b       	LD.W      R4, [R0 + #12]
80006a74:	14 85       	ST.W      [R1], R4
##@@@P_:tasks.c:4401
##@@@L4401_:                *ppxTaskBuffer = NULL;   
80006a76:	25 85       	ST.W      [R2], R5
80006a78:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:tasks.c:4419
##@@@L4414_:        }   
##@@@L4415_:        #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 */   
##@@@L4416_:
##@@@L4417_:        traceRETURN_xTaskGetStaticBuffers( xReturn );   
##@@@L4418_:
##@@@L4419_:        return xReturn;   
80006a7a:	05 58       	MOV       R0, R5
80006a7c:	e4 28       	ADD       SP, #4			;->0x04
80006a7e:	0d 5d       	POP       LR
80006a80:	1d 5c       	JMP       LR
80006a82:	00 00       	NOP      NOP      
80006a84:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
##@@@P_:tasks.c:4382
##@@@L4377_:        BaseType_t xReturn;   
##@@@L4378_:        TCB_t * pxTCB;   
##@@@L4379_:
##@@@L4380_:        traceENTER_xTaskGetStaticBuffers( xTask, ppuxStackBuffer, ppxTaskBuffer );   
##@@@L4381_:
##@@@L4382_:        configASSERT( ppuxStackBuffer != NULL );   
80006a88:	20 5d       	PUSH      R0
80006a8a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006a8e:	08 00       	SYNC     SYNC     
80006a90:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006a94:	08 00       	SYNC     SYNC     
80006a96:	00 5d       	POP       R0
80006a98:	20 5d       	PUSH      R0
80006a9a:	21 5d       	PUSH      R1
80006a9c:	1e 45       	LD        R5, [PC + #30]        ;->0x80006b14  :=0x1ff
80006a9e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006aa2:	25 58       	MOV       R1, R5
80006aa4:	11 68       	NOT       R1, R1
80006aa6:	01 69       	ANL       R0, R1
80006aa8:	5f 11       	MOV       R5, #31			;->0x001F
80006aaa:	25 58       	MOV       R1, R5
80006aac:	01 6a       	ORL       R0, R1
80006aae:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006ab2:	08 00       	SYNC     SYNC     
80006ab4:	01 5d       	POP       R1
80006ab6:	00 5d       	POP       R0
80006ab8:	20 5d       	PUSH      R0
80006aba:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006abe:	08 00       	SYNC     SYNC     
80006ac0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006ac4:	08 00       	SYNC     SYNC     
80006ac6:	00 5d       	POP       R0
80006ac8:	07 00       	BREAK    BREAK    
80006aca:	14 45       	LD        R5, [PC + #20]        ;->0x80006b18  :=0x8000911c
80006acc:	05 5c       	LJMP      R5
##@@@P_:tasks.c:4383
##@@@L4383_:        configASSERT( ppxTaskBuffer != NULL );   
80006ace:	20 5d       	PUSH      R0
80006ad0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006ad4:	08 00       	SYNC     SYNC     
80006ad6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006ada:	08 00       	SYNC     SYNC     
80006adc:	00 5d       	POP       R0
80006ade:	20 5d       	PUSH      R0
80006ae0:	21 5d       	PUSH      R1
80006ae2:	0d 45       	LD        R5, [PC + #13]        ;->0x80006b14  :=0x1ff
80006ae4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006ae8:	25 58       	MOV       R1, R5
80006aea:	11 68       	NOT       R1, R1
80006aec:	01 69       	ANL       R0, R1
80006aee:	5f 11       	MOV       R5, #31			;->0x001F
80006af0:	25 58       	MOV       R1, R5
80006af2:	01 6a       	ORL       R0, R1
80006af4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006af8:	08 00       	SYNC     SYNC     
80006afa:	01 5d       	POP       R1
80006afc:	00 5d       	POP       R0
80006afe:	20 5d       	PUSH      R0
80006b00:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006b04:	08 00       	SYNC     SYNC     
80006b06:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006b0a:	08 00       	SYNC     SYNC     
80006b0c:	00 5d       	POP       R0
80006b0e:	07 00       	BREAK    BREAK    
80006b10:	02 45       	LD        R5, [PC + #2]         ;->0x80006b18  :=0x8000911c
80006b12:	05 5c       	LJMP      R5
80006b14:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006b18:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006b1c <uxTaskGetSystemState>:
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:4430
##@@@L4425_:#if ( configUSE_TRACE_FACILITY == 1 )   
##@@@L4426_:
##@@@L4427_:    UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,   
##@@@L4428_:                                      const UBaseType_t uxArraySize,   
##@@@L4429_:                                      configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )   
##@@@L4430_:    {   
80006b1c:	ff 5f       	PUSH      {R6-R12,LR}
80006b1e:	e8 32       	SUB       SP, #40			;->0x28
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
80006b20:	96 45       	LD        R5, [PC + #150]       ;->0x80006d78  :=0xd0000068
80006b22:	45 82       	LD.W      R4, [R5]
80006b24:	64 c0       	ADD       R4, R4, #1
80006b26:	54 85       	ST.W      [R5], R4
##@@@F_:uxTaskGetSystemState():
##@@@P_:tasks.c:4438
##@@@L4433_:        traceENTER_uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );   
##@@@L4434_:
##@@@L4435_:        vTaskSuspendAll();   
##@@@L4436_:        {   
##@@@L4437_:            /* Is there a space in the array for each task in the system? */   
##@@@L4438_:            if( uxArraySize >= uxCurrentNumberOfTasks )   
80006b28:	95 45       	LD        R5, [PC + #149]       ;->0x80006d7c  :=0xd0000060
80006b2a:	55 82       	LD.W      R5, [R5]
80006b2c:	51 70       	CMP       R5, R1
80006b2e:	03 f9       	JLS       $+3                   ;->0x80006b34
80006b30:	70 10       	MOV       R7, #0			;->0x0000
80006b32:	1c 05       	SJMP      $+284                 ;->0x80006d6a
80006b34:	60 59       	MOV       R11, R0
80006b36:	01 22       	ST.W      [SP + #1], R2
80006b38:	3e 11       	MOV       R3, #30			;->0x001E
80006b3a:	90 10       	MOV       R9, #0			;->0x0000
80006b3c:	c4 12       	MOV       R12, #36			;->0x0024
80006b3e:	24 11       	MOV       R2, #20			;->0x0014
80006b40:	90 41       	LD        R1, [PC + #144]       ;->0x80006d80  :=0xd00000a0
80006b42:	a1 10       	MOV       R10, #1			;->0x0001
80006b44:	89 58       	MOV       R4, R9
80006b46:	03 22       	ST.W      [SP + #3], R2
80006b48:	02 21       	ST.W      [SP + #2], R1
80006b4a:	09 04       	SJMP      $+9                   ;->0x80006b5c
80006b4c:	04 0b       	LD.W      R3, [SP + #4]
80006b4e:	03 0a       	LD.W      R2, [SP + #3]
80006b50:	02 09       	LD.W      R1, [SP + #2]
80006b52:	09 0d       	LD.W      R5, [SP + #9]
80006b54:	05 0c       	LD.W      R4, [SP + #5]
##@@@P_:tasks.c:4445
##@@@L4440_:                /* Fill in an TaskStatus_t structure with information on each   
##@@@L4441_:                 * task in the Ready state. */   
##@@@L4442_:                do   
##@@@L4443_:                {   
##@@@L4444_:                    uxQueue--;   
##@@@L4445_:                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady ) );   
80006b56:	25 c3       	ADD       R4, R5, R4
##@@@P_:tasks.c:4446
##@@@L4446_:                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );   
80006b58:	30 38       	CMP       R3, #0			;->0x00
80006b5a:	35 f0       	JZ        $+53                  ;->0x80006bc4
##@@@P_:tasks.c:4444
##@@@L4439_:            {   
##@@@L4440_:                /* Fill in an TaskStatus_t structure with information on each   
##@@@L4441_:                 * task in the Ready state. */   
##@@@L4442_:                do   
##@@@L4443_:                {   
##@@@L4444_:                    uxQueue--;   
80006b5c:	5b cc       	SUB       R3, R3, #1
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006b5e:	ab ca       	MULS      R5, R3, R2
80006b60:	69 e9       	LD.W      R5, [R1 + R5]
80006b62:	50 38       	CMP       R5, #0			;->0x00
80006b64:	05 24       	ST.W      [SP + #5], R4
80006b66:	2d f0       	JZ        $+45                  ;->0x80006bc0
80006b68:	04 23       	ST.W      [SP + #4], R3
80006b6a:	19 00 62 04 	MADD32    R1, R3, R2
##@@@P_:tasks.c:6316
##@@@L6312_:        {   
##@@@L6313_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6314_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6315_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6316_:            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );   
80006b6e:	69 98       	LD.W      R5, [R1 + #1]
80006b70:	39 c1       	ADD       R7, R1, #4
80006b72:	41 58       	MOV       R2, R1
80006b74:	6d 98       	LD.W      R5, [R5 + #1]
80006b76:	28 28       	ADD       R2, #8			;->0x08
80006b78:	08 22       	ST.W      [SP + #8], R2
80006b7a:	52 70       	CMP       R5, R2
80006b7c:	02 f1       	JNZ       $+2                   ;->0x80006b80
80006b7e:	e9 98       	LD.W      R5, [R1 + #3]
80006b80:	0b 59       	MOV       R8, R11
80006b82:	19 00 8c 20 	MADD32    R8, R4, R12
80006b86:	e5 98       	LD.W      R4, [R5 + #3]
80006b88:	07 24       	ST.W      [SP + #7], R4
80006b8a:	1c 28       	ADD       R1, #12			;->0x0C
80006b8c:	06 21       	ST.W      [SP + #6], R1
80006b8e:	8a 58       	MOV       R4, R10
80006b90:	09 24       	ST.W      [SP + #9], R4
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006b92:	6d 98       	LD.W      R5, [R5 + #1]
80006b94:	08 0c       	LD.W      R4, [SP + #8]
80006b96:	54 70       	CMP       R5, R4
80006b98:	75 85       	ST.W      [R7], R5
80006b9a:	04 f1       	JNZ       $+4                   ;->0x80006ba2
80006b9c:	06 0d       	LD.W      R5, [SP + #6]
80006b9e:	55 82       	LD.W      R5, [R5]
80006ba0:	75 85       	ST.W      [R7], R5
80006ba2:	f5 98       	LD.W      R6, [R5 + #3]
80006ba4:	21 10       	MOV       R2, #1			;->0x0001
##@@@P_:tasks.c:6328
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
80006ba6:	06 58       	MOV       R0, R6
80006ba8:	28 58       	MOV       R1, R8
80006baa:	62 58       	MOV       R3, R2
80006bac:	76 45       	LD        R5, [PC + #118]       ;->0x80006d84  :=0x800074e8
80006bae:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6330
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006bb0:	07 0d       	LD.W      R5, [SP + #7]
80006bb2:	65 70       	CMP       R6, R5
80006bb4:	cc f0       	JZ        $-52                  ;->0x80006b4c
80006bb6:	84 2a       	ADD       R8, #36			;->0x24
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006bb8:	57 82       	LD.W      R5, [R7]
##@@@P_:tasks.c:6330
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006bba:	09 0c       	LD.W      R4, [SP + #9]
80006bbc:	64 c0       	ADD       R4, R4, #1
80006bbe:	e9 07       	SJMP      $-23                  ;->0x80006b90
##@@@F_:uxTaskGetSystemState():
80006bc0:	a9 58       	MOV       R5, R9
80006bc2:	c9 07       	SJMP      $-55                  ;->0x80006b54
80006bc4:	05 24       	ST.W      [SP + #5], R4
##@@@P_:tasks.c:4450
##@@@L4445_:                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady ) );   
##@@@L4446_:                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );   
##@@@L4447_:
##@@@L4448_:                /* Fill in an TaskStatus_t structure with information on each   
##@@@L4449_:                 * task in the Blocked state. */   
##@@@L4450_:                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked ) );   
80006bc6:	71 45       	LD        R5, [PC + #113]       ;->0x80006d88  :=0xd0000070
80006bc8:	65 82       	LD.W      R6, [R5]
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006bca:	56 82       	LD.W      R5, [R6]
80006bcc:	50 38       	CMP       R5, #0			;->0x00
80006bce:	2b f0       	JZ        $+43                  ;->0x80006c24
##@@@P_:tasks.c:6316
##@@@L6312_:        {   
##@@@L6313_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6314_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6315_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6316_:            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );   
80006bd0:	6e 98       	LD.W      R5, [R6 + #1]
80006bd2:	86 58       	MOV       R4, R6
80006bd4:	6d 98       	LD.W      R5, [R5 + #1]
80006bd6:	48 28       	ADD       R4, #8			;->0x08
80006bd8:	08 24       	ST.W      [SP + #8], R4
80006bda:	54 70       	CMP       R5, R4
80006bdc:	02 f1       	JNZ       $+2                   ;->0x80006be0
80006bde:	ee 98       	LD.W      R5, [R6 + #3]
80006be0:	0b 59       	MOV       R8, R11
80006be2:	05 0c       	LD.W      R4, [SP + #5]
80006be4:	19 00 8c 20 	MADD32    R8, R4, R12
80006be8:	91 10       	MOV       R9, #1			;->0x0001
80006bea:	e5 98       	LD.W      R4, [R5 + #3]
80006bec:	07 24       	ST.W      [SP + #7], R4
80006bee:	a2 10       	MOV       R10, #2			;->0x0002
80006bf0:	89 58       	MOV       R4, R9
80006bf2:	09 24       	ST.W      [SP + #9], R4
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006bf4:	6d 98       	LD.W      R5, [R5 + #1]
80006bf6:	08 0c       	LD.W      R4, [SP + #8]
80006bf8:	54 70       	CMP       R5, R4
80006bfa:	75 a0       	ST.W      [R6 + #1], R5
80006bfc:	03 f1       	JNZ       $+3                   ;->0x80006c02
80006bfe:	ee 98       	LD.W      R5, [R6 + #3]
80006c00:	75 a0       	ST.W      [R6 + #1], R5
80006c02:	fd 98       	LD.W      R7, [R5 + #3]
##@@@P_:tasks.c:6328
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
80006c04:	07 58       	MOV       R0, R7
80006c06:	28 58       	MOV       R1, R8
80006c08:	49 58       	MOV       R2, R9
80006c0a:	6a 58       	MOV       R3, R10
80006c0c:	5e 45       	LD        R5, [PC + #94]        ;->0x80006d84  :=0x800074e8
80006c0e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6330
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006c10:	07 0d       	LD.W      R5, [SP + #7]
80006c12:	75 70       	CMP       R7, R5
80006c14:	06 f0       	JZ        $+6                   ;->0x80006c20
80006c16:	84 2a       	ADD       R8, #36			;->0x24
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006c18:	6e 98       	LD.W      R5, [R6 + #1]
80006c1a:	09 0c       	LD.W      R4, [SP + #9]
##@@@P_:tasks.c:6330
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006c1c:	64 c0       	ADD       R4, R4, #1
80006c1e:	ea 07       	SJMP      $-22                  ;->0x80006bf2
##@@@F_:uxTaskGetSystemState():
80006c20:	09 0b       	LD.W      R3, [SP + #9]
80006c22:	02 04       	SJMP      $+2                   ;->0x80006c26
80006c24:	30 10       	MOV       R3, #0			;->0x0000
##@@@P_:tasks.c:4451
##@@@L4446_:                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );   
##@@@L4447_:
##@@@L4448_:                /* Fill in an TaskStatus_t structure with information on each   
##@@@L4449_:                 * task in the Blocked state. */   
##@@@L4450_:                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked ) );   
##@@@L4451_:                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked ) );   
80006c26:	5a 45       	LD        R5, [PC + #90]        ;->0x80006d8c  :=0xd0000074
80006c28:	65 82       	LD.W      R6, [R5]
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006c2a:	56 82       	LD.W      R5, [R6]
##@@@F_:uxTaskGetSystemState():
##@@@P_:tasks.c:4450
##@@@L4445_:                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady ) );   
##@@@L4446_:                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );   
##@@@L4447_:
##@@@L4448_:                /* Fill in an TaskStatus_t structure with information on each   
##@@@L4449_:                 * task in the Blocked state. */   
##@@@L4450_:                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked ) );   
80006c2c:	05 0c       	LD.W      R4, [SP + #5]
80006c2e:	23 c3       	ADD       R4, R3, R4
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006c30:	06 24       	ST.W      [SP + #6], R4
80006c32:	50 38       	CMP       R5, #0			;->0x00
80006c34:	2b f0       	JZ        $+43                  ;->0x80006c8a
##@@@P_:tasks.c:6316
##@@@L6312_:        {   
##@@@L6313_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6314_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6315_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6316_:            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );   
80006c36:	6e 98       	LD.W      R5, [R6 + #1]
80006c38:	86 58       	MOV       R4, R6
80006c3a:	6d 98       	LD.W      R5, [R5 + #1]
80006c3c:	48 28       	ADD       R4, #8			;->0x08
80006c3e:	08 24       	ST.W      [SP + #8], R4
80006c40:	54 70       	CMP       R5, R4
80006c42:	02 f1       	JNZ       $+2                   ;->0x80006c46
80006c44:	ee 98       	LD.W      R5, [R6 + #3]
80006c46:	0b 59       	MOV       R8, R11
80006c48:	06 0c       	LD.W      R4, [SP + #6]
80006c4a:	19 00 8c 20 	MADD32    R8, R4, R12
80006c4e:	91 10       	MOV       R9, #1			;->0x0001
80006c50:	e5 98       	LD.W      R4, [R5 + #3]
80006c52:	07 24       	ST.W      [SP + #7], R4
80006c54:	a2 10       	MOV       R10, #2			;->0x0002
80006c56:	89 58       	MOV       R4, R9
80006c58:	09 24       	ST.W      [SP + #9], R4
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006c5a:	6d 98       	LD.W      R5, [R5 + #1]
80006c5c:	08 0c       	LD.W      R4, [SP + #8]
80006c5e:	54 70       	CMP       R5, R4
80006c60:	75 a0       	ST.W      [R6 + #1], R5
80006c62:	03 f1       	JNZ       $+3                   ;->0x80006c68
80006c64:	ee 98       	LD.W      R5, [R6 + #3]
80006c66:	75 a0       	ST.W      [R6 + #1], R5
80006c68:	fd 98       	LD.W      R7, [R5 + #3]
##@@@P_:tasks.c:6328
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
80006c6a:	07 58       	MOV       R0, R7
80006c6c:	28 58       	MOV       R1, R8
80006c6e:	49 58       	MOV       R2, R9
80006c70:	6a 58       	MOV       R3, R10
80006c72:	45 45       	LD        R5, [PC + #69]        ;->0x80006d84  :=0x800074e8
80006c74:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6330
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006c76:	07 0d       	LD.W      R5, [SP + #7]
80006c78:	75 70       	CMP       R7, R5
80006c7a:	06 f0       	JZ        $+6                   ;->0x80006c86
80006c7c:	84 2a       	ADD       R8, #36			;->0x24
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006c7e:	6e 98       	LD.W      R5, [R6 + #1]
80006c80:	09 0c       	LD.W      R4, [SP + #9]
##@@@P_:tasks.c:6330
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006c82:	64 c0       	ADD       R4, R4, #1
80006c84:	ea 07       	SJMP      $-22                  ;->0x80006c58
##@@@F_:uxTaskGetSystemState():
80006c86:	09 0b       	LD.W      R3, [SP + #9]
80006c88:	02 04       	SJMP      $+2                   ;->0x80006c8c
80006c8a:	30 10       	MOV       R3, #0			;->0x0000
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006c8c:	41 46       	LD        R6, [PC + #65]        ;->0x80006d90  :=0xd0000048
80006c8e:	56 82       	LD.W      R5, [R6]
##@@@F_:uxTaskGetSystemState():
##@@@P_:tasks.c:4451
##@@@L4446_:                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );   
##@@@L4447_:
##@@@L4448_:                /* Fill in an TaskStatus_t structure with information on each   
##@@@L4449_:                 * task in the Blocked state. */   
##@@@L4450_:                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked ) );   
##@@@L4451_:                uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked ) );   
80006c90:	06 0c       	LD.W      R4, [SP + #6]
80006c92:	23 c3       	ADD       R4, R3, R4
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006c94:	06 24       	ST.W      [SP + #6], R4
80006c96:	50 38       	CMP       R5, #0			;->0x00
80006c98:	2b f0       	JZ        $+43                  ;->0x80006cee
##@@@P_:tasks.c:6316
##@@@L6312_:        {   
##@@@L6313_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6314_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6315_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6316_:            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );   
80006c9a:	6e 98       	LD.W      R5, [R6 + #1]
80006c9c:	86 58       	MOV       R4, R6
80006c9e:	6d 98       	LD.W      R5, [R5 + #1]
80006ca0:	48 28       	ADD       R4, #8			;->0x08
80006ca2:	08 24       	ST.W      [SP + #8], R4
80006ca4:	54 70       	CMP       R5, R4
80006ca6:	02 f1       	JNZ       $+2                   ;->0x80006caa
80006ca8:	ee 98       	LD.W      R5, [R6 + #3]
80006caa:	0b 59       	MOV       R8, R11
80006cac:	06 0c       	LD.W      R4, [SP + #6]
80006cae:	19 00 8c 20 	MADD32    R8, R4, R12
80006cb2:	91 10       	MOV       R9, #1			;->0x0001
80006cb4:	e5 98       	LD.W      R4, [R5 + #3]
80006cb6:	07 24       	ST.W      [SP + #7], R4
80006cb8:	a4 10       	MOV       R10, #4			;->0x0004
80006cba:	89 58       	MOV       R4, R9
80006cbc:	09 24       	ST.W      [SP + #9], R4
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006cbe:	6d 98       	LD.W      R5, [R5 + #1]
80006cc0:	08 0c       	LD.W      R4, [SP + #8]
80006cc2:	54 70       	CMP       R5, R4
80006cc4:	75 a0       	ST.W      [R6 + #1], R5
80006cc6:	03 f1       	JNZ       $+3                   ;->0x80006ccc
80006cc8:	ee 98       	LD.W      R5, [R6 + #3]
80006cca:	75 a0       	ST.W      [R6 + #1], R5
80006ccc:	fd 98       	LD.W      R7, [R5 + #3]
##@@@P_:tasks.c:6328
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
80006cce:	07 58       	MOV       R0, R7
80006cd0:	28 58       	MOV       R1, R8
80006cd2:	49 58       	MOV       R2, R9
80006cd4:	6a 58       	MOV       R3, R10
80006cd6:	2c 45       	LD        R5, [PC + #44]        ;->0x80006d84  :=0x800074e8
80006cd8:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6330
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006cda:	07 0d       	LD.W      R5, [SP + #7]
80006cdc:	75 70       	CMP       R7, R5
80006cde:	06 f0       	JZ        $+6                   ;->0x80006cea
80006ce0:	84 2a       	ADD       R8, #36			;->0x24
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006ce2:	6e 98       	LD.W      R5, [R6 + #1]
80006ce4:	09 0c       	LD.W      R4, [SP + #9]
##@@@P_:tasks.c:6330
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006ce6:	64 c0       	ADD       R4, R4, #1
80006ce8:	ea 07       	SJMP      $-22                  ;->0x80006cbc
##@@@F_:uxTaskGetSystemState():
80006cea:	09 0b       	LD.W      R3, [SP + #9]
80006cec:	02 04       	SJMP      $+2                   ;->0x80006cf0
80006cee:	30 10       	MOV       R3, #0			;->0x0000
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006cf0:	29 47       	LD        R7, [PC + #41]        ;->0x80006d94  :=0xd000008c
80006cf2:	57 82       	LD.W      R5, [R7]
##@@@F_:uxTaskGetSystemState():
##@@@P_:tasks.c:4457
##@@@L4452_:
##@@@L4453_:                #if ( INCLUDE_vTaskDelete == 1 )   
##@@@L4454_:                {   
##@@@L4455_:                    /* Fill in an TaskStatus_t structure with information on   
##@@@L4456_:                     * each task that has been deleted but not yet cleaned up. */   
##@@@L4457_:                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted ) );   
80006cf4:	06 0c       	LD.W      R4, [SP + #6]
80006cf6:	23 c3       	ADD       R4, R3, R4
##@@@F_:prvListTasksWithinSingleList():
##@@@P_:tasks.c:6311
##@@@L6306_:    {   
##@@@L6307_:        configLIST_VOLATILE TCB_t * pxNextTCB;   
##@@@L6308_:        configLIST_VOLATILE TCB_t * pxFirstTCB;   
##@@@L6309_:        UBaseType_t uxTask = 0;   
##@@@L6310_:
##@@@L6311_:        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )   
80006cf8:	06 24       	ST.W      [SP + #6], R4
80006cfa:	50 38       	CMP       R5, #0			;->0x00
80006cfc:	2d f0       	JZ        $+45                  ;->0x80006d56
##@@@P_:tasks.c:6316
##@@@L6312_:        {   
##@@@L6313_:            /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6314_:            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6315_:            /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6316_:            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );   
80006cfe:	6f 98       	LD.W      R5, [R7 + #1]
80006d00:	87 58       	MOV       R4, R7
80006d02:	6d 98       	LD.W      R5, [R5 + #1]
80006d04:	48 28       	ADD       R4, #8			;->0x08
80006d06:	08 24       	ST.W      [SP + #8], R4
80006d08:	54 70       	CMP       R5, R4
80006d0a:	02 f1       	JNZ       $+2                   ;->0x80006d0e
80006d0c:	ef 98       	LD.W      R5, [R7 + #3]
80006d0e:	06 0c       	LD.W      R4, [SP + #6]
80006d10:	19 00 8c 2c 	MADD32    R11, R4, R12
80006d14:	81 10       	MOV       R8, #1			;->0x0001
80006d16:	e5 98       	LD.W      R4, [R5 + #3]
80006d18:	07 24       	ST.W      [SP + #7], R4
80006d1a:	93 10       	MOV       R9, #3			;->0x0003
80006d1c:	88 58       	MOV       R4, R8
80006d1e:	09 24       	ST.W      [SP + #9], R4
80006d20:	01 08       	LD.W      R0, [SP + #1]
80006d22:	40 59       	MOV       R10, R0
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006d24:	6d 98       	LD.W      R5, [R5 + #1]
80006d26:	08 0c       	LD.W      R4, [SP + #8]
80006d28:	54 70       	CMP       R5, R4
80006d2a:	7d a0       	ST.W      [R7 + #1], R5
80006d2c:	03 f1       	JNZ       $+3                   ;->0x80006d32
80006d2e:	ef 98       	LD.W      R5, [R7 + #3]
80006d30:	7d a0       	ST.W      [R7 + #1], R5
80006d32:	f5 98       	LD.W      R6, [R5 + #3]
##@@@P_:tasks.c:6328
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
80006d34:	06 58       	MOV       R0, R6
80006d36:	2b 58       	MOV       R1, R11
80006d38:	48 58       	MOV       R2, R8
80006d3a:	69 58       	MOV       R3, R9
80006d3c:	12 45       	LD        R5, [PC + #18]        ;->0x80006d84  :=0x800074e8
80006d3e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6330
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006d40:	07 0d       	LD.W      R5, [SP + #7]
80006d42:	65 70       	CMP       R6, R5
80006d44:	07 f0       	JZ        $+7                   ;->0x80006d52
80006d46:	b4 2a       	ADD       R11, #36			;->0x24
##@@@P_:tasks.c:6327
##@@@L6322_:            do   
##@@@L6323_:            {   
##@@@L6324_:                /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6325_:                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6326_:                /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6327_:                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );   
80006d48:	6f 98       	LD.W      R5, [R7 + #1]
##@@@P_:tasks.c:6330
##@@@L6328_:                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );   
##@@@L6329_:                uxTask++;   
##@@@L6330_:            } while( pxNextTCB != pxFirstTCB );   
80006d4a:	09 0c       	LD.W      R4, [SP + #9]
80006d4c:	64 c0       	ADD       R4, R4, #1
80006d4e:	09 24       	ST.W      [SP + #9], R4
80006d50:	ea 07       	SJMP      $-22                  ;->0x80006d24
##@@@F_:uxTaskGetSystemState():
80006d52:	09 0c       	LD.W      R4, [SP + #9]
80006d54:	04 04       	SJMP      $+4                   ;->0x80006d5c
80006d56:	40 10       	MOV       R4, #0			;->0x0000
80006d58:	01 08       	LD.W      R0, [SP + #1]
80006d5a:	40 59       	MOV       R10, R0
##@@@P_:tasks.c:4465
##@@@L4460_:
##@@@L4461_:                #if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L4462_:                {   
##@@@L4463_:                    /* Fill in an TaskStatus_t structure with information on   
##@@@L4464_:                     * each task in the Suspended state. */   
##@@@L4465_:                    uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended ) );   
80006d5c:	06 0d       	LD.W      R5, [SP + #6]
80006d5e:	7c c3       	ADD       R7, R4, R5
##@@@P_:tasks.c:4471
##@@@L4466_:                }   
##@@@L4467_:                #endif   
##@@@L4468_:
##@@@L4469_:                #if ( configGENERATE_RUN_TIME_STATS == 1 )   
##@@@L4470_:                {   
##@@@L4471_:                    if( pulTotalRunTime != NULL )   
80006d60:	a0 38       	CMP       R10, #0			;->0x00
80006d62:	04 f0       	JZ        $+4                   ;->0x80006d6a
##@@@F_:xTaskGetTickCount():
##@@@P_:tasks.c:4083
##@@@L4078_:    traceENTER_xTaskGetTickCount();   
##@@@L4079_:
##@@@L4080_:    /* Critical section required if running on a 16 bit processor. */   
##@@@L4081_:    portTICK_TYPE_ENTER_CRITICAL();   
##@@@L4082_:    {   
##@@@L4083_:        xTicks = xTickCount;   
80006d64:	0d 45       	LD        R5, [PC + #13]        ;->0x80006d98  :=0xd000006c
80006d66:	55 82       	LD.W      R5, [R5]
##@@@F_:uxTaskGetSystemState():
##@@@P_:tasks.c:4476
##@@@L4471_:                    if( pulTotalRunTime != NULL )   
##@@@L4472_:                    {   
##@@@L4473_:                        #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE   
##@@@L4474_:                            portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );   
##@@@L4475_:                        #else   
##@@@L4476_:                            *pulTotalRunTime = ( configRUN_TIME_COUNTER_TYPE ) portGET_RUN_TIME_COUNTER_VALUE();   
80006d68:	a5 85       	ST.W      [R10], R5
##@@@P_:tasks.c:4494
##@@@L4489_:            else   
##@@@L4490_:            {   
##@@@L4491_:                mtCOVERAGE_TEST_MARKER();   
##@@@L4492_:            }   
##@@@L4493_:        }   
##@@@L4494_:        ( void ) xTaskResumeAll();   
80006d6a:	0d 45       	LD        R5, [PC + #13]        ;->0x80006d9c  :=0x80005a70
80006d6c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:4498
##@@@L4495_:
##@@@L4496_:        traceRETURN_uxTaskGetSystemState( uxTask );   
##@@@L4497_:
##@@@L4498_:        return uxTask;   
80006d6e:	07 58       	MOV       R0, R7
80006d70:	e8 2a       	ADD       SP, #40			;->0x28
80006d72:	7f 5e       	POP       {R6-R12}
80006d74:	0d 5d       	POP       LR
80006d76:	1d 5c       	JMP       LR
80006d78:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80006d7c:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
80006d80:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80006d84:	e8 74 00 80 	.long     0x800074e8 ->-2147453720  [!!!@2@:LD.H      SP, [R8++]	@@: LD.B      R0, [R0]
80006d88:	70 00 00 d0 	.long     0xd0000070 ->-805306256  [!!!@4@:ST.H      [R0 + #52], R0
80006d8c:	74 00 00 d0 	.long     0xd0000074 ->-805306252  [!!!@4@:ST.H      [R0 + #-204], R0
80006d90:	48 00 00 d0 	.long     0xd0000048 ->-805306296  [!!!@4@:LD.H      R0, [R0 + #52]
80006d94:	8c 00 00 d0 	.long     0xd000008c ->-805306228  [!!!@4@:LJMP      $+839680              ;->0x801a0d94
80006d98:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
80006d9c:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]

80006da0 <xTaskCatchUpTicks>:
##@@@F_:xTaskCatchUpTicks():
##@@@P_:tasks.c:4589
##@@@L4584_:
##@@@L4585_:#endif /* configUSE_TICKLESS_IDLE */   
##@@@L4586_:/*----------------------------------------------------------*/   
##@@@L4587_:
##@@@L4588_:BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )   
##@@@L4589_:{   
80006da0:	2d 5d       	PUSH      LR
80006da2:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:4596
##@@@L4591_:
##@@@L4592_:    traceENTER_xTaskCatchUpTicks( xTicksToCatchUp );   
##@@@L4593_:
##@@@L4594_:    /* Must not be called with the scheduler suspended as the implementation   
##@@@L4595_:     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */   
##@@@L4596_:    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );   
80006da4:	1f 44       	LD        R4, [PC + #31]        ;->0x80006e20  :=0xd0000068
80006da6:	54 82       	LD.W      R5, [R4]
80006da8:	50 38       	CMP       R5, #0			;->0x00
80006daa:	49 f1       	JNZ       $+73                  ;->0x80006e3c
80006dac:	a0 58       	MOV       R5, R0
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
80006dae:	34 82       	LD.W      R3, [R4]
80006db0:	5b c0       	ADD       R3, R3, #1
80006db2:	43 85       	ST.W      [R4], R3
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80006db4:	20 5d       	PUSH      R0
80006db6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006dba:	08 00       	SYNC     SYNC     
80006dbc:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006dc0:	08 00       	SYNC     SYNC     
80006dc2:	00 5d       	POP       R0
80006dc4:	20 5d       	PUSH      R0
80006dc6:	21 5d       	PUSH      R1
80006dc8:	17 44       	LD        R4, [PC + #23]        ;->0x80006e24  :=0x1ff
80006dca:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006dce:	24 58       	MOV       R1, R4
80006dd0:	11 68       	NOT       R1, R1
80006dd2:	01 69       	ANL       R0, R1
80006dd4:	4f 11       	MOV       R4, #31			;->0x001F
80006dd6:	24 58       	MOV       R1, R4
80006dd8:	01 6a       	ORL       R0, R1
80006dda:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006dde:	08 00       	SYNC     SYNC     
80006de0:	01 5d       	POP       R1
80006de2:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80006de4:	11 44       	LD        R4, [PC + #17]        ;->0x80006e28  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80006de6:	20 5d       	PUSH      R0
80006de8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006dec:	08 00       	SYNC     SYNC     
80006dee:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006df2:	08 00       	SYNC     SYNC     
80006df4:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80006df6:	44 82       	LD.W      R4, [R4]
80006df8:	40 38       	CMP       R4, #0			;->0x00
80006dfa:	07 f0       	JZ        $+7                   ;->0x80006e08
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80006dfc:	0c 44       	LD        R4, [PC + #12]        ;->0x80006e2c  :=0xd0000040
80006dfe:	34 82       	LD.W      R3, [R4]
80006e00:	53 9c       	LD.W      R2, [R3 + #17]
80006e02:	52 c0       	ADD       R2, R2, #1
80006e04:	5a a4       	ST.W      [R3 + #17], R2
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80006e06:	44 82       	LD.W      R4, [R4]
##@@@F_:xTaskCatchUpTicks():
##@@@P_:tasks.c:4605
##@@@L4600_:    vTaskSuspendAll();   
##@@@L4601_:
##@@@L4602_:    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */   
##@@@L4603_:    taskENTER_CRITICAL();   
##@@@L4604_:    {   
##@@@L4605_:        xPendedTicks += xTicksToCatchUp;   
80006e08:	0a 44       	LD        R4, [PC + #10]        ;->0x80006e30  :=0xd0000308
80006e0a:	34 82       	LD.W      R3, [R4]
80006e0c:	6b c3       	ADD       R5, R3, R5
80006e0e:	45 85       	ST.W      [R4], R5
##@@@P_:tasks.c:4607
##@@@L4606_:    }   
##@@@L4607_:    taskEXIT_CRITICAL();   
80006e10:	09 45       	LD        R5, [PC + #9]         ;->0x80006e34  :=0x80005730
80006e12:	05 5c       	LJMP      R5
##@@@P_:tasks.c:4608
##@@@L4608_:    xYieldOccurred = xTaskResumeAll();   
80006e14:	09 45       	LD        R5, [PC + #9]         ;->0x80006e38  :=0x80005a70
80006e16:	05 5c       	LJMP      R5
##@@@P_:tasks.c:4612
##@@@L4609_:
##@@@L4610_:    traceRETURN_xTaskCatchUpTicks( xYieldOccurred );   
##@@@L4611_:
##@@@L4612_:    return xYieldOccurred;   
80006e18:	e4 28       	ADD       SP, #4			;->0x04
80006e1a:	0d 5d       	POP       LR
80006e1c:	1d 5c       	JMP       LR
80006e1e:	00 00       	NOP      NOP      
80006e20:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80006e24:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006e28:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80006e2c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80006e30:	08 03 00 d0 	.long     0xd0000308 ->-805305592  [!!!@4@:JMP       $+577536              ;->0x80120e30
80006e34:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80006e34
80006e38:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:4596
##@@@L4591_:
##@@@L4592_:    traceENTER_xTaskCatchUpTicks( xTicksToCatchUp );   
##@@@L4593_:
##@@@L4594_:    /* Must not be called with the scheduler suspended as the implementation   
##@@@L4595_:     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */   
##@@@L4596_:    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );   
80006e3c:	20 5d       	PUSH      R0
80006e3e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006e42:	08 00       	SYNC     SYNC     
80006e44:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006e48:	08 00       	SYNC     SYNC     
80006e4a:	00 5d       	POP       R0
80006e4c:	20 5d       	PUSH      R0
80006e4e:	21 5d       	PUSH      R1
80006e50:	0d 45       	LD        R5, [PC + #13]        ;->0x80006e84  :=0x1ff
80006e52:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006e56:	25 58       	MOV       R1, R5
80006e58:	11 68       	NOT       R1, R1
80006e5a:	01 69       	ANL       R0, R1
80006e5c:	5f 11       	MOV       R5, #31			;->0x001F
80006e5e:	25 58       	MOV       R1, R5
80006e60:	01 6a       	ORL       R0, R1
80006e62:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006e66:	08 00       	SYNC     SYNC     
80006e68:	01 5d       	POP       R1
80006e6a:	00 5d       	POP       R0
80006e6c:	20 5d       	PUSH      R0
80006e6e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006e72:	08 00       	SYNC     SYNC     
80006e74:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006e78:	08 00       	SYNC     SYNC     
80006e7a:	00 5d       	POP       R0
80006e7c:	07 00       	BREAK    BREAK    
80006e7e:	03 45       	LD        R5, [PC + #3]         ;->0x80006e88  :=0x8000911c
80006e80:	05 5c       	LJMP      R5
80006e82:	00 00       	NOP      NOP      
80006e84:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006e88:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006e8c <vTaskPlaceOnEventList>:
##@@@F_:vTaskPlaceOnEventList():
##@@@P_:tasks.c:5284
##@@@L5279_:#endif /* if ( configNUMBER_OF_CORES > 1 ) */   
##@@@L5280_:/*-----------------------------------------------------------*/   
##@@@L5281_:
##@@@L5282_:void vTaskPlaceOnEventList( List_t * const pxEventList,   
##@@@L5283_:                            const TickType_t xTicksToWait )   
##@@@L5284_:{   
80006e8c:	81 5f       	PUSH      {R6,LR}
80006e8e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:5287
##@@@L5285_:    traceENTER_vTaskPlaceOnEventList( pxEventList, xTicksToWait );   
##@@@L5286_:
##@@@L5287_:    configASSERT( pxEventList );   
80006e90:	00 38       	CMP       R0, #0			;->0x00
80006e92:	15 f0       	JZ        $+21                  ;->0x80006ebc
80006e94:	c1 58       	MOV       R6, R1
##@@@P_:tasks.c:5303
##@@@L5298_:     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )   
##@@@L5299_:     * Therefore, the event list is sorted in descending priority order.   
##@@@L5300_:     *   
##@@@L5301_:     * The queue that contains the event list is locked, preventing   
##@@@L5302_:     * simultaneous access from interrupts. */   
##@@@L5303_:    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );   
80006e96:	07 45       	LD        R5, [PC + #7]         ;->0x80006eb0  :=0xd0000040
80006e98:	15 82       	LD.W      R1, [R5]
80006e9a:	18 29       	ADD       R1, #24			;->0x18
80006e9c:	06 45       	LD        R5, [PC + #6]         ;->0x80006eb4  :=0x8000225c
80006e9e:	05 5c       	LJMP      R5
80006ea0:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:tasks.c:5305
##@@@L5304_:
##@@@L5305_:    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );   
80006ea2:	06 58       	MOV       R0, R6
80006ea4:	05 45       	LD        R5, [PC + #5]         ;->0x80006eb8  :=0x800059c0
80006ea6:	05 5c       	LJMP      R5
##@@@P_:tasks.c:5308
##@@@L5306_:
##@@@L5307_:    traceRETURN_vTaskPlaceOnEventList();   
##@@@L5308_:}   
80006ea8:	e4 28       	ADD       SP, #4			;->0x04
80006eaa:	06 5d       	POP       R6
80006eac:	0d 5d       	POP       LR
80006eae:	1d 5c       	JMP       LR
80006eb0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80006eb4:	5c 22 00 80 	.long     0x8000225c ->-2147474852  [!!!@2@:ST.W      [SP + #92], R2	@@: LD.B      R0, [R0]
80006eb8:	c0 59 00 80 	.long     0x800059c0 ->-2147460672  [!!!@2@:MOV       SP, R0	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:5287
##@@@L5282_:void vTaskPlaceOnEventList( List_t * const pxEventList,   
##@@@L5283_:                            const TickType_t xTicksToWait )   
##@@@L5284_:{   
##@@@L5285_:    traceENTER_vTaskPlaceOnEventList( pxEventList, xTicksToWait );   
##@@@L5286_:
##@@@L5287_:    configASSERT( pxEventList );   
80006ebc:	20 5d       	PUSH      R0
80006ebe:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006ec2:	08 00       	SYNC     SYNC     
80006ec4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006ec8:	08 00       	SYNC     SYNC     
80006eca:	00 5d       	POP       R0
80006ecc:	20 5d       	PUSH      R0
80006ece:	21 5d       	PUSH      R1
80006ed0:	0d 45       	LD        R5, [PC + #13]        ;->0x80006f04  :=0x1ff
80006ed2:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006ed6:	25 58       	MOV       R1, R5
80006ed8:	11 68       	NOT       R1, R1
80006eda:	01 69       	ANL       R0, R1
80006edc:	5f 11       	MOV       R5, #31			;->0x001F
80006ede:	25 58       	MOV       R1, R5
80006ee0:	01 6a       	ORL       R0, R1
80006ee2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006ee6:	08 00       	SYNC     SYNC     
80006ee8:	01 5d       	POP       R1
80006eea:	00 5d       	POP       R0
80006eec:	20 5d       	PUSH      R0
80006eee:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006ef2:	08 00       	SYNC     SYNC     
80006ef4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006ef8:	08 00       	SYNC     SYNC     
80006efa:	00 5d       	POP       R0
80006efc:	07 00       	BREAK    BREAK    
80006efe:	03 45       	LD        R5, [PC + #3]         ;->0x80006f08  :=0x8000911c
80006f00:	05 5c       	LJMP      R5
80006f02:	00 00       	NOP      NOP      
80006f04:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006f08:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006f0c <vTaskPlaceOnUnorderedEventList>:
##@@@F_:vTaskPlaceOnUnorderedEventList():
##@@@P_:tasks.c:5314
##@@@L5309_:/*-----------------------------------------------------------*/   
##@@@L5310_:
##@@@L5311_:void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,   
##@@@L5312_:                                     const TickType_t xItemValue,   
##@@@L5313_:                                     const TickType_t xTicksToWait )   
##@@@L5314_:{   
80006f0c:	2d 5d       	PUSH      LR
80006f0e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:5317
##@@@L5315_:    traceENTER_vTaskPlaceOnUnorderedEventList( pxEventList, xItemValue, xTicksToWait );   
##@@@L5316_:
##@@@L5317_:    configASSERT( pxEventList );   
80006f10:	00 38       	CMP       R0, #0			;->0x00
80006f12:	2b f0       	JZ        $+43                  ;->0x80006f68
##@@@P_:tasks.c:5321
##@@@L5318_:
##@@@L5319_:    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by   
##@@@L5320_:     * the event groups implementation. */   
##@@@L5321_:    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );   
80006f14:	11 45       	LD        R5, [PC + #17]        ;->0x80006f58  :=0xd0000068
80006f16:	55 82       	LD.W      R5, [R5]
80006f18:	50 38       	CMP       R5, #0			;->0x00
80006f1a:	4a f0       	JZ        $+74                  ;->0x80006fae
##@@@P_:tasks.c:5326
##@@@L5322_:
##@@@L5323_:    /* Store the item value in the event list item.  It is safe to access the   
##@@@L5324_:     * event list item here as interrupts won't access the event list item of a   
##@@@L5325_:     * task that is not in the Blocked state. */   
##@@@L5326_:    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );   
80006f1c:	10 45       	LD        R5, [PC + #16]        ;->0x80006f5c  :=0xd0000040
80006f1e:	11 44       	LD        R4, [PC + #17]        ;->0x80006f60  :=0x80000000
80006f20:	35 82       	LD.W      R3, [R5]
80006f22:	14 6a       	ORL       R1, R4
80006f24:	99 a1       	ST.W      [R3 + #6], R1
##@@@P_:tasks.c:5333
##@@@L5328_:    /* Place the event list item of the TCB at the end of the appropriate event   
##@@@L5329_:     * list.  It is safe to access the event list here because it is part of an   
##@@@L5330_:     * event group implementation - and interrupts don't access event groups   
##@@@L5331_:     * directly (instead they access them indirectly by pending function calls to   
##@@@L5332_:     * the task level). */   
##@@@L5333_:    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );   
80006f26:	60 98       	LD.W      R4, [R0 + #1]
80006f28:	35 82       	LD.W      R3, [R5]
80006f2a:	dc a1       	ST.W      [R3 + #7], R4
80006f2c:	9c 98       	LD.W      R3, [R4 + #2]
80006f2e:	15 82       	LD.W      R1, [R5]
80006f30:	0b a2       	ST.W      [R1 + #8], R3
80006f32:	35 82       	LD.W      R3, [R5]
80006f34:	8c 98       	LD.W      R1, [R4 + #2]
80006f36:	38 29       	ADD       R3, #24			;->0x18
80006f38:	4b a0       	ST.W      [R1 + #1], R3
80006f3a:	35 82       	LD.W      R3, [R5]
80006f3c:	38 29       	ADD       R3, #24			;->0x18
80006f3e:	a3 a0       	ST.W      [R4 + #2], R3
80006f40:	55 82       	LD.W      R5, [R5]
80006f42:	a8 a2       	ST.W      [R5 + #10], R0
80006f44:	50 82       	LD.W      R5, [R0]
80006f46:	6d c0       	ADD       R5, R5, #1
80006f48:	05 85       	ST.W      [R0], R5
80006f4a:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:tasks.c:5335
##@@@L5334_:
##@@@L5335_:    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );   
80006f4c:	02 58       	MOV       R0, R2
80006f4e:	06 45       	LD        R5, [PC + #6]         ;->0x80006f64  :=0x800059c0
80006f50:	05 5c       	LJMP      R5
##@@@P_:tasks.c:5338
##@@@L5336_:
##@@@L5337_:    traceRETURN_vTaskPlaceOnUnorderedEventList();   
##@@@L5338_:}   
80006f52:	e4 28       	ADD       SP, #4			;->0x04
80006f54:	0d 5d       	POP       LR
80006f56:	1d 5c       	JMP       LR
80006f58:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80006f5c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80006f60:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
80006f64:	c0 59 00 80 	.long     0x800059c0 ->-2147460672  [!!!@2@:MOV       SP, R0	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:5317
##@@@L5312_:                                     const TickType_t xItemValue,   
##@@@L5313_:                                     const TickType_t xTicksToWait )   
##@@@L5314_:{   
##@@@L5315_:    traceENTER_vTaskPlaceOnUnorderedEventList( pxEventList, xItemValue, xTicksToWait );   
##@@@L5316_:
##@@@L5317_:    configASSERT( pxEventList );   
80006f68:	20 5d       	PUSH      R0
80006f6a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006f6e:	08 00       	SYNC     SYNC     
80006f70:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006f74:	08 00       	SYNC     SYNC     
80006f76:	00 5d       	POP       R0
80006f78:	20 5d       	PUSH      R0
80006f7a:	21 5d       	PUSH      R1
80006f7c:	1e 45       	LD        R5, [PC + #30]        ;->0x80006ff4  :=0x1ff
80006f7e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006f82:	25 58       	MOV       R1, R5
80006f84:	11 68       	NOT       R1, R1
80006f86:	01 69       	ANL       R0, R1
80006f88:	5f 11       	MOV       R5, #31			;->0x001F
80006f8a:	25 58       	MOV       R1, R5
80006f8c:	01 6a       	ORL       R0, R1
80006f8e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006f92:	08 00       	SYNC     SYNC     
80006f94:	01 5d       	POP       R1
80006f96:	00 5d       	POP       R0
80006f98:	20 5d       	PUSH      R0
80006f9a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006f9e:	08 00       	SYNC     SYNC     
80006fa0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006fa4:	08 00       	SYNC     SYNC     
80006fa6:	00 5d       	POP       R0
80006fa8:	07 00       	BREAK    BREAK    
80006faa:	14 45       	LD        R5, [PC + #20]        ;->0x80006ff8  :=0x8000911c
80006fac:	05 5c       	LJMP      R5
##@@@P_:tasks.c:5321
##@@@L5318_:
##@@@L5319_:    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by   
##@@@L5320_:     * the event groups implementation. */   
##@@@L5321_:    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );   
80006fae:	20 5d       	PUSH      R0
80006fb0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006fb4:	08 00       	SYNC     SYNC     
80006fb6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80006fba:	08 00       	SYNC     SYNC     
80006fbc:	00 5d       	POP       R0
80006fbe:	20 5d       	PUSH      R0
80006fc0:	21 5d       	PUSH      R1
80006fc2:	0d 45       	LD        R5, [PC + #13]        ;->0x80006ff4  :=0x1ff
80006fc4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80006fc8:	25 58       	MOV       R1, R5
80006fca:	11 68       	NOT       R1, R1
80006fcc:	01 69       	ANL       R0, R1
80006fce:	5f 11       	MOV       R5, #31			;->0x001F
80006fd0:	25 58       	MOV       R1, R5
80006fd2:	01 6a       	ORL       R0, R1
80006fd4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80006fd8:	08 00       	SYNC     SYNC     
80006fda:	01 5d       	POP       R1
80006fdc:	00 5d       	POP       R0
80006fde:	20 5d       	PUSH      R0
80006fe0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80006fe4:	08 00       	SYNC     SYNC     
80006fe6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80006fea:	08 00       	SYNC     SYNC     
80006fec:	00 5d       	POP       R0
80006fee:	07 00       	BREAK    BREAK    
80006ff0:	02 45       	LD        R5, [PC + #2]         ;->0x80006ff8  :=0x8000911c
80006ff2:	05 5c       	LJMP      R5
80006ff4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80006ff8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80006ffc <xTaskRemoveFromEventList>:
##@@@F_:xTaskRemoveFromEventList():
##@@@P_:tasks.c:5381
##@@@L5376_:
##@@@L5377_:#endif /* configUSE_TIMERS */   
##@@@L5378_:/*-----------------------------------------------------------*/   
##@@@L5379_:
##@@@L5380_:BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )   
##@@@L5381_:{   
80006ffc:	83 5f       	PUSH      {R6-R7,LR}
80006ffe:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:5403
##@@@L5398_:     * This function assumes that a check has already been made to ensure that   
##@@@L5399_:     * pxEventList is not empty. */   
##@@@L5400_:    /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5401_:    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5402_:    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5403_:    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );   
80007000:	e8 98       	LD.W      R5, [R0 + #3]
80007002:	ed 98       	LD.W      R5, [R5 + #3]
##@@@P_:tasks.c:5404
##@@@L5404_:    configASSERT( pxUnblockedTCB );   
80007004:	50 38       	CMP       R5, #0			;->0x00
80007006:	02 f1       	JNZ       $+2                   ;->0x8000700a
80007008:	64 04       	SJMP      $+100                 ;->0x800070d0
##@@@P_:tasks.c:5405
##@@@L5405_:    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );   
8000700a:	e5 99       	LD.W      R4, [R5 + #7]
8000700c:	15 9a       	LD.W      R2, [R5 + #8]
8000700e:	9d 9a       	LD.W      R3, [R5 + #10]
80007010:	a2 a0       	ST.W      [R4 + #2], R2
80007012:	15 9a       	LD.W      R2, [R5 + #8]
80007014:	54 a0       	ST.W      [R2 + #1], R4
80007016:	85 58       	MOV       R4, R5
80007018:	4b 98       	LD.W      R1, [R3 + #1]
8000701a:	48 29       	ADD       R4, #24			;->0x18
8000701c:	14 70       	CMP       R1, R4
8000701e:	02 f1       	JNZ       $+2                   ;->0x80007022
80007020:	5a a0       	ST.W      [R3 + #1], R2
80007022:	20 10       	MOV       R2, #0			;->0x0000
80007024:	aa a2       	ST.W      [R5 + #10], R2
80007026:	23 82       	LD.W      R2, [R3]
80007028:	52 cc       	SUB       R2, R2, #1
##@@@P_:tasks.c:5407
##@@@L5406_:
##@@@L5407_:    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
8000702a:	24 41       	LD        R1, [PC + #36]        ;->0x800070b8  :=0xd0000068
##@@@P_:tasks.c:5405
##@@@L5400_:    /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5401_:    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5402_:    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5403_:    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );   
##@@@L5404_:    configASSERT( pxUnblockedTCB );   
##@@@L5405_:    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );   
8000702c:	32 85       	ST.W      [R3], R2
##@@@P_:tasks.c:5407
##@@@L5406_:
##@@@L5407_:    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
8000702e:	31 82       	LD.W      R3, [R1]
80007030:	30 38       	CMP       R3, #0			;->0x00
80007032:	0f f0       	JZ        $+15                  ;->0x80007050
##@@@P_:tasks.c:5430
##@@@L5425_:    }   
##@@@L5426_:    else   
##@@@L5427_:    {   
##@@@L5428_:        /* The delayed and ready lists cannot be accessed, so hold this task   
##@@@L5429_:         * pending until the scheduler is resumed. */   
##@@@L5430_:        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );   
80007034:	22 43       	LD        R3, [PC + #34]        ;->0x800070bc  :=0xd0000078
80007036:	53 98       	LD.W      R2, [R3 + #1]
80007038:	ea a1       	ST.W      [R5 + #7], R2
8000703a:	8a 98       	LD.W      R1, [R2 + #2]
8000703c:	29 a2       	ST.W      [R5 + #8], R1
8000703e:	8a 98       	LD.W      R1, [R2 + #2]
80007040:	4c a0       	ST.W      [R1 + #1], R4
80007042:	94 a0       	ST.W      [R2 + #2], R4
80007044:	ab a2       	ST.W      [R5 + #10], R3
80007046:	43 82       	LD.W      R4, [R3]
80007048:	64 c0       	ADD       R4, R4, #1
8000704a:	34 85       	ST.W      [R3], R4
##@@@P_:tasks.c:5435
##@@@L5431_:    }   
##@@@L5432_:
##@@@L5433_:    #if ( configNUMBER_OF_CORES == 1 )   
##@@@L5434_:    {   
##@@@L5435_:        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )   
8000704c:	e5 9a       	LD.W      R4, [R5 + #11]
8000704e:	26 04       	SJMP      $+38                  ;->0x8000709a
##@@@P_:tasks.c:5409
##@@@L5404_:    configASSERT( pxUnblockedTCB );   
##@@@L5405_:    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );   
##@@@L5406_:
##@@@L5407_:    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
##@@@L5408_:    {   
##@@@L5409_:        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );   
80007050:	9d 98       	LD.W      R3, [R5 + #2]
80007052:	d5 98       	LD.W      R2, [R5 + #3]
80007054:	65 99       	LD.W      R4, [R5 + #5]
80007056:	9a a0       	ST.W      [R3 + #2], R2
80007058:	d5 98       	LD.W      R2, [R5 + #3]
8000705a:	53 a0       	ST.W      [R2 + #1], R3
8000705c:	4c 98       	LD.W      R1, [R4 + #1]
8000705e:	1d c1       	ADD       R3, R5, #4
80007060:	13 70       	CMP       R1, R3
80007062:	02 f1       	JNZ       $+2                   ;->0x80007066
80007064:	62 a0       	ST.W      [R4 + #1], R2
80007066:	24 82       	LD.W      R2, [R4]
80007068:	52 cc       	SUB       R2, R2, #1
8000706a:	42 85       	ST.W      [R4], R2
##@@@P_:tasks.c:5410
##@@@L5410_:        prvAddTaskToReadyList( pxUnblockedTCB );   
8000706c:	15 42       	LD        R2, [PC + #21]        ;->0x800070c0  :=0xd00002f8
8000706e:	e5 9a       	LD.W      R4, [R5 + #11]
80007070:	12 82       	LD.W      R1, [R2]
80007072:	41 70       	CMP       R4, R1
80007074:	02 f9       	JLS       $+2                   ;->0x80007078
80007076:	24 85       	ST.W      [R2], R4
80007078:	13 42       	LD        R2, [PC + #19]        ;->0x800070c4  :=0xd00000a0
8000707a:	14 11       	MOV       R1, #20			;->0x0014
8000707c:	02 58       	MOV       R0, R2
8000707e:	19 00 81 00 	MADD32    R0, R4, R1
80007082:	70 98       	LD.W      R6, [R0 + #1]
80007084:	ae a0       	ST.W      [R5 + #2], R6
80007086:	be 98       	LD.W      R7, [R6 + #2]
80007088:	ef a0       	ST.W      [R5 + #3], R7
8000708a:	be 98       	LD.W      R7, [R6 + #2]
8000708c:	7b a0       	ST.W      [R7 + #1], R3
8000708e:	b3 a0       	ST.W      [R6 + #2], R3
80007090:	68 a1       	ST.W      [R5 + #5], R0
80007092:	6c ca       	MULS      R5, R4, R1
80007094:	5a e9       	LD.W      R3, [R2 + R5]
80007096:	5b c0       	ADD       R3, R3, #1
80007098:	53 ef       	ST.W      [R2 + R5], R3
##@@@P_:tasks.c:5435
##@@@L5430_:        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );   
##@@@L5431_:    }   
##@@@L5432_:
##@@@L5433_:    #if ( configNUMBER_OF_CORES == 1 )   
##@@@L5434_:    {   
##@@@L5435_:        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )   
8000709a:	0c 45       	LD        R5, [PC + #12]        ;->0x800070c8  :=0xd0000040
8000709c:	55 82       	LD.W      R5, [R5]
8000709e:	ed 9a       	LD.W      R5, [R5 + #11]
800070a0:	45 70       	CMP       R4, R5
800070a2:	05 f9       	JLS       $+5                   ;->0x800070ac
##@@@P_:tasks.c:5444
##@@@L5439_:             * it should force a context switch now. */   
##@@@L5440_:            xReturn = pdTRUE;   
##@@@L5441_:
##@@@L5442_:            /* Mark that a yield is pending in case the user is not using the   
##@@@L5443_:             * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */   
##@@@L5444_:            xYieldPendings[ 0 ] = pdTRUE;   
800070a4:	0a 45       	LD        R5, [PC + #10]        ;->0x800070cc  :=0xd00002fc
800070a6:	01 10       	MOV       R0, #1			;->0x0001
800070a8:	50 85       	ST.W      [R5], R0
800070aa:	02 04       	SJMP      $+2                   ;->0x800070ae
800070ac:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:tasks.c:5469
##@@@L5464_:        #endif /* #if ( configUSE_PREEMPTION == 1 ) */   
##@@@L5465_:    }   
##@@@L5466_:    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L5467_:
##@@@L5468_:    traceRETURN_xTaskRemoveFromEventList( xReturn );   
##@@@L5469_:    return xReturn;   
800070ae:	e4 28       	ADD       SP, #4			;->0x04
800070b0:	03 5e       	POP       {R6-R7}
800070b2:	0d 5d       	POP       LR
800070b4:	1d 5c       	JMP       LR
800070b6:	00 00       	NOP      NOP      
800070b8:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800070bc:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
800070c0:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
800070c4:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
800070c8:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800070cc:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
##@@@P_:tasks.c:5404
##@@@L5399_:     * pxEventList is not empty. */   
##@@@L5400_:    /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5401_:    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5402_:    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5403_:    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );   
##@@@L5404_:    configASSERT( pxUnblockedTCB );   
800070d0:	20 5d       	PUSH      R0
800070d2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800070d6:	08 00       	SYNC     SYNC     
800070d8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800070dc:	08 00       	SYNC     SYNC     
800070de:	00 5d       	POP       R0
800070e0:	20 5d       	PUSH      R0
800070e2:	21 5d       	PUSH      R1
800070e4:	0d 45       	LD        R5, [PC + #13]        ;->0x80007118  :=0x1ff
800070e6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800070ea:	25 58       	MOV       R1, R5
800070ec:	11 68       	NOT       R1, R1
800070ee:	01 69       	ANL       R0, R1
800070f0:	5f 11       	MOV       R5, #31			;->0x001F
800070f2:	25 58       	MOV       R1, R5
800070f4:	01 6a       	ORL       R0, R1
800070f6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800070fa:	08 00       	SYNC     SYNC     
800070fc:	01 5d       	POP       R1
800070fe:	00 5d       	POP       R0
80007100:	20 5d       	PUSH      R0
80007102:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007106:	08 00       	SYNC     SYNC     
80007108:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000710c:	08 00       	SYNC     SYNC     
8000710e:	00 5d       	POP       R0
80007110:	07 00       	BREAK    BREAK    
80007112:	03 45       	LD        R5, [PC + #3]         ;->0x8000711c  :=0x8000911c
80007114:	05 5c       	LJMP      R5
80007116:	00 00       	NOP      NOP      
80007118:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000711c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80007120 <vTaskRemoveFromUnorderedEventList>:
##@@@F_:vTaskRemoveFromUnorderedEventList():
##@@@P_:tasks.c:5475
##@@@L5470_:}   
##@@@L5471_:/*-----------------------------------------------------------*/   
##@@@L5472_:
##@@@L5473_:void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,   
##@@@L5474_:                                        const TickType_t xItemValue )   
##@@@L5475_:{   
80007120:	83 5f       	PUSH      {R6-R7,LR}
80007122:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:5482
##@@@L5477_:
##@@@L5478_:    traceENTER_vTaskRemoveFromUnorderedEventList( pxEventListItem, xItemValue );   
##@@@L5479_:
##@@@L5480_:    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by   
##@@@L5481_:     * the event flags implementation. */   
##@@@L5482_:    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );   
80007124:	27 45       	LD        R5, [PC + #39]        ;->0x800071c0  :=0xd0000068
80007126:	55 82       	LD.W      R5, [R5]
80007128:	50 38       	CMP       R5, #0			;->0x00
8000712a:	02 f1       	JNZ       $+2                   ;->0x8000712e
8000712c:	56 04       	SJMP      $+86                  ;->0x800071d8
8000712e:	26 45       	LD        R5, [PC + #38]        ;->0x800071c4  :=0x80000000
##@@@P_:tasks.c:5485
##@@@L5483_:
##@@@L5484_:    /* Store the new item value in the event list. */   
##@@@L5485_:    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );   
80007130:	15 6a       	ORL       R1, R5
80007132:	01 85       	ST.W      [R0], R1
##@@@P_:tasks.c:5492
##@@@L5487_:    /* Remove the event list form the event flag.  Interrupts do not access   
##@@@L5488_:     * event flags. */   
##@@@L5489_:    /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5490_:    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5491_:    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5492_:    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );   
80007134:	e8 98       	LD.W      R5, [R0 + #3]
##@@@P_:tasks.c:5493
##@@@L5493_:    configASSERT( pxUnblockedTCB );   
80007136:	50 38       	CMP       R5, #0			;->0x00
80007138:	02 f1       	JNZ       $+2                   ;->0x8000713c
8000713a:	72 04       	SJMP      $+114                 ;->0x8000721e
##@@@P_:tasks.c:5494
##@@@L5494_:    listREMOVE_ITEM( pxEventListItem );   
8000713c:	50 98       	LD.W      R2, [R0 + #1]
8000713e:	98 98       	LD.W      R3, [R0 + #2]
80007140:	20 99       	LD.W      R4, [R0 + #4]
80007142:	93 a0       	ST.W      [R2 + #2], R3
80007144:	98 98       	LD.W      R3, [R0 + #2]
80007146:	5a a0       	ST.W      [R3 + #1], R2
80007148:	54 98       	LD.W      R2, [R4 + #1]
8000714a:	20 70       	CMP       R2, R0
8000714c:	02 f1       	JNZ       $+2                   ;->0x80007150
8000714e:	63 a0       	ST.W      [R4 + #1], R3
80007150:	30 10       	MOV       R3, #0			;->0x0000
80007152:	03 a1       	ST.W      [R0 + #4], R3
80007154:	24 82       	LD.W      R2, [R4]
80007156:	52 cc       	SUB       R2, R2, #1
80007158:	42 85       	ST.W      [R4], R2
##@@@P_:tasks.c:5513
##@@@L5508_:    #endif   
##@@@L5509_:
##@@@L5510_:    /* Remove the task from the delayed list and add it to the ready list.  The   
##@@@L5511_:     * scheduler is suspended so interrupts will not be accessing the ready   
##@@@L5512_:     * lists. */   
##@@@L5513_:    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );   
8000715a:	a5 98       	LD.W      R4, [R5 + #2]
8000715c:	cd 98       	LD.W      R1, [R5 + #3]
8000715e:	55 99       	LD.W      R2, [R5 + #5]
80007160:	a1 a0       	ST.W      [R4 + #2], R1
80007162:	cd 98       	LD.W      R1, [R5 + #3]
80007164:	4c a0       	ST.W      [R1 + #1], R4
80007166:	42 98       	LD.W      R0, [R2 + #1]
80007168:	25 c1       	ADD       R4, R5, #4
8000716a:	04 70       	CMP       R0, R4
8000716c:	02 f1       	JNZ       $+2                   ;->0x80007170
8000716e:	51 a0       	ST.W      [R2 + #1], R1
80007170:	6b a1       	ST.W      [R5 + #5], R3
80007172:	32 82       	LD.W      R3, [R2]
80007174:	5b cc       	SUB       R3, R3, #1
80007176:	23 85       	ST.W      [R2], R3
##@@@P_:tasks.c:5514
##@@@L5514_:    prvAddTaskToReadyList( pxUnblockedTCB );   
80007178:	14 42       	LD        R2, [PC + #20]        ;->0x800071c8  :=0xd00002f8
8000717a:	dd 9a       	LD.W      R3, [R5 + #11]
8000717c:	12 82       	LD.W      R1, [R2]
8000717e:	31 70       	CMP       R3, R1
80007180:	02 f9       	JLS       $+2                   ;->0x80007184
80007182:	23 85       	ST.W      [R2], R3
80007184:	12 42       	LD        R2, [PC + #18]        ;->0x800071cc  :=0xd00000a0
80007186:	14 11       	MOV       R1, #20			;->0x0014
80007188:	02 58       	MOV       R0, R2
8000718a:	19 00 61 00 	MADD32    R0, R3, R1
8000718e:	70 98       	LD.W      R6, [R0 + #1]
80007190:	ae a0       	ST.W      [R5 + #2], R6
80007192:	be 98       	LD.W      R7, [R6 + #2]
80007194:	ef a0       	ST.W      [R5 + #3], R7
80007196:	be 98       	LD.W      R7, [R6 + #2]
80007198:	7c a0       	ST.W      [R7 + #1], R4
8000719a:	b4 a0       	ST.W      [R6 + #2], R4
8000719c:	68 a1       	ST.W      [R5 + #5], R0
8000719e:	6b ca       	MULS      R5, R3, R1
800071a0:	62 e9       	LD.W      R4, [R2 + R5]
800071a2:	64 c0       	ADD       R4, R4, #1
##@@@P_:tasks.c:5518
##@@@L5515_:
##@@@L5516_:    #if ( configNUMBER_OF_CORES == 1 )   
##@@@L5517_:    {   
##@@@L5518_:        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )   
800071a4:	0b 41       	LD        R1, [PC + #11]        ;->0x800071d0  :=0xd0000040
##@@@P_:tasks.c:5514
##@@@L5509_:
##@@@L5510_:    /* Remove the task from the delayed list and add it to the ready list.  The   
##@@@L5511_:     * scheduler is suspended so interrupts will not be accessing the ready   
##@@@L5512_:     * lists. */   
##@@@L5513_:    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );   
##@@@L5514_:    prvAddTaskToReadyList( pxUnblockedTCB );   
800071a6:	54 ef       	ST.W      [R2 + R5], R4
##@@@P_:tasks.c:5518
##@@@L5515_:
##@@@L5516_:    #if ( configNUMBER_OF_CORES == 1 )   
##@@@L5517_:    {   
##@@@L5518_:        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )   
800071a8:	51 82       	LD.W      R5, [R1]
800071aa:	ed 9a       	LD.W      R5, [R5 + #11]
800071ac:	35 70       	CMP       R3, R5
800071ae:	04 f9       	JLS       $+4                   ;->0x800071b6
##@@@P_:tasks.c:5524
##@@@L5519_:        {   
##@@@L5520_:            /* The unblocked task has a priority above that of the calling task, so   
##@@@L5521_:             * a context switch is required.  This function is called with the   
##@@@L5522_:             * scheduler suspended so xYieldPending is set so the context switch   
##@@@L5523_:             * occurs immediately that the scheduler is resumed (unsuspended). */   
##@@@L5524_:            xYieldPendings[ 0 ] = pdTRUE;   
800071b0:	09 45       	LD        R5, [PC + #9]         ;->0x800071d4  :=0xd00002fc
800071b2:	41 10       	MOV       R4, #1			;->0x0001
800071b4:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:5542
##@@@L5537_:        #endif   
##@@@L5538_:    }   
##@@@L5539_:    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L5540_:
##@@@L5541_:    traceRETURN_vTaskRemoveFromUnorderedEventList();   
##@@@L5542_:}   
800071b6:	e4 28       	ADD       SP, #4			;->0x04
800071b8:	03 5e       	POP       {R6-R7}
800071ba:	0d 5d       	POP       LR
800071bc:	1d 5c       	JMP       LR
800071be:	00 00       	NOP      NOP      
800071c0:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800071c4:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
800071c8:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
800071cc:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
800071d0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800071d4:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
##@@@P_:tasks.c:5482
##@@@L5477_:
##@@@L5478_:    traceENTER_vTaskRemoveFromUnorderedEventList( pxEventListItem, xItemValue );   
##@@@L5479_:
##@@@L5480_:    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by   
##@@@L5481_:     * the event flags implementation. */   
##@@@L5482_:    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );   
800071d8:	20 5d       	PUSH      R0
800071da:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800071de:	08 00       	SYNC     SYNC     
800071e0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800071e4:	08 00       	SYNC     SYNC     
800071e6:	00 5d       	POP       R0
800071e8:	20 5d       	PUSH      R0
800071ea:	21 5d       	PUSH      R1
800071ec:	1e 45       	LD        R5, [PC + #30]        ;->0x80007264  :=0x1ff
800071ee:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800071f2:	25 58       	MOV       R1, R5
800071f4:	11 68       	NOT       R1, R1
800071f6:	01 69       	ANL       R0, R1
800071f8:	5f 11       	MOV       R5, #31			;->0x001F
800071fa:	25 58       	MOV       R1, R5
800071fc:	01 6a       	ORL       R0, R1
800071fe:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007202:	08 00       	SYNC     SYNC     
80007204:	01 5d       	POP       R1
80007206:	00 5d       	POP       R0
80007208:	20 5d       	PUSH      R0
8000720a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000720e:	08 00       	SYNC     SYNC     
80007210:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007214:	08 00       	SYNC     SYNC     
80007216:	00 5d       	POP       R0
80007218:	07 00       	BREAK    BREAK    
8000721a:	14 45       	LD        R5, [PC + #20]        ;->0x80007268  :=0x8000911c
8000721c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:5493
##@@@L5488_:     * event flags. */   
##@@@L5489_:    /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L5490_:    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L5491_:    /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L5492_:    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );   
##@@@L5493_:    configASSERT( pxUnblockedTCB );   
8000721e:	20 5d       	PUSH      R0
80007220:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007224:	08 00       	SYNC     SYNC     
80007226:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000722a:	08 00       	SYNC     SYNC     
8000722c:	00 5d       	POP       R0
8000722e:	20 5d       	PUSH      R0
80007230:	21 5d       	PUSH      R1
80007232:	0d 45       	LD        R5, [PC + #13]        ;->0x80007264  :=0x1ff
80007234:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007238:	25 58       	MOV       R1, R5
8000723a:	11 68       	NOT       R1, R1
8000723c:	01 69       	ANL       R0, R1
8000723e:	5f 11       	MOV       R5, #31			;->0x001F
80007240:	25 58       	MOV       R1, R5
80007242:	01 6a       	ORL       R0, R1
80007244:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007248:	08 00       	SYNC     SYNC     
8000724a:	01 5d       	POP       R1
8000724c:	00 5d       	POP       R0
8000724e:	20 5d       	PUSH      R0
80007250:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007254:	08 00       	SYNC     SYNC     
80007256:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000725a:	08 00       	SYNC     SYNC     
8000725c:	00 5d       	POP       R0
8000725e:	07 00       	BREAK    BREAK    
80007260:	02 45       	LD        R5, [PC + #2]         ;->0x80007268  :=0x8000911c
80007262:	05 5c       	LJMP      R5
80007264:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80007268:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

8000726c <vTaskSetTimeOutState>:
##@@@F_:vTaskSetTimeOutState():
##@@@P_:tasks.c:5546
##@@@L5541_:    traceRETURN_vTaskRemoveFromUnorderedEventList();   
##@@@L5542_:}   
##@@@L5543_:/*-----------------------------------------------------------*/   
##@@@L5544_:
##@@@L5545_:void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )   
##@@@L5546_:{   
8000726c:	2d 5d       	PUSH      LR
8000726e:	e4 30       	SUB       SP, #4			;->0x04
80007270:	a0 58       	MOV       R5, R0
80007272:	20 5d       	PUSH      R0
80007274:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007278:	08 00       	SYNC     SYNC     
8000727a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000727e:	08 00       	SYNC     SYNC     
80007280:	00 5d       	POP       R0
80007282:	20 5d       	PUSH      R0
80007284:	21 5d       	PUSH      R1
80007286:	17 44       	LD        R4, [PC + #23]        ;->0x800072e0  :=0x1ff
80007288:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000728c:	24 58       	MOV       R1, R4
8000728e:	11 68       	NOT       R1, R1
80007290:	01 69       	ANL       R0, R1
80007292:	4f 11       	MOV       R4, #31			;->0x001F
80007294:	24 58       	MOV       R1, R4
80007296:	01 6a       	ORL       R0, R1
80007298:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000729c:	08 00       	SYNC     SYNC     
8000729e:	01 5d       	POP       R1
800072a0:	00 5d       	POP       R0
##@@@P_:tasks.c:5549
##@@@L5547_:    traceENTER_vTaskSetTimeOutState( pxTimeOut );   
##@@@L5548_:
##@@@L5549_:    configASSERT( pxTimeOut );   
800072a2:	50 38       	CMP       R5, #0			;->0x00
800072a4:	20 5d       	PUSH      R0
800072a6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800072aa:	08 00       	SYNC     SYNC     
800072ac:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800072b0:	08 00       	SYNC     SYNC     
800072b2:	00 5d       	POP       R0
800072b4:	22 f0       	JZ        $+34                  ;->0x800072f8
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6962
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
800072b6:	0c 44       	LD        R4, [PC + #12]        ;->0x800072e4  :=0xd0000064
800072b8:	44 82       	LD.W      R4, [R4]
800072ba:	40 38       	CMP       R4, #0			;->0x00
800072bc:	07 f0       	JZ        $+7                   ;->0x800072ca
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
800072be:	0b 44       	LD        R4, [PC + #11]        ;->0x800072e8  :=0xd0000040
800072c0:	34 82       	LD.W      R3, [R4]
800072c2:	53 9c       	LD.W      R2, [R3 + #17]
800072c4:	52 c0       	ADD       R2, R2, #1
800072c6:	5a a4       	ST.W      [R3 + #17], R2
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
800072c8:	44 82       	LD.W      R4, [R4]
##@@@F_:vTaskSetTimeOutState():
##@@@P_:tasks.c:5552
##@@@L5547_:    traceENTER_vTaskSetTimeOutState( pxTimeOut );   
##@@@L5548_:
##@@@L5549_:    configASSERT( pxTimeOut );   
##@@@L5550_:    taskENTER_CRITICAL();   
##@@@L5551_:    {   
##@@@L5552_:        pxTimeOut->xOverflowCount = xNumOfOverflows;   
800072ca:	09 44       	LD        R4, [PC + #9]         ;->0x800072ec  :=0xd000030c
800072cc:	44 82       	LD.W      R4, [R4]
##@@@P_:tasks.c:5553
##@@@L5553_:        pxTimeOut->xTimeOnEntering = xTickCount;   
800072ce:	09 43       	LD        R3, [PC + #9]         ;->0x800072f0  :=0xd000006c
##@@@P_:tasks.c:5552
##@@@L5547_:    traceENTER_vTaskSetTimeOutState( pxTimeOut );   
##@@@L5548_:
##@@@L5549_:    configASSERT( pxTimeOut );   
##@@@L5550_:    taskENTER_CRITICAL();   
##@@@L5551_:    {   
##@@@L5552_:        pxTimeOut->xOverflowCount = xNumOfOverflows;   
800072d0:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:5553
##@@@L5553_:        pxTimeOut->xTimeOnEntering = xTickCount;   
800072d2:	43 82       	LD.W      R4, [R3]
800072d4:	6c a0       	ST.W      [R5 + #1], R4
##@@@P_:tasks.c:5555
##@@@L5554_:    }   
##@@@L5555_:    taskEXIT_CRITICAL();   
800072d6:	08 45       	LD        R5, [PC + #8]         ;->0x800072f4  :=0x80005730
800072d8:	05 5c       	LJMP      R5
##@@@P_:tasks.c:5558
##@@@L5556_:
##@@@L5557_:    traceRETURN_vTaskSetTimeOutState();   
##@@@L5558_:}   
800072da:	e4 28       	ADD       SP, #4			;->0x04
800072dc:	0d 5d       	POP       LR
800072de:	1d 5c       	JMP       LR
800072e0:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800072e4:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
800072e8:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800072ec:	0c 03 00 d0 	.long     0xd000030c ->-805305588  [!!!@4@:JMP       $+839680              ;->0x801a12ec
800072f0:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
800072f4:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x800072f4
##@@@P_:tasks.c:5549
##@@@L5544_:
##@@@L5545_:void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )   
##@@@L5546_:{   
##@@@L5547_:    traceENTER_vTaskSetTimeOutState( pxTimeOut );   
##@@@L5548_:
##@@@L5549_:    configASSERT( pxTimeOut );   
800072f8:	07 00       	BREAK    BREAK    
800072fa:	02 45       	LD        R5, [PC + #2]         ;->0x80007300  :=0x8000911c
800072fc:	05 5c       	LJMP      R5
800072fe:	00 00       	NOP      NOP      
80007300:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80007304 <vTaskInternalSetTimeOutState>:
##@@@F_:vTaskInternalSetTimeOutState():
##@@@P_:tasks.c:5566
##@@@L5561_:void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )   
##@@@L5562_:{   
##@@@L5563_:    traceENTER_vTaskInternalSetTimeOutState( pxTimeOut );   
##@@@L5564_:
##@@@L5565_:    /* For internal use only as it does not use a critical section. */   
##@@@L5566_:    pxTimeOut->xOverflowCount = xNumOfOverflows;   
80007304:	04 45       	LD        R5, [PC + #4]         ;->0x80007314  :=0xd000030c
80007306:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:5567
##@@@L5567_:    pxTimeOut->xTimeOnEntering = xTickCount;   
80007308:	04 44       	LD        R4, [PC + #4]         ;->0x80007318  :=0xd000006c
##@@@P_:tasks.c:5566
##@@@L5561_:void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )   
##@@@L5562_:{   
##@@@L5563_:    traceENTER_vTaskInternalSetTimeOutState( pxTimeOut );   
##@@@L5564_:
##@@@L5565_:    /* For internal use only as it does not use a critical section. */   
##@@@L5566_:    pxTimeOut->xOverflowCount = xNumOfOverflows;   
8000730a:	05 85       	ST.W      [R0], R5
##@@@P_:tasks.c:5567
##@@@L5567_:    pxTimeOut->xTimeOnEntering = xTickCount;   
8000730c:	54 82       	LD.W      R5, [R4]
8000730e:	45 a0       	ST.W      [R0 + #1], R5
##@@@P_:tasks.c:5570
##@@@L5568_:
##@@@L5569_:    traceRETURN_vTaskInternalSetTimeOutState();   
##@@@L5570_:}   
80007310:	1d 5c       	JMP       LR
80007312:	00 00       	NOP      NOP      
80007314:	0c 03 00 d0 	.long     0xd000030c ->-805305588  [!!!@4@:JMP       $+839680              ;->0x801a1314
80007318:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0

8000731c <xTaskCheckForTimeOut>:
##@@@F_:xTaskCheckForTimeOut():
##@@@P_:tasks.c:5575
##@@@L5571_:/*-----------------------------------------------------------*/   
##@@@L5572_:
##@@@L5573_:BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,   
##@@@L5574_:                                 TickType_t * const pxTicksToWait )   
##@@@L5575_:{   
8000731c:	8f 5f       	PUSH      {R6-R9,LR}
8000731e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:5580
##@@@L5576_:    BaseType_t xReturn;   
##@@@L5577_:
##@@@L5578_:    traceENTER_xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );   
##@@@L5579_:
##@@@L5580_:    configASSERT( pxTimeOut );   
80007320:	00 38       	CMP       R0, #0			;->0x00
80007322:	61 f0       	JZ        $+97                  ;->0x800073e4
80007324:	a0 58       	MOV       R5, R0
80007326:	81 58       	MOV       R4, R1
80007328:	20 5d       	PUSH      R0
8000732a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000732e:	08 00       	SYNC     SYNC     
80007330:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007334:	08 00       	SYNC     SYNC     
80007336:	00 5d       	POP       R0
80007338:	20 5d       	PUSH      R0
8000733a:	21 5d       	PUSH      R1
8000733c:	23 43       	LD        R3, [PC + #35]        ;->0x800073c8  :=0x1ff
8000733e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007342:	23 58       	MOV       R1, R3
80007344:	11 68       	NOT       R1, R1
80007346:	01 69       	ANL       R0, R1
80007348:	3f 11       	MOV       R3, #31			;->0x001F
8000734a:	23 58       	MOV       R1, R3
8000734c:	01 6a       	ORL       R0, R1
8000734e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007352:	08 00       	SYNC     SYNC     
80007354:	01 5d       	POP       R1
80007356:	00 5d       	POP       R0
##@@@P_:tasks.c:5581
##@@@L5581_:    configASSERT( pxTicksToWait );   
80007358:	40 38       	CMP       R4, #0			;->0x00
8000735a:	20 5d       	PUSH      R0
8000735c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007360:	08 00       	SYNC     SYNC     
80007362:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007366:	08 00       	SYNC     SYNC     
80007368:	00 5d       	POP       R0
8000736a:	60 f0       	JZ        $+96                  ;->0x8000742a
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6962
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
8000736c:	18 43       	LD        R3, [PC + #24]        ;->0x800073cc  :=0xd0000064
8000736e:	33 82       	LD.W      R3, [R3]
80007370:	30 38       	CMP       R3, #0			;->0x00
80007372:	07 f0       	JZ        $+7                   ;->0x80007380
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80007374:	17 43       	LD        R3, [PC + #23]        ;->0x800073d0  :=0xd0000040
80007376:	23 82       	LD.W      R2, [R3]
80007378:	4a 9c       	LD.W      R1, [R2 + #17]
8000737a:	49 c0       	ADD       R1, R1, #1
8000737c:	51 a4       	ST.W      [R2 + #17], R1
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
8000737e:	33 82       	LD.W      R3, [R3]
##@@@F_:xTaskCheckForTimeOut():
##@@@P_:tasks.c:5586
##@@@L5581_:    configASSERT( pxTicksToWait );   
##@@@L5582_:
##@@@L5583_:    taskENTER_CRITICAL();   
##@@@L5584_:    {   
##@@@L5585_:        /* Minor optimisation.  The tick count cannot change in this block. */   
##@@@L5586_:        const TickType_t xConstTickCount = xTickCount;   
80007380:	15 43       	LD        R3, [PC + #21]        ;->0x800073d4  :=0xd000006c
80007382:	13 82       	LD.W      R1, [R3]
##@@@P_:tasks.c:5601
##@@@L5596_:            }   
##@@@L5597_:            else   
##@@@L5598_:        #endif   
##@@@L5599_:
##@@@L5600_:        #if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L5601_:            if( *pxTicksToWait == portMAX_DELAY )   
80007384:	24 82       	LD.W      R2, [R4]
80007386:	15 40       	LD        R0, [PC + #21]        ;->0x800073d8  :=0xffffffff
80007388:	60 10       	MOV       R6, #0			;->0x0000
8000738a:	20 70       	CMP       R2, R0
8000738c:	16 f0       	JZ        $+22                  ;->0x800073b8
##@@@P_:tasks.c:5611
##@@@L5606_:                xReturn = pdFALSE;   
##@@@L5607_:            }   
##@@@L5608_:            else   
##@@@L5609_:        #endif   
##@@@L5610_:
##@@@L5611_:        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )   
8000738e:	14 40       	LD        R0, [PC + #20]        ;->0x800073dc  :=0xd000030c
80007390:	7d 98       	LD.W      R7, [R5 + #1]
80007392:	80 82       	LD.W      R8, [R0]
80007394:	95 82       	LD.W      R9, [R5]
80007396:	89 70       	CMP       R8, R9
80007398:	03 f0       	JZ        $+3                   ;->0x8000739e
8000739a:	17 70       	CMP       R1, R7
8000739c:	0c f2       	JC        $+12                  ;->0x800073b4
8000739e:	c9 c7       	SUB       R1, R1, R7
##@@@P_:tasks.c:5621
##@@@L5616_:             * around and gone past again. This passed since vTaskSetTimeout()   
##@@@L5617_:             * was called. */   
##@@@L5618_:            xReturn = pdTRUE;   
##@@@L5619_:            *pxTicksToWait = ( TickType_t ) 0;   
##@@@L5620_:        }   
##@@@L5621_:        else if( xElapsedTime < *pxTicksToWait )   
800073a0:	21 70       	CMP       R2, R1
800073a2:	09 f9       	JLS       $+9                   ;->0x800073b4
##@@@P_:tasks.c:5624
##@@@L5622_:        {   
##@@@L5623_:            /* Not a genuine timeout. Adjust parameters for time remaining. */   
##@@@L5624_:            *pxTicksToWait -= xElapsedTime;   
800073a4:	52 c6       	SUB       R2, R2, R1
800073a6:	42 85       	ST.W      [R4], R2
##@@@F_:vTaskInternalSetTimeOutState():
##@@@P_:tasks.c:5566
##@@@L5561_:void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )   
##@@@L5562_:{   
##@@@L5563_:    traceENTER_vTaskInternalSetTimeOutState( pxTimeOut );   
##@@@L5564_:
##@@@L5565_:    /* For internal use only as it does not use a critical section. */   
##@@@L5566_:    pxTimeOut->xOverflowCount = xNumOfOverflows;   
800073a8:	40 82       	LD.W      R4, [R0]
800073aa:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:5567
##@@@L5567_:    pxTimeOut->xTimeOnEntering = xTickCount;   
800073ac:	43 82       	LD.W      R4, [R3]
800073ae:	6c a0       	ST.W      [R5 + #1], R4
800073b0:	60 10       	MOV       R6, #0			;->0x0000
800073b2:	03 04       	SJMP      $+3                   ;->0x800073b8
##@@@F_:xTaskCheckForTimeOut():
800073b4:	46 85       	ST.W      [R4], R6
800073b6:	61 10       	MOV       R6, #1			;->0x0001
##@@@P_:tasks.c:5634
##@@@L5629_:        {   
##@@@L5630_:            *pxTicksToWait = ( TickType_t ) 0;   
##@@@L5631_:            xReturn = pdTRUE;   
##@@@L5632_:        }   
##@@@L5633_:    }   
##@@@L5634_:    taskEXIT_CRITICAL();   
800073b8:	0a 45       	LD        R5, [PC + #10]        ;->0x800073e0  :=0x80005730
800073ba:	05 5c       	LJMP      R5
##@@@P_:tasks.c:5638
##@@@L5635_:
##@@@L5636_:    traceRETURN_xTaskCheckForTimeOut( xReturn );   
##@@@L5637_:
##@@@L5638_:    return xReturn;   
800073bc:	06 58       	MOV       R0, R6
800073be:	e4 28       	ADD       SP, #4			;->0x04
800073c0:	0f 5e       	POP       {R6-R9}
800073c2:	0d 5d       	POP       LR
800073c4:	1d 5c       	JMP       LR
800073c6:	00 00       	NOP      NOP      
800073c8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800073cc:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
800073d0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800073d4:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
800073d8:	ff ff ff ff 	.long     0xffffffff ->-00000001 
800073dc:	0c 03 00 d0 	.long     0xd000030c ->-805305588  [!!!@4@:JMP       $+839680              ;->0x801a13dc
800073e0:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x800073e0
##@@@P_:tasks.c:5580
##@@@L5575_:{   
##@@@L5576_:    BaseType_t xReturn;   
##@@@L5577_:
##@@@L5578_:    traceENTER_xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );   
##@@@L5579_:
##@@@L5580_:    configASSERT( pxTimeOut );   
800073e4:	20 5d       	PUSH      R0
800073e6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800073ea:	08 00       	SYNC     SYNC     
800073ec:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800073f0:	08 00       	SYNC     SYNC     
800073f2:	00 5d       	POP       R0
800073f4:	20 5d       	PUSH      R0
800073f6:	21 5d       	PUSH      R1
800073f8:	0e 45       	LD        R5, [PC + #14]        ;->0x80007430  :=0x1ff
800073fa:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800073fe:	25 58       	MOV       R1, R5
80007400:	11 68       	NOT       R1, R1
80007402:	01 69       	ANL       R0, R1
80007404:	5f 11       	MOV       R5, #31			;->0x001F
80007406:	25 58       	MOV       R1, R5
80007408:	01 6a       	ORL       R0, R1
8000740a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000740e:	08 00       	SYNC     SYNC     
80007410:	01 5d       	POP       R1
80007412:	00 5d       	POP       R0
80007414:	20 5d       	PUSH      R0
80007416:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000741a:	08 00       	SYNC     SYNC     
8000741c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007420:	08 00       	SYNC     SYNC     
80007422:	00 5d       	POP       R0
80007424:	07 00       	BREAK    BREAK    
80007426:	04 45       	LD        R5, [PC + #4]         ;->0x80007434  :=0x8000911c
80007428:	05 5c       	LJMP      R5
##@@@P_:tasks.c:5581
##@@@L5581_:    configASSERT( pxTicksToWait );   
8000742a:	07 00       	BREAK    BREAK    
8000742c:	02 45       	LD        R5, [PC + #2]         ;->0x80007434  :=0x8000911c
8000742e:	05 5c       	LJMP      R5
80007430:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80007434:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80007438 <vTaskMissedYield>:
##@@@F_:vTaskMissedYield():
##@@@P_:tasks.c:5647
##@@@L5642_:void vTaskMissedYield( void )   
##@@@L5643_:{   
##@@@L5644_:    traceENTER_vTaskMissedYield();   
##@@@L5645_:
##@@@L5646_:    /* Must be called from within a critical section. */   
##@@@L5647_:    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;   
80007438:	02 45       	LD        R5, [PC + #2]         ;->0x80007440  :=0xd00002fc
8000743a:	41 10       	MOV       R4, #1			;->0x0001
8000743c:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:5650
##@@@L5648_:
##@@@L5649_:    traceRETURN_vTaskMissedYield();   
##@@@L5650_:}   
8000743e:	1d 5c       	JMP       LR
80007440:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 

80007444 <uxTaskGetTaskNumber>:
##@@@F_:uxTaskGetTaskNumber():
##@@@P_:tasks.c:5662
##@@@L5657_:        UBaseType_t uxReturn;   
##@@@L5658_:        TCB_t const * pxTCB;   
##@@@L5659_:
##@@@L5660_:        traceENTER_uxTaskGetTaskNumber( xTask );   
##@@@L5661_:
##@@@L5662_:        if( xTask != NULL )   
80007444:	00 38       	CMP       R0, #0			;->0x00
80007446:	03 f0       	JZ        $+3                   ;->0x8000744c
##@@@P_:tasks.c:5665
##@@@L5663_:        {   
##@@@L5664_:            pxTCB = xTask;   
##@@@L5665_:            uxReturn = pxTCB->uxTaskNumber;   
80007448:	c0 9c       	LD.W      R0, [R0 + #19]
##@@@P_:tasks.c:5674
##@@@L5669_:            uxReturn = 0U;   
##@@@L5670_:        }   
##@@@L5671_:
##@@@L5672_:        traceRETURN_uxTaskGetTaskNumber( uxReturn );   
##@@@L5673_:
##@@@L5674_:        return uxReturn;   
8000744a:	1d 5c       	JMP       LR
8000744c:	00 10       	MOV       R0, #0			;->0x0000
8000744e:	1d 5c       	JMP       LR

80007450 <vTaskSetTaskNumber>:
##@@@F_:vTaskSetTaskNumber():
##@@@P_:tasks.c:5689
##@@@L5684_:    {   
##@@@L5685_:        TCB_t * pxTCB;   
##@@@L5686_:
##@@@L5687_:        traceENTER_vTaskSetTaskNumber( xTask, uxHandle );   
##@@@L5688_:
##@@@L5689_:        if( xTask != NULL )   
80007450:	00 38       	CMP       R0, #0			;->0x00
80007452:	02 f0       	JZ        $+2                   ;->0x80007456
##@@@P_:tasks.c:5692
##@@@L5690_:        {   
##@@@L5691_:            pxTCB = xTask;   
##@@@L5692_:            pxTCB->uxTaskNumber = uxHandle;   
80007454:	c1 a4       	ST.W      [R0 + #19], R1
##@@@P_:tasks.c:5696
##@@@L5693_:        }   
##@@@L5694_:
##@@@L5695_:        traceRETURN_vTaskSetTaskNumber();   
##@@@L5696_:    }   
80007456:	1d 5c       	JMP       LR

80007458 <vTaskSetThreadLocalStoragePointer>:
##@@@F_:vTaskSetThreadLocalStoragePointer():
##@@@P_:tasks.c:5981
##@@@L5976_:#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )   
##@@@L5977_:
##@@@L5978_:    void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,   
##@@@L5979_:                                            BaseType_t xIndex,   
##@@@L5980_:                                            void * pvValue )   
##@@@L5981_:    {   
80007458:	2d 5d       	PUSH      LR
8000745a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:5986
##@@@L5982_:        TCB_t * pxTCB;   
##@@@L5983_:
##@@@L5984_:        traceENTER_vTaskSetThreadLocalStoragePointer( xTaskToSet, xIndex, pvValue );   
##@@@L5985_:
##@@@L5986_:        if( ( xIndex >= 0 ) &&   
8000745c:	14 38       	CMP       R1, #4			;->0x04
8000745e:	0a f8       	JHI       $+10                  ;->0x80007472
##@@@P_:tasks.c:5989
##@@@L5987_:            ( xIndex < ( BaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )   
##@@@L5988_:        {   
##@@@L5989_:            pxTCB = prvGetTCBFromHandle( xTaskToSet );   
80007460:	00 38       	CMP       R0, #0			;->0x00
80007462:	05 f1       	JNZ       $+5                   ;->0x8000746c
80007464:	05 45       	LD        R5, [PC + #5]         ;->0x80007478  :=0xd0000040
80007466:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:5990
##@@@L5990_:            configASSERT( pxTCB != NULL );   
80007468:	00 38       	CMP       R0, #0			;->0x00
8000746a:	09 f0       	JZ        $+9                   ;->0x8000747c
##@@@P_:tasks.c:5991
##@@@L5991_:            pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;   
8000746c:	0a 7a       	LSL       R1, #2			;->0x02
8000746e:	68 c2       	ADD       R5, R0, R1
80007470:	aa a5       	ST.W      [R5 + #22], R2
##@@@P_:tasks.c:5995
##@@@L5992_:        }   
##@@@L5993_:
##@@@L5994_:        traceRETURN_vTaskSetThreadLocalStoragePointer();   
##@@@L5995_:    }   
80007472:	e4 28       	ADD       SP, #4			;->0x04
80007474:	0d 5d       	POP       LR
80007476:	1d 5c       	JMP       LR
80007478:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
##@@@P_:tasks.c:5990
##@@@L5985_:
##@@@L5986_:        if( ( xIndex >= 0 ) &&   
##@@@L5987_:            ( xIndex < ( BaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )   
##@@@L5988_:        {   
##@@@L5989_:            pxTCB = prvGetTCBFromHandle( xTaskToSet );   
##@@@L5990_:            configASSERT( pxTCB != NULL );   
8000747c:	20 5d       	PUSH      R0
8000747e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007482:	08 00       	SYNC     SYNC     
80007484:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007488:	08 00       	SYNC     SYNC     
8000748a:	00 5d       	POP       R0
8000748c:	20 5d       	PUSH      R0
8000748e:	21 5d       	PUSH      R1
80007490:	0d 45       	LD        R5, [PC + #13]        ;->0x800074c4  :=0x1ff
80007492:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007496:	25 58       	MOV       R1, R5
80007498:	11 68       	NOT       R1, R1
8000749a:	01 69       	ANL       R0, R1
8000749c:	5f 11       	MOV       R5, #31			;->0x001F
8000749e:	25 58       	MOV       R1, R5
800074a0:	01 6a       	ORL       R0, R1
800074a2:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800074a6:	08 00       	SYNC     SYNC     
800074a8:	01 5d       	POP       R1
800074aa:	00 5d       	POP       R0
800074ac:	20 5d       	PUSH      R0
800074ae:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800074b2:	08 00       	SYNC     SYNC     
800074b4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800074b8:	08 00       	SYNC     SYNC     
800074ba:	00 5d       	POP       R0
800074bc:	07 00       	BREAK    BREAK    
800074be:	03 45       	LD        R5, [PC + #3]         ;->0x800074c8  :=0x8000911c
800074c0:	05 5c       	LJMP      R5
800074c2:	00 00       	NOP      NOP      
800074c4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800074c8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800074cc <pvTaskGetThreadLocalStoragePointer>:
##@@@F_:pvTaskGetThreadLocalStoragePointer():
##@@@P_:tasks.c:6010
##@@@L6005_:        void * pvReturn = NULL;   
##@@@L6006_:        TCB_t * pxTCB;   
##@@@L6007_:
##@@@L6008_:        traceENTER_pvTaskGetThreadLocalStoragePointer( xTaskToQuery, xIndex );   
##@@@L6009_:
##@@@L6010_:        if( ( xIndex >= 0 ) &&   
800074cc:	14 38       	CMP       R1, #4			;->0x04
800074ce:	0b f8       	JHI       $+11                  ;->0x800074e4
##@@@P_:tasks.c:6013
##@@@L6011_:            ( xIndex < ( BaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )   
##@@@L6012_:        {   
##@@@L6013_:            pxTCB = prvGetTCBFromHandle( xTaskToQuery );   
800074d0:	00 38       	CMP       R0, #0			;->0x00
800074d2:	03 f1       	JNZ       $+3                   ;->0x800074d8
800074d4:	03 45       	LD        R5, [PC + #3]         ;->0x800074e0  :=0xd0000040
800074d6:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:6014
##@@@L6014_:            pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];   
800074d8:	0a 7a       	LSL       R1, #2			;->0x02
800074da:	68 c2       	ADD       R5, R0, R1
800074dc:	85 9d       	LD.W      R0, [R5 + #22]
##@@@P_:tasks.c:6023
##@@@L6018_:            pvReturn = NULL;   
##@@@L6019_:        }   
##@@@L6020_:
##@@@L6021_:        traceRETURN_pvTaskGetThreadLocalStoragePointer( pvReturn );   
##@@@L6022_:
##@@@L6023_:        return pvReturn;   
800074de:	1d 5c       	JMP       LR
800074e0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800074e4:	00 10       	MOV       R0, #0			;->0x0000
800074e6:	1d 5c       	JMP       LR

800074e8 <vTaskGetInfo>:
##@@@F_:vTaskGetInfo():
##@@@P_:tasks.c:6164
##@@@L6159_:
##@@@L6160_:    void vTaskGetInfo( TaskHandle_t xTask,   
##@@@L6161_:                       TaskStatus_t * pxTaskStatus,   
##@@@L6162_:                       BaseType_t xGetFreeStackSpace,   
##@@@L6163_:                       eTaskState eState )   
##@@@L6164_:    {   
800074e8:	87 5f       	PUSH      {R6-R8,LR}
800074ea:	e8 30       	SUB       SP, #8			;->0x08
800074ec:	e0 58       	MOV       R7, R0
##@@@P_:tasks.c:6170
##@@@L6165_:        TCB_t * pxTCB;   
##@@@L6166_:
##@@@L6167_:        traceENTER_vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );   
##@@@L6168_:
##@@@L6169_:        /* xTask is NULL then get the state of the calling task. */   
##@@@L6170_:        pxTCB = prvGetTCBFromHandle( xTask );   
800074ee:	00 38       	CMP       R0, #0			;->0x00
800074f0:	02 59       	MOV       R8, R2
800074f2:	c1 58       	MOV       R6, R1
800074f4:	03 f1       	JNZ       $+3                   ;->0x800074fa
800074f6:	3f 45       	LD        R5, [PC + #63]        ;->0x800075f0  :=0xd0000040
800074f8:	75 82       	LD.W      R7, [R5]
##@@@P_:tasks.c:6173
##@@@L6171_:
##@@@L6172_:        pxTaskStatus->xHandle = pxTCB;   
##@@@L6173_:        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );   
800074fa:	a7 58       	MOV       R5, R7
800074fc:	54 2b       	ADD       R5, #52			;->0x34
800074fe:	75 a0       	ST.W      [R6 + #1], R5
##@@@P_:tasks.c:6172
##@@@L6167_:        traceENTER_vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );   
##@@@L6168_:
##@@@L6169_:        /* xTask is NULL then get the state of the calling task. */   
##@@@L6170_:        pxTCB = prvGetTCBFromHandle( xTask );   
##@@@L6171_:
##@@@L6172_:        pxTaskStatus->xHandle = pxTCB;   
80007500:	67 85       	ST.W      [R6], R7
##@@@P_:tasks.c:6174
##@@@L6173_:        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );   
##@@@L6174_:        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;   
80007502:	ef 9a       	LD.W      R5, [R7 + #11]
80007504:	35 a1       	ST.W      [R6 + #4], R5
##@@@P_:tasks.c:6175
##@@@L6175_:        pxTaskStatus->pxStackBase = pxTCB->pxStack;   
80007506:	2f 9b       	LD.W      R5, [R7 + #12]
80007508:	f5 a1       	ST.W      [R6 + #7], R5
##@@@P_:tasks.c:6180
##@@@L6176_:        #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )   
##@@@L6177_:            pxTaskStatus->pxTopOfStack = ( StackType_t * ) pxTCB->pxTopOfStack;   
##@@@L6178_:            pxTaskStatus->pxEndOfStack = pxTCB->pxEndOfStack;   
##@@@L6179_:        #endif   
##@@@L6180_:        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;   
8000750a:	af 9c       	LD.W      R5, [R7 + #18]
8000750c:	b5 a0       	ST.W      [R6 + #2], R5
##@@@P_:tasks.c:6190
##@@@L6185_:        }   
##@@@L6186_:        #endif   
##@@@L6187_:
##@@@L6188_:        #if ( configUSE_MUTEXES == 1 )   
##@@@L6189_:        {   
##@@@L6190_:            pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;   
8000750e:	2f 9d       	LD.W      R5, [R7 + #20]
80007510:	75 a1       	ST.W      [R6 + #5], R5
##@@@P_:tasks.c:6200
##@@@L6195_:        }   
##@@@L6196_:        #endif   
##@@@L6197_:
##@@@L6198_:        #if ( configGENERATE_RUN_TIME_STATS == 1 )   
##@@@L6199_:        {   
##@@@L6200_:            pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;   
80007512:	ef 9e       	LD.W      R5, [R7 + #27]
##@@@P_:tasks.c:6211
##@@@L6206_:        #endif   
##@@@L6207_:
##@@@L6208_:        /* Obtaining the task state is a little fiddly, so is only done if the   
##@@@L6209_:         * value of eState passed into this function is eInvalid - otherwise the   
##@@@L6210_:         * state is just set to whatever is passed in. */   
##@@@L6211_:        if( eState != eInvalid )   
80007514:	35 38       	CMP       R3, #5			;->0x05
##@@@P_:tasks.c:6200
##@@@L6195_:        }   
##@@@L6196_:        #endif   
##@@@L6197_:
##@@@L6198_:        #if ( configGENERATE_RUN_TIME_STATS == 1 )   
##@@@L6199_:        {   
##@@@L6200_:            pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;   
80007516:	b5 a1       	ST.W      [R6 + #6], R5
##@@@P_:tasks.c:6211
##@@@L6206_:        #endif   
##@@@L6207_:
##@@@L6208_:        /* Obtaining the task state is a little fiddly, so is only done if the   
##@@@L6209_:         * value of eState passed into this function is eInvalid - otherwise the   
##@@@L6210_:         * state is just set to whatever is passed in. */   
##@@@L6211_:        if( eState != eInvalid )   
80007518:	08 f1       	JNZ       $+8                   ;->0x80007528
##@@@P_:tasks.c:6273
##@@@L6268_:                taskEXIT_CRITICAL();   
##@@@L6269_:            }   
##@@@L6270_:        }   
##@@@L6271_:        else   
##@@@L6272_:        {   
##@@@L6273_:            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );   
8000751a:	07 58       	MOV       R0, R7
8000751c:	36 45       	LD        R5, [PC + #54]        ;->0x800075f4  :=0x80005d70
8000751e:	05 5c       	LJMP      R5
80007520:	f0 a0       	ST.W      [R6 + #3], R0
##@@@P_:tasks.c:6278
##@@@L6274_:        }   
##@@@L6275_:
##@@@L6276_:        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace   
##@@@L6277_:         * parameter is provided to allow it to be skipped. */   
##@@@L6278_:        if( xGetFreeStackSpace != pdFALSE )   
80007522:	80 38       	CMP       R8, #0			;->0x00
80007524:	52 f1       	JNZ       $+82                  ;->0x800075c8
80007526:	5e 04       	SJMP      $+94                  ;->0x800075e2
##@@@P_:tasks.c:6213
##@@@L6208_:        /* Obtaining the task state is a little fiddly, so is only done if the   
##@@@L6209_:         * value of eState passed into this function is eInvalid - otherwise the   
##@@@L6210_:         * state is just set to whatever is passed in. */   
##@@@L6211_:        if( eState != eInvalid )   
##@@@L6212_:        {   
##@@@L6213_:            if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )   
80007528:	32 42       	LD        R2, [PC + #50]        ;->0x800075f0  :=0xd0000040
8000752a:	52 82       	LD.W      R5, [R2]
8000752c:	75 70       	CMP       R7, R5
8000752e:	49 f0       	JZ        $+73                  ;->0x800075c0
##@@@P_:tasks.c:6226
##@@@L6221_:                #if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L6222_:                {   
##@@@L6223_:                    /* If the task is in the suspended list then there is a   
##@@@L6224_:                     *  chance it is actually just blocked indefinitely - so really   
##@@@L6225_:                     *  it should be reported as being in the Blocked state. */   
##@@@L6226_:                    if( eState == eSuspended )   
80007530:	33 38       	CMP       R3, #3			;->0x03
##@@@P_:tasks.c:6219
##@@@L6214_:            {   
##@@@L6215_:                pxTaskStatus->eCurrentState = eRunning;   
##@@@L6216_:            }   
##@@@L6217_:            else   
##@@@L6218_:            {   
##@@@L6219_:                pxTaskStatus->eCurrentState = eState;   
80007532:	f3 a0       	ST.W      [R6 + #3], R3
##@@@P_:tasks.c:6226
##@@@L6221_:                #if ( INCLUDE_vTaskSuspend == 1 )   
##@@@L6222_:                {   
##@@@L6223_:                    /* If the task is in the suspended list then there is a   
##@@@L6224_:                     *  chance it is actually just blocked indefinitely - so really   
##@@@L6225_:                     *  it should be reported as being in the Blocked state. */   
##@@@L6226_:                    if( eState == eSuspended )   
80007534:	12 f1       	JNZ       $+18                  ;->0x80007558
80007536:	01 22       	ST.W      [SP + #1], R2
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
80007538:	30 45       	LD        R5, [PC + #48]        ;->0x800075f8  :=0xd0000068
8000753a:	45 82       	LD.W      R4, [R5]
8000753c:	64 c0       	ADD       R4, R4, #1
8000753e:	54 85       	ST.W      [R5], R4
##@@@F_:vTaskGetInfo():
##@@@P_:tasks.c:6230
##@@@L6225_:                     *  it should be reported as being in the Blocked state. */   
##@@@L6226_:                    if( eState == eSuspended )   
##@@@L6227_:                    {   
##@@@L6228_:                        vTaskSuspendAll();   
##@@@L6229_:                        {   
##@@@L6230_:                            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )   
80007540:	af 9a       	LD.W      R5, [R7 + #10]
80007542:	50 38       	CMP       R5, #0			;->0x00
80007544:	05 f1       	JNZ       $+5                   ;->0x8000754e
80007546:	51 00 e5 d0 	LD.B      R5, [R7 + #116]			;->0x74
##@@@P_:tasks.c:6245
##@@@L6240_:                                 * blocked state if it is waiting on its notification   
##@@@L6241_:                                 * rather than waiting on an object.  If not, is   
##@@@L6242_:                                 * suspended. */   
##@@@L6243_:                                for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )   
##@@@L6244_:                                {   
##@@@L6245_:                                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )   
8000754a:	51 38       	CMP       R5, #1			;->0x01
8000754c:	03 f1       	JNZ       $+3                   ;->0x80007552
8000754e:	52 10       	MOV       R5, #2			;->0x0002
80007550:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:tasks.c:6253
##@@@L6248_:                                        break;   
##@@@L6249_:                                    }   
##@@@L6250_:                                }   
##@@@L6251_:                            }   
##@@@L6252_:                        }   
##@@@L6253_:                        ( void ) xTaskResumeAll();   
80007552:	2b 45       	LD        R5, [PC + #43]        ;->0x800075fc  :=0x80005a70
80007554:	05 5c       	LJMP      R5
80007556:	01 0a       	LD.W      R2, [SP + #1]
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80007558:	20 5d       	PUSH      R0
8000755a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000755e:	08 00       	SYNC     SYNC     
80007560:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007564:	08 00       	SYNC     SYNC     
80007566:	00 5d       	POP       R0
80007568:	20 5d       	PUSH      R0
8000756a:	21 5d       	PUSH      R1
8000756c:	25 45       	LD        R5, [PC + #37]        ;->0x80007600  :=0x1ff
8000756e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007572:	25 58       	MOV       R1, R5
80007574:	11 68       	NOT       R1, R1
80007576:	01 69       	ANL       R0, R1
80007578:	5f 11       	MOV       R5, #31			;->0x001F
8000757a:	25 58       	MOV       R1, R5
8000757c:	01 6a       	ORL       R0, R1
8000757e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007582:	08 00       	SYNC     SYNC     
80007584:	01 5d       	POP       R1
80007586:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80007588:	1f 45       	LD        R5, [PC + #31]        ;->0x80007604  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
8000758a:	20 5d       	PUSH      R0
8000758c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007590:	08 00       	SYNC     SYNC     
80007592:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007596:	08 00       	SYNC     SYNC     
80007598:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
8000759a:	55 82       	LD.W      R5, [R5]
8000759c:	50 38       	CMP       R5, #0			;->0x00
8000759e:	06 f0       	JZ        $+6                   ;->0x800075aa
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
800075a0:	52 82       	LD.W      R5, [R2]
800075a2:	65 9c       	LD.W      R4, [R5 + #17]
800075a4:	64 c0       	ADD       R4, R4, #1
800075a6:	6c a4       	ST.W      [R5 + #17], R4
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
800075a8:	52 82       	LD.W      R5, [R2]
##@@@F_:vTaskGetInfo():
##@@@P_:tasks.c:6263
##@@@L6258_:                /* Tasks can be in pending ready list and other state list at the   
##@@@L6259_:                 * same time. These tasks are in ready state no matter what state   
##@@@L6260_:                 * list the task is in. */   
##@@@L6261_:                taskENTER_CRITICAL();   
##@@@L6262_:                {   
##@@@L6263_:                    if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdFALSE )   
800075aa:	af 9a       	LD.W      R5, [R7 + #10]
800075ac:	17 44       	LD        R4, [PC + #23]        ;->0x80007608  :=0xd0000078
800075ae:	54 70       	CMP       R5, R4
800075b0:	03 f1       	JNZ       $+3                   ;->0x800075b6
800075b2:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:tasks.c:6265
##@@@L6264_:                    {   
##@@@L6265_:                        pxTaskStatus->eCurrentState = eReady;   
800075b4:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:tasks.c:6268
##@@@L6266_:                    }   
##@@@L6267_:                }   
##@@@L6268_:                taskEXIT_CRITICAL();   
800075b6:	16 45       	LD        R5, [PC + #22]        ;->0x8000760c  :=0x80005730
800075b8:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6278
##@@@L6273_:            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );   
##@@@L6274_:        }   
##@@@L6275_:
##@@@L6276_:        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace   
##@@@L6277_:         * parameter is provided to allow it to be skipped. */   
##@@@L6278_:        if( xGetFreeStackSpace != pdFALSE )   
800075ba:	80 38       	CMP       R8, #0			;->0x00
800075bc:	06 f1       	JNZ       $+6                   ;->0x800075c8
800075be:	12 04       	SJMP      $+18                  ;->0x800075e2
800075c0:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:tasks.c:6215
##@@@L6210_:         * state is just set to whatever is passed in. */   
##@@@L6211_:        if( eState != eInvalid )   
##@@@L6212_:        {   
##@@@L6213_:            if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )   
##@@@L6214_:            {   
##@@@L6215_:                pxTaskStatus->eCurrentState = eRunning;   
800075c2:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:tasks.c:6278
##@@@L6273_:            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );   
##@@@L6274_:        }   
##@@@L6275_:
##@@@L6276_:        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace   
##@@@L6277_:         * parameter is provided to allow it to be skipped. */   
##@@@L6278_:        if( xGetFreeStackSpace != pdFALSE )   
800075c4:	80 38       	CMP       R8, #0			;->0x00
800075c6:	0e f0       	JZ        $+14                  ;->0x800075e2
##@@@P_:tasks.c:6286
##@@@L6281_:            {   
##@@@L6282_:                pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );   
##@@@L6283_:            }   
##@@@L6284_:            #else   
##@@@L6285_:            {   
##@@@L6286_:                pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );   
800075c8:	1f 9b       	LD.W      R3, [R7 + #12]
##@@@F_:prvTaskCheckFreeStackSpace():
##@@@P_:tasks.c:6349
##@@@L6344_:
##@@@L6345_:    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )   
##@@@L6346_:    {   
##@@@L6347_:        uint32_t ulCount = 0U;   
##@@@L6348_:
##@@@L6349_:        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )   
800075ca:	53 80       	LD.B      R5, [R3]
800075cc:	45 1a       	MOV       R4, #165			;->0x00A5
800075ce:	54 70       	CMP       R5, R4
800075d0:	09 f1       	JNZ       $+9                   ;->0x800075e2
800075d2:	50 10       	MOV       R5, #0			;->0x0000
800075d4:	5b c0       	ADD       R3, R3, #1
800075d6:	53 e5       	LD.B      R2, [R3 + R5]
##@@@P_:tasks.c:6352
##@@@L6350_:        {   
##@@@L6351_:            pucStackByte -= portSTACK_GROWTH;   
##@@@L6352_:            ulCount++;   
800075d8:	6d c0       	ADD       R5, R5, #1
##@@@P_:tasks.c:6349
##@@@L6344_:
##@@@L6345_:    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )   
##@@@L6346_:    {   
##@@@L6347_:        uint32_t ulCount = 0U;   
##@@@L6348_:
##@@@L6349_:        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )   
800075da:	24 70       	CMP       R2, R4
800075dc:	fd f0       	JZ        $-3                   ;->0x800075d6
##@@@P_:tasks.c:6355
##@@@L6350_:        {   
##@@@L6351_:            pucStackByte -= portSTACK_GROWTH;   
##@@@L6352_:            ulCount++;   
##@@@L6353_:        }   
##@@@L6354_:
##@@@L6355_:        ulCount /= ( uint32_t ) sizeof( StackType_t );   
800075de:	2a 7c       	LSR       R5, #2			;->0x02
800075e0:	02 04       	SJMP      $+2                   ;->0x800075e4
##@@@F_:vTaskGetInfo():
800075e2:	50 10       	MOV       R5, #0			;->0x0000
800075e4:	35 b4       	ST.H      [R6 + #16], R5
##@@@P_:tasks.c:6296
##@@@L6291_:        {   
##@@@L6292_:            pxTaskStatus->usStackHighWaterMark = 0;   
##@@@L6293_:        }   
##@@@L6294_:
##@@@L6295_:        traceRETURN_vTaskGetInfo();   
##@@@L6296_:    }   
800075e6:	e8 28       	ADD       SP, #8			;->0x08
800075e8:	07 5e       	POP       {R6-R8}
800075ea:	0d 5d       	POP       LR
800075ec:	1d 5c       	JMP       LR
800075ee:	00 00       	NOP      NOP      
800075f0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800075f4:	70 5d 00 80 	.long     0x80005d70 ->-2147459728 
800075f8:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800075fc:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80007600:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80007604:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80007608:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
8000760c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x8000760c

80007610 <xTaskGetCurrentTaskHandle>:
##@@@F_:xTaskGetCurrentTaskHandle():
##@@@P_:tasks.c:6527
##@@@L6522_:            traceENTER_xTaskGetCurrentTaskHandle();   
##@@@L6523_:
##@@@L6524_:            /* A critical section is not required as this is not called from   
##@@@L6525_:             * an interrupt and the current TCB will always be the same for any   
##@@@L6526_:             * individual execution thread. */   
##@@@L6527_:            xReturn = pxCurrentTCB;   
80007610:	02 45       	LD        R5, [PC + #2]         ;->0x80007618  :=0xd0000040
80007612:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:6531
##@@@L6528_:
##@@@L6529_:            traceRETURN_xTaskGetCurrentTaskHandle( xReturn );   
##@@@L6530_:
##@@@L6531_:            return xReturn;   
80007614:	1d 5c       	JMP       LR
80007616:	00 00       	NOP      NOP      
80007618:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]

8000761c <xTaskPriorityInherit>:
##@@@F_:xTaskPriorityInherit():
##@@@P_:tasks.c:6615
##@@@L6610_:/*-----------------------------------------------------------*/   
##@@@L6611_:
##@@@L6612_:#if ( configUSE_MUTEXES == 1 )   
##@@@L6613_:
##@@@L6614_:    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )   
##@@@L6615_:    {   
8000761c:	83 5f       	PUSH      {R6-R7,LR}
8000761e:	e0 31       	SUB       SP, #16			;->0x10
80007620:	c0 58       	MOV       R6, R0
80007622:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:tasks.c:6623
##@@@L6618_:
##@@@L6619_:        traceENTER_xTaskPriorityInherit( pxMutexHolder );   
##@@@L6620_:
##@@@L6621_:        /* If the mutex is taken by an interrupt, the mutex holder is NULL. Priority   
##@@@L6622_:         * inheritance is not applied in this scenario. */   
##@@@L6623_:        if( pxMutexHolder != NULL )   
80007624:	60 38       	CMP       R6, #0			;->0x00
80007626:	42 f0       	JZ        $+66                  ;->0x800076aa
##@@@P_:tasks.c:6628
##@@@L6624_:        {   
##@@@L6625_:            /* If the holder of the mutex has a priority below the priority of   
##@@@L6626_:             * the task attempting to obtain the mutex then it will temporarily   
##@@@L6627_:             * inherit the priority of the task attempting to obtain the mutex. */   
##@@@L6628_:            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )   
80007628:	23 47       	LD        R7, [PC + #35]        ;->0x800076b4  :=0xd0000040
8000762a:	ee 9a       	LD.W      R5, [R6 + #11]
8000762c:	47 82       	LD.W      R4, [R7]
8000762e:	e4 9a       	LD.W      R4, [R4 + #11]
80007630:	54 70       	CMP       R5, R4
80007632:	15 f2       	JC        $+21                  ;->0x8000765c
##@@@P_:tasks.c:6633
##@@@L6629_:            {   
##@@@L6630_:                /* Adjust the mutex holder state to account for its new   
##@@@L6631_:                 * priority.  Only reset the event list item value if the value is   
##@@@L6632_:                 * not being used for anything else. */   
##@@@L6633_:                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0UL ) )   
80007634:	a6 99       	LD.W      R4, [R6 + #6]
80007636:	40 38       	CMP       R4, #0			;->0x00
80007638:	06 fb       	JLT       $+6                   ;->0x80007644
##@@@P_:tasks.c:6635
##@@@L6634_:                {   
##@@@L6635_:                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority );   
8000763a:	47 82       	LD.W      R4, [R7]
8000763c:	e4 9a       	LD.W      R4, [R4 + #11]
8000763e:	3e 11       	MOV       R3, #30			;->0x001E
80007640:	23 c7       	SUB       R4, R3, R4
80007642:	b4 a1       	ST.W      [R6 + #6], R4
##@@@P_:tasks.c:6644
##@@@L6639_:                    mtCOVERAGE_TEST_MARKER();   
##@@@L6640_:                }   
##@@@L6641_:
##@@@L6642_:                /* If the task being modified is in the ready state it will need   
##@@@L6643_:                 * to be moved into a new list. */   
##@@@L6644_:                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )   
80007644:	1d 42       	LD        R2, [PC + #29]        ;->0x800076b8  :=0xd00000a0
80007646:	14 11       	MOV       R1, #20			;->0x0014
80007648:	82 58       	MOV       R4, R2
8000764a:	5e 99       	LD.W      R3, [R6 + #5]
8000764c:	19 00 a1 10 	MADD32    R4, R5, R1
80007650:	34 70       	CMP       R3, R4
80007652:	0b f0       	JZ        $+11                  ;->0x80007668
##@@@P_:tasks.c:6675
##@@@L6670_:                    #endif /* if ( configNUMBER_OF_CORES > 1 ) */   
##@@@L6671_:                }   
##@@@L6672_:                else   
##@@@L6673_:                {   
##@@@L6674_:                    /* Just inherit the priority. */   
##@@@L6675_:                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;   
80007654:	57 82       	LD.W      R5, [R7]
80007656:	ed 9a       	LD.W      R5, [R5 + #11]
80007658:	f5 a2       	ST.W      [R6 + #11], R5
8000765a:	27 04       	SJMP      $+39                  ;->0x800076a8
##@@@P_:tasks.c:6685
##@@@L6680_:                /* Inheritance occurred. */   
##@@@L6681_:                xReturn = pdTRUE;   
##@@@L6682_:            }   
##@@@L6683_:            else   
##@@@L6684_:            {   
##@@@L6685_:                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )   
8000765c:	2e 9d       	LD.W      R5, [R6 + #20]
8000765e:	47 82       	LD.W      R4, [R7]
80007660:	e4 9a       	LD.W      R4, [R4 + #11]
80007662:	54 70       	CMP       R5, R4
80007664:	22 f3       	JNC       $+34                  ;->0x800076a8
80007666:	22 04       	SJMP      $+34                  ;->0x800076aa
80007668:	02 21       	ST.W      [SP + #2], R1
8000766a:	03 22       	ST.W      [SP + #3], R2
8000766c:	06 c1       	ADD       R0, R6, #4
8000766e:	01 20       	ST.W      [SP + #1], R0
##@@@P_:tasks.c:6646
##@@@L6641_:
##@@@L6642_:                /* If the task being modified is in the ready state it will need   
##@@@L6643_:                 * to be moved into a new list. */   
##@@@L6644_:                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )   
##@@@L6645_:                {   
##@@@L6646_:                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
80007670:	13 45       	LD        R5, [PC + #19]        ;->0x800076bc  :=0x80002290
80007672:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6659
##@@@L6654_:                    {   
##@@@L6655_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L6656_:                    }   
##@@@L6657_:
##@@@L6658_:                    /* Inherit the priority before being moved into the new list. */   
##@@@L6659_:                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;   
80007674:	57 82       	LD.W      R5, [R7]
80007676:	ed 9a       	LD.W      R5, [R5 + #11]
##@@@P_:tasks.c:6660
##@@@L6660_:                    prvAddTaskToReadyList( pxMutexHolderTCB );   
80007678:	12 44       	LD        R4, [PC + #18]        ;->0x800076c0  :=0xd00002f8
##@@@P_:tasks.c:6659
##@@@L6654_:                    {   
##@@@L6655_:                        mtCOVERAGE_TEST_MARKER();   
##@@@L6656_:                    }   
##@@@L6657_:
##@@@L6658_:                    /* Inherit the priority before being moved into the new list. */   
##@@@L6659_:                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;   
8000767a:	f5 a2       	ST.W      [R6 + #11], R5
##@@@P_:tasks.c:6660
##@@@L6660_:                    prvAddTaskToReadyList( pxMutexHolderTCB );   
8000767c:	34 82       	LD.W      R3, [R4]
8000767e:	53 70       	CMP       R5, R3
80007680:	02 f9       	JLS       $+2                   ;->0x80007684
80007682:	45 85       	ST.W      [R4], R5
80007684:	03 09       	LD.W      R1, [SP + #3]
80007686:	81 58       	MOV       R4, R1
80007688:	02 08       	LD.W      R0, [SP + #2]
8000768a:	19 00 a0 10 	MADD32    R4, R5, R0
8000768e:	5c 98       	LD.W      R3, [R4 + #1]
80007690:	b3 a0       	ST.W      [R6 + #2], R3
80007692:	93 98       	LD.W      R2, [R3 + #2]
80007694:	f2 a0       	ST.W      [R6 + #3], R2
80007696:	93 98       	LD.W      R2, [R3 + #2]
80007698:	01 0f       	LD.W      R7, [SP + #1]
8000769a:	57 a0       	ST.W      [R2 + #1], R7
8000769c:	9f a0       	ST.W      [R3 + #2], R7
8000769e:	74 a1       	ST.W      [R6 + #5], R4
800076a0:	2d ca       	MULS      R5, R5, R0
800076a2:	61 e9       	LD.W      R4, [R1 + R5]
800076a4:	64 c0       	ADD       R4, R4, #1
800076a6:	4c ef       	ST.W      [R1 + R5], R4
800076a8:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:tasks.c:6709
##@@@L6704_:            mtCOVERAGE_TEST_MARKER();   
##@@@L6705_:        }   
##@@@L6706_:
##@@@L6707_:        traceRETURN_xTaskPriorityInherit( xReturn );   
##@@@L6708_:
##@@@L6709_:        return xReturn;   
800076aa:	e0 29       	ADD       SP, #16			;->0x10
800076ac:	03 5e       	POP       {R6-R7}
800076ae:	0d 5d       	POP       LR
800076b0:	1d 5c       	JMP       LR
800076b2:	00 00       	NOP      NOP      
800076b4:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800076b8:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
800076bc:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
800076c0:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 

800076c4 <xTaskPriorityDisinherit>:
##@@@F_:xTaskPriorityDisinherit():
##@@@P_:tasks.c:6718
##@@@L6713_:/*-----------------------------------------------------------*/   
##@@@L6714_:
##@@@L6715_:#if ( configUSE_MUTEXES == 1 )   
##@@@L6716_:
##@@@L6717_:    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )   
##@@@L6718_:    {   
800076c4:	83 5f       	PUSH      {R6-R7,LR}
800076c6:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:6724
##@@@L6719_:        TCB_t * const pxTCB = pxMutexHolder;   
##@@@L6720_:        BaseType_t xReturn = pdFALSE;   
##@@@L6721_:
##@@@L6722_:        traceENTER_xTaskPriorityDisinherit( pxMutexHolder );   
##@@@L6723_:
##@@@L6724_:        if( pxMutexHolder != NULL )   
800076c8:	00 38       	CMP       R0, #0			;->0x00
800076ca:	33 f0       	JZ        $+51                  ;->0x80007730
800076cc:	c0 58       	MOV       R6, R0
##@@@P_:tasks.c:6730
##@@@L6725_:        {   
##@@@L6726_:            /* A task can only have an inherited priority if it holds the mutex.   
##@@@L6727_:             * If the mutex is held by a task then it cannot be given from an   
##@@@L6728_:             * interrupt, and if a mutex is given by the holding task then it must   
##@@@L6729_:             * be the running state task. */   
##@@@L6730_:            configASSERT( pxTCB == pxCurrentTCB );   
800076ce:	1c 45       	LD        R5, [PC + #28]        ;->0x8000773c  :=0xd0000040
800076d0:	55 82       	LD.W      R5, [R5]
800076d2:	50 70       	CMP       R5, R0
800076d4:	3c f1       	JNZ       $+60                  ;->0x8000774c
##@@@P_:tasks.c:6731
##@@@L6731_:            configASSERT( pxTCB->uxMutexesHeld );   
800076d6:	6e 9d       	LD.W      R5, [R6 + #21]
800076d8:	50 38       	CMP       R5, #0			;->0x00
800076da:	5c f0       	JZ        $+92                  ;->0x80007792
##@@@P_:tasks.c:6732
##@@@L6732_:            ( pxTCB->uxMutexesHeld )--;   
800076dc:	6d cc       	SUB       R5, R5, #1
800076de:	75 a5       	ST.W      [R6 + #21], R5
##@@@P_:tasks.c:6736
##@@@L6733_:
##@@@L6734_:            /* Has the holder of the mutex inherited the priority of another   
##@@@L6735_:             * task? */   
##@@@L6736_:            if( pxTCB->uxPriority != pxTCB->uxBasePriority )   
800076e0:	26 9d       	LD.W      R4, [R6 + #20]
800076e2:	de 9a       	LD.W      R3, [R6 + #11]
800076e4:	00 10       	MOV       R0, #0			;->0x0000
800076e6:	34 70       	CMP       R3, R4
800076e8:	25 f0       	JZ        $+37                  ;->0x80007732
800076ea:	50 38       	CMP       R5, #0			;->0x00
800076ec:	23 f1       	JNZ       $+35                  ;->0x80007732
##@@@P_:tasks.c:6746
##@@@L6741_:                    /* A task can only have an inherited priority if it holds   
##@@@L6742_:                     * the mutex.  If the mutex is held by a task then it cannot be   
##@@@L6743_:                     * given from an interrupt, and if a mutex is given by the   
##@@@L6744_:                     * holding task then it must be the running state task.  Remove   
##@@@L6745_:                     * the holding task from the ready list. */   
##@@@L6746_:                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
800076ee:	3e c1       	ADD       R7, R6, #4
800076f0:	07 58       	MOV       R0, R7
800076f2:	14 45       	LD        R5, [PC + #20]        ;->0x80007740  :=0x80002290
800076f4:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6758
##@@@L6753_:                    }   
##@@@L6754_:
##@@@L6755_:                    /* Disinherit the priority before adding the task into the   
##@@@L6756_:                     * new  ready list. */   
##@@@L6757_:                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );   
##@@@L6758_:                    pxTCB->uxPriority = pxTCB->uxBasePriority;   
800076f6:	2e 9d       	LD.W      R5, [R6 + #20]
800076f8:	4e 11       	MOV       R4, #30			;->0x001E
##@@@P_:tasks.c:6763
##@@@L6759_:
##@@@L6760_:                    /* Reset the event list item value.  It cannot be in use for   
##@@@L6761_:                     * any other purpose if this task is running, and it must be   
##@@@L6762_:                     * running to give back the mutex. */   
##@@@L6763_:                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );   
800076fa:	64 c7       	SUB       R4, R4, R5
800076fc:	b4 a1       	ST.W      [R6 + #6], R4
##@@@P_:tasks.c:6764
##@@@L6764_:                    prvAddTaskToReadyList( pxTCB );   
800076fe:	12 44       	LD        R4, [PC + #18]        ;->0x80007744  :=0xd00002f8
##@@@P_:tasks.c:6758
##@@@L6753_:                    }   
##@@@L6754_:
##@@@L6755_:                    /* Disinherit the priority before adding the task into the   
##@@@L6756_:                     * new  ready list. */   
##@@@L6757_:                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );   
##@@@L6758_:                    pxTCB->uxPriority = pxTCB->uxBasePriority;   
80007700:	f5 a2       	ST.W      [R6 + #11], R5
##@@@P_:tasks.c:6764
##@@@L6759_:
##@@@L6760_:                    /* Reset the event list item value.  It cannot be in use for   
##@@@L6761_:                     * any other purpose if this task is running, and it must be   
##@@@L6762_:                     * running to give back the mutex. */   
##@@@L6763_:                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );   
##@@@L6764_:                    prvAddTaskToReadyList( pxTCB );   
80007702:	34 82       	LD.W      R3, [R4]
80007704:	53 70       	CMP       R5, R3
80007706:	02 f9       	JLS       $+2                   ;->0x8000770a
80007708:	45 85       	ST.W      [R4], R5
8000770a:	10 44       	LD        R4, [PC + #16]        ;->0x80007748  :=0xd00000a0
8000770c:	34 11       	MOV       R3, #20			;->0x0014
8000770e:	44 58       	MOV       R2, R4
80007710:	19 00 a3 08 	MADD32    R2, R5, R3
80007714:	4a 98       	LD.W      R1, [R2 + #1]
80007716:	b1 a0       	ST.W      [R6 + #2], R1
80007718:	81 98       	LD.W      R0, [R1 + #2]
8000771a:	f0 a0       	ST.W      [R6 + #3], R0
8000771c:	81 98       	LD.W      R0, [R1 + #2]
8000771e:	47 a0       	ST.W      [R0 + #1], R7
80007720:	8f a0       	ST.W      [R1 + #2], R7
80007722:	72 a1       	ST.W      [R6 + #5], R2
80007724:	ed ca       	MULS      R5, R5, R3
80007726:	5c e9       	LD.W      R3, [R4 + R5]
80007728:	5b c0       	ADD       R3, R3, #1
8000772a:	63 ef       	ST.W      [R4 + R5], R3
8000772c:	01 10       	MOV       R0, #1			;->0x0001
8000772e:	02 04       	SJMP      $+2                   ;->0x80007732
80007730:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:tasks.c:6803
##@@@L6798_:            mtCOVERAGE_TEST_MARKER();   
##@@@L6799_:        }   
##@@@L6800_:
##@@@L6801_:        traceRETURN_xTaskPriorityDisinherit( xReturn );   
##@@@L6802_:
##@@@L6803_:        return xReturn;   
80007732:	e4 28       	ADD       SP, #4			;->0x04
80007734:	03 5e       	POP       {R6-R7}
80007736:	0d 5d       	POP       LR
80007738:	1d 5c       	JMP       LR
8000773a:	00 00       	NOP      NOP      
8000773c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80007740:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80007744:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
80007748:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
##@@@P_:tasks.c:6730
##@@@L6725_:        {   
##@@@L6726_:            /* A task can only have an inherited priority if it holds the mutex.   
##@@@L6727_:             * If the mutex is held by a task then it cannot be given from an   
##@@@L6728_:             * interrupt, and if a mutex is given by the holding task then it must   
##@@@L6729_:             * be the running state task. */   
##@@@L6730_:            configASSERT( pxTCB == pxCurrentTCB );   
8000774c:	20 5d       	PUSH      R0
8000774e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007752:	08 00       	SYNC     SYNC     
80007754:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007758:	08 00       	SYNC     SYNC     
8000775a:	00 5d       	POP       R0
8000775c:	20 5d       	PUSH      R0
8000775e:	21 5d       	PUSH      R1
80007760:	1e 45       	LD        R5, [PC + #30]        ;->0x800077d8  :=0x1ff
80007762:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007766:	25 58       	MOV       R1, R5
80007768:	11 68       	NOT       R1, R1
8000776a:	01 69       	ANL       R0, R1
8000776c:	5f 11       	MOV       R5, #31			;->0x001F
8000776e:	25 58       	MOV       R1, R5
80007770:	01 6a       	ORL       R0, R1
80007772:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007776:	08 00       	SYNC     SYNC     
80007778:	01 5d       	POP       R1
8000777a:	00 5d       	POP       R0
8000777c:	20 5d       	PUSH      R0
8000777e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007782:	08 00       	SYNC     SYNC     
80007784:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007788:	08 00       	SYNC     SYNC     
8000778a:	00 5d       	POP       R0
8000778c:	07 00       	BREAK    BREAK    
8000778e:	14 45       	LD        R5, [PC + #20]        ;->0x800077dc  :=0x8000911c
80007790:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6731
##@@@L6731_:            configASSERT( pxTCB->uxMutexesHeld );   
80007792:	20 5d       	PUSH      R0
80007794:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007798:	08 00       	SYNC     SYNC     
8000779a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000779e:	08 00       	SYNC     SYNC     
800077a0:	00 5d       	POP       R0
800077a2:	20 5d       	PUSH      R0
800077a4:	21 5d       	PUSH      R1
800077a6:	0d 45       	LD        R5, [PC + #13]        ;->0x800077d8  :=0x1ff
800077a8:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800077ac:	25 58       	MOV       R1, R5
800077ae:	11 68       	NOT       R1, R1
800077b0:	01 69       	ANL       R0, R1
800077b2:	5f 11       	MOV       R5, #31			;->0x001F
800077b4:	25 58       	MOV       R1, R5
800077b6:	01 6a       	ORL       R0, R1
800077b8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800077bc:	08 00       	SYNC     SYNC     
800077be:	01 5d       	POP       R1
800077c0:	00 5d       	POP       R0
800077c2:	20 5d       	PUSH      R0
800077c4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800077c8:	08 00       	SYNC     SYNC     
800077ca:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800077ce:	08 00       	SYNC     SYNC     
800077d0:	00 5d       	POP       R0
800077d2:	07 00       	BREAK    BREAK    
800077d4:	02 45       	LD        R5, [PC + #2]         ;->0x800077dc  :=0x8000911c
800077d6:	05 5c       	LJMP      R5
800077d8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800077dc:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800077e0 <vTaskPriorityDisinheritAfterTimeout>:
##@@@F_:vTaskPriorityDisinheritAfterTimeout():
##@@@P_:tasks.c:6813
##@@@L6808_:
##@@@L6809_:#if ( configUSE_MUTEXES == 1 )   
##@@@L6810_:
##@@@L6811_:    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,   
##@@@L6812_:                                              UBaseType_t uxHighestPriorityWaitingTask )   
##@@@L6813_:    {   
800077e0:	83 5f       	PUSH      {R6-R7,LR}
800077e2:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:tasks.c:6820
##@@@L6815_:        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;   
##@@@L6816_:        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;   
##@@@L6817_:
##@@@L6818_:        traceENTER_vTaskPriorityDisinheritAfterTimeout( pxMutexHolder, uxHighestPriorityWaitingTask );   
##@@@L6819_:
##@@@L6820_:        if( pxMutexHolder != NULL )   
800077e4:	00 38       	CMP       R0, #0			;->0x00
800077e6:	3d f0       	JZ        $+61                  ;->0x80007860
800077e8:	c0 58       	MOV       R6, R0
##@@@P_:tasks.c:6824
##@@@L6821_:        {   
##@@@L6822_:            /* If pxMutexHolder is not NULL then the holder must hold at least   
##@@@L6823_:             * one mutex. */   
##@@@L6824_:            configASSERT( pxTCB->uxMutexesHeld );   
800077ea:	60 9d       	LD.W      R4, [R0 + #21]
800077ec:	40 38       	CMP       R4, #0			;->0x00
800077ee:	45 f0       	JZ        $+69                  ;->0x80007878
##@@@P_:tasks.c:6830
##@@@L6825_:
##@@@L6826_:            /* Determine the priority to which the priority of the task that   
##@@@L6827_:             * holds the mutex should be set.  This will be the greater of the   
##@@@L6828_:             * holding task's base priority and the priority of the highest   
##@@@L6829_:             * priority task that is waiting to obtain the mutex. */   
##@@@L6830_:            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )   
800077f0:	2e 9d       	LD.W      R5, [R6 + #20]
800077f2:	51 70       	CMP       R5, R1
800077f4:	02 f3       	JNC       $+2                   ;->0x800077f8
800077f6:	25 58       	MOV       R1, R5
##@@@P_:tasks.c:6840
##@@@L6835_:            {   
##@@@L6836_:                uxPriorityToUse = pxTCB->uxBasePriority;   
##@@@L6837_:            }   
##@@@L6838_:
##@@@L6839_:            /* Does the priority need to change? */   
##@@@L6840_:            if( pxTCB->uxPriority != uxPriorityToUse )   
800077f8:	ee 9a       	LD.W      R5, [R6 + #11]
800077fa:	51 70       	CMP       R5, R1
800077fc:	32 f0       	JZ        $+50                  ;->0x80007860
800077fe:	41 38       	CMP       R4, #1			;->0x01
80007800:	30 f1       	JNZ       $+48                  ;->0x80007860
##@@@P_:tasks.c:6851
##@@@L6846_:                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )   
##@@@L6847_:                {   
##@@@L6848_:                    /* If a task has timed out because it already holds the   
##@@@L6849_:                     * mutex it was trying to obtain then it cannot of inherited   
##@@@L6850_:                     * its own priority. */   
##@@@L6851_:                    configASSERT( pxTCB != pxCurrentTCB );   
80007802:	1a 44       	LD        R4, [PC + #26]        ;->0x80007868  :=0xd0000040
80007804:	44 82       	LD.W      R4, [R4]
80007806:	46 70       	CMP       R4, R6
80007808:	5b f0       	JZ        $+91                  ;->0x800078be
##@@@P_:tasks.c:6858
##@@@L6853_:                    /* Disinherit the priority, remembering the previous   
##@@@L6854_:                     * priority to facilitate determining the subject task's   
##@@@L6855_:                     * state. */   
##@@@L6856_:                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );   
##@@@L6857_:                    uxPriorityUsedOnEntry = pxTCB->uxPriority;   
##@@@L6858_:                    pxTCB->uxPriority = uxPriorityToUse;   
8000780a:	f1 a2       	ST.W      [R6 + #11], R1
##@@@P_:tasks.c:6862
##@@@L6859_:
##@@@L6860_:                    /* Only reset the event list item value if the value is not   
##@@@L6861_:                     * being used for anything else. */   
##@@@L6862_:                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0UL ) )   
8000780c:	a6 99       	LD.W      R4, [R6 + #6]
8000780e:	40 38       	CMP       R4, #0			;->0x00
80007810:	04 fb       	JLT       $+4                   ;->0x80007818
80007812:	4e 11       	MOV       R4, #30			;->0x001E
##@@@P_:tasks.c:6864
##@@@L6863_:                    {   
##@@@L6864_:                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse );   
80007814:	64 c6       	SUB       R4, R4, R1
80007816:	b4 a1       	ST.W      [R6 + #6], R4
##@@@P_:tasks.c:6877
##@@@L6872_:                     * then the task that holds the mutex could be in either the   
##@@@L6873_:                     * Ready, Blocked or Suspended states.  Only remove the task   
##@@@L6874_:                     * from its current state list if it is in the Ready state as   
##@@@L6875_:                     * the task's priority is going to change and there is one   
##@@@L6876_:                     * Ready list per priority. */   
##@@@L6877_:                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )   
80007818:	15 47       	LD        R7, [PC + #21]        ;->0x8000786c  :=0xd00000a0
8000781a:	24 11       	MOV       R2, #20			;->0x0014
8000781c:	87 58       	MOV       R4, R7
8000781e:	5e 99       	LD.W      R3, [R6 + #5]
80007820:	19 00 a2 10 	MADD32    R4, R5, R2
80007824:	34 70       	CMP       R3, R4
80007826:	1d f1       	JNZ       $+29                  ;->0x80007860
80007828:	02 22       	ST.W      [SP + #2], R2
8000782a:	06 c1       	ADD       R0, R6, #4
8000782c:	01 20       	ST.W      [SP + #1], R0
##@@@P_:tasks.c:6879
##@@@L6878_:                    {   
##@@@L6879_:                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )   
8000782e:	11 45       	LD        R5, [PC + #17]        ;->0x80007870  :=0x80002290
80007830:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6891
##@@@L6886_:                        else   
##@@@L6887_:                        {   
##@@@L6888_:                            mtCOVERAGE_TEST_MARKER();   
##@@@L6889_:                        }   
##@@@L6890_:
##@@@L6891_:                        prvAddTaskToReadyList( pxTCB );   
80007832:	11 44       	LD        R4, [PC + #17]        ;->0x80007874  :=0xd00002f8
80007834:	ee 9a       	LD.W      R5, [R6 + #11]
80007836:	34 82       	LD.W      R3, [R4]
80007838:	53 70       	CMP       R5, R3
8000783a:	02 f9       	JLS       $+2                   ;->0x8000783e
8000783c:	45 85       	ST.W      [R4], R5
8000783e:	87 58       	MOV       R4, R7
80007840:	02 09       	LD.W      R1, [SP + #2]
80007842:	19 00 a1 10 	MADD32    R4, R5, R1
80007846:	5c 98       	LD.W      R3, [R4 + #1]
80007848:	b3 a0       	ST.W      [R6 + #2], R3
8000784a:	93 98       	LD.W      R2, [R3 + #2]
8000784c:	f2 a0       	ST.W      [R6 + #3], R2
8000784e:	93 98       	LD.W      R2, [R3 + #2]
80007850:	01 08       	LD.W      R0, [SP + #1]
80007852:	50 a0       	ST.W      [R2 + #1], R0
80007854:	98 a0       	ST.W      [R3 + #2], R0
80007856:	74 a1       	ST.W      [R6 + #5], R4
80007858:	6d ca       	MULS      R5, R5, R1
8000785a:	67 e9       	LD.W      R4, [R7 + R5]
8000785c:	64 c0       	ADD       R4, R4, #1
8000785e:	7c ef       	ST.W      [R7 + R5], R4
##@@@P_:tasks.c:6924
##@@@L6919_:        {   
##@@@L6920_:            mtCOVERAGE_TEST_MARKER();   
##@@@L6921_:        }   
##@@@L6922_:
##@@@L6923_:        traceRETURN_vTaskPriorityDisinheritAfterTimeout();   
##@@@L6924_:    }   
80007860:	ec 28       	ADD       SP, #12			;->0x0C
80007862:	03 5e       	POP       {R6-R7}
80007864:	0d 5d       	POP       LR
80007866:	1d 5c       	JMP       LR
80007868:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
8000786c:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80007870:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80007874:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
##@@@P_:tasks.c:6824
##@@@L6819_:
##@@@L6820_:        if( pxMutexHolder != NULL )   
##@@@L6821_:        {   
##@@@L6822_:            /* If pxMutexHolder is not NULL then the holder must hold at least   
##@@@L6823_:             * one mutex. */   
##@@@L6824_:            configASSERT( pxTCB->uxMutexesHeld );   
80007878:	20 5d       	PUSH      R0
8000787a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000787e:	08 00       	SYNC     SYNC     
80007880:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007884:	08 00       	SYNC     SYNC     
80007886:	00 5d       	POP       R0
80007888:	20 5d       	PUSH      R0
8000788a:	21 5d       	PUSH      R1
8000788c:	1e 45       	LD        R5, [PC + #30]        ;->0x80007904  :=0x1ff
8000788e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007892:	25 58       	MOV       R1, R5
80007894:	11 68       	NOT       R1, R1
80007896:	01 69       	ANL       R0, R1
80007898:	5f 11       	MOV       R5, #31			;->0x001F
8000789a:	25 58       	MOV       R1, R5
8000789c:	01 6a       	ORL       R0, R1
8000789e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800078a2:	08 00       	SYNC     SYNC     
800078a4:	01 5d       	POP       R1
800078a6:	00 5d       	POP       R0
800078a8:	20 5d       	PUSH      R0
800078aa:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800078ae:	08 00       	SYNC     SYNC     
800078b0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800078b4:	08 00       	SYNC     SYNC     
800078b6:	00 5d       	POP       R0
800078b8:	07 00       	BREAK    BREAK    
800078ba:	14 45       	LD        R5, [PC + #20]        ;->0x80007908  :=0x8000911c
800078bc:	05 5c       	LJMP      R5
##@@@P_:tasks.c:6851
##@@@L6846_:                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )   
##@@@L6847_:                {   
##@@@L6848_:                    /* If a task has timed out because it already holds the   
##@@@L6849_:                     * mutex it was trying to obtain then it cannot of inherited   
##@@@L6850_:                     * its own priority. */   
##@@@L6851_:                    configASSERT( pxTCB != pxCurrentTCB );   
800078be:	20 5d       	PUSH      R0
800078c0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800078c4:	08 00       	SYNC     SYNC     
800078c6:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800078ca:	08 00       	SYNC     SYNC     
800078cc:	00 5d       	POP       R0
800078ce:	20 5d       	PUSH      R0
800078d0:	21 5d       	PUSH      R1
800078d2:	0d 45       	LD        R5, [PC + #13]        ;->0x80007904  :=0x1ff
800078d4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800078d8:	25 58       	MOV       R1, R5
800078da:	11 68       	NOT       R1, R1
800078dc:	01 69       	ANL       R0, R1
800078de:	5f 11       	MOV       R5, #31			;->0x001F
800078e0:	25 58       	MOV       R1, R5
800078e2:	01 6a       	ORL       R0, R1
800078e4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800078e8:	08 00       	SYNC     SYNC     
800078ea:	01 5d       	POP       R1
800078ec:	00 5d       	POP       R0
800078ee:	20 5d       	PUSH      R0
800078f0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800078f4:	08 00       	SYNC     SYNC     
800078f6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800078fa:	08 00       	SYNC     SYNC     
800078fc:	00 5d       	POP       R0
800078fe:	07 00       	BREAK    BREAK    
80007900:	02 45       	LD        R5, [PC + #2]         ;->0x80007908  :=0x8000911c
80007902:	05 5c       	LJMP      R5
80007904:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80007908:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

8000790c <vTaskListTasks>:
##@@@F_:vTaskListTasks():
##@@@P_:tasks.c:7249
##@@@L7244_:
##@@@L7245_:#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )   
##@@@L7246_:
##@@@L7247_:    void vTaskListTasks( char * pcWriteBuffer,   
##@@@L7248_:                         size_t uxBufferLength )   
##@@@L7249_:    {   
8000790c:	8f 5f       	PUSH      {R6-R9,LR}
8000790e:	e0 33       	SUB       SP, #48			;->0x30
80007910:	09 21       	ST.W      [SP + #9], R1
80007912:	c0 58       	MOV       R6, R0
80007914:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:tasks.c:7292
##@@@L7287_:        /* Make sure the write buffer does not contain a string. */   
##@@@L7288_:        *pcWriteBuffer = ( char ) 0x00;   
##@@@L7289_:
##@@@L7290_:        /* Take a snapshot of the number of tasks in case it changes while this   
##@@@L7291_:         * function is executing. */   
##@@@L7292_:        uxArraySize = uxCurrentNumberOfTasks;   
80007916:	3b 44       	LD        R4, [PC + #59]        ;->0x80007a00  :=0xd0000060
##@@@P_:tasks.c:7288
##@@@L7283_:         * through a call to vTaskListTasks().   
##@@@L7284_:         */   
##@@@L7285_:
##@@@L7286_:
##@@@L7287_:        /* Make sure the write buffer does not contain a string. */   
##@@@L7288_:        *pcWriteBuffer = ( char ) 0x00;   
80007918:	05 83       	ST.B      [R0], R5
##@@@P_:tasks.c:7292
##@@@L7289_:
##@@@L7290_:        /* Take a snapshot of the number of tasks in case it changes while this   
##@@@L7291_:         * function is executing. */   
##@@@L7292_:        uxArraySize = uxCurrentNumberOfTasks;   
8000791a:	74 82       	LD.W      R7, [R4]
##@@@P_:tasks.c:7300
##@@@L7295_:         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will   
##@@@L7296_:         * equate to NULL. */   
##@@@L7297_:        /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L7298_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L7299_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L7300_:        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );   
8000791c:	54 82       	LD.W      R5, [R4]
8000791e:	44 12       	MOV       R4, #36			;->0x0024
80007920:	05 cb       	MULS      R0, R5, R4
80007922:	39 45       	LD        R5, [PC + #57]        ;->0x80007a04  :=0x80008960
80007924:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7302
##@@@L7301_:
##@@@L7302_:        if( pxTaskStatusArray != NULL )   
80007926:	00 38       	CMP       R0, #0			;->0x00
80007928:	02 f1       	JNZ       $+2                   ;->0x8000792c
8000792a:	67 04       	SJMP      $+103                 ;->0x800079f8
8000792c:	00 59       	MOV       R8, R0
8000792e:	20 10       	MOV       R2, #0			;->0x0000
##@@@P_:tasks.c:7305
##@@@L7303_:        {   
##@@@L7304_:            /* Generate the (binary) data. */   
##@@@L7305_:            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );   
80007930:	27 58       	MOV       R1, R7
80007932:	0b 22       	ST.W      [SP + #11], R2
80007934:	35 45       	LD        R5, [PC + #53]        ;->0x80007a08  :=0x80006b1c
80007936:	05 5c       	LJMP      R5
80007938:	08 20       	ST.W      [SP + #8], R0
##@@@P_:tasks.c:7308
##@@@L7306_:
##@@@L7307_:            /* Create a human readable table from the binary data. */   
##@@@L7308_:            for( x = 0; x < uxArraySize; x++ )   
8000793a:	00 38       	CMP       R0, #0			;->0x00
8000793c:	02 f1       	JNZ       $+2                   ;->0x80007940
8000793e:	5a 04       	SJMP      $+90                  ;->0x800079f2
80007940:	68 58       	MOV       R3, R8
80007942:	30 29       	ADD       R3, #16			;->0x10
80007944:	09 0d       	LD.W      R5, [SP + #9]
80007946:	6d cc       	SUB       R5, R5, #1
80007948:	05 25       	ST.W      [SP + #5], R5
8000794a:	31 45       	LD        R5, [PC + #49]        ;->0x80007a0c  :=0x80000f98
8000794c:	03 25       	ST.W      [SP + #3], R5
8000794e:	5f 10       	MOV       R5, #15			;->0x000F
80007950:	04 25       	ST.W      [SP + #4], R5
80007952:	90 12       	MOV       R9, #32			;->0x0020
80007954:	0b 0f       	LD.W      R7, [SP + #11]
80007956:	0b 04       	SJMP      $+11                  ;->0x8000796c
##@@@P_:tasks.c:7382
##@@@L7377_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );   
##@@@L7378_:                        #endif /* ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) ) */   
##@@@L7379_:                        uxCharsWrittenBySnprintf = prvSnprintfReturnValueToCharsWritten( iSnprintfReturnValue, uxBufferLength - uxConsumedBufferLength );   
##@@@L7380_:
##@@@L7381_:                        uxConsumedBufferLength += uxCharsWrittenBySnprintf;   
##@@@L7382_:                        pcWriteBuffer += uxCharsWrittenBySnprintf;   
80007958:	06 0d       	LD.W      R5, [SP + #6]
8000795a:	35 c3       	ADD       R6, R5, R4
##@@@P_:tasks.c:7381
##@@@L7376_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark,   
##@@@L7377_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );   
##@@@L7378_:                        #endif /* ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) ) */   
##@@@L7379_:                        uxCharsWrittenBySnprintf = prvSnprintfReturnValueToCharsWritten( iSnprintfReturnValue, uxBufferLength - uxConsumedBufferLength );   
##@@@L7380_:
##@@@L7381_:                        uxConsumedBufferLength += uxCharsWrittenBySnprintf;   
8000795c:	fc c3       	ADD       R7, R4, R7
8000795e:	0a 0b       	LD.W      R3, [SP + #10]
##@@@P_:tasks.c:7308
##@@@L7303_:        {   
##@@@L7304_:            /* Generate the (binary) data. */   
##@@@L7305_:            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );   
##@@@L7306_:
##@@@L7307_:            /* Create a human readable table from the binary data. */   
##@@@L7308_:            for( x = 0; x < uxArraySize; x++ )   
80007960:	34 2a       	ADD       R3, #36			;->0x24
80007962:	08 0d       	LD.W      R5, [SP + #8]
80007964:	6d cc       	SUB       R5, R5, #1
80007966:	08 25       	ST.W      [SP + #8], R5
80007968:	50 38       	CMP       R5, #0			;->0x00
8000796a:	44 f0       	JZ        $+68                  ;->0x800079f2
##@@@P_:tasks.c:7310
##@@@L7309_:            {   
##@@@L7310_:                switch( pxTaskStatusArray[ x ].eCurrentState )   
8000796c:	2b cd       	SUB       R5, R3, #4
8000796e:	55 82       	LD.W      R5, [R5]
80007970:	54 38       	CMP       R5, #4			;->0x04
80007972:	0b 0c       	LD.W      R4, [SP + #11]
80007974:	04 f8       	JHI       $+4                   ;->0x8000797c
80007976:	2a 7a       	LSL       R5, #2			;->0x02
80007978:	03 0c       	LD.W      R4, [SP + #3]
8000797a:	64 e9       	LD.W      R4, [R4 + R5]
8000797c:	07 24       	ST.W      [SP + #7], R4
##@@@P_:tasks.c:7340
##@@@L7335_:                        cStatus = ( char ) 0x00;   
##@@@L7336_:                        break;   
##@@@L7337_:                }   
##@@@L7338_:
##@@@L7339_:                /* Is there enough space in the buffer to hold task name? */   
##@@@L7340_:                if( ( uxConsumedBufferLength + configMAX_TASK_NAME_LEN ) <= uxBufferLength )   
8000797e:	a7 58       	MOV       R5, R7
80007980:	50 29       	ADD       R5, #16			;->0x10
80007982:	09 0c       	LD.W      R4, [SP + #9]
80007984:	54 70       	CMP       R5, R4
80007986:	36 f8       	JHI       $+54                  ;->0x800079f2
80007988:	0a 23       	ST.W      [SP + #10], R3
##@@@P_:tasks.c:7344
##@@@L7341_:                {   
##@@@L7342_:                    /* Write the task name to the string, padding with spaces so it   
##@@@L7343_:                     * can be printed in tabular form more easily. */   
##@@@L7344_:                    pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );   
8000798a:	a3 58       	MOV       R5, R3
8000798c:	5c 30       	SUB       R5, #12			;->0x0C
8000798e:	15 82       	LD.W      R1, [R5]
##@@@F_:prvWriteNameToBuffer():
##@@@P_:tasks.c:7226
##@@@L7221_:                                        const char * pcTaskName )   
##@@@L7222_:    {   
##@@@L7223_:        size_t x;   
##@@@L7224_:
##@@@L7225_:        /* Start by copying the entire string. */   
##@@@L7226_:        ( void ) strcpy( pcBuffer, pcTaskName );   
80007990:	06 58       	MOV       R0, R6
80007992:	20 45       	LD        R5, [PC + #32]        ;->0x80007a10  :=0x8000da18
80007994:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7230
##@@@L7227_:
##@@@L7228_:        /* Pad the end of the string with spaces to ensure columns line up when   
##@@@L7229_:         * printed out. */   
##@@@L7230_:        for( x = strlen( pcBuffer ); x < ( size_t ) ( ( size_t ) configMAX_TASK_NAME_LEN - 1U ); x++ )   
80007996:	06 58       	MOV       R0, R6
80007998:	1f 45       	LD        R5, [PC + #31]        ;->0x80007a14  :=0x8000da28
8000799a:	05 5c       	LJMP      R5
8000799c:	0e 38       	CMP       R0, #14			;->0x0E
8000799e:	09 f8       	JHI       $+9                   ;->0x800079b0
800079a0:	2e c2       	ADD       R5, R6, R0
800079a2:	04 0c       	LD.W      R4, [SP + #4]
800079a4:	14 c6       	SUB       R2, R4, R0
##@@@P_:tasks.c:7232
##@@@L7231_:        {   
##@@@L7232_:            pcBuffer[ x ] = ' ';   
800079a6:	05 58       	MOV       R0, R5
800079a8:	29 58       	MOV       R1, R9
800079aa:	1c 45       	LD        R5, [PC + #28]        ;->0x80007a18  :=0x8000da04
800079ac:	05 5c       	LJMP      R5
800079ae:	04 08       	LD.W      R0, [SP + #4]
##@@@F_:vTaskListTasks():
##@@@P_:tasks.c:7346
##@@@L7341_:                {   
##@@@L7342_:                    /* Write the task name to the string, padding with spaces so it   
##@@@L7343_:                     * can be printed in tabular form more easily. */   
##@@@L7344_:                    pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );   
##@@@L7345_:                    /* Do not count the terminating null character. */   
##@@@L7346_:                    uxConsumedBufferLength = uxConsumedBufferLength + ( configMAX_TASK_NAME_LEN - 1U );   
800079b0:	7f 28       	ADD       R7, #15			;->0x0F
##@@@P_:tasks.c:7352
##@@@L7347_:
##@@@L7348_:                    /* Is there space left in the buffer? -1 is done because snprintf   
##@@@L7349_:                     * writes a terminating null character. So we are essentially   
##@@@L7350_:                     * checking if the buffer has space to write at least one non-null   
##@@@L7351_:                     * character. */   
##@@@L7352_:                    if( uxConsumedBufferLength < ( uxBufferLength - 1U ) )   
800079b2:	05 0d       	LD.W      R5, [SP + #5]
800079b4:	75 70       	CMP       R7, R5
##@@@F_:prvWriteNameToBuffer():
##@@@P_:tasks.c:7236
##@@@L7231_:        {   
##@@@L7232_:            pcBuffer[ x ] = ' ';   
##@@@L7233_:        }   
##@@@L7234_:
##@@@L7235_:        /* Terminate. */   
##@@@L7236_:        pcBuffer[ x ] = ( char ) 0x00;   
800079b6:	0b 0d       	LD.W      R5, [SP + #11]
800079b8:	35 ea       	ST.B      [R6 + R0], R5
800079ba:	0a 0b       	LD.W      R3, [SP + #10]
##@@@F_:vTaskListTasks():
##@@@P_:tasks.c:7352
##@@@L7347_:
##@@@L7348_:                    /* Is there space left in the buffer? -1 is done because snprintf   
##@@@L7349_:                     * writes a terminating null character. So we are essentially   
##@@@L7350_:                     * checking if the buffer has space to write at least one non-null   
##@@@L7351_:                     * character. */   
##@@@L7352_:                    if( uxConsumedBufferLength < ( uxBufferLength - 1U ) )   
800079bc:	1b f2       	JC        $+27                  ;->0x800079f2
##@@@P_:tasks.c:7377
##@@@L7372_:                                                             uxBufferLength - uxConsumedBufferLength,   
##@@@L7373_:                                                             "\t%c\t%u\t%u\t%u\r\n",   
##@@@L7374_:                                                             cStatus,   
##@@@L7375_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority,   
##@@@L7376_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark,   
##@@@L7377_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );   
800079be:	a3 58       	MOV       R5, R3
800079c0:	58 30       	SUB       R5, #8			;->0x08
800079c2:	55 82       	LD.W      R5, [R5]
##@@@P_:tasks.c:7375
##@@@L7370_:                            /* coverity[misra_c_2012_rule_21_6_violation] */   
##@@@L7371_:                            iSnprintfReturnValue = snprintf( pcWriteBuffer,   
##@@@L7372_:                                                             uxBufferLength - uxConsumedBufferLength,   
##@@@L7373_:                                                             "\t%c\t%u\t%u\t%u\r\n",   
##@@@L7374_:                                                             cStatus,   
##@@@L7375_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority,   
800079c4:	43 82       	LD.W      R4, [R3]
##@@@P_:tasks.c:7376
##@@@L7376_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark,   
800079c6:	1b aa       	LD.H      R3, [R3 + #8]
800079c8:	06 c2       	ADD       R0, R6, R0
##@@@P_:tasks.c:7371
##@@@L7366_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].uxCoreAffinityMask );   
##@@@L7367_:                        #else /* ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) ) */   
##@@@L7368_:                            /* MISRA Ref 21.6.1 [snprintf for utility] */   
##@@@L7369_:                            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */   
##@@@L7370_:                            /* coverity[misra_c_2012_rule_21_6_violation] */   
##@@@L7371_:                            iSnprintfReturnValue = snprintf( pcWriteBuffer,   
800079ca:	2e 58       	MOV       R1, SP
800079cc:	4d a0       	ST.W      [R1 + #1], R5
800079ce:	14 42       	LD        R2, [PC + #20]        ;->0x80007a1c  :=0x80000f6c
##@@@P_:tasks.c:7372
##@@@L7372_:                                                             uxBufferLength - uxConsumedBufferLength,   
800079d0:	09 0d       	LD.W      R5, [SP + #9]
800079d2:	f5 c7       	SUB       R6, R5, R7
##@@@P_:tasks.c:7371
##@@@L7366_:                                                             ( unsigned int ) pxTaskStatusArray[ x ].uxCoreAffinityMask );   
##@@@L7367_:                        #else /* ( ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) ) */   
##@@@L7368_:                            /* MISRA Ref 21.6.1 [snprintf for utility] */   
##@@@L7369_:                            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */   
##@@@L7370_:                            /* coverity[misra_c_2012_rule_21_6_violation] */   
##@@@L7371_:                            iSnprintfReturnValue = snprintf( pcWriteBuffer,   
800079d4:	13 85       	ST.W      [R1], R3
800079d6:	06 20       	ST.W      [SP + #6], R0
800079d8:	26 58       	MOV       R1, R6
800079da:	07 0b       	LD.W      R3, [SP + #7]
800079dc:	11 45       	LD        R5, [PC + #17]        ;->0x80007a20  :=0x8000da38
800079de:	05 5c       	LJMP      R5
800079e0:	a0 58       	MOV       R5, R0
##@@@F_:prvSnprintfReturnValueToCharsWritten():
##@@@P_:tasks.c:2175
##@@@L2170_:    static size_t prvSnprintfReturnValueToCharsWritten( int iSnprintfReturnValue,   
##@@@L2171_:                                                        size_t n )   
##@@@L2172_:    {   
##@@@L2173_:        size_t uxCharsWritten;   
##@@@L2174_:
##@@@L2175_:        if( iSnprintfReturnValue < 0 )   
800079e2:	06 70       	CMP       R0, R6
800079e4:	02 fb       	JLT       $+2                   ;->0x800079e8
800079e6:	6e cc       	SUB       R5, R6, #1
800079e8:	0b 0c       	LD.W      R4, [SP + #11]
800079ea:	00 38       	CMP       R0, #0			;->0x00
800079ec:	b6 fb       	JLT       $-74                  ;->0x80007958
##@@@F_:vTaskListTasks():
800079ee:	85 58       	MOV       R4, R5
800079f0:	b4 07       	SJMP      $-76                  ;->0x80007958
##@@@P_:tasks.c:7402
##@@@L7397_:                }   
##@@@L7398_:            }   
##@@@L7399_:
##@@@L7400_:            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION   
##@@@L7401_:             * is 0 then vPortFree() will be #defined to nothing. */   
##@@@L7402_:            vPortFree( pxTaskStatusArray );   
800079f2:	08 58       	MOV       R0, R8
800079f4:	0c 45       	LD        R5, [PC + #12]        ;->0x80007a24  :=0x80008b9c
800079f6:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7410
##@@@L7405_:        {   
##@@@L7406_:            mtCOVERAGE_TEST_MARKER();   
##@@@L7407_:        }   
##@@@L7408_:
##@@@L7409_:        traceRETURN_vTaskListTasks();   
##@@@L7410_:    }   
800079f8:	e0 2b       	ADD       SP, #48			;->0x30
800079fa:	0f 5e       	POP       {R6-R9}
800079fc:	0d 5d       	POP       LR
800079fe:	1d 5c       	JMP       LR
80007a00:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
80007a04:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
80007a08:	1c 6b 00 80 	.long     0x80006b1c ->-2147456228  [!!!@2@:XRL       R1, R12	@@: LD.B      R0, [R0]
80007a0c:	98 0f 00 80 	.long     0x80000f98 ->-2147479656  [!!!@2@:LD.W      R7, [SP + #152]	@@: LD.B      R0, [R0]
80007a10:	18 da 00 80 	.long     0x8000da18 ->-2147427816  [!!!@2@:LSL       R3, R0, R0	@@: LD.B      R0, [R0]
80007a14:	28 da 00 80 	.long     0x8000da28 ->-2147427800  [!!!@2@:LSL       R5, R0, R0	@@: LD.B      R0, [R0]
80007a18:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
80007a1c:	6c 0f 00 80 	.long     0x80000f6c ->-2147479700  [!!!@2@:LD.W      R7, [SP + #108]	@@: LD.B      R0, [R0]
80007a20:	38 da 00 80 	.long     0x8000da38 ->-2147427784  [!!!@2@:LSL       R7, R0, R0	@@: LD.B      R0, [R0]
80007a24:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]

80007a28 <vTaskGetRunTimeStatistics>:
##@@@F_:vTaskGetRunTimeStatistics():
##@@@P_:tasks.c:7419
##@@@L7414_:
##@@@L7415_:#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configUSE_TRACE_FACILITY == 1 ) )   
##@@@L7416_:
##@@@L7417_:    void vTaskGetRunTimeStatistics( char * pcWriteBuffer,   
##@@@L7418_:                                    size_t uxBufferLength )   
##@@@L7419_:    {   
80007a28:	87 5f       	PUSH      {R6-R8,LR}
80007a2a:	e0 33       	SUB       SP, #48			;->0x30
80007a2c:	09 21       	ST.W      [SP + #9], R1
80007a2e:	c0 58       	MOV       R6, R0
80007a30:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:tasks.c:7426
##@@@L7421_:        size_t uxConsumedBufferLength = 0;   
##@@@L7422_:        size_t uxCharsWrittenBySnprintf;   
##@@@L7423_:        int iSnprintfReturnValue;   
##@@@L7424_:        BaseType_t xOutputBufferFull = pdFALSE;   
##@@@L7425_:        UBaseType_t uxArraySize, x;   
##@@@L7426_:        configRUN_TIME_COUNTER_TYPE ulTotalTime = 0;   
80007a32:	0b 25       	ST.W      [SP + #11], R5
##@@@P_:tasks.c:7461
##@@@L7456_:        /* Make sure the write buffer does not contain a string. */   
##@@@L7457_:        *pcWriteBuffer = ( char ) 0x00;   
##@@@L7458_:
##@@@L7459_:        /* Take a snapshot of the number of tasks in case it changes while this   
##@@@L7460_:         * function is executing. */   
##@@@L7461_:        uxArraySize = uxCurrentNumberOfTasks;   
80007a34:	43 44       	LD        R4, [PC + #67]        ;->0x80007b40  :=0xd0000060
##@@@P_:tasks.c:7457
##@@@L7452_:         * directly to get access to raw stats data, rather than indirectly   
##@@@L7453_:         * through a call to vTaskGetRunTimeStatistics().   
##@@@L7454_:         */   
##@@@L7455_:
##@@@L7456_:        /* Make sure the write buffer does not contain a string. */   
##@@@L7457_:        *pcWriteBuffer = ( char ) 0x00;   
80007a36:	05 83       	ST.B      [R0], R5
##@@@P_:tasks.c:7461
##@@@L7458_:
##@@@L7459_:        /* Take a snapshot of the number of tasks in case it changes while this   
##@@@L7460_:         * function is executing. */   
##@@@L7461_:        uxArraySize = uxCurrentNumberOfTasks;   
80007a38:	74 82       	LD.W      R7, [R4]
##@@@P_:tasks.c:7469
##@@@L7464_:         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will   
##@@@L7465_:         * equate to NULL. */   
##@@@L7466_:        /* MISRA Ref 11.5.1 [Malloc memory assignment] */   
##@@@L7467_:        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L7468_:        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L7469_:        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );   
80007a3a:	54 82       	LD.W      R5, [R4]
80007a3c:	44 12       	MOV       R4, #36			;->0x0024
80007a3e:	05 cb       	MULS      R0, R5, R4
80007a40:	41 45       	LD        R5, [PC + #65]        ;->0x80007b44  :=0x80008960
80007a42:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7471
##@@@L7470_:
##@@@L7471_:        if( pxTaskStatusArray != NULL )   
80007a44:	00 38       	CMP       R0, #0			;->0x00
80007a46:	02 f1       	JNZ       $+2                   ;->0x80007a4a
80007a48:	78 04       	SJMP      $+120                 ;->0x80007b38
80007a4a:	40 42       	LD        R2, [PC + #64]        ;->0x80007b48  :=0x2c
80007a4c:	2e 64       	ADD       R2, SP
80007a4e:	01 20       	ST.W      [SP + #1], R0
##@@@P_:tasks.c:7474
##@@@L7472_:        {   
##@@@L7473_:            /* Generate the (binary) data. */   
##@@@L7474_:            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );   
80007a50:	27 58       	MOV       R1, R7
80007a52:	3f 45       	LD        R5, [PC + #63]        ;->0x80007b4c  :=0x80006b1c
80007a54:	05 5c       	LJMP      R5
80007a56:	08 20       	ST.W      [SP + #8], R0
##@@@P_:tasks.c:7477
##@@@L7475_:
##@@@L7476_:            /* For percentage calculations. */   
##@@@L7477_:            ulTotalTime /= ( ( configRUN_TIME_COUNTER_TYPE ) 100UL );   
80007a58:	0b 0d       	LD.W      R5, [SP + #11]
80007a5a:	44 16       	MOV       R4, #100			;->0x0064
80007a5c:	1d d3       	DIVU      R3, R5, R4
##@@@P_:tasks.c:7480
##@@@L7478_:
##@@@L7479_:            /* Avoid divide by zero errors. */   
##@@@L7480_:            if( ulTotalTime > 0UL )   
80007a5e:	54 3e       	CMP       R5, #100			;->0x64
##@@@P_:tasks.c:7477
##@@@L7472_:        {   
##@@@L7473_:            /* Generate the (binary) data. */   
##@@@L7474_:            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );   
##@@@L7475_:
##@@@L7476_:            /* For percentage calculations. */   
##@@@L7477_:            ulTotalTime /= ( ( configRUN_TIME_COUNTER_TYPE ) 100UL );   
80007a60:	0b 23       	ST.W      [SP + #11], R3
##@@@P_:tasks.c:7480
##@@@L7478_:
##@@@L7479_:            /* Avoid divide by zero errors. */   
##@@@L7480_:            if( ulTotalTime > 0UL )   
80007a62:	02 f2       	JC        $+2                   ;->0x80007a66
80007a64:	67 04       	SJMP      $+103                 ;->0x80007b32
80007a66:	08 0d       	LD.W      R5, [SP + #8]
80007a68:	50 38       	CMP       R5, #0			;->0x00
80007a6a:	02 f1       	JNZ       $+2                   ;->0x80007a6e
80007a6c:	63 04       	SJMP      $+99                  ;->0x80007b32
##@@@P_:tasks.c:7491
##@@@L7486_:                     * This will always be rounded down to the nearest integer.   
##@@@L7487_:                     * ulTotalRunTime has already been divided by 100. */   
##@@@L7488_:                    ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;   
##@@@L7489_:
##@@@L7490_:                    /* Is there enough space in the buffer to hold task name? */   
##@@@L7491_:                    if( ( uxConsumedBufferLength + configMAX_TASK_NAME_LEN ) <= uxBufferLength )   
80007a6e:	09 0d       	LD.W      R5, [SP + #9]
80007a70:	50 39       	CMP       R5, #16			;->0x10
80007a72:	02 f2       	JC        $+2                   ;->0x80007a76
80007a74:	5f 04       	SJMP      $+95                  ;->0x80007b32
80007a76:	01 0c       	LD.W      R4, [SP + #1]
80007a78:	94 99       	LD.W      R2, [R4 + #6]
80007a7a:	09 0d       	LD.W      R5, [SP + #9]
80007a7c:	6d cc       	SUB       R5, R5, #1
##@@@P_:tasks.c:7488
##@@@L7483_:                for( x = 0; x < uxArraySize; x++ )   
##@@@L7484_:                {   
##@@@L7485_:                    /* What percentage of the total run time has the task used?   
##@@@L7486_:                     * This will always be rounded down to the nearest integer.   
##@@@L7487_:                     * ulTotalRunTime has already been divided by 100. */   
##@@@L7488_:                    ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;   
80007a7e:	02 25       	ST.W      [SP + #2], R5
80007a80:	05 22       	ST.W      [SP + #5], R2
80007a82:	ea d2       	DIVU      R5, R2, R3
80007a84:	03 25       	ST.W      [SP + #3], R5
80007a86:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:tasks.c:7491
##@@@L7489_:
##@@@L7490_:                    /* Is there enough space in the buffer to hold task name? */   
##@@@L7491_:                    if( ( uxConsumedBufferLength + configMAX_TASK_NAME_LEN ) <= uxBufferLength )   
80007a88:	4c 2b       	ADD       R4, #60			;->0x3C
80007a8a:	0a 24       	ST.W      [SP + #10], R4
80007a8c:	80 12       	MOV       R8, #32			;->0x0020
80007a8e:	07 27       	ST.W      [SP + #7], R7
80007a90:	06 23       	ST.W      [SP + #6], R3
##@@@P_:tasks.c:7496
##@@@L7492_:                    {   
##@@@L7493_:                        /* Write the task name to the string, padding with   
##@@@L7494_:                         * spaces so it can be printed in tabular form more   
##@@@L7495_:                         * easily. */   
##@@@L7496_:                        pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );   
80007a92:	0a 0d       	LD.W      R5, [SP + #10]
80007a94:	58 33       	SUB       R5, #56			;->0x38
80007a96:	15 82       	LD.W      R1, [R5]
##@@@F_:prvWriteNameToBuffer():
##@@@P_:tasks.c:7226
##@@@L7221_:                                        const char * pcTaskName )   
##@@@L7222_:    {   
##@@@L7223_:        size_t x;   
##@@@L7224_:
##@@@L7225_:        /* Start by copying the entire string. */   
##@@@L7226_:        ( void ) strcpy( pcBuffer, pcTaskName );   
80007a98:	06 58       	MOV       R0, R6
80007a9a:	2e 45       	LD        R5, [PC + #46]        ;->0x80007b50  :=0x8000da18
80007a9c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7230
##@@@L7227_:
##@@@L7228_:        /* Pad the end of the string with spaces to ensure columns line up when   
##@@@L7229_:         * printed out. */   
##@@@L7230_:        for( x = strlen( pcBuffer ); x < ( size_t ) ( ( size_t ) configMAX_TASK_NAME_LEN - 1U ); x++ )   
80007a9e:	06 58       	MOV       R0, R6
80007aa0:	2d 45       	LD        R5, [PC + #45]        ;->0x80007b54  :=0x8000da28
80007aa2:	05 5c       	LJMP      R5
80007aa4:	0e 38       	CMP       R0, #14			;->0x0E
80007aa6:	0a f8       	JHI       $+10                  ;->0x80007aba
80007aa8:	2e c2       	ADD       R5, R6, R0
80007aaa:	4f 10       	MOV       R4, #15			;->0x000F
80007aac:	04 24       	ST.W      [SP + #4], R4
80007aae:	14 c6       	SUB       R2, R4, R0
##@@@P_:tasks.c:7232
##@@@L7231_:        {   
##@@@L7232_:            pcBuffer[ x ] = ' ';   
80007ab0:	05 58       	MOV       R0, R5
80007ab2:	28 58       	MOV       R1, R8
80007ab4:	29 45       	LD        R5, [PC + #41]        ;->0x80007b58  :=0x8000da04
80007ab6:	05 5c       	LJMP      R5
80007ab8:	04 08       	LD.W      R0, [SP + #4]
##@@@F_:vTaskGetRunTimeStatistics():
##@@@P_:tasks.c:7498
##@@@L7493_:                        /* Write the task name to the string, padding with   
##@@@L7494_:                         * spaces so it can be printed in tabular form more   
##@@@L7495_:                         * easily. */   
##@@@L7496_:                        pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );   
##@@@L7497_:                        /* Do not count the terminating null character. */   
##@@@L7498_:                        uxConsumedBufferLength = uxConsumedBufferLength + ( configMAX_TASK_NAME_LEN - 1U );   
80007aba:	7f 28       	ADD       R7, #15			;->0x0F
##@@@P_:tasks.c:7504
##@@@L7499_:
##@@@L7500_:                        /* Is there space left in the buffer? -1 is done because snprintf   
##@@@L7501_:                         * writes a terminating null character. So we are essentially   
##@@@L7502_:                         * checking if the buffer has space to write at least one non-null   
##@@@L7503_:                         * character. */   
##@@@L7504_:                        if( uxConsumedBufferLength < ( uxBufferLength - 1U ) )   
80007abc:	02 0d       	LD.W      R5, [SP + #2]
80007abe:	75 70       	CMP       R7, R5
##@@@F_:prvWriteNameToBuffer():
##@@@P_:tasks.c:7236
##@@@L7231_:        {   
##@@@L7232_:            pcBuffer[ x ] = ' ';   
##@@@L7233_:        }   
##@@@L7234_:
##@@@L7235_:        /* Terminate. */   
##@@@L7236_:        pcBuffer[ x ] = ( char ) 0x00;   
80007ac0:	07 0d       	LD.W      R5, [SP + #7]
80007ac2:	35 ea       	ST.B      [R6 + R0], R5
80007ac4:	06 0c       	LD.W      R4, [SP + #6]
##@@@F_:vTaskGetRunTimeStatistics():
##@@@P_:tasks.c:7504
##@@@L7499_:
##@@@L7500_:                        /* Is there space left in the buffer? -1 is done because snprintf   
##@@@L7501_:                         * writes a terminating null character. So we are essentially   
##@@@L7502_:                         * checking if the buffer has space to write at least one non-null   
##@@@L7503_:                         * character. */   
##@@@L7504_:                        if( uxConsumedBufferLength < ( uxBufferLength - 1U ) )   
80007ac6:	36 f2       	JC        $+54                  ;->0x80007b32
80007ac8:	06 c2       	ADD       R0, R6, R0
80007aca:	09 0d       	LD.W      R5, [SP + #9]
80007acc:	f5 c7       	SUB       R6, R5, R7
80007ace:	0a 0d       	LD.W      R5, [SP + #10]
80007ad0:	54 32       	SUB       R5, #36			;->0x24
80007ad2:	35 82       	LD.W      R3, [R5]
##@@@P_:tasks.c:7506
##@@@L7505_:                        {   
##@@@L7506_:                            if( ulStatsAsPercentage > 0UL )   
80007ad4:	05 0d       	LD.W      R5, [SP + #5]
80007ad6:	45 70       	CMP       R4, R5
80007ad8:	04 20       	ST.W      [SP + #4], R0
80007ada:	09 f9       	JLS       $+9                   ;->0x80007aec
##@@@P_:tasks.c:7555
##@@@L7550_:                                    /* sizeof( int ) == sizeof( long ) so a smaller   
##@@@L7551_:                                     * printf() library can be used. */   
##@@@L7552_:                                    /* MISRA Ref 21.6.1 [snprintf for utility] */   
##@@@L7553_:                                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */   
##@@@L7554_:                                    /* coverity[misra_c_2012_rule_21_6_violation] */   
##@@@L7555_:                                    iSnprintfReturnValue = snprintf( pcWriteBuffer,   
80007adc:	20 42       	LD        R2, [PC + #32]        ;->0x80007b5c  :=0x80000f87
80007ade:	26 58       	MOV       R1, R6
80007ae0:	20 45       	LD        R5, [PC + #32]        ;->0x80007b60  :=0x8000da38
80007ae2:	05 5c       	LJMP      R5
80007ae4:	80 58       	MOV       R4, R0
##@@@F_:prvSnprintfReturnValueToCharsWritten():
##@@@P_:tasks.c:2175
##@@@L2170_:    static size_t prvSnprintfReturnValueToCharsWritten( int iSnprintfReturnValue,   
##@@@L2171_:                                                        size_t n )   
##@@@L2172_:    {   
##@@@L2173_:        size_t uxCharsWritten;   
##@@@L2174_:
##@@@L2175_:        if( iSnprintfReturnValue < 0 )   
80007ae6:	06 70       	CMP       R0, R6
80007ae8:	0a fa       	JGE       $+10                  ;->0x80007afc
80007aea:	0a 04       	SJMP      $+10                  ;->0x80007afe
##@@@F_:vTaskGetRunTimeStatistics():
##@@@P_:tasks.c:7526
##@@@L7521_:                                    /* sizeof( int ) == sizeof( long ) so a smaller   
##@@@L7522_:                                     * printf() library can be used. */   
##@@@L7523_:                                    /* MISRA Ref 21.6.1 [snprintf for utility] */   
##@@@L7524_:                                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-216 */   
##@@@L7525_:                                    /* coverity[misra_c_2012_rule_21_6_violation] */   
##@@@L7526_:                                    iSnprintfReturnValue = snprintf( pcWriteBuffer,   
80007aec:	1e 42       	LD        R2, [PC + #30]        ;->0x80007b64  :=0x80000f7b
80007aee:	26 58       	MOV       R1, R6
80007af0:	03 0c       	LD.W      R4, [SP + #3]
80007af2:	1c 45       	LD        R5, [PC + #28]        ;->0x80007b60  :=0x8000da38
80007af4:	05 5c       	LJMP      R5
80007af6:	80 58       	MOV       R4, R0
##@@@F_:prvSnprintfReturnValueToCharsWritten():
##@@@P_:tasks.c:2175
##@@@L2170_:    static size_t prvSnprintfReturnValueToCharsWritten( int iSnprintfReturnValue,   
##@@@L2171_:                                                        size_t n )   
##@@@L2172_:    {   
##@@@L2173_:        size_t uxCharsWritten;   
##@@@L2174_:
##@@@L2175_:        if( iSnprintfReturnValue < 0 )   
80007af8:	06 70       	CMP       R0, R6
80007afa:	02 fb       	JLT       $+2                   ;->0x80007afe
80007afc:	66 cc       	SUB       R4, R6, #1
80007afe:	07 0d       	LD.W      R5, [SP + #7]
80007b00:	00 38       	CMP       R0, #0			;->0x00
80007b02:	02 fb       	JLT       $+2                   ;->0x80007b06
##@@@F_:vTaskGetRunTimeStatistics():
80007b04:	a4 58       	MOV       R5, R4
80007b06:	08 0c       	LD.W      R4, [SP + #8]
##@@@P_:tasks.c:7483
##@@@L7478_:
##@@@L7479_:            /* Avoid divide by zero errors. */   
##@@@L7480_:            if( ulTotalTime > 0UL )   
##@@@L7481_:            {   
##@@@L7482_:                /* Create a human readable table from the binary data. */   
##@@@L7483_:                for( x = 0; x < uxArraySize; x++ )   
80007b08:	64 cc       	SUB       R4, R4, #1
80007b0a:	08 24       	ST.W      [SP + #8], R4
80007b0c:	40 38       	CMP       R4, #0			;->0x00
80007b0e:	12 f0       	JZ        $+18                  ;->0x80007b32
##@@@P_:tasks.c:7565
##@@@L7560_:                                #endif /* ifdef portLU_PRINTF_SPECIFIER_REQUIRED */   
##@@@L7561_:                            }   
##@@@L7562_:
##@@@L7563_:                            uxCharsWrittenBySnprintf = prvSnprintfReturnValueToCharsWritten( iSnprintfReturnValue, uxBufferLength - uxConsumedBufferLength );   
##@@@L7564_:                            uxConsumedBufferLength += uxCharsWrittenBySnprintf;   
##@@@L7565_:                            pcWriteBuffer += uxCharsWrittenBySnprintf;   
80007b10:	04 0c       	LD.W      R4, [SP + #4]
80007b12:	74 c3       	ADD       R6, R4, R5
##@@@P_:tasks.c:7564
##@@@L7559_:                                }   
##@@@L7560_:                                #endif /* ifdef portLU_PRINTF_SPECIFIER_REQUIRED */   
##@@@L7561_:                            }   
##@@@L7562_:
##@@@L7563_:                            uxCharsWrittenBySnprintf = prvSnprintfReturnValueToCharsWritten( iSnprintfReturnValue, uxBufferLength - uxConsumedBufferLength );   
##@@@L7564_:                            uxConsumedBufferLength += uxCharsWrittenBySnprintf;   
80007b14:	fd c3       	ADD       R7, R5, R7
80007b16:	0a 0d       	LD.W      R5, [SP + #10]
##@@@P_:tasks.c:7488
##@@@L7483_:                for( x = 0; x < uxArraySize; x++ )   
##@@@L7484_:                {   
##@@@L7485_:                    /* What percentage of the total run time has the task used?   
##@@@L7486_:                     * This will always be rounded down to the nearest integer.   
##@@@L7487_:                     * ulTotalRunTime has already been divided by 100. */   
##@@@L7488_:                    ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;   
80007b18:	45 82       	LD.W      R4, [R5]
80007b1a:	0b 0b       	LD.W      R3, [SP + #11]
80007b1c:	54 2a       	ADD       R5, #36			;->0x24
80007b1e:	0a 25       	ST.W      [SP + #10], R5
80007b20:	05 24       	ST.W      [SP + #5], R4
80007b22:	ec d2       	DIVU      R5, R4, R3
##@@@P_:tasks.c:7491
##@@@L7489_:
##@@@L7490_:                    /* Is there enough space in the buffer to hold task name? */   
##@@@L7491_:                    if( ( uxConsumedBufferLength + configMAX_TASK_NAME_LEN ) <= uxBufferLength )   
80007b24:	03 25       	ST.W      [SP + #3], R5
80007b26:	a7 58       	MOV       R5, R7
80007b28:	50 29       	ADD       R5, #16			;->0x10
80007b2a:	09 0c       	LD.W      R4, [SP + #9]
80007b2c:	54 70       	CMP       R5, R4
80007b2e:	02 f8       	JHI       $+2                   ;->0x80007b32
80007b30:	b0 07       	SJMP      $-80                  ;->0x80007a90
##@@@P_:tasks.c:7590
##@@@L7585_:                mtCOVERAGE_TEST_MARKER();   
##@@@L7586_:            }   
##@@@L7587_:
##@@@L7588_:            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION   
##@@@L7589_:             * is 0 then vPortFree() will be #defined to nothing. */   
##@@@L7590_:            vPortFree( pxTaskStatusArray );   
80007b32:	01 08       	LD.W      R0, [SP + #1]
80007b34:	0d 45       	LD        R5, [PC + #13]        ;->0x80007b68  :=0x80008b9c
80007b36:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7598
##@@@L7593_:        {   
##@@@L7594_:            mtCOVERAGE_TEST_MARKER();   
##@@@L7595_:        }   
##@@@L7596_:
##@@@L7597_:        traceRETURN_vTaskGetRunTimeStatistics();   
##@@@L7598_:    }   
80007b38:	e0 2b       	ADD       SP, #48			;->0x30
80007b3a:	07 5e       	POP       {R6-R8}
80007b3c:	0d 5d       	POP       LR
80007b3e:	1d 5c       	JMP       LR
80007b40:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
80007b44:	60 89 00 80 	.long     0x80008960 ->-2147448480  [!!!@2@:LD.B      R4, [R0 + #5]	@@: LD.B      R0, [R0]
80007b48:	2c 00 00 00 	.long     0x0000002c ->000000044  [!!!@4@:FMAXNM.F32      S0, 	S0, 	S0
80007b4c:	1c 6b 00 80 	.long     0x80006b1c ->-2147456228  [!!!@2@:XRL       R1, R12	@@: LD.B      R0, [R0]
80007b50:	18 da 00 80 	.long     0x8000da18 ->-2147427816  [!!!@2@:LSL       R3, R0, R0	@@: LD.B      R0, [R0]
80007b54:	28 da 00 80 	.long     0x8000da28 ->-2147427800  [!!!@2@:LSL       R5, R0, R0	@@: LD.B      R0, [R0]
80007b58:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
80007b5c:	87 0f 00 80 	.long     0x80000f87 ->-2147479673  [!!!@2@:LD.W      R7, [SP + #135]	@@: LD.B      R0, [R0]
80007b60:	38 da 00 80 	.long     0x8000da38 ->-2147427784  [!!!@2@:LSL       R7, R0, R0	@@: LD.B      R0, [R0]
80007b64:	7b 0f 00 80 	.long     0x80000f7b ->-2147479685  [!!!@2@:LD.W      R7, [SP + #123]	@@: LD.B      R0, [R0]
80007b68:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]

80007b6c <uxTaskResetEventItemValue>:
##@@@F_:uxTaskResetEventItemValue():
##@@@P_:tasks.c:7609
##@@@L7604_:{   
##@@@L7605_:    TickType_t uxReturn;   
##@@@L7606_:
##@@@L7607_:    traceENTER_uxTaskResetEventItemValue();   
##@@@L7608_:
##@@@L7609_:    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );   
80007b6c:	05 45       	LD        R5, [PC + #5]         ;->0x80007b80  :=0xd0000040
80007b6e:	45 82       	LD.W      R4, [R5]
80007b70:	84 99       	LD.W      R0, [R4 + #6]
##@@@P_:tasks.c:7613
##@@@L7610_:
##@@@L7611_:    /* Reset the event list item to its normal value - so it can be used with   
##@@@L7612_:     * queues and semaphores. */   
##@@@L7613_:    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );   
80007b72:	45 82       	LD.W      R4, [R5]
80007b74:	e4 9a       	LD.W      R4, [R4 + #11]
80007b76:	3e 11       	MOV       R3, #30			;->0x001E
80007b78:	55 82       	LD.W      R5, [R5]
80007b7a:	23 c7       	SUB       R4, R3, R4
80007b7c:	ac a1       	ST.W      [R5 + #6], R4
##@@@P_:tasks.c:7617
##@@@L7614_:
##@@@L7615_:    traceRETURN_uxTaskResetEventItemValue( uxReturn );   
##@@@L7616_:
##@@@L7617_:    return uxReturn;   
80007b7e:	1d 5c       	JMP       LR
80007b80:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]

80007b84 <pvTaskIncrementMutexHeldCount>:
##@@@F_:pvTaskIncrementMutexHeldCount():
##@@@P_:tasks.c:7629
##@@@L7624_:    {   
##@@@L7625_:        TCB_t * pxTCB;   
##@@@L7626_:
##@@@L7627_:        traceENTER_pvTaskIncrementMutexHeldCount();   
##@@@L7628_:
##@@@L7629_:        pxTCB = pxCurrentTCB;   
80007b84:	04 45       	LD        R5, [PC + #4]         ;->0x80007b94  :=0xd0000040
80007b86:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:7633
##@@@L7630_:
##@@@L7631_:        /* If xSemaphoreCreateMutex() is called before any tasks have been created   
##@@@L7632_:         * then pxCurrentTCB will be NULL. */   
##@@@L7633_:        if( pxTCB != NULL )   
80007b88:	00 38       	CMP       R0, #0			;->0x00
80007b8a:	04 f0       	JZ        $+4                   ;->0x80007b92
##@@@P_:tasks.c:7635
##@@@L7634_:        {   
##@@@L7635_:            ( pxTCB->uxMutexesHeld )++;   
80007b8c:	68 9d       	LD.W      R5, [R0 + #21]
80007b8e:	6d c0       	ADD       R5, R5, #1
80007b90:	45 a5       	ST.W      [R0 + #21], R5
##@@@P_:tasks.c:7640
##@@@L7636_:        }   
##@@@L7637_:
##@@@L7638_:        traceRETURN_pvTaskIncrementMutexHeldCount( pxTCB );   
##@@@L7639_:
##@@@L7640_:        return pxTCB;   
80007b92:	1d 5c       	JMP       LR
80007b94:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]

80007b98 <ulTaskGenericNotifyTake>:
##@@@F_:ulTaskGenericNotifyTake():
##@@@P_:tasks.c:7651
##@@@L7646_:#if ( configUSE_TASK_NOTIFICATIONS == 1 )   
##@@@L7647_:
##@@@L7648_:    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,   
##@@@L7649_:                                      BaseType_t xClearCountOnExit,   
##@@@L7650_:                                      TickType_t xTicksToWait )   
##@@@L7651_:    {   
80007b98:	8f 5f       	PUSH      {R6-R9,LR}
80007b9a:	e4 30       	SUB       SP, #4			;->0x04
80007b9c:	01 59       	MOV       R8, R1
80007b9e:	a0 58       	MOV       R5, R0
80007ba0:	20 5d       	PUSH      R0
80007ba2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007ba6:	08 00       	SYNC     SYNC     
80007ba8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007bac:	08 00       	SYNC     SYNC     
80007bae:	00 5d       	POP       R0
80007bb0:	20 5d       	PUSH      R0
80007bb2:	21 5d       	PUSH      R1
80007bb4:	40 44       	LD        R4, [PC + #64]        ;->0x80007cb4  :=0x1ff
80007bb6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007bba:	24 58       	MOV       R1, R4
80007bbc:	11 68       	NOT       R1, R1
80007bbe:	01 69       	ANL       R0, R1
80007bc0:	4f 11       	MOV       R4, #31			;->0x001F
80007bc2:	24 58       	MOV       R1, R4
80007bc4:	01 6a       	ORL       R0, R1
80007bc6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007bca:	08 00       	SYNC     SYNC     
80007bcc:	01 5d       	POP       R1
80007bce:	00 5d       	POP       R0
##@@@P_:tasks.c:7657
##@@@L7652_:        uint32_t ulReturn;   
##@@@L7653_:        BaseType_t xAlreadyYielded;   
##@@@L7654_:
##@@@L7655_:        traceENTER_ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );   
##@@@L7656_:
##@@@L7657_:        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80007bd0:	50 38       	CMP       R5, #0			;->0x00
80007bd2:	20 5d       	PUSH      R0
80007bd4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007bd8:	08 00       	SYNC     SYNC     
80007bda:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007bde:	08 00       	SYNC     SYNC     
80007be0:	00 5d       	POP       R0
80007be2:	02 f0       	JZ        $+2                   ;->0x80007be6
80007be4:	78 04       	SJMP      $+120                 ;->0x80007cd4
80007be6:	22 59       	MOV       R9, R2
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6962
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80007be8:	34 47       	LD        R7, [PC + #52]        ;->0x80007cb8  :=0xd0000064
80007bea:	57 82       	LD.W      R5, [R7]
80007bec:	50 38       	CMP       R5, #0			;->0x00
80007bee:	07 f0       	JZ        $+7                   ;->0x80007bfc
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80007bf0:	33 45       	LD        R5, [PC + #51]        ;->0x80007cbc  :=0xd0000040
80007bf2:	45 82       	LD.W      R4, [R5]
80007bf4:	5c 9c       	LD.W      R3, [R4 + #17]
80007bf6:	5b c0       	ADD       R3, R3, #1
80007bf8:	63 a4       	ST.W      [R4 + #17], R3
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80007bfa:	55 82       	LD.W      R5, [R5]
##@@@F_:ulTaskGenericNotifyTake():
##@@@P_:tasks.c:7662
##@@@L7657_:        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
##@@@L7658_:
##@@@L7659_:        taskENTER_CRITICAL();   
##@@@L7660_:
##@@@L7661_:        /* Only block if the notification count is not already non-zero. */   
##@@@L7662_:        if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0UL )   
80007bfc:	30 46       	LD        R6, [PC + #48]        ;->0x80007cbc  :=0xd0000040
80007bfe:	56 82       	LD.W      R5, [R6]
80007c00:	2d 9f       	LD.W      R5, [R5 + #28]
80007c02:	50 38       	CMP       R5, #0			;->0x00
80007c04:	33 f0       	JZ        $+51                  ;->0x80007c6a
80007c06:	2f 45       	LD        R5, [PC + #47]        ;->0x80007cc0  :=0x80005730
80007c08:	05 5c       	LJMP      R5
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80007c0a:	20 5d       	PUSH      R0
80007c0c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007c10:	08 00       	SYNC     SYNC     
80007c12:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007c16:	08 00       	SYNC     SYNC     
80007c18:	00 5d       	POP       R0
80007c1a:	20 5d       	PUSH      R0
80007c1c:	21 5d       	PUSH      R1
80007c1e:	26 45       	LD        R5, [PC + #38]        ;->0x80007cb4  :=0x1ff
80007c20:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007c24:	25 58       	MOV       R1, R5
80007c26:	11 68       	NOT       R1, R1
80007c28:	01 69       	ANL       R0, R1
80007c2a:	5f 11       	MOV       R5, #31			;->0x001F
80007c2c:	25 58       	MOV       R1, R5
80007c2e:	01 6a       	ORL       R0, R1
80007c30:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007c34:	08 00       	SYNC     SYNC     
80007c36:	01 5d       	POP       R1
80007c38:	00 5d       	POP       R0
80007c3a:	20 5d       	PUSH      R0
80007c3c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007c40:	08 00       	SYNC     SYNC     
80007c42:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007c46:	08 00       	SYNC     SYNC     
80007c48:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80007c4a:	57 82       	LD.W      R5, [R7]
80007c4c:	50 38       	CMP       R5, #0			;->0x00
80007c4e:	06 f0       	JZ        $+6                   ;->0x80007c5a
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80007c50:	56 82       	LD.W      R5, [R6]
80007c52:	65 9c       	LD.W      R4, [R5 + #17]
80007c54:	64 c0       	ADD       R4, R4, #1
80007c56:	6c a4       	ST.W      [R5 + #17], R4
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80007c58:	56 82       	LD.W      R5, [R6]
##@@@F_:ulTaskGenericNotifyTake():
##@@@P_:tasks.c:7735
##@@@L7730_:        }   
##@@@L7731_:
##@@@L7732_:        taskENTER_CRITICAL();   
##@@@L7733_:        {   
##@@@L7734_:            traceTASK_NOTIFY_TAKE( uxIndexToWaitOn );   
##@@@L7735_:            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];   
80007c5a:	56 82       	LD.W      R5, [R6]
80007c5c:	3d 9f       	LD.W      R7, [R5 + #28]
##@@@P_:tasks.c:7737
##@@@L7736_:
##@@@L7737_:            if( ulReturn != 0UL )   
80007c5e:	70 38       	CMP       R7, #0			;->0x00
80007c60:	1f f0       	JZ        $+31                  ;->0x80007c9e
##@@@P_:tasks.c:7739
##@@@L7738_:            {   
##@@@L7739_:                if( xClearCountOnExit != pdFALSE )   
80007c62:	80 38       	CMP       R8, #0			;->0x00
80007c64:	1a f0       	JZ        $+26                  ;->0x80007c98
80007c66:	50 10       	MOV       R5, #0			;->0x0000
80007c68:	19 04       	SJMP      $+25                  ;->0x80007c9a
##@@@P_:tasks.c:7665
##@@@L7660_:
##@@@L7661_:        /* Only block if the notification count is not already non-zero. */   
##@@@L7662_:        if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0UL )   
##@@@L7663_:        {   
##@@@L7664_:            /* Mark this task as waiting for a notification. */   
##@@@L7665_:            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;   
80007c6a:	56 82       	LD.W      R5, [R6]
80007c6c:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:tasks.c:7667
##@@@L7666_:
##@@@L7667_:            if( xTicksToWait > ( TickType_t ) 0 )   
80007c6e:	90 38       	CMP       R9, #0			;->0x00
80007c70:	79 00 a4 d0 	ST.B      [R5 + #116], R4			;->0x74
80007c74:	c9 f0       	JZ        $-55                  ;->0x80007c06
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
80007c76:	14 45       	LD        R5, [PC + #20]        ;->0x80007cc4  :=0xd0000068
80007c78:	45 82       	LD.W      R4, [R5]
80007c7a:	64 c0       	ADD       R4, R4, #1
80007c7c:	54 85       	ST.W      [R5], R4
##@@@F_:ulTaskGenericNotifyTake():
##@@@P_:tasks.c:7707
##@@@L7702_:                 * 5. Resume scheduler moves the task from pendingReady list to   
##@@@L7703_:                 *    the Ready list.   
##@@@L7704_:                 */   
##@@@L7705_:                vTaskSuspendAll();   
##@@@L7706_:                {   
##@@@L7707_:                    taskEXIT_CRITICAL();   
80007c7e:	11 45       	LD        R5, [PC + #17]        ;->0x80007cc0  :=0x80005730
80007c80:	05 5c       	LJMP      R5
80007c82:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:tasks.c:7709
##@@@L7708_:
##@@@L7709_:                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );   
80007c84:	09 58       	MOV       R0, R9
80007c86:	11 45       	LD        R5, [PC + #17]        ;->0x80007cc8  :=0x800059c0
80007c88:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7711
##@@@L7710_:                }   
##@@@L7711_:                xAlreadyYielded = xTaskResumeAll();   
80007c8a:	11 45       	LD        R5, [PC + #17]        ;->0x80007ccc  :=0x80005a70
80007c8c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7713
##@@@L7712_:
##@@@L7713_:                if( xAlreadyYielded == pdFALSE )   
80007c8e:	00 38       	CMP       R0, #0			;->0x00
80007c90:	bd f1       	JNZ       $-67                  ;->0x80007c0a
##@@@P_:tasks.c:7715
##@@@L7714_:                {   
##@@@L7715_:                    taskYIELD_WITHIN_API();   
80007c92:	10 45       	LD        R5, [PC + #16]        ;->0x80007cd0  :=0x80008f64
80007c94:	05 5c       	LJMP      R5
80007c96:	ba 07       	SJMP      $-70                  ;->0x80007c0a
80007c98:	6f cc       	SUB       R5, R7, #1
80007c9a:	46 82       	LD.W      R4, [R6]
80007c9c:	25 a7       	ST.W      [R4 + #28], R5
##@@@P_:tasks.c:7753
##@@@L7748_:            else   
##@@@L7749_:            {   
##@@@L7750_:                mtCOVERAGE_TEST_MARKER();   
##@@@L7751_:            }   
##@@@L7752_:
##@@@L7753_:            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;   
80007c9e:	56 82       	LD.W      R5, [R6]
80007ca0:	40 10       	MOV       R4, #0			;->0x0000
80007ca2:	79 00 a4 d0 	ST.B      [R5 + #116], R4			;->0x74
##@@@P_:tasks.c:7755
##@@@L7754_:        }   
##@@@L7755_:        taskEXIT_CRITICAL();   
80007ca6:	07 45       	LD        R5, [PC + #7]         ;->0x80007cc0  :=0x80005730
80007ca8:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7759
##@@@L7756_:
##@@@L7757_:        traceRETURN_ulTaskGenericNotifyTake( ulReturn );   
##@@@L7758_:
##@@@L7759_:        return ulReturn;   
80007caa:	07 58       	MOV       R0, R7
80007cac:	e4 28       	ADD       SP, #4			;->0x04
80007cae:	0f 5e       	POP       {R6-R9}
80007cb0:	0d 5d       	POP       LR
80007cb2:	1d 5c       	JMP       LR
80007cb4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80007cb8:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80007cbc:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80007cc0:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80007cc0
80007cc4:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80007cc8:	c0 59 00 80 	.long     0x800059c0 ->-2147460672  [!!!@2@:MOV       SP, R0	@@: LD.B      R0, [R0]
80007ccc:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80007cd0:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:7657
##@@@L7652_:        uint32_t ulReturn;   
##@@@L7653_:        BaseType_t xAlreadyYielded;   
##@@@L7654_:
##@@@L7655_:        traceENTER_ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );   
##@@@L7656_:
##@@@L7657_:        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80007cd4:	07 00       	BREAK    BREAK    
80007cd6:	02 45       	LD        R5, [PC + #2]         ;->0x80007cdc  :=0x8000911c
80007cd8:	05 5c       	LJMP      R5
80007cda:	00 00       	NOP      NOP      
80007cdc:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80007ce0 <xTaskGenericNotifyWait>:
##@@@F_:xTaskGenericNotifyWait():
##@@@P_:tasks.c:7772
##@@@L7767_:    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,   
##@@@L7768_:                                       uint32_t ulBitsToClearOnEntry,   
##@@@L7769_:                                       uint32_t ulBitsToClearOnExit,   
##@@@L7770_:                                       uint32_t * pulNotificationValue,   
##@@@L7771_:                                       TickType_t xTicksToWait )   
##@@@L7772_:    {   
80007ce0:	9f 5f       	PUSH      {R6-R10,LR}
80007ce2:	e4 30       	SUB       SP, #4			;->0x04
80007ce4:	04 59       	MOV       R8, R4
80007ce6:	43 59       	MOV       R10, R3
80007ce8:	a1 58       	MOV       R5, R1
80007cea:	80 58       	MOV       R4, R0
80007cec:	20 5d       	PUSH      R0
80007cee:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007cf2:	08 00       	SYNC     SYNC     
80007cf4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007cf8:	08 00       	SYNC     SYNC     
80007cfa:	00 5d       	POP       R0
80007cfc:	20 5d       	PUSH      R0
80007cfe:	21 5d       	PUSH      R1
80007d00:	46 43       	LD        R3, [PC + #70]        ;->0x80007e18  :=0x1ff
80007d02:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007d06:	23 58       	MOV       R1, R3
80007d08:	11 68       	NOT       R1, R1
80007d0a:	01 69       	ANL       R0, R1
80007d0c:	3f 11       	MOV       R3, #31			;->0x001F
80007d0e:	23 58       	MOV       R1, R3
80007d10:	01 6a       	ORL       R0, R1
80007d12:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007d16:	08 00       	SYNC     SYNC     
80007d18:	01 5d       	POP       R1
80007d1a:	00 5d       	POP       R0
##@@@P_:tasks.c:7777
##@@@L7773_:        BaseType_t xReturn, xAlreadyYielded;   
##@@@L7774_:
##@@@L7775_:        traceENTER_xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );   
##@@@L7776_:
##@@@L7777_:        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80007d1c:	40 38       	CMP       R4, #0			;->0x00
80007d1e:	20 5d       	PUSH      R0
80007d20:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007d24:	08 00       	SYNC     SYNC     
80007d26:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007d2a:	08 00       	SYNC     SYNC     
80007d2c:	00 5d       	POP       R0
80007d2e:	02 f0       	JZ        $+2                   ;->0x80007d32
80007d30:	84 04       	SJMP      $+132                 ;->0x80007e38
80007d32:	22 59       	MOV       R9, R2
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6962
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80007d34:	3a 47       	LD        R7, [PC + #58]        ;->0x80007e1c  :=0xd0000064
80007d36:	47 82       	LD.W      R4, [R7]
80007d38:	40 38       	CMP       R4, #0			;->0x00
80007d3a:	07 f0       	JZ        $+7                   ;->0x80007d48
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80007d3c:	39 44       	LD        R4, [PC + #57]        ;->0x80007e20  :=0xd0000040
80007d3e:	34 82       	LD.W      R3, [R4]
80007d40:	53 9c       	LD.W      R2, [R3 + #17]
80007d42:	52 c0       	ADD       R2, R2, #1
80007d44:	5a a4       	ST.W      [R3 + #17], R2
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80007d46:	44 82       	LD.W      R4, [R4]
##@@@F_:xTaskGenericNotifyWait():
##@@@P_:tasks.c:7782
##@@@L7777_:        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
##@@@L7778_:
##@@@L7779_:        taskENTER_CRITICAL();   
##@@@L7780_:
##@@@L7781_:        /* Only block if a notification is not already pending. */   
##@@@L7782_:        if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )   
80007d48:	36 46       	LD        R6, [PC + #54]        ;->0x80007e20  :=0xd0000040
80007d4a:	46 82       	LD.W      R4, [R6]
80007d4c:	51 00 84 d0 	LD.B      R4, [R4 + #116]			;->0x74
80007d50:	42 38       	CMP       R4, #2			;->0x02
80007d52:	1d f0       	JZ        $+29                  ;->0x80007d8c
##@@@P_:tasks.c:7787
##@@@L7783_:        {   
##@@@L7784_:            /* Clear bits in the task's notification value as bits may get   
##@@@L7785_:             * set  by the notifying task or interrupt.  This can be used to   
##@@@L7786_:             * clear the value to zero. */   
##@@@L7787_:            pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;   
80007d54:	46 82       	LD.W      R4, [R6]
80007d56:	1c 9f       	LD.W      R3, [R4 + #28]
80007d58:	55 68       	NOT       R5, R5
80007d5a:	35 69       	ANL       R3, R5
80007d5c:	23 a7       	ST.W      [R4 + #28], R3
##@@@P_:tasks.c:7790
##@@@L7788_:
##@@@L7789_:            /* Mark this task as waiting for a notification. */   
##@@@L7790_:            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;   
80007d5e:	56 82       	LD.W      R5, [R6]
80007d60:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:tasks.c:7792
##@@@L7791_:
##@@@L7792_:            if( xTicksToWait > ( TickType_t ) 0 )   
80007d62:	80 38       	CMP       R8, #0			;->0x00
80007d64:	79 00 a4 d0 	ST.B      [R5 + #116], R4			;->0x74
80007d68:	12 f0       	JZ        $+18                  ;->0x80007d8c
##@@@F_:vTaskSuspendAll():
##@@@P_:tasks.c:3792
##@@@L3787_:         * do not otherwise exhibit real time behaviour. */   
##@@@L3788_:        portSOFTWARE_BARRIER();   
##@@@L3789_:
##@@@L3790_:        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment   
##@@@L3791_:         * is used to allow calls to vTaskSuspendAll() to nest. */   
##@@@L3792_:        ++uxSchedulerSuspended;   
80007d6a:	2f 45       	LD        R5, [PC + #47]        ;->0x80007e24  :=0xd0000068
80007d6c:	45 82       	LD.W      R4, [R5]
80007d6e:	64 c0       	ADD       R4, R4, #1
80007d70:	54 85       	ST.W      [R5], R4
##@@@F_:xTaskGenericNotifyWait():
##@@@P_:tasks.c:7832
##@@@L7827_:                 * 5. Resume scheduler moves the task from pendingReady list to   
##@@@L7828_:                 *    the Ready list.   
##@@@L7829_:                 */   
##@@@L7830_:                vTaskSuspendAll();   
##@@@L7831_:                {   
##@@@L7832_:                    taskEXIT_CRITICAL();   
80007d72:	2e 45       	LD        R5, [PC + #46]        ;->0x80007e28  :=0x80005730
80007d74:	05 5c       	LJMP      R5
80007d76:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:tasks.c:7834
##@@@L7833_:
##@@@L7834_:                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );   
80007d78:	08 58       	MOV       R0, R8
80007d7a:	2d 45       	LD        R5, [PC + #45]        ;->0x80007e2c  :=0x800059c0
80007d7c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7836
##@@@L7835_:                }   
##@@@L7836_:                xAlreadyYielded = xTaskResumeAll();   
80007d7e:	2d 45       	LD        R5, [PC + #45]        ;->0x80007e30  :=0x80005a70
80007d80:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7838
##@@@L7837_:
##@@@L7838_:                if( xAlreadyYielded == pdFALSE )   
80007d82:	00 38       	CMP       R0, #0			;->0x00
80007d84:	06 f1       	JNZ       $+6                   ;->0x80007d90
##@@@P_:tasks.c:7840
##@@@L7839_:                {   
##@@@L7840_:                    taskYIELD_WITHIN_API();   
80007d86:	2c 45       	LD        R5, [PC + #44]        ;->0x80007e34  :=0x80008f64
80007d88:	05 5c       	LJMP      R5
80007d8a:	03 04       	SJMP      $+3                   ;->0x80007d90
80007d8c:	27 45       	LD        R5, [PC + #39]        ;->0x80007e28  :=0x80005730
80007d8e:	05 5c       	LJMP      R5
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80007d90:	20 5d       	PUSH      R0
80007d92:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007d96:	08 00       	SYNC     SYNC     
80007d98:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007d9c:	08 00       	SYNC     SYNC     
80007d9e:	00 5d       	POP       R0
80007da0:	20 5d       	PUSH      R0
80007da2:	21 5d       	PUSH      R1
80007da4:	1d 45       	LD        R5, [PC + #29]        ;->0x80007e18  :=0x1ff
80007da6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007daa:	25 58       	MOV       R1, R5
80007dac:	11 68       	NOT       R1, R1
80007dae:	01 69       	ANL       R0, R1
80007db0:	5f 11       	MOV       R5, #31			;->0x001F
80007db2:	25 58       	MOV       R1, R5
80007db4:	01 6a       	ORL       R0, R1
80007db6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007dba:	08 00       	SYNC     SYNC     
80007dbc:	01 5d       	POP       R1
80007dbe:	00 5d       	POP       R0
80007dc0:	20 5d       	PUSH      R0
80007dc2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007dc6:	08 00       	SYNC     SYNC     
80007dc8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007dcc:	08 00       	SYNC     SYNC     
80007dce:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80007dd0:	57 82       	LD.W      R5, [R7]
80007dd2:	50 38       	CMP       R5, #0			;->0x00
80007dd4:	06 f0       	JZ        $+6                   ;->0x80007de0
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80007dd6:	56 82       	LD.W      R5, [R6]
80007dd8:	65 9c       	LD.W      R4, [R5 + #17]
80007dda:	64 c0       	ADD       R4, R4, #1
80007ddc:	6c a4       	ST.W      [R5 + #17], R4
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80007dde:	56 82       	LD.W      R5, [R6]
##@@@F_:xTaskGenericNotifyWait():
##@@@P_:tasks.c:7861
##@@@L7856_:
##@@@L7857_:        taskENTER_CRITICAL();   
##@@@L7858_:        {   
##@@@L7859_:            traceTASK_NOTIFY_WAIT( uxIndexToWaitOn );   
##@@@L7860_:
##@@@L7861_:            if( pulNotificationValue != NULL )   
80007de0:	a0 38       	CMP       R10, #0			;->0x00
80007de2:	04 f0       	JZ        $+4                   ;->0x80007dea
##@@@P_:tasks.c:7865
##@@@L7862_:            {   
##@@@L7863_:                /* Output the current notification value, which may or may not   
##@@@L7864_:                 * have changed. */   
##@@@L7865_:                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];   
80007de4:	56 82       	LD.W      R5, [R6]
80007de6:	2d 9f       	LD.W      R5, [R5 + #28]
80007de8:	a5 85       	ST.W      [R10], R5
##@@@P_:tasks.c:7872
##@@@L7867_:
##@@@L7868_:            /* If ucNotifyValue is set then either the task never entered the   
##@@@L7869_:             * blocked state (because a notification was already pending) or the   
##@@@L7870_:             * task unblocked because of a notification.  Otherwise the task   
##@@@L7871_:             * unblocked because of a timeout. */   
##@@@L7872_:            if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )   
80007dea:	56 82       	LD.W      R5, [R6]
80007dec:	51 00 a4 d0 	LD.B      R4, [R5 + #116]			;->0x74
80007df0:	50 10       	MOV       R5, #0			;->0x0000
80007df2:	42 38       	CMP       R4, #2			;->0x02
80007df4:	e5 58       	MOV       R7, R5
80007df6:	07 f1       	JNZ       $+7                   ;->0x80007e04
##@@@P_:tasks.c:7881
##@@@L7876_:            }   
##@@@L7877_:            else   
##@@@L7878_:            {   
##@@@L7879_:                /* A notification was already pending or a notification was   
##@@@L7880_:                 * received while the task was waiting. */   
##@@@L7881_:                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;   
80007df8:	46 82       	LD.W      R4, [R6]
80007dfa:	1c 9f       	LD.W      R3, [R4 + #28]
80007dfc:	29 68       	NOT       R2, R9
80007dfe:	32 69       	ANL       R3, R2
80007e00:	23 a7       	ST.W      [R4 + #28], R3
80007e02:	71 10       	MOV       R7, #1			;->0x0001
##@@@P_:tasks.c:7885
##@@@L7882_:                xReturn = pdTRUE;   
##@@@L7883_:            }   
##@@@L7884_:
##@@@L7885_:            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;   
80007e04:	46 82       	LD.W      R4, [R6]
80007e06:	79 00 85 d0 	ST.B      [R4 + #116], R5			;->0x74
##@@@P_:tasks.c:7887
##@@@L7886_:        }   
##@@@L7887_:        taskEXIT_CRITICAL();   
80007e0a:	08 45       	LD        R5, [PC + #8]         ;->0x80007e28  :=0x80005730
80007e0c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7891
##@@@L7888_:
##@@@L7889_:        traceRETURN_xTaskGenericNotifyWait( xReturn );   
##@@@L7890_:
##@@@L7891_:        return xReturn;   
80007e0e:	07 58       	MOV       R0, R7
80007e10:	e4 28       	ADD       SP, #4			;->0x04
80007e12:	1f 5e       	POP       {R6-R10}
80007e14:	0d 5d       	POP       LR
80007e16:	1d 5c       	JMP       LR
80007e18:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80007e1c:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80007e20:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80007e24:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80007e28:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80007e28
80007e2c:	c0 59 00 80 	.long     0x800059c0 ->-2147460672  [!!!@2@:MOV       SP, R0	@@: LD.B      R0, [R0]
80007e30:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80007e34:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:7777
##@@@L7772_:    {   
##@@@L7773_:        BaseType_t xReturn, xAlreadyYielded;   
##@@@L7774_:
##@@@L7775_:        traceENTER_xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );   
##@@@L7776_:
##@@@L7777_:        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80007e38:	07 00       	BREAK    BREAK    
80007e3a:	02 45       	LD        R5, [PC + #2]         ;->0x80007e40  :=0x8000911c
80007e3c:	05 5c       	LJMP      R5
80007e3e:	00 00       	NOP      NOP      
80007e40:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80007e44 <xTaskGenericNotify>:
##@@@F_:xTaskGenericNotify():
##@@@P_:tasks.c:7904
##@@@L7899_:    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,   
##@@@L7900_:                                   UBaseType_t uxIndexToNotify,   
##@@@L7901_:                                   uint32_t ulValue,   
##@@@L7902_:                                   eNotifyAction eAction,   
##@@@L7903_:                                   uint32_t * pulPreviousNotificationValue )   
##@@@L7904_:    {   
80007e44:	83 5f       	PUSH      {R6-R7,LR}
80007e46:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:7911
##@@@L7906_:        BaseType_t xReturn = pdPASS;   
##@@@L7907_:        uint8_t ucOriginalNotifyState;   
##@@@L7908_:
##@@@L7909_:        traceENTER_xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );   
##@@@L7910_:
##@@@L7911_:        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80007e48:	10 38       	CMP       R1, #0			;->0x00
80007e4a:	02 f0       	JZ        $+2                   ;->0x80007e4e
80007e4c:	a2 04       	SJMP      $+162                 ;->0x80007f90
80007e4e:	a0 58       	MOV       R5, R0
80007e50:	20 5d       	PUSH      R0
80007e52:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007e56:	08 00       	SYNC     SYNC     
80007e58:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007e5c:	08 00       	SYNC     SYNC     
80007e5e:	00 5d       	POP       R0
80007e60:	20 5d       	PUSH      R0
80007e62:	21 5d       	PUSH      R1
80007e64:	42 46       	LD        R6, [PC + #66]        ;->0x80007f6c  :=0x1ff
80007e66:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007e6a:	26 58       	MOV       R1, R6
80007e6c:	11 68       	NOT       R1, R1
80007e6e:	01 69       	ANL       R0, R1
80007e70:	0f 11       	MOV       R0, #31			;->0x001F
80007e72:	20 58       	MOV       R1, R0
80007e74:	01 6a       	ORL       R0, R1
80007e76:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007e7a:	08 00       	SYNC     SYNC     
80007e7c:	01 5d       	POP       R1
80007e7e:	00 5d       	POP       R0
##@@@P_:tasks.c:7912
##@@@L7912_:        configASSERT( xTaskToNotify );   
80007e80:	50 38       	CMP       R5, #0			;->0x00
80007e82:	20 5d       	PUSH      R0
80007e84:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007e88:	08 00       	SYNC     SYNC     
80007e8a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007e8e:	08 00       	SYNC     SYNC     
80007e90:	00 5d       	POP       R0
80007e92:	02 f1       	JNZ       $+2                   ;->0x80007e96
80007e94:	a1 04       	SJMP      $+161                 ;->0x80007fd6
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6962
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
80007e96:	37 41       	LD        R1, [PC + #55]        ;->0x80007f70  :=0xd0000064
80007e98:	11 82       	LD.W      R1, [R1]
80007e9a:	10 38       	CMP       R1, #0			;->0x00
80007e9c:	07 f0       	JZ        $+7                   ;->0x80007eaa
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
80007e9e:	36 41       	LD        R1, [PC + #54]        ;->0x80007f74  :=0xd0000040
80007ea0:	01 82       	LD.W      R0, [R1]
80007ea2:	70 9c       	LD.W      R6, [R0 + #17]
80007ea4:	76 c0       	ADD       R6, R6, #1
80007ea6:	46 a4       	ST.W      [R0 + #17], R6
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80007ea8:	11 82       	LD.W      R1, [R1]
##@@@F_:xTaskGenericNotify():
##@@@P_:tasks.c:7917
##@@@L7912_:        configASSERT( xTaskToNotify );   
##@@@L7913_:        pxTCB = xTaskToNotify;   
##@@@L7914_:
##@@@L7915_:        taskENTER_CRITICAL();   
##@@@L7916_:        {   
##@@@L7917_:            if( pulPreviousNotificationValue != NULL )   
80007eaa:	40 38       	CMP       R4, #0			;->0x00
80007eac:	03 f0       	JZ        $+3                   ;->0x80007eb2
##@@@P_:tasks.c:7919
##@@@L7918_:            {   
##@@@L7919_:                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];   
80007eae:	0d 9f       	LD.W      R1, [R5 + #28]
80007eb0:	41 85       	ST.W      [R4], R1
80007eb2:	51 00 a4 d0 	LD.B      R4, [R5 + #116]			;->0x74
##@@@P_:tasks.c:7922
##@@@L7920_:            }   
##@@@L7921_:
##@@@L7922_:            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];   
80007eb6:	44 62       	SXT.B     R4, R4
80007eb8:	12 10       	MOV       R1, #2			;->0x0002
##@@@P_:tasks.c:7926
##@@@L7923_:
##@@@L7924_:            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;   
##@@@L7925_:
##@@@L7926_:            switch( eAction )   
80007eba:	34 38       	CMP       R3, #4			;->0x04
80007ebc:	79 00 a1 d0 	ST.B      [R5 + #116], R1			;->0x74
80007ec0:	15 f8       	JHI       $+21                  ;->0x80007eea
80007ec2:	2e 41       	LD        R1, [PC + #46]        ;->0x80007f78  :=0x80000f40
80007ec4:	1a 7a       	LSL       R3, #2			;->0x02
80007ec6:	d9 e8       	LD.W      R3, [R1 + R3]
80007ec8:	13 5c       	JMP       R3
##@@@P_:tasks.c:7929
##@@@L7927_:            {   
##@@@L7928_:                case eSetBits:   
##@@@L7929_:                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;   
80007eca:	1d 9f       	LD.W      R3, [R5 + #28]
80007ecc:	32 6a       	ORL       R3, R2
80007ece:	03 04       	SJMP      $+3                   ;->0x80007ed4
##@@@P_:tasks.c:7933
##@@@L7930_:                    break;   
##@@@L7931_:
##@@@L7932_:                case eIncrement:   
##@@@L7933_:                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;   
80007ed0:	1d 9f       	LD.W      R3, [R5 + #28]
80007ed2:	5b c0       	ADD       R3, R3, #1
80007ed4:	2b a7       	ST.W      [R5 + #28], R3
80007ed6:	0f 04       	SJMP      $+15                  ;->0x80007ef4
80007ed8:	3f 1f       	MOV       R3, #255			;->0x00FF
##@@@P_:tasks.c:7942
##@@@L7937_:                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;   
##@@@L7938_:                    break;   
##@@@L7939_:
##@@@L7940_:                case eSetValueWithoutOverwrite:   
##@@@L7941_:
##@@@L7942_:                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )   
80007eda:	24 58       	MOV       R1, R4
80007edc:	13 69       	ANL       R1, R3
80007ede:	12 38       	CMP       R1, #2			;->0x02
80007ee0:	03 f1       	JNZ       $+3                   ;->0x80007ee6
80007ee2:	60 10       	MOV       R6, #0			;->0x0000
80007ee4:	3c 04       	SJMP      $+60                  ;->0x80007f5c
80007ee6:	2a a7       	ST.W      [R5 + #28], R2
80007ee8:	06 04       	SJMP      $+6                   ;->0x80007ef4
##@@@P_:tasks.c:7965
##@@@L7960_:                default:   
##@@@L7961_:
##@@@L7962_:                    /* Should not get here if all enums are handled.   
##@@@L7963_:                     * Artificially force an assert by testing a value the   
##@@@L7964_:                     * compiler can't assume is const. */   
##@@@L7965_:                    configASSERT( xTickCount == ( TickType_t ) 0 );   
80007eea:	25 43       	LD        R3, [PC + #37]        ;->0x80007f7c  :=0xd000006c
80007eec:	33 82       	LD.W      R3, [R3]
80007eee:	30 38       	CMP       R3, #0			;->0x00
80007ef0:	02 f0       	JZ        $+2                   ;->0x80007ef4
80007ef2:	98 04       	SJMP      $+152                 ;->0x80008022
80007ef4:	3f 1f       	MOV       R3, #255			;->0x00FF
##@@@P_:tasks.c:7974
##@@@L7969_:
##@@@L7970_:            traceTASK_NOTIFY( uxIndexToNotify );   
##@@@L7971_:
##@@@L7972_:            /* If the task is in the blocked state specifically to wait for a   
##@@@L7973_:             * notification then unblock it now. */   
##@@@L7974_:            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )   
80007ef6:	43 69       	ANL       R4, R3
80007ef8:	41 38       	CMP       R4, #1			;->0x01
80007efa:	30 f1       	JNZ       $+48                  ;->0x80007f5a
##@@@P_:tasks.c:7976
##@@@L7975_:            {   
##@@@L7976_:                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
80007efc:	9d 98       	LD.W      R3, [R5 + #2]
80007efe:	d5 98       	LD.W      R2, [R5 + #3]
80007f00:	65 99       	LD.W      R4, [R5 + #5]
80007f02:	9a a0       	ST.W      [R3 + #2], R2
80007f04:	d5 98       	LD.W      R2, [R5 + #3]
80007f06:	53 a0       	ST.W      [R2 + #1], R3
80007f08:	4c 98       	LD.W      R1, [R4 + #1]
80007f0a:	1d c1       	ADD       R3, R5, #4
80007f0c:	13 70       	CMP       R1, R3
80007f0e:	02 f1       	JNZ       $+2                   ;->0x80007f12
80007f10:	62 a0       	ST.W      [R4 + #1], R2
80007f12:	24 82       	LD.W      R2, [R4]
80007f14:	52 cc       	SUB       R2, R2, #1
80007f16:	42 85       	ST.W      [R4], R2
##@@@P_:tasks.c:7977
##@@@L7977_:                prvAddTaskToReadyList( pxTCB );   
80007f18:	1a 42       	LD        R2, [PC + #26]        ;->0x80007f80  :=0xd00002f8
80007f1a:	e5 9a       	LD.W      R4, [R5 + #11]
80007f1c:	12 82       	LD.W      R1, [R2]
80007f1e:	41 70       	CMP       R4, R1
80007f20:	02 f9       	JLS       $+2                   ;->0x80007f24
80007f22:	24 85       	ST.W      [R2], R4
80007f24:	18 42       	LD        R2, [PC + #24]        ;->0x80007f84  :=0xd00000a0
80007f26:	14 11       	MOV       R1, #20			;->0x0014
80007f28:	02 58       	MOV       R0, R2
80007f2a:	19 00 81 00 	MADD32    R0, R4, R1
80007f2e:	70 98       	LD.W      R6, [R0 + #1]
80007f30:	ae a0       	ST.W      [R5 + #2], R6
80007f32:	be 98       	LD.W      R7, [R6 + #2]
80007f34:	ef a0       	ST.W      [R5 + #3], R7
80007f36:	be 98       	LD.W      R7, [R6 + #2]
80007f38:	7b a0       	ST.W      [R7 + #1], R3
80007f3a:	b3 a0       	ST.W      [R6 + #2], R3
80007f3c:	5c ca       	MULS      R3, R4, R1
80007f3e:	68 a1       	ST.W      [R5 + #5], R0
80007f40:	ca e8       	LD.W      R1, [R2 + R3]
80007f42:	49 c0       	ADD       R1, R1, #1
80007f44:	d1 ee       	ST.W      [R2 + R3], R1
##@@@P_:tasks.c:7980
##@@@L7978_:
##@@@L7979_:                /* The task should not have been on an event list. */   
##@@@L7980_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
80007f46:	ad 9a       	LD.W      R5, [R5 + #10]
80007f48:	50 38       	CMP       R5, #0			;->0x00
80007f4a:	49 f1       	JNZ       $+73                  ;->0x80007fdc
##@@@P_:tasks.c:8000
##@@@L7995_:                }   
##@@@L7996_:                #endif   
##@@@L7997_:
##@@@L7998_:                /* Check if the notified task has a priority above the currently   
##@@@L7999_:                 * executing task. */   
##@@@L8000_:                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );   
80007f4c:	0a 45       	LD        R5, [PC + #10]        ;->0x80007f74  :=0xd0000040
80007f4e:	55 82       	LD.W      R5, [R5]
80007f50:	ed 9a       	LD.W      R5, [R5 + #11]
80007f52:	54 70       	CMP       R5, R4
80007f54:	03 f2       	JC        $+3                   ;->0x80007f5a
80007f56:	0d 45       	LD        R5, [PC + #13]        ;->0x80007f88  :=0x80008f64
80007f58:	05 5c       	LJMP      R5
80007f5a:	61 10       	MOV       R6, #1			;->0x0001
##@@@P_:tasks.c:8007
##@@@L8002_:            else   
##@@@L8003_:            {   
##@@@L8004_:                mtCOVERAGE_TEST_MARKER();   
##@@@L8005_:            }   
##@@@L8006_:        }   
##@@@L8007_:        taskEXIT_CRITICAL();   
80007f5c:	0c 45       	LD        R5, [PC + #12]        ;->0x80007f8c  :=0x80005730
80007f5e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8011
##@@@L8008_:
##@@@L8009_:        traceRETURN_xTaskGenericNotify( xReturn );   
##@@@L8010_:
##@@@L8011_:        return xReturn;   
80007f60:	06 58       	MOV       R0, R6
80007f62:	e4 28       	ADD       SP, #4			;->0x04
80007f64:	03 5e       	POP       {R6-R7}
80007f66:	0d 5d       	POP       LR
80007f68:	1d 5c       	JMP       LR
80007f6a:	00 00       	NOP      NOP      
80007f6c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80007f70:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80007f74:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80007f78:	40 0f 00 80 	.long     0x80000f40 ->-2147479744  [!!!@2@:LD.W      R7, [SP + #64]	@@: LD.B      R0, [R0]
80007f7c:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
80007f80:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
80007f84:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
80007f88:	64 8f 00 80 	.long     0x80008f64 ->-2147446940  [!!!@2@:LD.B      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80007f8c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80007f8c
##@@@P_:tasks.c:7911
##@@@L7906_:        BaseType_t xReturn = pdPASS;   
##@@@L7907_:        uint8_t ucOriginalNotifyState;   
##@@@L7908_:
##@@@L7909_:        traceENTER_xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );   
##@@@L7910_:
##@@@L7911_:        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80007f90:	20 5d       	PUSH      R0
80007f92:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007f96:	08 00       	SYNC     SYNC     
80007f98:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007f9c:	08 00       	SYNC     SYNC     
80007f9e:	00 5d       	POP       R0
80007fa0:	20 5d       	PUSH      R0
80007fa2:	21 5d       	PUSH      R1
80007fa4:	31 45       	LD        R5, [PC + #49]        ;->0x80008068  :=0x1ff
80007fa6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007faa:	25 58       	MOV       R1, R5
80007fac:	11 68       	NOT       R1, R1
80007fae:	01 69       	ANL       R0, R1
80007fb0:	5f 11       	MOV       R5, #31			;->0x001F
80007fb2:	25 58       	MOV       R1, R5
80007fb4:	01 6a       	ORL       R0, R1
80007fb6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80007fba:	08 00       	SYNC     SYNC     
80007fbc:	01 5d       	POP       R1
80007fbe:	00 5d       	POP       R0
80007fc0:	20 5d       	PUSH      R0
80007fc2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007fc6:	08 00       	SYNC     SYNC     
80007fc8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80007fcc:	08 00       	SYNC     SYNC     
80007fce:	00 5d       	POP       R0
80007fd0:	07 00       	BREAK    BREAK    
80007fd2:	27 45       	LD        R5, [PC + #39]        ;->0x8000806c  :=0x8000911c
80007fd4:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7912
##@@@L7912_:        configASSERT( xTaskToNotify );   
80007fd6:	07 00       	BREAK    BREAK    
80007fd8:	25 45       	LD        R5, [PC + #37]        ;->0x8000806c  :=0x8000911c
80007fda:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7980
##@@@L7975_:            {   
##@@@L7976_:                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
##@@@L7977_:                prvAddTaskToReadyList( pxTCB );   
##@@@L7978_:
##@@@L7979_:                /* The task should not have been on an event list. */   
##@@@L7980_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
80007fdc:	20 5d       	PUSH      R0
80007fde:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80007fe2:	08 00       	SYNC     SYNC     
80007fe4:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80007fe8:	08 00       	SYNC     SYNC     
80007fea:	00 5d       	POP       R0
80007fec:	20 5d       	PUSH      R0
80007fee:	21 5d       	PUSH      R1
80007ff0:	1e 45       	LD        R5, [PC + #30]        ;->0x80008068  :=0x1ff
80007ff2:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80007ff6:	25 58       	MOV       R1, R5
80007ff8:	11 68       	NOT       R1, R1
80007ffa:	01 69       	ANL       R0, R1
80007ffc:	5f 11       	MOV       R5, #31			;->0x001F
80007ffe:	25 58       	MOV       R1, R5
80008000:	01 6a       	ORL       R0, R1
80008002:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008006:	08 00       	SYNC     SYNC     
80008008:	01 5d       	POP       R1
8000800a:	00 5d       	POP       R0
8000800c:	20 5d       	PUSH      R0
8000800e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008012:	08 00       	SYNC     SYNC     
80008014:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008018:	08 00       	SYNC     SYNC     
8000801a:	00 5d       	POP       R0
8000801c:	07 00       	BREAK    BREAK    
8000801e:	14 45       	LD        R5, [PC + #20]        ;->0x8000806c  :=0x8000911c
80008020:	05 5c       	LJMP      R5
##@@@P_:tasks.c:7965
##@@@L7960_:                default:   
##@@@L7961_:
##@@@L7962_:                    /* Should not get here if all enums are handled.   
##@@@L7963_:                     * Artificially force an assert by testing a value the   
##@@@L7964_:                     * compiler can't assume is const. */   
##@@@L7965_:                    configASSERT( xTickCount == ( TickType_t ) 0 );   
80008022:	20 5d       	PUSH      R0
80008024:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008028:	08 00       	SYNC     SYNC     
8000802a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000802e:	08 00       	SYNC     SYNC     
80008030:	00 5d       	POP       R0
80008032:	20 5d       	PUSH      R0
80008034:	21 5d       	PUSH      R1
80008036:	0d 45       	LD        R5, [PC + #13]        ;->0x80008068  :=0x1ff
80008038:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000803c:	25 58       	MOV       R1, R5
8000803e:	11 68       	NOT       R1, R1
80008040:	01 69       	ANL       R0, R1
80008042:	5f 11       	MOV       R5, #31			;->0x001F
80008044:	25 58       	MOV       R1, R5
80008046:	01 6a       	ORL       R0, R1
80008048:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000804c:	08 00       	SYNC     SYNC     
8000804e:	01 5d       	POP       R1
80008050:	00 5d       	POP       R0
80008052:	20 5d       	PUSH      R0
80008054:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008058:	08 00       	SYNC     SYNC     
8000805a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000805e:	08 00       	SYNC     SYNC     
80008060:	00 5d       	POP       R0
80008062:	07 00       	BREAK    BREAK    
80008064:	02 45       	LD        R5, [PC + #2]         ;->0x8000806c  :=0x8000911c
80008066:	05 5c       	LJMP      R5
80008068:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000806c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80008070 <xTaskGenericNotifyFromISR>:
##@@@F_:xTaskGenericNotifyFromISR():
##@@@P_:tasks.c:8025
##@@@L8020_:                                          UBaseType_t uxIndexToNotify,   
##@@@L8021_:                                          uint32_t ulValue,   
##@@@L8022_:                                          eNotifyAction eAction,   
##@@@L8023_:                                          uint32_t * pulPreviousNotificationValue,   
##@@@L8024_:                                          BaseType_t * pxHigherPriorityTaskWoken )   
##@@@L8025_:    {   
80008070:	8f 5f       	PUSH      {R6-R9,LR}
80008072:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:tasks.c:8033
##@@@L8028_:        BaseType_t xReturn = pdPASS;   
##@@@L8029_:        UBaseType_t uxSavedInterruptStatus;   
##@@@L8030_:
##@@@L8031_:        traceENTER_xTaskGenericNotifyFromISR( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken );   
##@@@L8032_:
##@@@L8033_:        configASSERT( xTaskToNotify );   
80008074:	00 38       	CMP       R0, #0			;->0x00
80008076:	02 f1       	JNZ       $+2                   ;->0x8000807a
80008078:	9c 04       	SJMP      $+156                 ;->0x800081b0
8000807a:	01 22       	ST.W      [SP + #1], R2
##@@@P_:tasks.c:8034
##@@@L8034_:        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
8000807c:	10 38       	CMP       R1, #0			;->0x00
8000807e:	02 f0       	JZ        $+2                   ;->0x80008082
80008080:	bb 04       	SJMP      $+187                 ;->0x800081f6
80008082:	c0 58       	MOV       R6, R0
80008084:	04 59       	MOV       R8, R4
80008086:	e3 58       	MOV       R7, R3
##@@@P_:tasks.c:8056
##@@@L8051_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L8052_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L8053_:
##@@@L8054_:        pxTCB = xTaskToNotify;   
##@@@L8055_:
##@@@L8056_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
80008088:	40 45       	LD        R5, [PC + #64]        ;->0x80008188  :=0x80008ff0
8000808a:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8058
##@@@L8057_:        {   
##@@@L8058_:            if( pulPreviousNotificationValue != NULL )   
8000808c:	80 38       	CMP       R8, #0			;->0x00
##@@@P_:tasks.c:8056
##@@@L8051_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L8052_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L8053_:
##@@@L8054_:        pxTCB = xTaskToNotify;   
##@@@L8055_:
##@@@L8056_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
8000808e:	20 59       	MOV       R9, R0
##@@@P_:tasks.c:8058
##@@@L8057_:        {   
##@@@L8058_:            if( pulPreviousNotificationValue != NULL )   
80008090:	03 f0       	JZ        $+3                   ;->0x80008096
##@@@P_:tasks.c:8060
##@@@L8059_:            {   
##@@@L8060_:                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];   
80008092:	2e 9f       	LD.W      R5, [R6 + #28]
80008094:	85 85       	ST.W      [R8], R5
80008096:	51 00 c5 d0 	LD.B      R5, [R6 + #116]			;->0x74
##@@@P_:tasks.c:8063
##@@@L8061_:            }   
##@@@L8062_:
##@@@L8063_:            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];   
8000809a:	55 62       	SXT.B     R5, R5
8000809c:	42 10       	MOV       R4, #2			;->0x0002
##@@@P_:tasks.c:8066
##@@@L8064_:            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;   
##@@@L8065_:
##@@@L8066_:            switch( eAction )   
8000809e:	74 38       	CMP       R7, #4			;->0x04
800080a0:	79 00 c4 d0 	ST.B      [R6 + #116], R4			;->0x74
800080a4:	16 f8       	JHI       $+22                  ;->0x800080d0
800080a6:	3a 44       	LD        R4, [PC + #58]        ;->0x8000818c  :=0x80000f54
800080a8:	3a 7a       	LSL       R7, #2			;->0x02
800080aa:	e4 e9       	LD.W      R4, [R4 + R7]
800080ac:	14 5c       	JMP       R4
##@@@P_:tasks.c:8069
##@@@L8067_:            {   
##@@@L8068_:                case eSetBits:   
##@@@L8069_:                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;   
800080ae:	26 9f       	LD.W      R4, [R6 + #28]
800080b0:	01 0b       	LD.W      R3, [SP + #1]
800080b2:	43 6a       	ORL       R4, R3
800080b4:	0c 04       	SJMP      $+12                  ;->0x800080cc
##@@@P_:tasks.c:8073
##@@@L8070_:                    break;   
##@@@L8071_:
##@@@L8072_:                case eIncrement:   
##@@@L8073_:                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;   
800080b6:	26 9f       	LD.W      R4, [R6 + #28]
800080b8:	64 c0       	ADD       R4, R4, #1
800080ba:	09 04       	SJMP      $+9                   ;->0x800080cc
800080bc:	4f 1f       	MOV       R4, #255			;->0x00FF
##@@@P_:tasks.c:8082
##@@@L8077_:                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;   
##@@@L8078_:                    break;   
##@@@L8079_:
##@@@L8080_:                case eSetValueWithoutOverwrite:   
##@@@L8081_:
##@@@L8082_:                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )   
800080be:	65 58       	MOV       R3, R5
800080c0:	34 69       	ANL       R3, R4
800080c2:	32 38       	CMP       R3, #2			;->0x02
800080c4:	03 f1       	JNZ       $+3                   ;->0x800080ca
800080c6:	60 10       	MOV       R6, #0			;->0x0000
800080c8:	58 04       	SJMP      $+88                  ;->0x80008178
800080ca:	01 0c       	LD.W      R4, [SP + #1]
800080cc:	34 a7       	ST.W      [R6 + #28], R4
800080ce:	06 04       	SJMP      $+6                   ;->0x800080da
##@@@P_:tasks.c:8105
##@@@L8100_:                default:   
##@@@L8101_:
##@@@L8102_:                    /* Should not get here if all enums are handled.   
##@@@L8103_:                     * Artificially force an assert by testing a value the   
##@@@L8104_:                     * compiler can't assume is const. */   
##@@@L8105_:                    configASSERT( xTickCount == ( TickType_t ) 0 );   
800080d0:	30 44       	LD        R4, [PC + #48]        ;->0x80008190  :=0xd000006c
800080d2:	44 82       	LD.W      R4, [R4]
800080d4:	40 38       	CMP       R4, #0			;->0x00
800080d6:	02 f0       	JZ        $+2                   ;->0x800080da
800080d8:	d5 04       	SJMP      $+213                 ;->0x80008282
800080da:	4f 1f       	MOV       R4, #255			;->0x00FF
##@@@P_:tasks.c:8113
##@@@L8108_:
##@@@L8109_:            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );   
##@@@L8110_:
##@@@L8111_:            /* If the task is in the blocked state specifically to wait for a   
##@@@L8112_:             * notification then unblock it now. */   
##@@@L8113_:            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )   
800080dc:	54 69       	ANL       R5, R4
800080de:	51 38       	CMP       R5, #1			;->0x01
800080e0:	19 f1       	JNZ       $+25                  ;->0x80008112
##@@@P_:tasks.c:8116
##@@@L8114_:            {   
##@@@L8115_:                /* The task should not have been on an event list. */   
##@@@L8116_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
800080e2:	ae 9a       	LD.W      R5, [R6 + #10]
800080e4:	50 38       	CMP       R5, #0			;->0x00
800080e6:	02 f0       	JZ        $+2                   ;->0x800080ea
800080e8:	aa 04       	SJMP      $+170                 ;->0x8000823c
##@@@P_:tasks.c:8118
##@@@L8117_:
##@@@L8118_:                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
800080ea:	2b 45       	LD        R5, [PC + #43]        ;->0x80008194  :=0xd0000068
800080ec:	55 82       	LD.W      R5, [R5]
800080ee:	50 38       	CMP       R5, #0			;->0x00
800080f0:	13 f0       	JZ        $+19                  ;->0x80008116
##@@@P_:tasks.c:8127
##@@@L8122_:                }   
##@@@L8123_:                else   
##@@@L8124_:                {   
##@@@L8125_:                    /* The delayed and ready lists cannot be accessed, so hold   
##@@@L8126_:                     * this task pending until the scheduler is resumed. */   
##@@@L8127_:                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );   
800080f2:	2a 45       	LD        R5, [PC + #42]        ;->0x80008198  :=0xd0000078
800080f4:	65 98       	LD.W      R4, [R5 + #1]
800080f6:	f4 a1       	ST.W      [R6 + #7], R4
800080f8:	9c 98       	LD.W      R3, [R4 + #2]
800080fa:	46 58       	MOV       R2, R6
800080fc:	33 a2       	ST.W      [R6 + #8], R3
800080fe:	9c 98       	LD.W      R3, [R4 + #2]
80008100:	28 29       	ADD       R2, #24			;->0x18
80008102:	5a a0       	ST.W      [R3 + #1], R2
80008104:	a2 a0       	ST.W      [R4 + #2], R2
80008106:	b5 a2       	ST.W      [R6 + #10], R5
80008108:	45 82       	LD.W      R4, [R5]
8000810a:	64 c0       	ADD       R4, R4, #1
8000810c:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:8132
##@@@L8128_:                }   
##@@@L8129_:
##@@@L8130_:                #if ( configNUMBER_OF_CORES == 1 )   
##@@@L8131_:                {   
##@@@L8132_:                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
8000810e:	ee 9a       	LD.W      R5, [R6 + #11]
80008110:	28 04       	SJMP      $+40                  ;->0x80008160
80008112:	61 10       	MOV       R6, #1			;->0x0001
80008114:	32 04       	SJMP      $+50                  ;->0x80008178
##@@@P_:tasks.c:8120
##@@@L8115_:                /* The task should not have been on an event list. */   
##@@@L8116_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
##@@@L8117_:
##@@@L8118_:                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
##@@@L8119_:                {   
##@@@L8120_:                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
80008116:	a6 98       	LD.W      R4, [R6 + #2]
80008118:	de 98       	LD.W      R3, [R6 + #3]
8000811a:	6e 99       	LD.W      R5, [R6 + #5]
8000811c:	a3 a0       	ST.W      [R4 + #2], R3
8000811e:	de 98       	LD.W      R3, [R6 + #3]
80008120:	5c a0       	ST.W      [R3 + #1], R4
80008122:	55 98       	LD.W      R2, [R5 + #1]
80008124:	06 c1       	ADD       R0, R6, #4
80008126:	20 70       	CMP       R2, R0
80008128:	02 f1       	JNZ       $+2                   ;->0x8000812c
8000812a:	6b a0       	ST.W      [R5 + #1], R3
8000812c:	35 82       	LD.W      R3, [R5]
8000812e:	5b cc       	SUB       R3, R3, #1
80008130:	53 85       	ST.W      [R5], R3
##@@@P_:tasks.c:8121
##@@@L8121_:                    prvAddTaskToReadyList( pxTCB );   
80008132:	1b 43       	LD        R3, [PC + #27]        ;->0x8000819c  :=0xd00002f8
80008134:	ee 9a       	LD.W      R5, [R6 + #11]
80008136:	23 82       	LD.W      R2, [R3]
80008138:	52 70       	CMP       R5, R2
8000813a:	02 f9       	JLS       $+2                   ;->0x8000813e
8000813c:	35 85       	ST.W      [R3], R5
8000813e:	19 43       	LD        R3, [PC + #25]        ;->0x800081a0  :=0xd00000a0
80008140:	24 11       	MOV       R2, #20			;->0x0014
80008142:	23 58       	MOV       R1, R3
80008144:	19 00 a2 04 	MADD32    R1, R5, R2
80008148:	79 98       	LD.W      R7, [R1 + #1]
8000814a:	b7 a0       	ST.W      [R6 + #2], R7
8000814c:	a7 98       	LD.W      R4, [R7 + #2]
8000814e:	f4 a0       	ST.W      [R6 + #3], R4
80008150:	a7 98       	LD.W      R4, [R7 + #2]
80008152:	60 a0       	ST.W      [R4 + #1], R0
80008154:	b8 a0       	ST.W      [R7 + #2], R0
80008156:	71 a1       	ST.W      [R6 + #5], R1
80008158:	a5 ca       	MULS      R4, R5, R2
8000815a:	13 e9       	LD.W      R2, [R3 + R4]
8000815c:	52 c0       	ADD       R2, R2, #1
8000815e:	1a ef       	ST.W      [R3 + R4], R2
##@@@P_:tasks.c:8132
##@@@L8127_:                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );   
##@@@L8128_:                }   
##@@@L8129_:
##@@@L8130_:                #if ( configNUMBER_OF_CORES == 1 )   
##@@@L8131_:                {   
##@@@L8132_:                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
80008160:	11 44       	LD        R4, [PC + #17]        ;->0x800081a4  :=0xd0000040
80008162:	44 82       	LD.W      R4, [R4]
80008164:	e4 9a       	LD.W      R4, [R4 + #11]
80008166:	61 10       	MOV       R6, #1			;->0x0001
80008168:	54 70       	CMP       R5, R4
8000816a:	07 f9       	JLS       $+7                   ;->0x80008178
8000816c:	07 0d       	LD.W      R5, [SP + #7]
##@@@P_:tasks.c:8136
##@@@L8133_:                    {   
##@@@L8134_:                        /* The notified task has a priority above the currently   
##@@@L8135_:                         * executing task so a yield is required. */   
##@@@L8136_:                        if( pxHigherPriorityTaskWoken != NULL )   
8000816e:	50 38       	CMP       R5, #0			;->0x00
80008170:	02 f0       	JZ        $+2                   ;->0x80008174
##@@@P_:tasks.c:8138
##@@@L8137_:                        {   
##@@@L8138_:                            *pxHigherPriorityTaskWoken = pdTRUE;   
80008172:	56 85       	ST.W      [R5], R6
##@@@P_:tasks.c:8144
##@@@L8139_:                        }   
##@@@L8140_:
##@@@L8141_:                        /* Mark that a yield is pending in case the user is not   
##@@@L8142_:                         * using the "xHigherPriorityTaskWoken" parameter to an ISR   
##@@@L8143_:                         * safe FreeRTOS function. */   
##@@@L8144_:                        xYieldPendings[ 0 ] = pdTRUE;   
80008174:	0d 45       	LD        R5, [PC + #13]        ;->0x800081a8  :=0xd00002fc
80008176:	56 85       	ST.W      [R5], R6
##@@@P_:tasks.c:8170
##@@@L8165_:                    #endif /* if ( configUSE_PREEMPTION == 1 ) */   
##@@@L8166_:                }   
##@@@L8167_:                #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L8168_:            }   
##@@@L8169_:        }   
##@@@L8170_:        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80008178:	09 58       	MOV       R0, R9
8000817a:	0d 45       	LD        R5, [PC + #13]        ;->0x800081ac  :=0x80009034
8000817c:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8174
##@@@L8171_:
##@@@L8172_:        traceRETURN_xTaskGenericNotifyFromISR( xReturn );   
##@@@L8173_:
##@@@L8174_:        return xReturn;   
8000817e:	06 58       	MOV       R0, R6
80008180:	e8 28       	ADD       SP, #8			;->0x08
80008182:	0f 5e       	POP       {R6-R9}
80008184:	0d 5d       	POP       LR
80008186:	1d 5c       	JMP       LR
80008188:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
8000818c:	54 0f 00 80 	.long     0x80000f54 ->-2147479724  [!!!@2@:LD.W      R7, [SP + #84]	@@: LD.B      R0, [R0]
80008190:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
80008194:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
80008198:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
8000819c:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
800081a0:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
800081a4:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800081a8:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
800081ac:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:8033
##@@@L8028_:        BaseType_t xReturn = pdPASS;   
##@@@L8029_:        UBaseType_t uxSavedInterruptStatus;   
##@@@L8030_:
##@@@L8031_:        traceENTER_xTaskGenericNotifyFromISR( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken );   
##@@@L8032_:
##@@@L8033_:        configASSERT( xTaskToNotify );   
800081b0:	20 5d       	PUSH      R0
800081b2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800081b6:	08 00       	SYNC     SYNC     
800081b8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800081bc:	08 00       	SYNC     SYNC     
800081be:	00 5d       	POP       R0
800081c0:	20 5d       	PUSH      R0
800081c2:	21 5d       	PUSH      R1
800081c4:	41 45       	LD        R5, [PC + #65]        ;->0x800082c8  :=0x1ff
800081c6:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800081ca:	25 58       	MOV       R1, R5
800081cc:	11 68       	NOT       R1, R1
800081ce:	01 69       	ANL       R0, R1
800081d0:	5f 11       	MOV       R5, #31			;->0x001F
800081d2:	25 58       	MOV       R1, R5
800081d4:	01 6a       	ORL       R0, R1
800081d6:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800081da:	08 00       	SYNC     SYNC     
800081dc:	01 5d       	POP       R1
800081de:	00 5d       	POP       R0
800081e0:	20 5d       	PUSH      R0
800081e2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800081e6:	08 00       	SYNC     SYNC     
800081e8:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800081ec:	08 00       	SYNC     SYNC     
800081ee:	00 5d       	POP       R0
800081f0:	07 00       	BREAK    BREAK    
800081f2:	37 45       	LD        R5, [PC + #55]        ;->0x800082cc  :=0x8000911c
800081f4:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8034
##@@@L8034_:        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
800081f6:	20 5d       	PUSH      R0
800081f8:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800081fc:	08 00       	SYNC     SYNC     
800081fe:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008202:	08 00       	SYNC     SYNC     
80008204:	00 5d       	POP       R0
80008206:	20 5d       	PUSH      R0
80008208:	21 5d       	PUSH      R1
8000820a:	30 45       	LD        R5, [PC + #48]        ;->0x800082c8  :=0x1ff
8000820c:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008210:	25 58       	MOV       R1, R5
80008212:	11 68       	NOT       R1, R1
80008214:	01 69       	ANL       R0, R1
80008216:	5f 11       	MOV       R5, #31			;->0x001F
80008218:	25 58       	MOV       R1, R5
8000821a:	01 6a       	ORL       R0, R1
8000821c:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008220:	08 00       	SYNC     SYNC     
80008222:	01 5d       	POP       R1
80008224:	00 5d       	POP       R0
80008226:	20 5d       	PUSH      R0
80008228:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000822c:	08 00       	SYNC     SYNC     
8000822e:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008232:	08 00       	SYNC     SYNC     
80008234:	00 5d       	POP       R0
80008236:	07 00       	BREAK    BREAK    
80008238:	25 45       	LD        R5, [PC + #37]        ;->0x800082cc  :=0x8000911c
8000823a:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8116
##@@@L8111_:            /* If the task is in the blocked state specifically to wait for a   
##@@@L8112_:             * notification then unblock it now. */   
##@@@L8113_:            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )   
##@@@L8114_:            {   
##@@@L8115_:                /* The task should not have been on an event list. */   
##@@@L8116_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
8000823c:	20 5d       	PUSH      R0
8000823e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008242:	08 00       	SYNC     SYNC     
80008244:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008248:	08 00       	SYNC     SYNC     
8000824a:	00 5d       	POP       R0
8000824c:	20 5d       	PUSH      R0
8000824e:	21 5d       	PUSH      R1
80008250:	1e 45       	LD        R5, [PC + #30]        ;->0x800082c8  :=0x1ff
80008252:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008256:	25 58       	MOV       R1, R5
80008258:	11 68       	NOT       R1, R1
8000825a:	01 69       	ANL       R0, R1
8000825c:	5f 11       	MOV       R5, #31			;->0x001F
8000825e:	25 58       	MOV       R1, R5
80008260:	01 6a       	ORL       R0, R1
80008262:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008266:	08 00       	SYNC     SYNC     
80008268:	01 5d       	POP       R1
8000826a:	00 5d       	POP       R0
8000826c:	20 5d       	PUSH      R0
8000826e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008272:	08 00       	SYNC     SYNC     
80008274:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008278:	08 00       	SYNC     SYNC     
8000827a:	00 5d       	POP       R0
8000827c:	07 00       	BREAK    BREAK    
8000827e:	14 45       	LD        R5, [PC + #20]        ;->0x800082cc  :=0x8000911c
80008280:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8105
##@@@L8100_:                default:   
##@@@L8101_:
##@@@L8102_:                    /* Should not get here if all enums are handled.   
##@@@L8103_:                     * Artificially force an assert by testing a value the   
##@@@L8104_:                     * compiler can't assume is const. */   
##@@@L8105_:                    configASSERT( xTickCount == ( TickType_t ) 0 );   
80008282:	20 5d       	PUSH      R0
80008284:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008288:	08 00       	SYNC     SYNC     
8000828a:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000828e:	08 00       	SYNC     SYNC     
80008290:	00 5d       	POP       R0
80008292:	20 5d       	PUSH      R0
80008294:	21 5d       	PUSH      R1
80008296:	0d 45       	LD        R5, [PC + #13]        ;->0x800082c8  :=0x1ff
80008298:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000829c:	25 58       	MOV       R1, R5
8000829e:	11 68       	NOT       R1, R1
800082a0:	01 69       	ANL       R0, R1
800082a2:	5f 11       	MOV       R5, #31			;->0x001F
800082a4:	25 58       	MOV       R1, R5
800082a6:	01 6a       	ORL       R0, R1
800082a8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800082ac:	08 00       	SYNC     SYNC     
800082ae:	01 5d       	POP       R1
800082b0:	00 5d       	POP       R0
800082b2:	20 5d       	PUSH      R0
800082b4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800082b8:	08 00       	SYNC     SYNC     
800082ba:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800082be:	08 00       	SYNC     SYNC     
800082c0:	00 5d       	POP       R0
800082c2:	07 00       	BREAK    BREAK    
800082c4:	02 45       	LD        R5, [PC + #2]         ;->0x800082cc  :=0x8000911c
800082c6:	05 5c       	LJMP      R5
800082c8:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
800082cc:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800082d0 <vTaskGenericNotifyGiveFromISR>:
##@@@F_:vTaskGenericNotifyGiveFromISR():
##@@@P_:tasks.c:8185
##@@@L8180_:#if ( configUSE_TASK_NOTIFICATIONS == 1 )   
##@@@L8181_:
##@@@L8182_:    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,   
##@@@L8183_:                                        UBaseType_t uxIndexToNotify,   
##@@@L8184_:                                        BaseType_t * pxHigherPriorityTaskWoken )   
##@@@L8185_:    {   
800082d0:	8f 5f       	PUSH      {R6-R9,LR}
800082d2:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:tasks.c:8192
##@@@L8187_:        uint8_t ucOriginalNotifyState;   
##@@@L8188_:        UBaseType_t uxSavedInterruptStatus;   
##@@@L8189_:
##@@@L8190_:        traceENTER_vTaskGenericNotifyGiveFromISR( xTaskToNotify, uxIndexToNotify, pxHigherPriorityTaskWoken );   
##@@@L8191_:
##@@@L8192_:        configASSERT( xTaskToNotify );   
800082d4:	00 38       	CMP       R0, #0			;->0x00
800082d6:	02 f1       	JNZ       $+2                   ;->0x800082da
800082d8:	76 04       	SJMP      $+118                 ;->0x800083c4
##@@@P_:tasks.c:8193
##@@@L8193_:        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
800082da:	10 38       	CMP       R1, #0			;->0x00
800082dc:	02 f0       	JZ        $+2                   ;->0x800082e0
800082de:	96 04       	SJMP      $+150                 ;->0x8000840a
800082e0:	e0 58       	MOV       R7, R0
800082e2:	02 59       	MOV       R8, R2
##@@@P_:tasks.c:8215
##@@@L8210_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L8211_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L8212_:
##@@@L8213_:        pxTCB = xTaskToNotify;   
##@@@L8214_:
##@@@L8215_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
800082e4:	30 45       	LD        R5, [PC + #48]        ;->0x800083a4  :=0x80008ff0
800082e6:	05 5c       	LJMP      R5
800082e8:	51 00 e5 d0 	LD.B      R5, [R7 + #116]			;->0x74
##@@@P_:tasks.c:8217
##@@@L8216_:        {   
##@@@L8217_:            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];   
800082ec:	42 10       	MOV       R4, #2			;->0x0002
800082ee:	79 00 e4 d0 	ST.B      [R7 + #116], R4			;->0x74
##@@@P_:tasks.c:8222
##@@@L8218_:            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;   
##@@@L8219_:
##@@@L8220_:            /* 'Giving' is equivalent to incrementing a count in a counting   
##@@@L8221_:             * semaphore. */   
##@@@L8222_:            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;   
800082f2:	27 9f       	LD.W      R4, [R7 + #28]
##@@@P_:tasks.c:8215
##@@@L8210_:         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */   
##@@@L8211_:        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();   
##@@@L8212_:
##@@@L8213_:        pxTCB = xTaskToNotify;   
##@@@L8214_:
##@@@L8215_:        uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();   
800082f4:	20 59       	MOV       R9, R0
##@@@P_:tasks.c:8222
##@@@L8217_:            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];   
##@@@L8218_:            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;   
##@@@L8219_:
##@@@L8220_:            /* 'Giving' is equivalent to incrementing a count in a counting   
##@@@L8221_:             * semaphore. */   
##@@@L8222_:            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;   
800082f6:	64 c0       	ADD       R4, R4, #1
##@@@P_:tasks.c:8228
##@@@L8223_:
##@@@L8224_:            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );   
##@@@L8225_:
##@@@L8226_:            /* If the task is in the blocked state specifically to wait for a   
##@@@L8227_:             * notification then unblock it now. */   
##@@@L8228_:            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )   
800082f8:	51 38       	CMP       R5, #1			;->0x01
##@@@P_:tasks.c:8222
##@@@L8217_:            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];   
##@@@L8218_:            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;   
##@@@L8219_:
##@@@L8220_:            /* 'Giving' is equivalent to incrementing a count in a counting   
##@@@L8221_:             * semaphore. */   
##@@@L8222_:            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;   
800082fa:	3c a7       	ST.W      [R7 + #28], R4
##@@@P_:tasks.c:8228
##@@@L8223_:
##@@@L8224_:            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );   
##@@@L8225_:
##@@@L8226_:            /* If the task is in the blocked state specifically to wait for a   
##@@@L8227_:             * notification then unblock it now. */   
##@@@L8228_:            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )   
800082fc:	02 f0       	JZ        $+2                   ;->0x80008300
800082fe:	4c 04       	SJMP      $+76                  ;->0x80008396
##@@@P_:tasks.c:8231
##@@@L8229_:            {   
##@@@L8230_:                /* The task should not have been on an event list. */   
##@@@L8231_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
80008300:	af 9a       	LD.W      R5, [R7 + #10]
80008302:	50 38       	CMP       R5, #0			;->0x00
80008304:	02 f0       	JZ        $+2                   ;->0x80008308
80008306:	a5 04       	SJMP      $+165                 ;->0x80008450
##@@@P_:tasks.c:8233
##@@@L8232_:
##@@@L8233_:                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
80008308:	28 45       	LD        R5, [PC + #40]        ;->0x800083a8  :=0xd0000068
8000830a:	55 82       	LD.W      R5, [R5]
8000830c:	50 38       	CMP       R5, #0			;->0x00
8000830e:	11 f0       	JZ        $+17                  ;->0x80008330
##@@@P_:tasks.c:8242
##@@@L8237_:                }   
##@@@L8238_:                else   
##@@@L8239_:                {   
##@@@L8240_:                    /* The delayed and ready lists cannot be accessed, so hold   
##@@@L8241_:                     * this task pending until the scheduler is resumed. */   
##@@@L8242_:                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );   
80008310:	27 45       	LD        R5, [PC + #39]        ;->0x800083ac  :=0xd0000078
80008312:	65 98       	LD.W      R4, [R5 + #1]
80008314:	fc a1       	ST.W      [R7 + #7], R4
80008316:	9c 98       	LD.W      R3, [R4 + #2]
80008318:	47 58       	MOV       R2, R7
8000831a:	3b a2       	ST.W      [R7 + #8], R3
8000831c:	9c 98       	LD.W      R3, [R4 + #2]
8000831e:	28 29       	ADD       R2, #24			;->0x18
80008320:	5a a0       	ST.W      [R3 + #1], R2
80008322:	a2 a0       	ST.W      [R4 + #2], R2
80008324:	bd a2       	ST.W      [R7 + #10], R5
80008326:	45 82       	LD.W      R4, [R5]
80008328:	64 c0       	ADD       R4, R4, #1
8000832a:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:8247
##@@@L8243_:                }   
##@@@L8244_:
##@@@L8245_:                #if ( configNUMBER_OF_CORES == 1 )   
##@@@L8246_:                {   
##@@@L8247_:                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
8000832c:	ef 9a       	LD.W      R5, [R7 + #11]
8000832e:	28 04       	SJMP      $+40                  ;->0x8000837e
##@@@P_:tasks.c:8235
##@@@L8230_:                /* The task should not have been on an event list. */   
##@@@L8231_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
##@@@L8232_:
##@@@L8233_:                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )   
##@@@L8234_:                {   
##@@@L8235_:                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );   
80008330:	a7 98       	LD.W      R4, [R7 + #2]
80008332:	df 98       	LD.W      R3, [R7 + #3]
80008334:	6f 99       	LD.W      R5, [R7 + #5]
80008336:	a3 a0       	ST.W      [R4 + #2], R3
80008338:	df 98       	LD.W      R3, [R7 + #3]
8000833a:	5c a0       	ST.W      [R3 + #1], R4
8000833c:	55 98       	LD.W      R2, [R5 + #1]
8000833e:	27 c1       	ADD       R4, R7, #4
80008340:	01 24       	ST.W      [SP + #1], R4
80008342:	24 70       	CMP       R2, R4
80008344:	02 f1       	JNZ       $+2                   ;->0x80008348
80008346:	6b a0       	ST.W      [R5 + #1], R3
80008348:	35 82       	LD.W      R3, [R5]
8000834a:	5b cc       	SUB       R3, R3, #1
8000834c:	53 85       	ST.W      [R5], R3
##@@@P_:tasks.c:8236
##@@@L8236_:                    prvAddTaskToReadyList( pxTCB );   
8000834e:	19 43       	LD        R3, [PC + #25]        ;->0x800083b0  :=0xd00002f8
80008350:	ef 9a       	LD.W      R5, [R7 + #11]
80008352:	23 82       	LD.W      R2, [R3]
80008354:	52 70       	CMP       R5, R2
80008356:	02 f9       	JLS       $+2                   ;->0x8000835a
80008358:	35 85       	ST.W      [R3], R5
8000835a:	17 40       	LD        R0, [PC + #23]        ;->0x800083b4  :=0xd00000a0
8000835c:	24 11       	MOV       R2, #20			;->0x0014
8000835e:	20 58       	MOV       R1, R0
80008360:	19 00 a2 04 	MADD32    R1, R5, R2
80008364:	71 98       	LD.W      R6, [R1 + #1]
80008366:	be a0       	ST.W      [R7 + #2], R6
80008368:	a6 98       	LD.W      R4, [R6 + #2]
8000836a:	fc a0       	ST.W      [R7 + #3], R4
8000836c:	a6 98       	LD.W      R4, [R6 + #2]
8000836e:	01 0b       	LD.W      R3, [SP + #1]
80008370:	63 a0       	ST.W      [R4 + #1], R3
80008372:	b3 a0       	ST.W      [R6 + #2], R3
80008374:	79 a1       	ST.W      [R7 + #5], R1
80008376:	a5 ca       	MULS      R4, R5, R2
80008378:	10 e9       	LD.W      R2, [R0 + R4]
8000837a:	52 c0       	ADD       R2, R2, #1
8000837c:	02 ef       	ST.W      [R0 + R4], R2
##@@@P_:tasks.c:8247
##@@@L8242_:                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );   
##@@@L8243_:                }   
##@@@L8244_:
##@@@L8245_:                #if ( configNUMBER_OF_CORES == 1 )   
##@@@L8246_:                {   
##@@@L8247_:                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )   
8000837e:	0f 44       	LD        R4, [PC + #15]        ;->0x800083b8  :=0xd0000040
80008380:	44 82       	LD.W      R4, [R4]
80008382:	e4 9a       	LD.W      R4, [R4 + #11]
80008384:	54 70       	CMP       R5, R4
80008386:	08 f9       	JLS       $+8                   ;->0x80008396
##@@@P_:tasks.c:8251
##@@@L8248_:                    {   
##@@@L8249_:                        /* The notified task has a priority above the currently   
##@@@L8250_:                         * executing task so a yield is required. */   
##@@@L8251_:                        if( pxHigherPriorityTaskWoken != NULL )   
80008388:	80 38       	CMP       R8, #0			;->0x00
8000838a:	03 f0       	JZ        $+3                   ;->0x80008390
8000838c:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:tasks.c:8253
##@@@L8252_:                        {   
##@@@L8253_:                            *pxHigherPriorityTaskWoken = pdTRUE;   
8000838e:	85 85       	ST.W      [R8], R5
##@@@P_:tasks.c:8259
##@@@L8254_:                        }   
##@@@L8255_:
##@@@L8256_:                        /* Mark that a yield is pending in case the user is not   
##@@@L8257_:                         * using the "xHigherPriorityTaskWoken" parameter in an ISR   
##@@@L8258_:                         * safe FreeRTOS function. */   
##@@@L8259_:                        xYieldPendings[ 0 ] = pdTRUE;   
80008390:	0b 45       	LD        R5, [PC + #11]        ;->0x800083bc  :=0xd00002fc
80008392:	41 10       	MOV       R4, #1			;->0x0001
80008394:	54 85       	ST.W      [R5], R4
##@@@P_:tasks.c:8285
##@@@L8280_:                    #endif /* #if ( configUSE_PREEMPTION == 1 ) */   
##@@@L8281_:                }   
##@@@L8282_:                #endif /* #if ( configNUMBER_OF_CORES == 1 ) */   
##@@@L8283_:            }   
##@@@L8284_:        }   
##@@@L8285_:        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );   
80008396:	09 58       	MOV       R0, R9
80008398:	0a 45       	LD        R5, [PC + #10]        ;->0x800083c0  :=0x80009034
8000839a:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8288
##@@@L8286_:
##@@@L8287_:        traceRETURN_vTaskGenericNotifyGiveFromISR();   
##@@@L8288_:    }   
8000839c:	e8 28       	ADD       SP, #8			;->0x08
8000839e:	0f 5e       	POP       {R6-R9}
800083a0:	0d 5d       	POP       LR
800083a2:	1d 5c       	JMP       LR
800083a4:	f0 8f 00 80 	.long     0x80008ff0 ->-2147446800  [!!!@2@:LD.B      R6, [R0 + #31]	@@: LD.B      R0, [R0]
800083a8:	68 00 00 d0 	.long     0xd0000068 ->-805306264  [!!!@4@:ST        [R0 + #52], R0
800083ac:	78 00 00 d0 	.long     0xd0000078 ->-805306248  [!!!@4@:ST.B      [R0 + #52], R0
800083b0:	f8 02 00 d0 	.long     0xd00002f8 ->-805305608 
800083b4:	a0 00 00 d0 	.long     0xd00000a0 ->-805306208 
800083b8:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800083bc:	fc 02 00 d0 	.long     0xd00002fc ->-805305604 
800083c0:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:8192
##@@@L8187_:        uint8_t ucOriginalNotifyState;   
##@@@L8188_:        UBaseType_t uxSavedInterruptStatus;   
##@@@L8189_:
##@@@L8190_:        traceENTER_vTaskGenericNotifyGiveFromISR( xTaskToNotify, uxIndexToNotify, pxHigherPriorityTaskWoken );   
##@@@L8191_:
##@@@L8192_:        configASSERT( xTaskToNotify );   
800083c4:	20 5d       	PUSH      R0
800083c6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800083ca:	08 00       	SYNC     SYNC     
800083cc:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800083d0:	08 00       	SYNC     SYNC     
800083d2:	00 5d       	POP       R0
800083d4:	20 5d       	PUSH      R0
800083d6:	21 5d       	PUSH      R1
800083d8:	30 45       	LD        R5, [PC + #48]        ;->0x80008498  :=0x1ff
800083da:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800083de:	25 58       	MOV       R1, R5
800083e0:	11 68       	NOT       R1, R1
800083e2:	01 69       	ANL       R0, R1
800083e4:	5f 11       	MOV       R5, #31			;->0x001F
800083e6:	25 58       	MOV       R1, R5
800083e8:	01 6a       	ORL       R0, R1
800083ea:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800083ee:	08 00       	SYNC     SYNC     
800083f0:	01 5d       	POP       R1
800083f2:	00 5d       	POP       R0
800083f4:	20 5d       	PUSH      R0
800083f6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800083fa:	08 00       	SYNC     SYNC     
800083fc:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008400:	08 00       	SYNC     SYNC     
80008402:	00 5d       	POP       R0
80008404:	07 00       	BREAK    BREAK    
80008406:	26 45       	LD        R5, [PC + #38]        ;->0x8000849c  :=0x8000911c
80008408:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8193
##@@@L8193_:        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
8000840a:	20 5d       	PUSH      R0
8000840c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008410:	08 00       	SYNC     SYNC     
80008412:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008416:	08 00       	SYNC     SYNC     
80008418:	00 5d       	POP       R0
8000841a:	20 5d       	PUSH      R0
8000841c:	21 5d       	PUSH      R1
8000841e:	1f 45       	LD        R5, [PC + #31]        ;->0x80008498  :=0x1ff
80008420:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008424:	25 58       	MOV       R1, R5
80008426:	11 68       	NOT       R1, R1
80008428:	01 69       	ANL       R0, R1
8000842a:	5f 11       	MOV       R5, #31			;->0x001F
8000842c:	25 58       	MOV       R1, R5
8000842e:	01 6a       	ORL       R0, R1
80008430:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008434:	08 00       	SYNC     SYNC     
80008436:	01 5d       	POP       R1
80008438:	00 5d       	POP       R0
8000843a:	20 5d       	PUSH      R0
8000843c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008440:	08 00       	SYNC     SYNC     
80008442:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008446:	08 00       	SYNC     SYNC     
80008448:	00 5d       	POP       R0
8000844a:	07 00       	BREAK    BREAK    
8000844c:	14 45       	LD        R5, [PC + #20]        ;->0x8000849c  :=0x8000911c
8000844e:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8231
##@@@L8226_:            /* If the task is in the blocked state specifically to wait for a   
##@@@L8227_:             * notification then unblock it now. */   
##@@@L8228_:            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )   
##@@@L8229_:            {   
##@@@L8230_:                /* The task should not have been on an event list. */   
##@@@L8231_:                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );   
80008450:	20 5d       	PUSH      R0
80008452:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008456:	08 00       	SYNC     SYNC     
80008458:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000845c:	08 00       	SYNC     SYNC     
8000845e:	00 5d       	POP       R0
80008460:	20 5d       	PUSH      R0
80008462:	21 5d       	PUSH      R1
80008464:	0d 45       	LD        R5, [PC + #13]        ;->0x80008498  :=0x1ff
80008466:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000846a:	25 58       	MOV       R1, R5
8000846c:	11 68       	NOT       R1, R1
8000846e:	01 69       	ANL       R0, R1
80008470:	5f 11       	MOV       R5, #31			;->0x001F
80008472:	25 58       	MOV       R1, R5
80008474:	01 6a       	ORL       R0, R1
80008476:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000847a:	08 00       	SYNC     SYNC     
8000847c:	01 5d       	POP       R1
8000847e:	00 5d       	POP       R0
80008480:	20 5d       	PUSH      R0
80008482:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008486:	08 00       	SYNC     SYNC     
80008488:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000848c:	08 00       	SYNC     SYNC     
8000848e:	00 5d       	POP       R0
80008490:	07 00       	BREAK    BREAK    
80008492:	03 45       	LD        R5, [PC + #3]         ;->0x8000849c  :=0x8000911c
80008494:	05 5c       	LJMP      R5
80008496:	00 00       	NOP      NOP      
80008498:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000849c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

800084a0 <xTaskGenericNotifyStateClear>:
##@@@F_:xTaskGenericNotifyStateClear():
##@@@P_:tasks.c:8297
##@@@L8292_:
##@@@L8293_:#if ( configUSE_TASK_NOTIFICATIONS == 1 )   
##@@@L8294_:
##@@@L8295_:    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,   
##@@@L8296_:                                             UBaseType_t uxIndexToClear )   
##@@@L8297_:    {   
800084a0:	81 5f       	PUSH      {R6,LR}
800084a2:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:8303
##@@@L8298_:        TCB_t * pxTCB;   
##@@@L8299_:        BaseType_t xReturn;   
##@@@L8300_:
##@@@L8301_:        traceENTER_xTaskGenericNotifyStateClear( xTask, uxIndexToClear );   
##@@@L8302_:
##@@@L8303_:        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
800084a4:	10 38       	CMP       R1, #0			;->0x00
800084a6:	47 f1       	JNZ       $+71                  ;->0x80008534
800084a8:	a0 58       	MOV       R5, R0
##@@@P_:tasks.c:8307
##@@@L8304_:
##@@@L8305_:        /* If null is passed in here then it is the calling task that is having   
##@@@L8306_:         * its notification state cleared. */   
##@@@L8307_:        pxTCB = prvGetTCBFromHandle( xTask );   
800084aa:	00 38       	CMP       R0, #0			;->0x00
800084ac:	03 f1       	JNZ       $+3                   ;->0x800084b2
800084ae:	1e 45       	LD        R5, [PC + #30]        ;->0x80008524  :=0xd0000040
800084b0:	55 82       	LD.W      R5, [R5]
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800084b2:	20 5d       	PUSH      R0
800084b4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800084b8:	08 00       	SYNC     SYNC     
800084ba:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800084be:	08 00       	SYNC     SYNC     
800084c0:	00 5d       	POP       R0
800084c2:	20 5d       	PUSH      R0
800084c4:	21 5d       	PUSH      R1
800084c6:	19 44       	LD        R4, [PC + #25]        ;->0x80008528  :=0x1ff
800084c8:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800084cc:	24 58       	MOV       R1, R4
800084ce:	11 68       	NOT       R1, R1
800084d0:	01 69       	ANL       R0, R1
800084d2:	4f 11       	MOV       R4, #31			;->0x001F
800084d4:	24 58       	MOV       R1, R4
800084d6:	01 6a       	ORL       R0, R1
800084d8:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800084dc:	08 00       	SYNC     SYNC     
800084de:	01 5d       	POP       R1
800084e0:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
800084e2:	13 44       	LD        R4, [PC + #19]        ;->0x8000852c  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800084e4:	20 5d       	PUSH      R0
800084e6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800084ea:	08 00       	SYNC     SYNC     
800084ec:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800084f0:	08 00       	SYNC     SYNC     
800084f2:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
800084f4:	44 82       	LD.W      R4, [R4]
800084f6:	40 38       	CMP       R4, #0			;->0x00
800084f8:	07 f0       	JZ        $+7                   ;->0x80008506
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
800084fa:	0b 44       	LD        R4, [PC + #11]        ;->0x80008524  :=0xd0000040
800084fc:	34 82       	LD.W      R3, [R4]
800084fe:	53 9c       	LD.W      R2, [R3 + #17]
80008500:	52 c0       	ADD       R2, R2, #1
80008502:	5a a4       	ST.W      [R3 + #17], R2
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
80008504:	44 82       	LD.W      R4, [R4]
##@@@F_:xTaskGenericNotifyStateClear():
80008506:	51 00 a4 d0 	LD.B      R4, [R5 + #116]			;->0x74
##@@@P_:tasks.c:8311
##@@@L8306_:         * its notification state cleared. */   
##@@@L8307_:        pxTCB = prvGetTCBFromHandle( xTask );   
##@@@L8308_:
##@@@L8309_:        taskENTER_CRITICAL();   
##@@@L8310_:        {   
##@@@L8311_:            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )   
8000850a:	60 10       	MOV       R6, #0			;->0x0000
8000850c:	42 38       	CMP       R4, #2			;->0x02
8000850e:	04 f1       	JNZ       $+4                   ;->0x80008516
80008510:	79 00 a6 d0 	ST.B      [R5 + #116], R6			;->0x74
##@@@P_:tasks.c:8313
##@@@L8312_:            {   
##@@@L8313_:                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;   
80008514:	61 10       	MOV       R6, #1			;->0x0001
##@@@P_:tasks.c:8321
##@@@L8316_:            else   
##@@@L8317_:            {   
##@@@L8318_:                xReturn = pdFAIL;   
##@@@L8319_:            }   
##@@@L8320_:        }   
##@@@L8321_:        taskEXIT_CRITICAL();   
80008516:	07 45       	LD        R5, [PC + #7]         ;->0x80008530  :=0x80005730
80008518:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8325
##@@@L8322_:
##@@@L8323_:        traceRETURN_xTaskGenericNotifyStateClear( xReturn );   
##@@@L8324_:
##@@@L8325_:        return xReturn;   
8000851a:	06 58       	MOV       R0, R6
8000851c:	e4 28       	ADD       SP, #4			;->0x04
8000851e:	06 5d       	POP       R6
80008520:	0d 5d       	POP       LR
80008522:	1d 5c       	JMP       LR
80008524:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80008528:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000852c:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80008530:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80008530
##@@@P_:tasks.c:8303
##@@@L8298_:        TCB_t * pxTCB;   
##@@@L8299_:        BaseType_t xReturn;   
##@@@L8300_:
##@@@L8301_:        traceENTER_xTaskGenericNotifyStateClear( xTask, uxIndexToClear );   
##@@@L8302_:
##@@@L8303_:        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80008534:	20 5d       	PUSH      R0
80008536:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000853a:	08 00       	SYNC     SYNC     
8000853c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008540:	08 00       	SYNC     SYNC     
80008542:	00 5d       	POP       R0
80008544:	20 5d       	PUSH      R0
80008546:	21 5d       	PUSH      R1
80008548:	0d 45       	LD        R5, [PC + #13]        ;->0x8000857c  :=0x1ff
8000854a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000854e:	25 58       	MOV       R1, R5
80008550:	11 68       	NOT       R1, R1
80008552:	01 69       	ANL       R0, R1
80008554:	5f 11       	MOV       R5, #31			;->0x001F
80008556:	25 58       	MOV       R1, R5
80008558:	01 6a       	ORL       R0, R1
8000855a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000855e:	08 00       	SYNC     SYNC     
80008560:	01 5d       	POP       R1
80008562:	00 5d       	POP       R0
80008564:	20 5d       	PUSH      R0
80008566:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000856a:	08 00       	SYNC     SYNC     
8000856c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008570:	08 00       	SYNC     SYNC     
80008572:	00 5d       	POP       R0
80008574:	07 00       	BREAK    BREAK    
80008576:	03 45       	LD        R5, [PC + #3]         ;->0x80008580  :=0x8000911c
80008578:	05 5c       	LJMP      R5
8000857a:	00 00       	NOP      NOP      
8000857c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80008580:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80008584 <ulTaskGenericNotifyValueClear>:
##@@@F_:ulTaskGenericNotifyValueClear():
##@@@P_:tasks.c:8336
##@@@L8331_:#if ( configUSE_TASK_NOTIFICATIONS == 1 )   
##@@@L8332_:
##@@@L8333_:    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,   
##@@@L8334_:                                            UBaseType_t uxIndexToClear,   
##@@@L8335_:                                            uint32_t ulBitsToClear )   
##@@@L8336_:    {   
80008584:	81 5f       	PUSH      {R6,LR}
80008586:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:tasks.c:8342
##@@@L8337_:        TCB_t * pxTCB;   
##@@@L8338_:        uint32_t ulReturn;   
##@@@L8339_:
##@@@L8340_:        traceENTER_ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );   
##@@@L8341_:
##@@@L8342_:        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80008588:	10 38       	CMP       R1, #0			;->0x00
8000858a:	45 f1       	JNZ       $+69                  ;->0x80008614
8000858c:	a0 58       	MOV       R5, R0
##@@@P_:tasks.c:8346
##@@@L8343_:
##@@@L8344_:        /* If null is passed in here then it is the calling task that is having   
##@@@L8345_:         * its notification state cleared. */   
##@@@L8346_:        pxTCB = prvGetTCBFromHandle( xTask );   
8000858e:	00 38       	CMP       R0, #0			;->0x00
80008590:	03 f1       	JNZ       $+3                   ;->0x80008596
80008592:	1d 45       	LD        R5, [PC + #29]        ;->0x80008604  :=0xd0000040
80008594:	55 82       	LD.W      R5, [R5]
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
80008596:	20 5d       	PUSH      R0
80008598:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000859c:	08 00       	SYNC     SYNC     
8000859e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800085a2:	08 00       	SYNC     SYNC     
800085a4:	00 5d       	POP       R0
800085a6:	20 5d       	PUSH      R0
800085a8:	21 5d       	PUSH      R1
800085aa:	18 44       	LD        R4, [PC + #24]        ;->0x80008608  :=0x1ff
800085ac:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
800085b0:	24 58       	MOV       R1, R4
800085b2:	11 68       	NOT       R1, R1
800085b4:	01 69       	ANL       R0, R1
800085b6:	4f 11       	MOV       R4, #31			;->0x001F
800085b8:	24 58       	MOV       R1, R4
800085ba:	01 6a       	ORL       R0, R1
800085bc:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
800085c0:	08 00       	SYNC     SYNC     
800085c2:	01 5d       	POP       R1
800085c4:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
800085c6:	12 44       	LD        R4, [PC + #18]        ;->0x8000860c  :=0xd0000064
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
800085c8:	20 5d       	PUSH      R0
800085ca:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800085ce:	08 00       	SYNC     SYNC     
800085d0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800085d4:	08 00       	SYNC     SYNC     
800085d6:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
800085d8:	44 82       	LD.W      R4, [R4]
800085da:	40 38       	CMP       R4, #0			;->0x00
800085dc:	07 f0       	JZ        $+7                   ;->0x800085ea
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
800085de:	0a 44       	LD        R4, [PC + #10]        ;->0x80008604  :=0xd0000040
800085e0:	34 82       	LD.W      R3, [R4]
800085e2:	4b 9c       	LD.W      R1, [R3 + #17]
800085e4:	49 c0       	ADD       R1, R1, #1
800085e6:	59 a4       	ST.W      [R3 + #17], R1
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
800085e8:	44 82       	LD.W      R4, [R4]
##@@@F_:ulTaskGenericNotifyValueClear():
##@@@P_:tasks.c:8352
##@@@L8347_:
##@@@L8348_:        taskENTER_CRITICAL();   
##@@@L8349_:        {   
##@@@L8350_:            /* Return the notification as it was before the bits were cleared,   
##@@@L8351_:             * then clear the bit mask. */   
##@@@L8352_:            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];   
800085ea:	35 9f       	LD.W      R6, [R5 + #28]
##@@@P_:tasks.c:8353
##@@@L8353_:            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;   
800085ec:	25 9f       	LD.W      R4, [R5 + #28]
800085ee:	32 68       	NOT       R3, R2
800085f0:	43 69       	ANL       R4, R3
800085f2:	2c a7       	ST.W      [R5 + #28], R4
##@@@P_:tasks.c:8355
##@@@L8354_:        }   
##@@@L8355_:        taskEXIT_CRITICAL();   
800085f4:	07 45       	LD        R5, [PC + #7]         ;->0x80008610  :=0x80005730
800085f6:	05 5c       	LJMP      R5
##@@@P_:tasks.c:8359
##@@@L8356_:
##@@@L8357_:        traceRETURN_ulTaskGenericNotifyValueClear( ulReturn );   
##@@@L8358_:
##@@@L8359_:        return ulReturn;   
800085f8:	06 58       	MOV       R0, R6
800085fa:	e4 28       	ADD       SP, #4			;->0x04
800085fc:	06 5d       	POP       R6
800085fe:	0d 5d       	POP       LR
80008600:	1d 5c       	JMP       LR
80008602:	00 00       	NOP      NOP      
80008604:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80008608:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000860c:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80008610:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80008610
##@@@P_:tasks.c:8342
##@@@L8337_:        TCB_t * pxTCB;   
##@@@L8338_:        uint32_t ulReturn;   
##@@@L8339_:
##@@@L8340_:        traceENTER_ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );   
##@@@L8341_:
##@@@L8342_:        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );   
80008614:	20 5d       	PUSH      R0
80008616:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000861a:	08 00       	SYNC     SYNC     
8000861c:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008620:	08 00       	SYNC     SYNC     
80008622:	00 5d       	POP       R0
80008624:	20 5d       	PUSH      R0
80008626:	21 5d       	PUSH      R1
80008628:	0d 45       	LD        R5, [PC + #13]        ;->0x8000865c  :=0x1ff
8000862a:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000862e:	25 58       	MOV       R1, R5
80008630:	11 68       	NOT       R1, R1
80008632:	01 69       	ANL       R0, R1
80008634:	5f 11       	MOV       R5, #31			;->0x001F
80008636:	25 58       	MOV       R1, R5
80008638:	01 6a       	ORL       R0, R1
8000863a:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000863e:	08 00       	SYNC     SYNC     
80008640:	01 5d       	POP       R1
80008642:	00 5d       	POP       R0
80008644:	20 5d       	PUSH      R0
80008646:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000864a:	08 00       	SYNC     SYNC     
8000864c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008650:	08 00       	SYNC     SYNC     
80008652:	00 5d       	POP       R0
80008654:	07 00       	BREAK    BREAK    
80008656:	03 45       	LD        R5, [PC + #3]         ;->0x80008660  :=0x8000911c
80008658:	05 5c       	LJMP      R5
8000865a:	00 00       	NOP      NOP      
8000865c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80008660:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80008664 <ulTaskGetRunTimeCounter>:
##@@@F_:ulTaskGetRunTimeCounter():
##@@@P_:tasks.c:8373
##@@@L8368_:    {   
##@@@L8369_:        TCB_t * pxTCB;   
##@@@L8370_:
##@@@L8371_:        traceENTER_ulTaskGetRunTimeCounter( xTask );   
##@@@L8372_:
##@@@L8373_:        pxTCB = prvGetTCBFromHandle( xTask );   
80008664:	00 38       	CMP       R0, #0			;->0x00
80008666:	03 f0       	JZ        $+3                   ;->0x8000866c
##@@@P_:tasks.c:8377
##@@@L8374_:
##@@@L8375_:        traceRETURN_ulTaskGetRunTimeCounter( pxTCB->ulRunTimeCounter );   
##@@@L8376_:
##@@@L8377_:        return pxTCB->ulRunTimeCounter;   
80008668:	c0 9e       	LD.W      R0, [R0 + #27]
8000866a:	1d 5c       	JMP       LR
##@@@P_:tasks.c:8373
##@@@L8368_:    {   
##@@@L8369_:        TCB_t * pxTCB;   
##@@@L8370_:
##@@@L8371_:        traceENTER_ulTaskGetRunTimeCounter( xTask );   
##@@@L8372_:
##@@@L8373_:        pxTCB = prvGetTCBFromHandle( xTask );   
8000866c:	02 45       	LD        R5, [PC + #2]         ;->0x80008674  :=0xd0000040
8000866e:	05 82       	LD.W      R0, [R5]
##@@@P_:tasks.c:8377
##@@@L8374_:
##@@@L8375_:        traceRETURN_ulTaskGetRunTimeCounter( pxTCB->ulRunTimeCounter );   
##@@@L8376_:
##@@@L8377_:        return pxTCB->ulRunTimeCounter;   
80008670:	c0 9e       	LD.W      R0, [R0 + #27]
80008672:	1d 5c       	JMP       LR
80008674:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]

80008678 <ulTaskGetRunTimePercent>:
##@@@F_:xTaskGetTickCount():
##@@@P_:tasks.c:4083
##@@@L4078_:    traceENTER_xTaskGetTickCount();   
##@@@L4079_:
##@@@L4080_:    /* Critical section required if running on a 16 bit processor. */   
##@@@L4081_:    portTICK_TYPE_ENTER_CRITICAL();   
##@@@L4082_:    {   
##@@@L4083_:        xTicks = xTickCount;   
80008678:	03 45       	LD        R5, [PC + #3]         ;->0x80008684  :=0xd000006c
8000867a:	55 82       	LD.W      R5, [R5]
##@@@F_:ulTaskGetRunTimePercent():
##@@@P_:tasks.c:8398
##@@@L8393_:
##@@@L8394_:        /* For percentage calculations. */   
##@@@L8395_:        ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;   
##@@@L8396_:
##@@@L8397_:        /* Avoid divide by zero errors. */   
##@@@L8398_:        if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )   
8000867c:	54 3e       	CMP       R5, #100			;->0x64
8000867e:	05 f2       	JC        $+5                   ;->0x80008688
80008680:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:tasks.c:8410
##@@@L8405_:            ulReturn = 0;   
##@@@L8406_:        }   
##@@@L8407_:
##@@@L8408_:        traceRETURN_ulTaskGetRunTimePercent( ulReturn );   
##@@@L8409_:
##@@@L8410_:        return ulReturn;   
80008682:	1d 5c       	JMP       LR
80008684:	6c 00 00 d0 	.long     0xd000006c ->-805306260  [!!!@4@:ST        [R0 + #-204], R0
80008688:	44 16       	MOV       R4, #100			;->0x0064
8000868a:	2d d3       	DIVU      R5, R5, R4
##@@@P_:tasks.c:8400
##@@@L8395_:        ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;   
##@@@L8396_:
##@@@L8397_:        /* Avoid divide by zero errors. */   
##@@@L8398_:        if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )   
##@@@L8399_:        {   
##@@@L8400_:            pxTCB = prvGetTCBFromHandle( xTask );   
8000868c:	00 38       	CMP       R0, #0			;->0x00
8000868e:	03 f1       	JNZ       $+3                   ;->0x80008694
80008690:	03 44       	LD        R4, [PC + #3]         ;->0x8000869c  :=0xd0000040
80008692:	04 82       	LD.W      R0, [R4]
##@@@P_:tasks.c:8401
##@@@L8401_:            ulReturn = pxTCB->ulRunTimeCounter / ulTotalTime;   
80008694:	e0 9e       	LD.W      R4, [R0 + #27]
80008696:	44 d3       	DIVU      R0, R4, R5
##@@@P_:tasks.c:8410
##@@@L8405_:            ulReturn = 0;   
##@@@L8406_:        }   
##@@@L8407_:
##@@@L8408_:        traceRETURN_ulTaskGetRunTimePercent( ulReturn );   
##@@@L8409_:
##@@@L8410_:        return ulReturn;   
80008698:	1d 5c       	JMP       LR
8000869a:	00 00       	NOP      NOP      
8000869c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]

800086a0 <prvInitialiseNewTask>:
##@@@F_:prvInitialiseNewTask():
##@@@P_:tasks.c:1793
##@@@L1788_:                                  void * const pvParameters,   
##@@@L1789_:                                  UBaseType_t uxPriority,   
##@@@L1790_:                                  TaskHandle_t * const pxCreatedTask,   
##@@@L1791_:                                  TCB_t * pxNewTCB,   
##@@@L1792_:                                  const MemoryRegion_t * const xRegions )   
##@@@L1793_:{   
800086a0:	8f 5f       	PUSH      {R6-R9,LR}
800086a2:	e0 31       	SUB       SP, #16			;->0x10
800086a4:	0a 0f       	LD.W      R7, [SP + #10]
##@@@P_:tasks.c:1816
##@@@L1811_:
##@@@L1812_:    /* Avoid dependency on memset() if it is not required. */   
##@@@L1813_:    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )   
##@@@L1814_:    {   
##@@@L1815_:        /* Fill the stack with a known value to assist debugging. */   
##@@@L1816_:        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );   
800086a6:	2f 9b       	LD.W      R5, [R7 + #12]
800086a8:	03 24       	ST.W      [SP + #3], R4
800086aa:	03 59       	MOV       R8, R3
800086ac:	c1 58       	MOV       R6, R1
800086ae:	20 59       	MOV       R9, R0
800086b0:	12 7a       	LSL       R2, #2			;->0x02
800086b2:	15 1a       	MOV       R1, #165			;->0x00A5
800086b4:	05 58       	MOV       R0, R5
800086b6:	02 22       	ST.W      [SP + #2], R2
800086b8:	4a 45       	LD        R5, [PC + #74]        ;->0x800087e0  :=0x8000da04
800086ba:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1855
##@@@L1850_:        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );   
##@@@L1851_:    }   
##@@@L1852_:    #endif /* portSTACK_GROWTH */   
##@@@L1853_:
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
800086bc:	60 38       	CMP       R6, #0			;->0x00
800086be:	47 58       	MOV       R2, R7
800086c0:	02 f1       	JNZ       $+2                   ;->0x800086c4
800086c2:	65 04       	SJMP      $+101                 ;->0x8000878c
##@@@P_:tasks.c:1859
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
800086c4:	56 80       	LD.B      R5, [R6]
800086c6:	78 00 45 d0 	ST.B      [R2 + #52], R5			;->0x34
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
800086ca:	56 80       	LD.B      R5, [R6]
800086cc:	50 38       	CMP       R5, #0			;->0x00
800086ce:	02 f1       	JNZ       $+2                   ;->0x800086d2
800086d0:	5b 04       	SJMP      $+91                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
800086d2:	6e 88       	LD.B      R5, [R6 + #1]
800086d4:	78 00 45 d4 	ST.B      [R2 + #53], R5			;->0x35
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
800086d8:	6e 88       	LD.B      R5, [R6 + #1]
800086da:	50 38       	CMP       R5, #0			;->0x00
800086dc:	02 f1       	JNZ       $+2                   ;->0x800086e0
800086de:	54 04       	SJMP      $+84                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
800086e0:	ae 88       	LD.B      R5, [R6 + #2]
800086e2:	78 00 45 d8 	ST.B      [R2 + #54], R5			;->0x36
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
800086e6:	ae 88       	LD.B      R5, [R6 + #2]
800086e8:	50 38       	CMP       R5, #0			;->0x00
800086ea:	02 f1       	JNZ       $+2                   ;->0x800086ee
800086ec:	4d 04       	SJMP      $+77                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
800086ee:	ee 88       	LD.B      R5, [R6 + #3]
800086f0:	78 00 45 dc 	ST.B      [R2 + #55], R5			;->0x37
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
800086f4:	ee 88       	LD.B      R5, [R6 + #3]
800086f6:	50 38       	CMP       R5, #0			;->0x00
800086f8:	02 f1       	JNZ       $+2                   ;->0x800086fc
800086fa:	46 04       	SJMP      $+70                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
800086fc:	2e 89       	LD.B      R5, [R6 + #4]
800086fe:	78 00 45 e0 	ST.B      [R2 + #56], R5			;->0x38
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
80008702:	2e 89       	LD.B      R5, [R6 + #4]
80008704:	50 38       	CMP       R5, #0			;->0x00
80008706:	40 f0       	JZ        $+64                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008708:	6e 89       	LD.B      R5, [R6 + #5]
8000870a:	78 00 45 e4 	ST.B      [R2 + #57], R5			;->0x39
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
8000870e:	6e 89       	LD.B      R5, [R6 + #5]
80008710:	50 38       	CMP       R5, #0			;->0x00
80008712:	3a f0       	JZ        $+58                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008714:	ae 89       	LD.B      R5, [R6 + #6]
80008716:	78 00 45 e8 	ST.B      [R2 + #58], R5			;->0x3A
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
8000871a:	ae 89       	LD.B      R5, [R6 + #6]
8000871c:	50 38       	CMP       R5, #0			;->0x00
8000871e:	34 f0       	JZ        $+52                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008720:	ee 89       	LD.B      R5, [R6 + #7]
80008722:	78 00 45 ec 	ST.B      [R2 + #59], R5			;->0x3B
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
80008726:	ee 89       	LD.B      R5, [R6 + #7]
80008728:	50 38       	CMP       R5, #0			;->0x00
8000872a:	2e f0       	JZ        $+46                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
8000872c:	2e 8a       	LD.B      R5, [R6 + #8]
8000872e:	78 00 45 f0 	ST.B      [R2 + #60], R5			;->0x3C
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
80008732:	2e 8a       	LD.B      R5, [R6 + #8]
80008734:	50 38       	CMP       R5, #0			;->0x00
80008736:	28 f0       	JZ        $+40                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008738:	6e 8a       	LD.B      R5, [R6 + #9]
8000873a:	78 00 45 f4 	ST.B      [R2 + #61], R5			;->0x3D
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
8000873e:	6e 8a       	LD.B      R5, [R6 + #9]
80008740:	50 38       	CMP       R5, #0			;->0x00
80008742:	22 f0       	JZ        $+34                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008744:	ae 8a       	LD.B      R5, [R6 + #10]
80008746:	78 00 45 f8 	ST.B      [R2 + #62], R5			;->0x3E
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
8000874a:	ae 8a       	LD.B      R5, [R6 + #10]
8000874c:	50 38       	CMP       R5, #0			;->0x00
8000874e:	1c f0       	JZ        $+28                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008750:	ee 8a       	LD.B      R5, [R6 + #11]
80008752:	78 00 45 fc 	ST.B      [R2 + #63], R5			;->0x3F
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
80008756:	ee 8a       	LD.B      R5, [R6 + #11]
80008758:	50 38       	CMP       R5, #0			;->0x00
8000875a:	16 f0       	JZ        $+22                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
8000875c:	2e 8b       	LD.B      R5, [R6 + #12]
8000875e:	79 00 45 00 	ST.B      [R2 + #64], R5			;->0x40
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
80008762:	2e 8b       	LD.B      R5, [R6 + #12]
80008764:	50 38       	CMP       R5, #0			;->0x00
80008766:	10 f0       	JZ        $+16                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008768:	6e 8b       	LD.B      R5, [R6 + #13]
8000876a:	79 00 45 04 	ST.B      [R2 + #65], R5			;->0x41
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
8000876e:	6e 8b       	LD.B      R5, [R6 + #13]
80008770:	50 38       	CMP       R5, #0			;->0x00
80008772:	0a f0       	JZ        $+10                  ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008774:	ae 8b       	LD.B      R5, [R6 + #14]
80008776:	79 00 45 08 	ST.B      [R2 + #66], R5			;->0x42
##@@@P_:tasks.c:1864
##@@@L1860_:
##@@@L1861_:            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than   
##@@@L1862_:             * configMAX_TASK_NAME_LEN characters just in case the memory after the   
##@@@L1863_:             * string is not accessible (extremely unlikely). */   
##@@@L1864_:            if( pcName[ x ] == ( char ) 0x00 )   
8000877a:	ae 8b       	LD.B      R5, [R6 + #14]
8000877c:	50 38       	CMP       R5, #0			;->0x00
8000877e:	04 f0       	JZ        $+4                   ;->0x80008786
##@@@P_:tasks.c:1859
##@@@L1854_:    /* Store the task name in the TCB. */   
##@@@L1855_:    if( pcName != NULL )   
##@@@L1856_:    {   
##@@@L1857_:        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )   
##@@@L1858_:        {   
##@@@L1859_:            pxNewTCB->pcTaskName[ x ] = pcName[ x ];   
80008780:	ee 8b       	LD.B      R5, [R6 + #15]
80008782:	79 00 45 0c 	ST.B      [R2 + #67], R5			;->0x43
80008786:	50 10       	MOV       R5, #0			;->0x0000
80008788:	79 00 45 0c 	ST.B      [R2 + #67], R5			;->0x43
##@@@P_:tasks.c:1876
##@@@L1871_:            }   
##@@@L1872_:        }   
##@@@L1873_:
##@@@L1874_:        /* Ensure the name string is terminated in the case that the string length   
##@@@L1875_:         * was greater or equal to configMAX_TASK_NAME_LEN. */   
##@@@L1876_:        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';   
8000878c:	03 0b       	LD.W      R3, [SP + #3]
##@@@P_:tasks.c:1884
##@@@L1879_:    {   
##@@@L1880_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1881_:    }   
##@@@L1882_:
##@@@L1883_:    /* This is used as an array index so must ensure it's not too large. */   
##@@@L1884_:    configASSERT( uxPriority < configMAX_PRIORITIES );   
8000878e:	3e 39       	CMP       R3, #30			;->0x1E
80008790:	30 f2       	JC        $+48                  ;->0x800087f0
80008792:	2f 9b       	LD.W      R5, [R7 + #12]
80008794:	02 0c       	LD.W      R4, [SP + #2]
80008796:	6c c3       	ADD       R5, R4, R5
80008798:	13 44       	LD        R4, [PC + #19]        ;->0x800087e4  :=0xfffffffc
8000879a:	2d cd       	SUB       R5, R5, #4
8000879c:	54 69       	ANL       R5, R4
8000879e:	01 25       	ST.W      [SP + #1], R5
800087a0:	09 0d       	LD.W      R5, [SP + #9]
##@@@P_:tasks.c:1898
##@@@L1893_:    }   
##@@@L1894_:
##@@@L1895_:    pxNewTCB->uxPriority = uxPriority;   
##@@@L1896_:    #if ( configUSE_MUTEXES == 1 )   
##@@@L1897_:    {   
##@@@L1898_:        pxNewTCB->uxBasePriority = uxPriority;   
800087a2:	02 25       	ST.W      [SP + #2], R5
800087a4:	13 a5       	ST.W      [R2 + #20], R3
##@@@P_:tasks.c:1895
##@@@L1890_:    else   
##@@@L1891_:    {   
##@@@L1892_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1893_:    }   
##@@@L1894_:
##@@@L1895_:    pxNewTCB->uxPriority = uxPriority;   
800087a6:	d3 a2       	ST.W      [R2 + #11], R3
##@@@P_:tasks.c:1902
##@@@L1897_:    {   
##@@@L1898_:        pxNewTCB->uxBasePriority = uxPriority;   
##@@@L1899_:    }   
##@@@L1900_:    #endif /* configUSE_MUTEXES */   
##@@@L1901_:
##@@@L1902_:    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );   
800087a8:	07 c1       	ADD       R0, R7, #4
800087aa:	c2 58       	MOV       R6, R2
800087ac:	0f 45       	LD        R5, [PC + #15]        ;->0x800087e8  :=0x8000223c
800087ae:	05 5c       	LJMP      R5
##@@@P_:tasks.c:1903
##@@@L1903_:    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );   
800087b0:	78 29       	ADD       R7, #24			;->0x18
800087b2:	07 58       	MOV       R0, R7
800087b4:	0d 45       	LD        R5, [PC + #13]        ;->0x800087e8  :=0x8000223c
800087b6:	05 5c       	LJMP      R5
800087b8:	5e 11       	MOV       R5, #30			;->0x001E
##@@@P_:tasks.c:1910
##@@@L1905_:    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get   
##@@@L1906_:     * back to  the containing TCB from a generic item in a list. */   
##@@@L1907_:    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );   
##@@@L1908_:
##@@@L1909_:    /* Event lists are always in priority order. */   
##@@@L1910_:    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );   
800087ba:	03 0c       	LD.W      R4, [SP + #3]
800087bc:	2d c7       	SUB       R5, R5, R4
800087be:	b5 a1       	ST.W      [R6 + #6], R5
##@@@P_:tasks.c:1911
##@@@L1911_:    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );   
800087c0:	76 a2       	ST.W      [R6 + #9], R6
##@@@P_:tasks.c:1907
##@@@L1902_:    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );   
##@@@L1903_:    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );   
##@@@L1904_:
##@@@L1905_:    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get   
##@@@L1906_:     * back to  the containing TCB from a generic item in a list. */   
##@@@L1907_:    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );   
800087c2:	36 a1       	ST.W      [R6 + #4], R6
##@@@P_:tasks.c:1977
##@@@L1972_:            }   
##@@@L1973_:            #endif /* portSTACK_GROWTH */   
##@@@L1974_:        }   
##@@@L1975_:        #else /* portHAS_STACK_OVERFLOW_CHECKING */   
##@@@L1976_:        {   
##@@@L1977_:            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );   
800087c4:	01 08       	LD.W      R0, [SP + #1]
800087c6:	29 58       	MOV       R1, R9
800087c8:	48 58       	MOV       R2, R8
800087ca:	09 45       	LD        R5, [PC + #9]         ;->0x800087ec  :=0x80008da0
800087cc:	05 5c       	LJMP      R5
800087ce:	02 0d       	LD.W      R5, [SP + #2]
##@@@P_:tasks.c:1996
##@@@L1991_:            pxNewTCB->uxTaskAttributes |= taskATTRIBUTE_IS_IDLE;   
##@@@L1992_:        }   
##@@@L1993_:    }   
##@@@L1994_:    #endif /* #if ( configNUMBER_OF_CORES > 1 ) */   
##@@@L1995_:
##@@@L1996_:    if( pxCreatedTask != NULL )   
800087d0:	50 38       	CMP       R5, #0			;->0x00
##@@@P_:tasks.c:1977
##@@@L1972_:            }   
##@@@L1973_:            #endif /* portSTACK_GROWTH */   
##@@@L1974_:        }   
##@@@L1975_:        #else /* portHAS_STACK_OVERFLOW_CHECKING */   
##@@@L1976_:        {   
##@@@L1977_:            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );   
800087d2:	60 85       	ST.W      [R6], R0
##@@@P_:tasks.c:1996
##@@@L1991_:            pxNewTCB->uxTaskAttributes |= taskATTRIBUTE_IS_IDLE;   
##@@@L1992_:        }   
##@@@L1993_:    }   
##@@@L1994_:    #endif /* #if ( configNUMBER_OF_CORES > 1 ) */   
##@@@L1995_:
##@@@L1996_:    if( pxCreatedTask != NULL )   
800087d4:	02 f0       	JZ        $+2                   ;->0x800087d8
##@@@P_:tasks.c:2000
##@@@L1997_:    {   
##@@@L1998_:        /* Pass the handle out in an anonymous way.  The handle can be used to   
##@@@L1999_:         * change the created task's priority, delete the created task, etc.*/   
##@@@L2000_:        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;   
800087d6:	56 85       	ST.W      [R5], R6
##@@@P_:tasks.c:2006
##@@@L2001_:    }   
##@@@L2002_:    else   
##@@@L2003_:    {   
##@@@L2004_:        mtCOVERAGE_TEST_MARKER();   
##@@@L2005_:    }   
##@@@L2006_:}   
800087d8:	e0 29       	ADD       SP, #16			;->0x10
800087da:	0f 5e       	POP       {R6-R9}
800087dc:	0d 5d       	POP       LR
800087de:	1d 5c       	JMP       LR
800087e0:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
800087e4:	fc ff ff ff 	.long     0xfffffffc ->-00000004 
800087e8:	3c 22 00 80 	.long     0x8000223c ->-2147474884  [!!!@2@:ST.W      [SP + #60], R2	@@: LD.B      R0, [R0]
800087ec:	a0 8d 00 80 	.long     0x80008da0 ->-2147447392  [!!!@2@:LD.B      R4, [R0 + #22]	@@: LD.B      R0, [R0]
##@@@P_:tasks.c:1884
##@@@L1879_:    {   
##@@@L1880_:        mtCOVERAGE_TEST_MARKER();   
##@@@L1881_:    }   
##@@@L1882_:
##@@@L1883_:    /* This is used as an array index so must ensure it's not too large. */   
##@@@L1884_:    configASSERT( uxPriority < configMAX_PRIORITIES );   
800087f0:	20 5d       	PUSH      R0
800087f2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800087f6:	08 00       	SYNC     SYNC     
800087f8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800087fc:	08 00       	SYNC     SYNC     
800087fe:	00 5d       	POP       R0
80008800:	20 5d       	PUSH      R0
80008802:	21 5d       	PUSH      R1
80008804:	0d 45       	LD        R5, [PC + #13]        ;->0x80008838  :=0x1ff
80008806:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000880a:	25 58       	MOV       R1, R5
8000880c:	11 68       	NOT       R1, R1
8000880e:	01 69       	ANL       R0, R1
80008810:	5f 11       	MOV       R5, #31			;->0x001F
80008812:	25 58       	MOV       R1, R5
80008814:	01 6a       	ORL       R0, R1
80008816:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000881a:	08 00       	SYNC     SYNC     
8000881c:	01 5d       	POP       R1
8000881e:	00 5d       	POP       R0
80008820:	20 5d       	PUSH      R0
80008822:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008826:	08 00       	SYNC     SYNC     
80008828:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000882c:	08 00       	SYNC     SYNC     
8000882e:	00 5d       	POP       R0
80008830:	07 00       	BREAK    BREAK    
80008832:	03 45       	LD        R5, [PC + #3]         ;->0x8000883c  :=0x8000911c
80008834:	05 5c       	LJMP      R5
80008836:	00 00       	NOP      NOP      
80008838:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
8000883c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80008840 <prvIdleTask>:
##@@@F_:prvIdleTask():
##@@@P_:tasks.c:5788
##@@@L5783_: * void prvIdleTask( void *pvParameters );   
##@@@L5784_: *   
##@@@L5785_: */   
##@@@L5786_:
##@@@L5787_:static portTASK_FUNCTION( prvIdleTask, pvParameters )   
##@@@L5788_:{   
80008840:	87 5f       	PUSH      {R6-R8,LR}
80008842:	e8 31       	SUB       SP, #24			;->0x18
80008844:	3d 47       	LD        R7, [PC + #61]        ;->0x80008938  :=0xd000005c
80008846:	3e 45       	LD        R5, [PC + #62]        ;->0x8000893c  :=0x1ff
80008848:	05 25       	ST.W      [SP + #5], R5
8000884a:	3e 45       	LD        R5, [PC + #62]        ;->0x80008940  :=0xd0000064
8000884c:	04 25       	ST.W      [SP + #4], R5
8000884e:	3e 45       	LD        R5, [PC + #62]        ;->0x80008944  :=0xd0000048
80008850:	03 25       	ST.W      [SP + #3], R5
80008852:	3e 45       	LD        R5, [PC + #62]        ;->0x80008948  :=0xd0000060
80008854:	02 25       	ST.W      [SP + #2], R5
80008856:	3e 45       	LD        R5, [PC + #62]        ;->0x8000894c  :=0xd0000040
80008858:	01 25       	ST.W      [SP + #1], R5
8000885a:	8f 11       	MOV       R8, #31			;->0x001F
8000885c:	04 04       	SJMP      $+4                   ;->0x80008864
##@@@F_:prvDeleteTCB():
8000885e:	06 58       	MOV       R0, R6
80008860:	3c 45       	LD        R5, [PC + #60]        ;->0x80008950  :=0x80008b9c
80008862:	05 5c       	LJMP      R5
##@@@F_:prvCheckTasksWaitingTermination():
##@@@P_:tasks.c:6092
##@@@L6087_:    {   
##@@@L6088_:        TCB_t * pxTCB;   
##@@@L6089_:
##@@@L6090_:        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()   
##@@@L6091_:         * being called too often in the idle task. */   
##@@@L6092_:        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )   
80008864:	57 82       	LD.W      R5, [R7]
80008866:	50 38       	CMP       R5, #0			;->0x00
80008868:	fe f0       	JZ        $-2                   ;->0x80008864
##@@@F_:vTaskEnterCritical():
##@@@P_:tasks.c:6960
##@@@L6955_:
##@@@L6956_:    void vTaskEnterCritical( void )   
##@@@L6957_:    {   
##@@@L6958_:        traceENTER_vTaskEnterCritical();   
##@@@L6959_:
##@@@L6960_:        portDISABLE_INTERRUPTS();   
8000886a:	20 5d       	PUSH      R0
8000886c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008870:	08 00       	SYNC     SYNC     
80008872:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008876:	08 00       	SYNC     SYNC     
80008878:	00 5d       	POP       R0
8000887a:	20 5d       	PUSH      R0
8000887c:	21 5d       	PUSH      R1
8000887e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008882:	05 0d       	LD.W      R5, [SP + #5]
80008884:	25 58       	MOV       R1, R5
80008886:	11 68       	NOT       R1, R1
80008888:	01 69       	ANL       R0, R1
8000888a:	28 58       	MOV       R1, R8
8000888c:	01 6a       	ORL       R0, R1
8000888e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008892:	08 00       	SYNC     SYNC     
80008894:	01 5d       	POP       R1
80008896:	00 5d       	POP       R0
80008898:	20 5d       	PUSH      R0
8000889a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000889e:	08 00       	SYNC     SYNC     
800088a0:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800088a4:	08 00       	SYNC     SYNC     
800088a6:	00 5d       	POP       R0
##@@@P_:tasks.c:6962
##@@@L6961_:
##@@@L6962_:        if( xSchedulerRunning != pdFALSE )   
800088a8:	04 0d       	LD.W      R5, [SP + #4]
800088aa:	55 82       	LD.W      R5, [R5]
800088ac:	50 38       	CMP       R5, #0			;->0x00
800088ae:	07 f0       	JZ        $+7                   ;->0x800088bc
800088b0:	01 0b       	LD.W      R3, [SP + #1]
##@@@P_:tasks.c:6964
##@@@L6963_:        {   
##@@@L6964_:            ( pxCurrentTCB->uxCriticalNesting )++;   
800088b2:	53 82       	LD.W      R5, [R3]
800088b4:	65 9c       	LD.W      R4, [R5 + #17]
800088b6:	64 c0       	ADD       R4, R4, #1
800088b8:	6c a4       	ST.W      [R5 + #17], R4
##@@@P_:tasks.c:6972
##@@@L6967_:             * function so  assert() if it is being called from an interrupt   
##@@@L6968_:             * context.  Only API functions that end in "FromISR" can be used in an   
##@@@L6969_:             * interrupt.  Only assert if the critical nesting count is 1 to   
##@@@L6970_:             * protect against recursive calls if the assert function also uses a   
##@@@L6971_:             * critical section. */   
##@@@L6972_:            if( pxCurrentTCB->uxCriticalNesting == 1U )   
800088ba:	53 82       	LD.W      R5, [R3]
##@@@F_:prvCheckTasksWaitingTermination():
##@@@P_:tasks.c:6102
##@@@L6097_:                {   
##@@@L6098_:                    {   
##@@@L6099_:                        /* MISRA Ref 11.5.3 [Void pointer assignment] */   
##@@@L6100_:                        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */   
##@@@L6101_:                        /* coverity[misra_c_2012_rule_11_5_violation] */   
##@@@L6102_:                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );   
800088bc:	03 0d       	LD.W      R5, [SP + #3]
800088be:	ed 98       	LD.W      R5, [R5 + #3]
800088c0:	f5 98       	LD.W      R6, [R5 + #3]
##@@@P_:tasks.c:6103
##@@@L6103_:                        ( void ) uxListRemove( &( pxTCB->xStateListItem ) );   
800088c2:	06 c1       	ADD       R0, R6, #4
800088c4:	24 45       	LD        R5, [PC + #36]        ;->0x80008954  :=0x80002290
800088c6:	05 5c       	LJMP      R5
800088c8:	02 0c       	LD.W      R4, [SP + #2]
##@@@P_:tasks.c:6104
##@@@L6104_:                        --uxCurrentNumberOfTasks;   
800088ca:	54 82       	LD.W      R5, [R4]
800088cc:	6d cc       	SUB       R5, R5, #1
800088ce:	45 85       	ST.W      [R4], R5
##@@@P_:tasks.c:6105
##@@@L6105_:                        --uxDeletedTasksWaitingCleanUp;   
800088d0:	57 82       	LD.W      R5, [R7]
800088d2:	6d cc       	SUB       R5, R5, #1
800088d4:	75 85       	ST.W      [R7], R5
##@@@P_:tasks.c:6108
##@@@L6106_:                    }   
##@@@L6107_:                }   
##@@@L6108_:                taskEXIT_CRITICAL();   
800088d6:	21 45       	LD        R5, [PC + #33]        ;->0x80008958  :=0x80005730
800088d8:	05 5c       	LJMP      R5
##@@@F_:prvDeleteTCB():
800088da:	51 00 c5 d4 	LD.B      R5, [R6 + #117]			;->0x75
##@@@P_:tasks.c:6467
##@@@L6462_:        #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )   
##@@@L6463_:        {   
##@@@L6464_:            /* The task could have been allocated statically or dynamically, so   
##@@@L6465_:             * check what was statically allocated before trying to free the   
##@@@L6466_:             * memory. */   
##@@@L6467_:            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )   
800088de:	52 38       	CMP       R5, #2			;->0x02
800088e0:	c2 f0       	JZ        $-62                  ;->0x80008864
800088e2:	51 38       	CMP       R5, #1			;->0x01
800088e4:	bd f0       	JZ        $-67                  ;->0x8000885e
800088e6:	50 38       	CMP       R5, #0			;->0x00
800088e8:	05 f1       	JNZ       $+5                   ;->0x800088f2
##@@@P_:tasks.c:6471
##@@@L6468_:            {   
##@@@L6469_:                /* Both the stack and TCB were allocated dynamically, so both   
##@@@L6470_:                 * must be freed. */   
##@@@L6471_:                vPortFreeStack( pxTCB->pxStack );   
800088ea:	06 9b       	LD.W      R0, [R6 + #12]
800088ec:	19 45       	LD        R5, [PC + #25]        ;->0x80008950  :=0x80008b9c
800088ee:	05 5c       	LJMP      R5
800088f0:	b7 07       	SJMP      $-73                  ;->0x8000885e
##@@@P_:tasks.c:6484
##@@@L6479_:            }   
##@@@L6480_:            else   
##@@@L6481_:            {   
##@@@L6482_:                /* Neither the stack nor the TCB were allocated dynamically, so   
##@@@L6483_:                 * nothing needs to be freed. */   
##@@@L6484_:                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );   
800088f2:	20 5d       	PUSH      R0
800088f4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800088f8:	08 00       	SYNC     SYNC     
800088fa:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
800088fe:	08 00       	SYNC     SYNC     
80008900:	00 5d       	POP       R0
80008902:	20 5d       	PUSH      R0
80008904:	21 5d       	PUSH      R1
80008906:	0e 45       	LD        R5, [PC + #14]        ;->0x8000893c  :=0x1ff
80008908:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
8000890c:	25 58       	MOV       R1, R5
8000890e:	11 68       	NOT       R1, R1
80008910:	01 69       	ANL       R0, R1
80008912:	5f 11       	MOV       R5, #31			;->0x001F
80008914:	25 58       	MOV       R1, R5
80008916:	01 6a       	ORL       R0, R1
80008918:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
8000891c:	08 00       	SYNC     SYNC     
8000891e:	01 5d       	POP       R1
80008920:	00 5d       	POP       R0
80008922:	20 5d       	PUSH      R0
80008924:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008928:	08 00       	SYNC     SYNC     
8000892a:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000892e:	08 00       	SYNC     SYNC     
80008930:	00 5d       	POP       R0
80008932:	07 00       	BREAK    BREAK    
80008934:	0a 45       	LD        R5, [PC + #10]        ;->0x8000895c  :=0x8000911c
80008936:	05 5c       	LJMP      R5
##@@@F_:prvIdleTask():
80008938:	5c 00 00 d0 	.long     0xd000005c ->-805306276  [!!!@4@:LDS.H     R0, [R0 + #-204]
8000893c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80008940:	64 00 00 d0 	.long     0xd0000064 ->-805306268  [!!!@4@:LDS.B     R0, [R0 + #-204]
80008944:	48 00 00 d0 	.long     0xd0000048 ->-805306296  [!!!@4@:LD.H      R0, [R0 + #52]
80008948:	60 00 00 d0 	.long     0xd0000060 ->-805306272  [!!!@4@:LDS.B     R0, [R0 + #52]
8000894c:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
80008950:	9c 8b 00 80 	.long     0x80008b9c ->-2147447908  [!!!@2@:LD.B      R3, [R4 + #14]	@@: LD.B      R0, [R0]
80008954:	90 22 00 80 	.long     0x80002290 ->-2147474800  [!!!@2@:ST.W      [SP + #144], R2	@@: LD.B      R0, [R0]
80008958:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80008958
8000895c:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80008960 <pvPortMalloc>:
##@@@F_:pvPortMalloc():
##@@@P_:heap_4.c:116
##@@@L0111_:static size_t xBlockAllocatedBit = 0;   
##@@@L0112_:
##@@@L0113_:/*-----------------------------------------------------------*/   
##@@@L0114_:
##@@@L0115_:void *pvPortMalloc(size_t xWantedSize)   
##@@@L0116_:{   
80008960:	8f 5f       	PUSH      {R6-R9,LR}
80008962:	ec 30       	SUB       SP, #12			;->0x0C
80008964:	c0 58       	MOV       R6, R0
##@@@P_:heap_4.c:120
##@@@L0117_:	BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;   
##@@@L0118_:	void *pvReturn = NULL;   
##@@@L0119_:
##@@@L0120_:	vTaskSuspendAll();   
80008966:	5d 45       	LD        R5, [PC + #93]        ;->0x80008ad8  :=0x800059b0
80008968:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:124
##@@@L0121_:	{   
##@@@L0122_:		/* If this is the first call to malloc then the heap will require   
##@@@L0123_:		initialisation to setup the list of free blocks. */   
##@@@L0124_:		if (pxEnd == NULL)   
8000896a:	5d 45       	LD        R5, [PC + #93]        ;->0x80008adc  :=0xd0000340
8000896c:	45 82       	LD.W      R4, [R5]
8000896e:	40 38       	CMP       R4, #0			;->0x00
80008970:	07 f0       	JZ        $+7                   ;->0x8000897e
##@@@P_:heap_4.c:137
##@@@L0132_:
##@@@L0133_:		/* Check the requested block size is not so large that the top bit is   
##@@@L0134_:		set.  The top bit of the block size member of the BlockLink_t structure   
##@@@L0135_:		is used to determine who owns the block - the application or the   
##@@@L0136_:		kernel, so it must be free. */   
##@@@L0137_:		if ((xWantedSize & xBlockAllocatedBit) == 0)   
80008972:	5c 44       	LD        R4, [PC + #92]        ;->0x80008ae0  :=0xd0000344
80008974:	44 80       	LD.B      R4, [R4]
##@@@P_:heap_4.c:124
##@@@L0119_:
##@@@L0120_:	vTaskSuspendAll();   
##@@@L0121_:	{   
##@@@L0122_:		/* If this is the first call to malloc then the heap will require   
##@@@L0123_:		initialisation to setup the list of free blocks. */   
##@@@L0124_:		if (pxEnd == NULL)   
80008976:	40 38       	CMP       R4, #0			;->0x00
80008978:	29 f1       	JNZ       $+41                  ;->0x800089ca
8000897a:	40 10       	MOV       R4, #0			;->0x0000
8000897c:	28 04       	SJMP      $+40                  ;->0x800089cc
##@@@F_:prvHeapInit():
##@@@P_:heap_4.c:354
##@@@L0349_:
##@@@L0350_:	pucAlignedHeap = (uint8_t *)uxAddress;   
##@@@L0351_:
##@@@L0352_:	/* xStart is used to hold a pointer to the first item in the list of free   
##@@@L0353_:	blocks.  The void cast is used to prevent compiler warnings. */   
##@@@L0354_:	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;   
8000897e:	5a 42       	LD        R2, [PC + #90]        ;->0x80008ae4  :=0xd0000360
80008980:	43 10       	MOV       R4, #3			;->0x0003
80008982:	02 58       	MOV       R0, R2
80008984:	04 69       	ANL       R0, R4
80008986:	e2 c0       	ADD       R4, R2, #3
80008988:	58 43       	LD        R3, [PC + #88]        ;->0x80008ae8  :=0xfffffffc
8000898a:	59 41       	LD        R1, [PC + #89]        ;->0x80008aec  :=0x8000
8000898c:	43 69       	ANL       R4, R3
##@@@P_:heap_4.c:362
##@@@L0357_:	/* pxEnd is used to mark the end of the list of free blocks and is inserted   
##@@@L0358_:	at the end of the heap space. */   
##@@@L0359_:	uxAddress = ((size_t)pucAlignedHeap) + xTotalHeapSize;   
##@@@L0360_:	uxAddress -= xHeapStructSize;   
##@@@L0361_:	uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);   
##@@@L0362_:	pxEnd = (void *)uxAddress;   
8000898e:	00 38       	CMP       R0, #0			;->0x00
80008990:	03 f0       	JZ        $+3                   ;->0x80008996
80008992:	3a c7       	SUB       R7, R2, R4
80008994:	4f c2       	ADD       R1, R7, R1
##@@@P_:heap_4.c:354
##@@@L0349_:
##@@@L0350_:	pucAlignedHeap = (uint8_t *)uxAddress;   
##@@@L0351_:
##@@@L0352_:	/* xStart is used to hold a pointer to the first item in the list of free   
##@@@L0353_:	blocks.  The void cast is used to prevent compiler warnings. */   
##@@@L0354_:	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;   
80008996:	00 38       	CMP       R0, #0			;->0x00
80008998:	02 f1       	JNZ       $+2                   ;->0x8000899c
8000899a:	82 58       	MOV       R4, R2
8000899c:	55 42       	LD        R2, [PC + #85]        ;->0x80008af0  :=0xd000034c
8000899e:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:heap_4.c:355
##@@@L0355_:	xStart.xBlockSize = (size_t)0;   
800089a0:	50 a0       	ST.W      [R2 + #1], R0
##@@@P_:heap_4.c:354
##@@@L0349_:
##@@@L0350_:	pucAlignedHeap = (uint8_t *)uxAddress;   
##@@@L0351_:
##@@@L0352_:	/* xStart is used to hold a pointer to the first item in the list of free   
##@@@L0353_:	blocks.  The void cast is used to prevent compiler warnings. */   
##@@@L0354_:	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;   
800089a2:	24 85       	ST.W      [R2], R4
##@@@P_:heap_4.c:362
##@@@L0357_:	/* pxEnd is used to mark the end of the list of free blocks and is inserted   
##@@@L0358_:	at the end of the heap space. */   
##@@@L0359_:	uxAddress = ((size_t)pucAlignedHeap) + xTotalHeapSize;   
##@@@L0360_:	uxAddress -= xHeapStructSize;   
##@@@L0361_:	uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);   
##@@@L0362_:	pxEnd = (void *)uxAddress;   
800089a4:	54 c2       	ADD       R2, R4, R1
800089a6:	28 30       	SUB       R2, #8			;->0x08
800089a8:	23 69       	ANL       R2, R3
800089aa:	52 85       	ST.W      [R5], R2
##@@@P_:heap_4.c:364
##@@@L0363_:	pxEnd->xBlockSize = 0;   
##@@@L0364_:	pxEnd->pxNextFreeBlock = NULL;   
800089ac:	20 85       	ST.W      [R2], R0
##@@@P_:heap_4.c:363
##@@@L0358_:	at the end of the heap space. */   
##@@@L0359_:	uxAddress = ((size_t)pucAlignedHeap) + xTotalHeapSize;   
##@@@L0360_:	uxAddress -= xHeapStructSize;   
##@@@L0361_:	uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);   
##@@@L0362_:	pxEnd = (void *)uxAddress;   
##@@@L0363_:	pxEnd->xBlockSize = 0;   
800089ae:	50 a0       	ST.W      [R2 + #1], R0
##@@@P_:heap_4.c:369
##@@@L0364_:	pxEnd->pxNextFreeBlock = NULL;   
##@@@L0365_:
##@@@L0366_:	/* To start with there is a single free block that is sized to take up the   
##@@@L0367_:	entire heap space, minus the space taken by pxEnd. */   
##@@@L0368_:	pxFirstFreeBlock = (void *)pucAlignedHeap;   
##@@@L0369_:	pxFirstFreeBlock->xBlockSize = uxAddress - (size_t)pxFirstFreeBlock;   
800089b0:	1a c7       	SUB       R3, R2, R4
800089b2:	63 a0       	ST.W      [R4 + #1], R3
##@@@P_:heap_4.c:370
##@@@L0370_:	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;   
800089b4:	25 82       	LD.W      R2, [R5]
800089b6:	42 85       	ST.W      [R4], R2
##@@@P_:heap_4.c:374
##@@@L0371_:
##@@@L0372_:	/* Only one block exists - and it covers the entire usable heap space. */   
##@@@L0373_:	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;   
##@@@L0374_:	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;   
800089b8:	4f 44       	LD        R4, [PC + #79]        ;->0x80008af4  :=0xd0000348
##@@@P_:heap_4.c:373
##@@@L0368_:	pxFirstFreeBlock = (void *)pucAlignedHeap;   
##@@@L0369_:	pxFirstFreeBlock->xBlockSize = uxAddress - (size_t)pxFirstFreeBlock;   
##@@@L0370_:	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;   
##@@@L0371_:
##@@@L0372_:	/* Only one block exists - and it covers the entire usable heap space. */   
##@@@L0373_:	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;   
800089ba:	50 42       	LD        R2, [PC + #80]        ;->0x80008af8  :=0xd0000354
##@@@P_:heap_4.c:374
##@@@L0374_:	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;   
800089bc:	43 85       	ST.W      [R4], R3
##@@@P_:heap_4.c:373
##@@@L0368_:	pxFirstFreeBlock = (void *)pucAlignedHeap;   
##@@@L0369_:	pxFirstFreeBlock->xBlockSize = uxAddress - (size_t)pxFirstFreeBlock;   
##@@@L0370_:	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;   
##@@@L0371_:
##@@@L0372_:	/* Only one block exists - and it covers the entire usable heap space. */   
##@@@L0373_:	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;   
800089be:	23 85       	ST.W      [R2], R3
##@@@P_:heap_4.c:377
##@@@L0374_:	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;   
##@@@L0375_:
##@@@L0376_:	/* Work out the position of the top bit in a size_t variable. */   
##@@@L0377_:	xBlockAllocatedBit = ((size_t)1) << ((sizeof(size_t) * heapBITS_PER_BYTE) - 1);   
800089c0:	48 43       	LD        R3, [PC + #72]        ;->0x80008ae0  :=0xd0000344
800089c2:	21 10       	MOV       R2, #1			;->0x0001
800089c4:	4e 44       	LD        R4, [PC + #78]        ;->0x80008afc  :=0x80000000
800089c6:	32 83       	ST.B      [R3], R2
800089c8:	02 04       	SJMP      $+2                   ;->0x800089cc
##@@@F_:pvPortMalloc():
800089ca:	4d 44       	LD        R4, [PC + #77]        ;->0x80008afc  :=0x80000000
800089cc:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:heap_4.c:137
##@@@L0132_:
##@@@L0133_:		/* Check the requested block size is not so large that the top bit is   
##@@@L0134_:		set.  The top bit of the block size member of the BlockLink_t structure   
##@@@L0135_:		is used to determine who owns the block - the application or the   
##@@@L0136_:		kernel, so it must be free. */   
##@@@L0137_:		if ((xWantedSize & xBlockAllocatedBit) == 0)   
800089ce:	60 38       	CMP       R6, #0			;->0x00
800089d0:	02 f1       	JNZ       $+2                   ;->0x800089d4
800089d2:	77 04       	SJMP      $+119                 ;->0x80008ac0
800089d4:	46 69       	ANL       R4, R6
800089d6:	40 38       	CMP       R4, #0			;->0x00
800089d8:	02 f0       	JZ        $+2                   ;->0x800089dc
800089da:	73 04       	SJMP      $+115                 ;->0x80008ac0
800089dc:	13 10       	MOV       R1, #3			;->0x0003
##@@@P_:heap_4.c:147
##@@@L0142_:			{   
##@@@L0143_:				xWantedSize += xHeapStructSize;   
##@@@L0144_:
##@@@L0145_:				/* Ensure that blocks are always aligned to the required number   
##@@@L0146_:				of bytes. */   
##@@@L0147_:				if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0x00)   
800089de:	86 58       	MOV       R4, R6
800089e0:	41 69       	ANL       R4, R1
800089e2:	40 38       	CMP       R4, #0			;->0x00
800089e4:	05 f0       	JZ        $+5                   ;->0x800089ee
800089e6:	41 44       	LD        R4, [PC + #65]        ;->0x80008ae8  :=0xfffffffc
800089e8:	6c 28       	ADD       R6, #12			;->0x0C
800089ea:	64 69       	ANL       R6, R4
800089ec:	02 04       	SJMP      $+2                   ;->0x800089f0
800089ee:	68 28       	ADD       R6, #8			;->0x08
800089f0:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:heap_4.c:163
##@@@L0158_:			else   
##@@@L0159_:			{   
##@@@L0160_:				mtCOVERAGE_TEST_MARKER();   
##@@@L0161_:			}   
##@@@L0162_:
##@@@L0163_:			if ((xWantedSize > 0) && (xWantedSize <= xFreeBytesRemaining))   
800089f2:	60 38       	CMP       R6, #0			;->0x00
800089f4:	02 f1       	JNZ       $+2                   ;->0x800089f8
800089f6:	65 04       	SJMP      $+101                 ;->0x80008ac0
800089f8:	3f 43       	LD        R3, [PC + #63]        ;->0x80008af4  :=0xd0000348
800089fa:	43 82       	LD.W      R4, [R3]
800089fc:	64 70       	CMP       R6, R4
800089fe:	02 f9       	JLS       $+2                   ;->0x80008a02
80008a00:	60 04       	SJMP      $+96                  ;->0x80008ac0
80008a02:	02 23       	ST.W      [SP + #2], R3
##@@@P_:heap_4.c:168
##@@@L0164_:			{   
##@@@L0165_:				/* Traverse the list from the start	(lowest address) block until   
##@@@L0166_:				one	of adequate size is found. */   
##@@@L0167_:				pxPreviousBlock = &xStart;   
##@@@L0168_:				pxBlock = xStart.pxNextFreeBlock;   
80008a04:	3b 40       	LD        R0, [PC + #59]        ;->0x80008af0  :=0xd000034c
80008a06:	40 82       	LD.W      R4, [R0]
##@@@P_:heap_4.c:169
##@@@L0169_:				while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL))   
80008a08:	54 98       	LD.W      R2, [R4 + #1]
80008a0a:	26 70       	CMP       R2, R6
80008a0c:	0e f2       	JC        $+14                  ;->0x80008a28
80008a0e:	74 82       	LD.W      R7, [R4]
80008a10:	70 38       	CMP       R7, #0			;->0x00
80008a12:	0a f0       	JZ        $+10                  ;->0x80008a26
80008a14:	04 58       	MOV       R0, R4
80008a16:	87 58       	MOV       R4, R7
80008a18:	57 98       	LD.W      R2, [R7 + #1]
80008a1a:	26 70       	CMP       R2, R6
80008a1c:	06 f2       	JC        $+6                   ;->0x80008a28
80008a1e:	74 82       	LD.W      R7, [R4]
80008a20:	70 38       	CMP       R7, #0			;->0x00
80008a22:	f9 f1       	JNZ       $-7                   ;->0x80008a14
80008a24:	02 04       	SJMP      $+2                   ;->0x80008a28
80008a26:	33 40       	LD        R0, [PC + #51]        ;->0x80008af0  :=0xd000034c
##@@@P_:heap_4.c:177
##@@@L0172_:					pxBlock = pxBlock->pxNextFreeBlock;   
##@@@L0173_:				}   
##@@@L0174_:
##@@@L0175_:				/* If the end marker was reached then a block of adequate size   
##@@@L0176_:				was	not found. */   
##@@@L0177_:				if (pxBlock != pxEnd)   
80008a28:	75 82       	LD.W      R7, [R5]
80008a2a:	80 10       	MOV       R8, #0			;->0x0000
80008a2c:	47 70       	CMP       R4, R7
80008a2e:	1c f0       	JZ        $+28                  ;->0x80008a66
##@@@P_:heap_4.c:185
##@@@L0180_:					BlockLink_t structure at its start. */   
##@@@L0181_:					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);   
##@@@L0182_:
##@@@L0183_:					/* This block is being returned for use so must be taken out   
##@@@L0184_:					of the list of free blocks. */   
##@@@L0185_:					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;   
80008a30:	94 82       	LD.W      R9, [R4]
##@@@P_:heap_4.c:181
##@@@L0176_:				was	not found. */   
##@@@L0177_:				if (pxBlock != pxEnd)   
##@@@L0178_:				{   
##@@@L0179_:					/* Return the memory space pointed to - jumping over the   
##@@@L0180_:					BlockLink_t structure at its start. */   
##@@@L0181_:					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);   
80008a32:	70 82       	LD.W      R7, [R0]
##@@@P_:heap_4.c:189
##@@@L0184_:					of the list of free blocks. */   
##@@@L0185_:					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;   
##@@@L0186_:
##@@@L0187_:					/* If the block is larger than required it can be split into   
##@@@L0188_:					two. */   
##@@@L0189_:					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE)   
80008a34:	92 c7       	SUB       R2, R2, R6
80008a36:	21 39       	CMP       R2, #17			;->0x11
##@@@P_:heap_4.c:185
##@@@L0180_:					BlockLink_t structure at its start. */   
##@@@L0181_:					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);   
##@@@L0182_:
##@@@L0183_:					/* This block is being returned for use so must be taken out   
##@@@L0184_:					of the list of free blocks. */   
##@@@L0185_:					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;   
80008a38:	09 85       	ST.W      [R0], R9
##@@@P_:heap_4.c:189
##@@@L0186_:
##@@@L0187_:					/* If the block is larger than required it can be split into   
##@@@L0188_:					two. */   
##@@@L0189_:					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE)   
80008a3a:	2a f3       	JNC       $+42                  ;->0x80008a8e
##@@@P_:heap_4.c:195
##@@@L0190_:					{   
##@@@L0191_:						/* This block is to be split into two.  Create a new   
##@@@L0192_:						block following the number of bytes requested. The void   
##@@@L0193_:						cast is used to prevent byte alignment warnings from the   
##@@@L0194_:						compiler. */   
##@@@L0195_:						pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);   
80008a3c:	9c c3       	ADD       R3, R4, R6
##@@@P_:heap_4.c:196
##@@@L0196_:						configASSERT((((size_t)pxNewBlockLink) & portBYTE_ALIGNMENT_MASK) == 0);   
80008a3e:	03 58       	MOV       R0, R3
80008a40:	01 69       	ANL       R0, R1
80008a42:	00 38       	CMP       R0, #0			;->0x00
80008a44:	02 f0       	JZ        $+2                   ;->0x80008a48
80008a46:	84 04       	SJMP      $+132                 ;->0x80008b4e
##@@@P_:heap_4.c:200
##@@@L0197_:
##@@@L0198_:						/* Calculate the sizes of two blocks split from the   
##@@@L0199_:						single block. */   
##@@@L0200_:						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;   
80008a48:	5a a0       	ST.W      [R3 + #1], R2
80008a4a:	2a 41       	LD        R1, [PC + #42]        ;->0x80008af0  :=0xd000034c
##@@@P_:heap_4.c:201
##@@@L0201_:						pxBlock->xBlockSize = xWantedSize;   
80008a4c:	66 a0       	ST.W      [R4 + #1], R6
##@@@F_:prvInsertBlockIntoFreeList():
80008a4e:	c1 58       	MOV       R6, R1
##@@@P_:heap_4.c:388
##@@@L0383_:	BlockLink_t *pxIterator;   
##@@@L0384_:	uint8_t *puc;   
##@@@L0385_:
##@@@L0386_:	/* Iterate through the list until a block is found that has a higher address   
##@@@L0387_:	than the block being inserted. */   
##@@@L0388_:	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock)   
80008a50:	11 82       	LD.W      R1, [R1]
80008a52:	13 70       	CMP       R1, R3
80008a54:	fd f3       	JNC       $-3                   ;->0x80008a4e
##@@@P_:heap_4.c:396
##@@@L0391_:	}   
##@@@L0392_:
##@@@L0393_:	/* Do the block being inserted, and the block it is being inserted after   
##@@@L0394_:	make a contiguous block of memory? */   
##@@@L0395_:	puc = (uint8_t *)pxIterator;   
##@@@L0396_:	if ((puc + pxIterator->xBlockSize) == (uint8_t *)pxBlockToInsert)   
80008a56:	56 98       	LD.W      R2, [R6 + #1]
80008a58:	43 98       	LD.W      R0, [R3 + #1]
80008a5a:	01 20       	ST.W      [SP + #1], R0
80008a5c:	86 c2       	ADD       R0, R6, R2
80008a5e:	03 70       	CMP       R0, R3
80008a60:	05 f0       	JZ        $+5                   ;->0x80008a6a
80008a62:	01 08       	LD.W      R0, [SP + #1]
80008a64:	07 04       	SJMP      $+7                   ;->0x80008a72
80008a66:	e8 58       	MOV       R7, R8
80008a68:	2c 04       	SJMP      $+44                  ;->0x80008ac0
80008a6a:	01 08       	LD.W      R0, [SP + #1]
##@@@P_:heap_4.c:398
##@@@L0397_:	{   
##@@@L0398_:		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;   
80008a6c:	80 c2       	ADD       R0, R0, R2
80008a6e:	70 a0       	ST.W      [R6 + #1], R0
80008a70:	66 58       	MOV       R3, R6
##@@@P_:heap_4.c:409
##@@@L0404_:	}   
##@@@L0405_:
##@@@L0406_:	/* Do the block being inserted, and the block it is being inserted before   
##@@@L0407_:	make a contiguous block of memory? */   
##@@@L0408_:	puc = (uint8_t *)pxBlockToInsert;   
##@@@L0409_:	if ((puc + pxBlockToInsert->xBlockSize) == (uint8_t *)pxIterator->pxNextFreeBlock)   
80008a72:	13 c2       	ADD       R2, R3, R0
80008a74:	21 70       	CMP       R2, R1
80008a76:	08 f1       	JNZ       $+8                   ;->0x80008a86
80008a78:	55 82       	LD.W      R5, [R5]
80008a7a:	15 70       	CMP       R1, R5
80008a7c:	05 f0       	JZ        $+5                   ;->0x80008a86
##@@@P_:heap_4.c:414
##@@@L0410_:	{   
##@@@L0411_:		if (pxIterator->pxNextFreeBlock != pxEnd)   
##@@@L0412_:		{   
##@@@L0413_:			/* Form one big block from the two blocks. */   
##@@@L0414_:			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;   
80008a7e:	69 98       	LD.W      R5, [R1 + #1]
80008a80:	2d c2       	ADD       R5, R5, R0
80008a82:	5d a0       	ST.W      [R3 + #1], R5
##@@@P_:heap_4.c:415
##@@@L0415_:			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;   
80008a84:	11 82       	LD.W      R1, [R1]
##@@@P_:heap_4.c:431
##@@@L0426_:
##@@@L0427_:	/* If the block being inserted plugged a gab, so was merged with the block   
##@@@L0428_:	before and the block after, then it's pxNextFreeBlock pointer will have   
##@@@L0429_:	already been set, and should not be set here as that would make it point   
##@@@L0430_:	to itself. */   
##@@@L0431_:	if (pxIterator != pxBlockToInsert)   
80008a86:	63 70       	CMP       R6, R3
80008a88:	31 85       	ST.W      [R3], R1
80008a8a:	02 f0       	JZ        $+2                   ;->0x80008a8e
##@@@P_:heap_4.c:433
##@@@L0432_:	{   
##@@@L0433_:		pxIterator->pxNextFreeBlock = pxBlockToInsert;   
80008a8c:	63 85       	ST.W      [R6], R3
##@@@F_:pvPortMalloc():
##@@@P_:heap_4.c:211
##@@@L0206_:					else   
##@@@L0207_:					{   
##@@@L0208_:						mtCOVERAGE_TEST_MARKER();   
##@@@L0209_:					}   
##@@@L0210_:
##@@@L0211_:					xFreeBytesRemaining -= pxBlock->xBlockSize;   
80008a8e:	6c 98       	LD.W      R5, [R4 + #1]
##@@@P_:heap_4.c:213
##@@@L0212_:
##@@@L0213_:					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining)   
80008a90:	1a 42       	LD        R2, [PC + #26]        ;->0x80008af8  :=0xd0000354
80008a92:	02 0e       	LD.W      R6, [SP + #2]
##@@@P_:heap_4.c:211
##@@@L0206_:					else   
##@@@L0207_:					{   
##@@@L0208_:						mtCOVERAGE_TEST_MARKER();   
##@@@L0209_:					}   
##@@@L0210_:
##@@@L0211_:					xFreeBytesRemaining -= pxBlock->xBlockSize;   
80008a94:	36 82       	LD.W      R3, [R6]
##@@@P_:heap_4.c:213
##@@@L0212_:
##@@@L0213_:					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining)   
80008a96:	02 82       	LD.W      R0, [R2]
##@@@P_:heap_4.c:211
##@@@L0206_:					else   
##@@@L0207_:					{   
##@@@L0208_:						mtCOVERAGE_TEST_MARKER();   
##@@@L0209_:					}   
##@@@L0210_:
##@@@L0211_:					xFreeBytesRemaining -= pxBlock->xBlockSize;   
80008a98:	4b c7       	SUB       R1, R3, R5
##@@@P_:heap_4.c:213
##@@@L0212_:
##@@@L0213_:					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining)   
80008a9a:	10 70       	CMP       R1, R0
##@@@P_:heap_4.c:211
##@@@L0206_:					else   
##@@@L0207_:					{   
##@@@L0208_:						mtCOVERAGE_TEST_MARKER();   
##@@@L0209_:					}   
##@@@L0210_:
##@@@L0211_:					xFreeBytesRemaining -= pxBlock->xBlockSize;   
80008a9c:	61 85       	ST.W      [R6], R1
##@@@P_:heap_4.c:213
##@@@L0212_:
##@@@L0213_:					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining)   
80008a9e:	02 f2       	JC        $+2                   ;->0x80008aa2
##@@@P_:heap_4.c:215
##@@@L0214_:					{   
##@@@L0215_:						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;   
80008aa0:	21 85       	ST.W      [R2], R1
##@@@P_:heap_4.c:224
##@@@L0219_:						mtCOVERAGE_TEST_MARKER();   
##@@@L0220_:					}   
##@@@L0221_:
##@@@L0222_:					/* The block is being returned - it is allocated and owned   
##@@@L0223_:					by the application and has no "next" block. */   
##@@@L0224_:					pxBlock->xBlockSize |= xBlockAllocatedBit;   
80008aa2:	10 43       	LD        R3, [PC + #16]        ;->0x80008ae0  :=0xd0000344
80008aa4:	33 80       	LD.B      R3, [R3]
80008aa6:	78 28       	ADD       R7, #8			;->0x08
80008aa8:	30 38       	CMP       R3, #0			;->0x00
80008aaa:	03 f1       	JNZ       $+3                   ;->0x80008ab0
80008aac:	68 58       	MOV       R3, R8
80008aae:	02 04       	SJMP      $+2                   ;->0x80008ab2
80008ab0:	13 43       	LD        R3, [PC + #19]        ;->0x80008afc  :=0x80000000
##@@@P_:heap_4.c:225
##@@@L0225_:					pxBlock->pxNextFreeBlock = NULL;   
80008ab2:	48 85       	ST.W      [R4], R8
##@@@P_:heap_4.c:224
##@@@L0219_:						mtCOVERAGE_TEST_MARKER();   
##@@@L0220_:					}   
##@@@L0221_:
##@@@L0222_:					/* The block is being returned - it is allocated and owned   
##@@@L0223_:					by the application and has no "next" block. */   
##@@@L0224_:					pxBlock->xBlockSize |= xBlockAllocatedBit;   
80008ab4:	53 6a       	ORL       R5, R3
##@@@P_:heap_4.c:226
##@@@L0225_:					pxBlock->pxNextFreeBlock = NULL;   
##@@@L0226_:					xNumberOfSuccessfulAllocations++;   
80008ab6:	13 43       	LD        R3, [PC + #19]        ;->0x80008b00  :=0xd0000358
##@@@P_:heap_4.c:224
##@@@L0219_:						mtCOVERAGE_TEST_MARKER();   
##@@@L0220_:					}   
##@@@L0221_:
##@@@L0222_:					/* The block is being returned - it is allocated and owned   
##@@@L0223_:					by the application and has no "next" block. */   
##@@@L0224_:					pxBlock->xBlockSize |= xBlockAllocatedBit;   
80008ab8:	65 a0       	ST.W      [R4 + #1], R5
##@@@P_:heap_4.c:226
##@@@L0225_:					pxBlock->pxNextFreeBlock = NULL;   
##@@@L0226_:					xNumberOfSuccessfulAllocations++;   
80008aba:	53 82       	LD.W      R5, [R3]
80008abc:	6d c0       	ADD       R5, R5, #1
80008abe:	35 85       	ST.W      [R3], R5
80008ac0:	53 10       	MOV       R5, #3			;->0x0003
##@@@P_:heap_4.c:261
##@@@L0256_:			mtCOVERAGE_TEST_MARKER();   
##@@@L0257_:		}   
##@@@L0258_:	}   
##@@@L0259_:#endif   
##@@@L0260_:
##@@@L0261_:	configASSERT((((size_t)pvReturn) & (size_t)portBYTE_ALIGNMENT_MASK) == 0);   
80008ac2:	c7 58       	MOV       R6, R7
80008ac4:	65 69       	ANL       R6, R5
##@@@P_:heap_4.c:245
##@@@L0240_:			mtCOVERAGE_TEST_MARKER();   
##@@@L0241_:		}   
##@@@L0242_:
##@@@L0243_:		traceMALLOC(pvReturn, xWantedSize);   
##@@@L0244_:	}   
##@@@L0245_:	(void)xTaskResumeAll();   
80008ac6:	10 45       	LD        R5, [PC + #16]        ;->0x80008b04  :=0x80005a70
80008ac8:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:261
##@@@L0256_:			mtCOVERAGE_TEST_MARKER();   
##@@@L0257_:		}   
##@@@L0258_:	}   
##@@@L0259_:#endif   
##@@@L0260_:
##@@@L0261_:	configASSERT((((size_t)pvReturn) & (size_t)portBYTE_ALIGNMENT_MASK) == 0);   
80008aca:	60 38       	CMP       R6, #0			;->0x00
80008acc:	1e f1       	JNZ       $+30                  ;->0x80008b08
##@@@P_:heap_4.c:262
##@@@L0262_:	return pvReturn;   
80008ace:	07 58       	MOV       R0, R7
80008ad0:	ec 28       	ADD       SP, #12			;->0x0C
80008ad2:	0f 5e       	POP       {R6-R9}
80008ad4:	0d 5d       	POP       LR
80008ad6:	1d 5c       	JMP       LR
80008ad8:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80008adc:	40 03 00 d0 	.long     0xd0000340 ->-805305536  [!!!@4@:JMP       $+4247552             ;->0x80822adc
80008ae0:	44 03 00 d0 	.long     0xd0000344 ->-805305532  [!!!@4@:JMP       $+4509696             ;->0x808a2ae0
80008ae4:	60 03 00 d0 	.long     0xd0000360 ->-805305504  [!!!@4@:JMP       $+6344704             ;->0x80c22ae4
80008ae8:	fc ff ff ff 	.long     0xfffffffc ->-00000004 
80008aec:	00 80 00 00 	.long     0x00008000 ->000032768  [!!!@2@:LD.B      R0, [R0]	@@: NOP      
80008af0:	4c 03 00 d0 	.long     0xd000034c ->-805305524  [!!!@4@:JMP       $+5033984             ;->0x809a2af0
80008af4:	48 03 00 d0 	.long     0xd0000348 ->-805305528  [!!!@4@:JMP       $+4771840             ;->0x80922af4
80008af8:	54 03 00 d0 	.long     0xd0000354 ->-805305516  [!!!@4@:JMP       $+5558272             ;->0x80aa2af8
80008afc:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
80008b00:	58 03 00 d0 	.long     0xd0000358 ->-805305512  [!!!@4@:JMP       $+5820416             ;->0x80b22b00
80008b04:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
##@@@P_:heap_4.c:261
##@@@L0256_:			mtCOVERAGE_TEST_MARKER();   
##@@@L0257_:		}   
##@@@L0258_:	}   
##@@@L0259_:#endif   
##@@@L0260_:
##@@@L0261_:	configASSERT((((size_t)pvReturn) & (size_t)portBYTE_ALIGNMENT_MASK) == 0);   
80008b08:	20 5d       	PUSH      R0
80008b0a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008b0e:	08 00       	SYNC     SYNC     
80008b10:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008b14:	08 00       	SYNC     SYNC     
80008b16:	00 5d       	POP       R0
80008b18:	20 5d       	PUSH      R0
80008b1a:	21 5d       	PUSH      R1
80008b1c:	1e 45       	LD        R5, [PC + #30]        ;->0x80008b94  :=0x1ff
80008b1e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008b22:	25 58       	MOV       R1, R5
80008b24:	11 68       	NOT       R1, R1
80008b26:	01 69       	ANL       R0, R1
80008b28:	5f 11       	MOV       R5, #31			;->0x001F
80008b2a:	25 58       	MOV       R1, R5
80008b2c:	01 6a       	ORL       R0, R1
80008b2e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008b32:	08 00       	SYNC     SYNC     
80008b34:	01 5d       	POP       R1
80008b36:	00 5d       	POP       R0
80008b38:	20 5d       	PUSH      R0
80008b3a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008b3e:	08 00       	SYNC     SYNC     
80008b40:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008b44:	08 00       	SYNC     SYNC     
80008b46:	00 5d       	POP       R0
80008b48:	07 00       	BREAK    BREAK    
80008b4a:	14 45       	LD        R5, [PC + #20]        ;->0x80008b98  :=0x8000911c
80008b4c:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:196
##@@@L0191_:						/* This block is to be split into two.  Create a new   
##@@@L0192_:						block following the number of bytes requested. The void   
##@@@L0193_:						cast is used to prevent byte alignment warnings from the   
##@@@L0194_:						compiler. */   
##@@@L0195_:						pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);   
##@@@L0196_:						configASSERT((((size_t)pxNewBlockLink) & portBYTE_ALIGNMENT_MASK) == 0);   
80008b4e:	20 5d       	PUSH      R0
80008b50:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008b54:	08 00       	SYNC     SYNC     
80008b56:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008b5a:	08 00       	SYNC     SYNC     
80008b5c:	00 5d       	POP       R0
80008b5e:	20 5d       	PUSH      R0
80008b60:	21 5d       	PUSH      R1
80008b62:	0d 45       	LD        R5, [PC + #13]        ;->0x80008b94  :=0x1ff
80008b64:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008b68:	25 58       	MOV       R1, R5
80008b6a:	11 68       	NOT       R1, R1
80008b6c:	01 69       	ANL       R0, R1
80008b6e:	5f 11       	MOV       R5, #31			;->0x001F
80008b70:	25 58       	MOV       R1, R5
80008b72:	01 6a       	ORL       R0, R1
80008b74:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008b78:	08 00       	SYNC     SYNC     
80008b7a:	01 5d       	POP       R1
80008b7c:	00 5d       	POP       R0
80008b7e:	20 5d       	PUSH      R0
80008b80:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008b84:	08 00       	SYNC     SYNC     
80008b86:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008b8a:	08 00       	SYNC     SYNC     
80008b8c:	00 5d       	POP       R0
80008b8e:	07 00       	BREAK    BREAK    
80008b90:	02 45       	LD        R5, [PC + #2]         ;->0x80008b98  :=0x8000911c
80008b92:	05 5c       	LJMP      R5
80008b94:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80008b98:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80008b9c <vPortFree>:
##@@@F_:vPortFree():
##@@@P_:heap_4.c:267
##@@@L0262_:	return pvReturn;   
##@@@L0263_:}   
##@@@L0264_:/*-----------------------------------------------------------*/   
##@@@L0265_:
##@@@L0266_:void vPortFree(void *pv)   
##@@@L0267_:{   
80008b9c:	83 5f       	PUSH      {R6-R7,LR}
80008b9e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:heap_4.c:271
##@@@L0268_:	uint8_t *puc = (uint8_t *)pv;   
##@@@L0269_:	BlockLink_t *pxLink;   
##@@@L0270_:
##@@@L0271_:	if (pv != NULL)   
80008ba0:	00 38       	CMP       R0, #0			;->0x00
80008ba2:	3e f0       	JZ        $+62                  ;->0x80008c1e
80008ba4:	c0 58       	MOV       R6, R0
##@@@P_:heap_4.c:281
##@@@L0276_:
##@@@L0277_:		/* This casting is to keep the compiler from issuing warnings. */   
##@@@L0278_:		pxLink = (void *)puc;   
##@@@L0279_:
##@@@L0280_:		/* Check the block is actually allocated. */   
##@@@L0281_:		configASSERT((pxLink->xBlockSize & xBlockAllocatedBit) != 0);   
80008ba6:	21 45       	LD        R5, [PC + #33]        ;->0x80008c28  :=0xd0000344
80008ba8:	55 80       	LD.B      R5, [R5]
80008baa:	50 38       	CMP       R5, #0			;->0x00
80008bac:	03 f1       	JNZ       $+3                   ;->0x80008bb2
80008bae:	50 10       	MOV       R5, #0			;->0x0000
80008bb0:	02 04       	SJMP      $+2                   ;->0x80008bb4
80008bb2:	1f 45       	LD        R5, [PC + #31]        ;->0x80008c2c  :=0x80000000
80008bb4:	3e cd       	SUB       R7, R6, #4
80008bb6:	47 82       	LD.W      R4, [R7]
80008bb8:	65 58       	MOV       R3, R5
80008bba:	34 69       	ANL       R3, R4
80008bbc:	30 38       	CMP       R3, #0			;->0x00
80008bbe:	45 f0       	JZ        $+69                  ;->0x80008c48
80008bc0:	68 30       	SUB       R6, #8			;->0x08
##@@@P_:heap_4.c:282
##@@@L0282_:		configASSERT(pxLink->pxNextFreeBlock == NULL);   
80008bc2:	36 82       	LD.W      R3, [R6]
80008bc4:	30 38       	CMP       R3, #0			;->0x00
80008bc6:	64 f1       	JNZ       $+100                 ;->0x80008c8e
##@@@P_:heap_4.c:290
##@@@L0285_:		{   
##@@@L0286_:			if (pxLink->pxNextFreeBlock == NULL)   
##@@@L0287_:			{   
##@@@L0288_:				/* The block is being returned to the heap - it is no longer   
##@@@L0289_:				allocated. */   
##@@@L0290_:				pxLink->xBlockSize &= ~xBlockAllocatedBit;   
80008bc8:	55 68       	NOT       R5, R5
80008bca:	45 69       	ANL       R4, R5
80008bcc:	74 85       	ST.W      [R7], R4
##@@@P_:heap_4.c:292
##@@@L0291_:
##@@@L0292_:				vTaskSuspendAll();   
80008bce:	19 45       	LD        R5, [PC + #25]        ;->0x80008c30  :=0x800059b0
80008bd0:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:295
##@@@L0293_:				{   
##@@@L0294_:					/* Add this block to the list of free blocks. */   
##@@@L0295_:					xFreeBytesRemaining += pxLink->xBlockSize;   
80008bd2:	19 44       	LD        R4, [PC + #25]        ;->0x80008c34  :=0xd0000348
80008bd4:	37 82       	LD.W      R3, [R7]
80008bd6:	54 82       	LD.W      R5, [R4]
80008bd8:	d5 c2       	ADD       R2, R5, R3
80008bda:	18 45       	LD        R5, [PC + #24]        ;->0x80008c38  :=0xd000034c
80008bdc:	42 85       	ST.W      [R4], R2
##@@@F_:prvInsertBlockIntoFreeList():
80008bde:	85 58       	MOV       R4, R5
##@@@P_:heap_4.c:388
##@@@L0383_:	BlockLink_t *pxIterator;   
##@@@L0384_:	uint8_t *puc;   
##@@@L0385_:
##@@@L0386_:	/* Iterate through the list until a block is found that has a higher address   
##@@@L0387_:	than the block being inserted. */   
##@@@L0388_:	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock)   
80008be0:	55 82       	LD.W      R5, [R5]
80008be2:	56 70       	CMP       R5, R6
80008be4:	fd f3       	JNC       $-3                   ;->0x80008bde
##@@@P_:heap_4.c:396
##@@@L0391_:	}   
##@@@L0392_:
##@@@L0393_:	/* Do the block being inserted, and the block it is being inserted after   
##@@@L0394_:	make a contiguous block of memory? */   
##@@@L0395_:	puc = (uint8_t *)pxIterator;   
##@@@L0396_:	if ((puc + pxIterator->xBlockSize) == (uint8_t *)pxBlockToInsert)   
80008be6:	54 98       	LD.W      R2, [R4 + #1]
80008be8:	8c c2       	ADD       R1, R4, R2
80008bea:	16 70       	CMP       R1, R6
80008bec:	04 f1       	JNZ       $+4                   ;->0x80008bf4
##@@@P_:heap_4.c:398
##@@@L0397_:	{   
##@@@L0398_:		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;   
80008bee:	9b c2       	ADD       R3, R3, R2
80008bf0:	63 a0       	ST.W      [R4 + #1], R3
80008bf2:	c4 58       	MOV       R6, R4
##@@@P_:heap_4.c:409
##@@@L0404_:	}   
##@@@L0405_:
##@@@L0406_:	/* Do the block being inserted, and the block it is being inserted before   
##@@@L0407_:	make a contiguous block of memory? */   
##@@@L0408_:	puc = (uint8_t *)pxBlockToInsert;   
##@@@L0409_:	if ((puc + pxBlockToInsert->xBlockSize) == (uint8_t *)pxIterator->pxNextFreeBlock)   
80008bf4:	d6 c2       	ADD       R2, R6, R3
80008bf6:	25 70       	CMP       R2, R5
80008bf8:	09 f1       	JNZ       $+9                   ;->0x80008c0a
80008bfa:	11 42       	LD        R2, [PC + #17]        ;->0x80008c3c  :=0xd0000340
80008bfc:	22 82       	LD.W      R2, [R2]
80008bfe:	52 70       	CMP       R5, R2
80008c00:	05 f0       	JZ        $+5                   ;->0x80008c0a
##@@@P_:heap_4.c:414
##@@@L0410_:	{   
##@@@L0411_:		if (pxIterator->pxNextFreeBlock != pxEnd)   
##@@@L0412_:		{   
##@@@L0413_:			/* Form one big block from the two blocks. */   
##@@@L0414_:			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;   
80008c02:	55 98       	LD.W      R2, [R5 + #1]
80008c04:	da c2       	ADD       R3, R2, R3
80008c06:	73 a0       	ST.W      [R6 + #1], R3
##@@@P_:heap_4.c:415
##@@@L0415_:			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;   
80008c08:	55 82       	LD.W      R5, [R5]
##@@@P_:heap_4.c:431
##@@@L0426_:
##@@@L0427_:	/* If the block being inserted plugged a gab, so was merged with the block   
##@@@L0428_:	before and the block after, then it's pxNextFreeBlock pointer will have   
##@@@L0429_:	already been set, and should not be set here as that would make it point   
##@@@L0430_:	to itself. */   
##@@@L0431_:	if (pxIterator != pxBlockToInsert)   
80008c0a:	46 70       	CMP       R4, R6
80008c0c:	65 85       	ST.W      [R6], R5
80008c0e:	02 f0       	JZ        $+2                   ;->0x80008c12
##@@@P_:heap_4.c:433
##@@@L0432_:	{   
##@@@L0433_:		pxIterator->pxNextFreeBlock = pxBlockToInsert;   
80008c10:	46 85       	ST.W      [R4], R6
##@@@F_:vPortFree():
##@@@P_:heap_4.c:298
##@@@L0293_:				{   
##@@@L0294_:					/* Add this block to the list of free blocks. */   
##@@@L0295_:					xFreeBytesRemaining += pxLink->xBlockSize;   
##@@@L0296_:					traceFREE(pv, pxLink->xBlockSize);   
##@@@L0297_:					prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));   
##@@@L0298_:					xNumberOfSuccessfulFrees++;   
80008c12:	0c 45       	LD        R5, [PC + #12]        ;->0x80008c40  :=0xd000035c
80008c14:	45 82       	LD.W      R4, [R5]
80008c16:	64 c0       	ADD       R4, R4, #1
80008c18:	54 85       	ST.W      [R5], R4
##@@@P_:heap_4.c:300
##@@@L0299_:				}   
##@@@L0300_:				(void)xTaskResumeAll();   
80008c1a:	0b 45       	LD        R5, [PC + #11]        ;->0x80008c44  :=0x80005a70
80008c1c:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:312
##@@@L0307_:		else   
##@@@L0308_:		{   
##@@@L0309_:			mtCOVERAGE_TEST_MARKER();   
##@@@L0310_:		}   
##@@@L0311_:	}   
##@@@L0312_:}   
80008c1e:	e4 28       	ADD       SP, #4			;->0x04
80008c20:	03 5e       	POP       {R6-R7}
80008c22:	0d 5d       	POP       LR
80008c24:	1d 5c       	JMP       LR
80008c26:	00 00       	NOP      NOP      
80008c28:	44 03 00 d0 	.long     0xd0000344 ->-805305532  [!!!@4@:JMP       $+4509696             ;->0x808a2c28
80008c2c:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
80008c30:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80008c34:	48 03 00 d0 	.long     0xd0000348 ->-805305528  [!!!@4@:JMP       $+4771840             ;->0x80922c34
80008c38:	4c 03 00 d0 	.long     0xd000034c ->-805305524  [!!!@4@:JMP       $+5033984             ;->0x809a2c38
80008c3c:	40 03 00 d0 	.long     0xd0000340 ->-805305536  [!!!@4@:JMP       $+4247552             ;->0x80822c3c
80008c40:	5c 03 00 d0 	.long     0xd000035c ->-805305508  [!!!@4@:JMP       $+6082560             ;->0x80ba2c40
80008c44:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
##@@@P_:heap_4.c:281
##@@@L0276_:
##@@@L0277_:		/* This casting is to keep the compiler from issuing warnings. */   
##@@@L0278_:		pxLink = (void *)puc;   
##@@@L0279_:
##@@@L0280_:		/* Check the block is actually allocated. */   
##@@@L0281_:		configASSERT((pxLink->xBlockSize & xBlockAllocatedBit) != 0);   
80008c48:	20 5d       	PUSH      R0
80008c4a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008c4e:	08 00       	SYNC     SYNC     
80008c50:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008c54:	08 00       	SYNC     SYNC     
80008c56:	00 5d       	POP       R0
80008c58:	20 5d       	PUSH      R0
80008c5a:	21 5d       	PUSH      R1
80008c5c:	1e 45       	LD        R5, [PC + #30]        ;->0x80008cd4  :=0x1ff
80008c5e:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008c62:	25 58       	MOV       R1, R5
80008c64:	11 68       	NOT       R1, R1
80008c66:	01 69       	ANL       R0, R1
80008c68:	5f 11       	MOV       R5, #31			;->0x001F
80008c6a:	25 58       	MOV       R1, R5
80008c6c:	01 6a       	ORL       R0, R1
80008c6e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008c72:	08 00       	SYNC     SYNC     
80008c74:	01 5d       	POP       R1
80008c76:	00 5d       	POP       R0
80008c78:	20 5d       	PUSH      R0
80008c7a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008c7e:	08 00       	SYNC     SYNC     
80008c80:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008c84:	08 00       	SYNC     SYNC     
80008c86:	00 5d       	POP       R0
80008c88:	07 00       	BREAK    BREAK    
80008c8a:	14 45       	LD        R5, [PC + #20]        ;->0x80008cd8  :=0x8000911c
80008c8c:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:282
##@@@L0282_:		configASSERT(pxLink->pxNextFreeBlock == NULL);   
80008c8e:	20 5d       	PUSH      R0
80008c90:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008c94:	08 00       	SYNC     SYNC     
80008c96:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008c9a:	08 00       	SYNC     SYNC     
80008c9c:	00 5d       	POP       R0
80008c9e:	20 5d       	PUSH      R0
80008ca0:	21 5d       	PUSH      R1
80008ca2:	0d 45       	LD        R5, [PC + #13]        ;->0x80008cd4  :=0x1ff
80008ca4:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008ca8:	25 58       	MOV       R1, R5
80008caa:	11 68       	NOT       R1, R1
80008cac:	01 69       	ANL       R0, R1
80008cae:	5f 11       	MOV       R5, #31			;->0x001F
80008cb0:	25 58       	MOV       R1, R5
80008cb2:	01 6a       	ORL       R0, R1
80008cb4:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008cb8:	08 00       	SYNC     SYNC     
80008cba:	01 5d       	POP       R1
80008cbc:	00 5d       	POP       R0
80008cbe:	20 5d       	PUSH      R0
80008cc0:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008cc4:	08 00       	SYNC     SYNC     
80008cc6:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008cca:	08 00       	SYNC     SYNC     
80008ccc:	00 5d       	POP       R0
80008cce:	07 00       	BREAK    BREAK    
80008cd0:	02 45       	LD        R5, [PC + #2]         ;->0x80008cd8  :=0x8000911c
80008cd2:	05 5c       	LJMP      R5
80008cd4:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80008cd8:	1c 91 00 80 	.long     0x8000911c ->-2147446500  [!!!@2@:ST.B      [R3 + #4], R4	@@: LD.B      R0, [R0]

80008cdc <xPortGetFreeHeapSize>:
##@@@F_:xPortGetFreeHeapSize():
##@@@P_:heap_4.c:317
##@@@L0312_:}   
##@@@L0313_:/*-----------------------------------------------------------*/   
##@@@L0314_:
##@@@L0315_:size_t xPortGetFreeHeapSize(void)   
##@@@L0316_:{   
##@@@L0317_:	return xFreeBytesRemaining;   
80008cdc:	02 45       	LD        R5, [PC + #2]         ;->0x80008ce4  :=0xd0000348
80008cde:	05 82       	LD.W      R0, [R5]
80008ce0:	1d 5c       	JMP       LR
80008ce2:	00 00       	NOP      NOP      
80008ce4:	48 03 00 d0 	.long     0xd0000348 ->-805305528  [!!!@4@:JMP       $+4771840             ;->0x80922ce4

80008ce8 <xPortGetMinimumEverFreeHeapSize>:
##@@@F_:xPortGetMinimumEverFreeHeapSize():
##@@@P_:heap_4.c:323
##@@@L0318_:}   
##@@@L0319_:/*-----------------------------------------------------------*/   
##@@@L0320_:
##@@@L0321_:size_t xPortGetMinimumEverFreeHeapSize(void)   
##@@@L0322_:{   
##@@@L0323_:	return xMinimumEverFreeBytesRemaining;   
80008ce8:	02 45       	LD        R5, [PC + #2]         ;->0x80008cf0  :=0xd0000354
80008cea:	05 82       	LD.W      R0, [R5]
80008cec:	1d 5c       	JMP       LR
80008cee:	00 00       	NOP      NOP      
80008cf0:	54 03 00 d0 	.long     0xd0000354 ->-805305516  [!!!@4@:JMP       $+5558272             ;->0x80aa2cf0

80008cf4 <vPortInitialiseBlocks>:
##@@@F_:vPortInitialiseBlocks():
##@@@P_:heap_4.c:330
##@@@L0325_:/*-----------------------------------------------------------*/   
##@@@L0326_:
##@@@L0327_:void vPortInitialiseBlocks(void)   
##@@@L0328_:{   
##@@@L0329_:	/* This just exists to keep the linker quiet. */   
##@@@L0330_:}   
80008cf4:	1d 5c       	JMP       LR
	...

80008cf8 <vPortGetHeapStats>:
##@@@F_:vPortGetHeapStats():
##@@@P_:heap_4.c:443
##@@@L0438_:	}   
##@@@L0439_:}   
##@@@L0440_:/*-----------------------------------------------------------*/   
##@@@L0441_:
##@@@L0442_:void vPortGetHeapStats(HeapStats_t *pxHeapStats)   
##@@@L0443_:{   
80008cf8:	83 5f       	PUSH      {R6-R7,LR}
80008cfa:	ec 30       	SUB       SP, #12			;->0x0C
80008cfc:	02 20       	ST.W      [SP + #2], R0
##@@@P_:heap_4.c:447
##@@@L0444_:	BlockLink_t *pxBlock;   
##@@@L0445_:	size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */   
##@@@L0446_:
##@@@L0447_:	vTaskSuspendAll();   
80008cfe:	1e 45       	LD        R5, [PC + #30]        ;->0x80008d74  :=0x800059b0
80008d00:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:449
##@@@L0448_:	{   
##@@@L0449_:		pxBlock = xStart.pxNextFreeBlock;   
80008d02:	1e 45       	LD        R5, [PC + #30]        ;->0x80008d78  :=0xd000034c
80008d04:	55 82       	LD.W      R5, [R5]
##@@@P_:heap_4.c:453
##@@@L0450_:
##@@@L0451_:		/* pxBlock will be NULL if the heap has not been initialised.  The heap   
##@@@L0452_:		is initialised automatically when the first allocation is made. */   
##@@@L0453_:		if (pxBlock != NULL)   
80008d06:	50 38       	CMP       R5, #0			;->0x00
80008d08:	16 f0       	JZ        $+22                  ;->0x80008d34
80008d0a:	1d 42       	LD        R2, [PC + #29]        ;->0x80008d7c  :=0xffffffff
80008d0c:	1d 44       	LD        R4, [PC + #29]        ;->0x80008d80  :=0xd0000340
80008d0e:	70 10       	MOV       R7, #0			;->0x0000
80008d10:	44 82       	LD.W      R4, [R4]
80008d12:	67 58       	MOV       R3, R7
80008d14:	07 04       	SJMP      $+7                   ;->0x80008d22
##@@@P_:heap_4.c:473
##@@@L0468_:					xMinSize = pxBlock->xBlockSize;   
##@@@L0469_:				}   
##@@@L0470_:
##@@@L0471_:				/* Move to the next block in the chain until the last block is   
##@@@L0472_:				reached. */   
##@@@L0473_:				pxBlock = pxBlock->pxNextFreeBlock;   
80008d16:	55 82       	LD.W      R5, [R5]
##@@@P_:heap_4.c:459
##@@@L0454_:		{   
##@@@L0455_:			do   
##@@@L0456_:			{   
##@@@L0457_:				/* Increment the number of blocks and record the largest block seen   
##@@@L0458_:				so far. */   
##@@@L0459_:				xBlocks++;   
80008d18:	7f c0       	ADD       R7, R7, #1
##@@@P_:heap_4.c:474
##@@@L0469_:				}   
##@@@L0470_:
##@@@L0471_:				/* Move to the next block in the chain until the last block is   
##@@@L0472_:				reached. */   
##@@@L0473_:				pxBlock = pxBlock->pxNextFreeBlock;   
##@@@L0474_:			} while (pxBlock != pxEnd);   
80008d1a:	54 70       	CMP       R5, R4
80008d1c:	66 58       	MOV       R3, R6
80008d1e:	41 58       	MOV       R2, R1
80008d20:	0d f0       	JZ        $+13                  ;->0x80008d3a
##@@@P_:heap_4.c:461
##@@@L0456_:			{   
##@@@L0457_:				/* Increment the number of blocks and record the largest block seen   
##@@@L0458_:				so far. */   
##@@@L0459_:				xBlocks++;   
##@@@L0460_:
##@@@L0461_:				if (pxBlock->xBlockSize > xMaxSize)   
80008d22:	75 98       	LD.W      R6, [R5 + #1]
80008d24:	26 58       	MOV       R1, R6
##@@@P_:heap_4.c:466
##@@@L0462_:				{   
##@@@L0463_:					xMaxSize = pxBlock->xBlockSize;   
##@@@L0464_:				}   
##@@@L0465_:
##@@@L0466_:				if (pxBlock->xBlockSize < xMinSize)   
80008d26:	62 70       	CMP       R6, R2
80008d28:	02 f3       	JNC       $+2                   ;->0x80008d2c
80008d2a:	22 58       	MOV       R1, R2
##@@@P_:heap_4.c:461
##@@@L0456_:			{   
##@@@L0457_:				/* Increment the number of blocks and record the largest block seen   
##@@@L0458_:				so far. */   
##@@@L0459_:				xBlocks++;   
##@@@L0460_:
##@@@L0461_:				if (pxBlock->xBlockSize > xMaxSize)   
80008d2c:	63 70       	CMP       R6, R3
80008d2e:	f4 f8       	JHI       $-12                  ;->0x80008d16
80008d30:	c3 58       	MOV       R6, R3
80008d32:	f2 07       	SJMP      $-14                  ;->0x80008d16
80008d34:	12 41       	LD        R1, [PC + #18]        ;->0x80008d7c  :=0xffffffff
80008d36:	70 10       	MOV       R7, #0			;->0x0000
80008d38:	c7 58       	MOV       R6, R7
##@@@P_:heap_4.c:477
##@@@L0472_:				reached. */   
##@@@L0473_:				pxBlock = pxBlock->pxNextFreeBlock;   
##@@@L0474_:			} while (pxBlock != pxEnd);   
##@@@L0475_:		}   
##@@@L0476_:	}   
##@@@L0477_:	xTaskResumeAll();   
80008d3a:	01 21       	ST.W      [SP + #1], R1
80008d3c:	12 45       	LD        R5, [PC + #18]        ;->0x80008d84  :=0x80005a70
80008d3e:	05 5c       	LJMP      R5
80008d40:	02 0d       	LD.W      R5, [SP + #2]
##@@@P_:heap_4.c:481
##@@@L0478_:
##@@@L0479_:	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;   
##@@@L0480_:	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;   
##@@@L0481_:	pxHeapStats->xNumberOfFreeBlocks = xBlocks;   
80008d42:	ef a0       	ST.W      [R5 + #3], R7
##@@@P_:heap_4.c:480
##@@@L0475_:		}   
##@@@L0476_:	}   
##@@@L0477_:	xTaskResumeAll();   
##@@@L0478_:
##@@@L0479_:	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;   
##@@@L0480_:	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;   
80008d44:	01 0c       	LD.W      R4, [SP + #1]
80008d46:	ac a0       	ST.W      [R5 + #2], R4
##@@@P_:heap_4.c:479
##@@@L0474_:			} while (pxBlock != pxEnd);   
##@@@L0475_:		}   
##@@@L0476_:	}   
##@@@L0477_:	xTaskResumeAll();   
##@@@L0478_:
##@@@L0479_:	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;   
80008d48:	6e a0       	ST.W      [R5 + #1], R6
80008d4a:	c5 58       	MOV       R6, R5
##@@@P_:heap_4.c:483
##@@@L0480_:	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;   
##@@@L0481_:	pxHeapStats->xNumberOfFreeBlocks = xBlocks;   
##@@@L0482_:
##@@@L0483_:	taskENTER_CRITICAL();   
80008d4c:	0f 45       	LD        R5, [PC + #15]        ;->0x80008d88  :=0x800056cc
80008d4e:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:485
##@@@L0484_:	{   
##@@@L0485_:		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;   
80008d50:	0f 45       	LD        R5, [PC + #15]        ;->0x80008d8c  :=0xd0000348
80008d52:	55 82       	LD.W      R5, [R5]
##@@@P_:heap_4.c:486
##@@@L0486_:		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;   
80008d54:	0f 44       	LD        R4, [PC + #15]        ;->0x80008d90  :=0xd0000358
##@@@P_:heap_4.c:485
##@@@L0480_:	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;   
##@@@L0481_:	pxHeapStats->xNumberOfFreeBlocks = xBlocks;   
##@@@L0482_:
##@@@L0483_:	taskENTER_CRITICAL();   
##@@@L0484_:	{   
##@@@L0485_:		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;   
80008d56:	65 85       	ST.W      [R6], R5
##@@@P_:heap_4.c:486
##@@@L0486_:		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;   
80008d58:	54 82       	LD.W      R5, [R4]
##@@@P_:heap_4.c:487
##@@@L0487_:		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;   
80008d5a:	0f 44       	LD        R4, [PC + #15]        ;->0x80008d94  :=0xd000035c
##@@@P_:heap_4.c:486
##@@@L0481_:	pxHeapStats->xNumberOfFreeBlocks = xBlocks;   
##@@@L0482_:
##@@@L0483_:	taskENTER_CRITICAL();   
##@@@L0484_:	{   
##@@@L0485_:		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;   
##@@@L0486_:		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;   
80008d5c:	75 a1       	ST.W      [R6 + #5], R5
##@@@P_:heap_4.c:487
##@@@L0487_:		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;   
80008d5e:	54 82       	LD.W      R5, [R4]
##@@@P_:heap_4.c:488
##@@@L0488_:		pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;   
80008d60:	0e 44       	LD        R4, [PC + #14]        ;->0x80008d98  :=0xd0000354
##@@@P_:heap_4.c:487
##@@@L0482_:
##@@@L0483_:	taskENTER_CRITICAL();   
##@@@L0484_:	{   
##@@@L0485_:		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;   
##@@@L0486_:		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;   
##@@@L0487_:		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;   
80008d62:	b5 a1       	ST.W      [R6 + #6], R5
##@@@P_:heap_4.c:488
##@@@L0488_:		pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;   
80008d64:	54 82       	LD.W      R5, [R4]
80008d66:	35 a1       	ST.W      [R6 + #4], R5
##@@@P_:heap_4.c:490
##@@@L0489_:	}   
##@@@L0490_:	taskEXIT_CRITICAL();   
80008d68:	0d 45       	LD        R5, [PC + #13]        ;->0x80008d9c  :=0x80005730
80008d6a:	05 5c       	LJMP      R5
##@@@P_:heap_4.c:491
##@@@L0491_:}   
80008d6c:	ec 28       	ADD       SP, #12			;->0x0C
80008d6e:	03 5e       	POP       {R6-R7}
80008d70:	0d 5d       	POP       LR
80008d72:	1d 5c       	JMP       LR
80008d74:	b0 59 00 80 	.long     0x800059b0 ->-2147460688  [!!!@2@:MOV       LR, R16	@@: LD.B      R0, [R0]
80008d78:	4c 03 00 d0 	.long     0xd000034c ->-805305524  [!!!@4@:JMP       $+5033984             ;->0x809a2d78
80008d7c:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80008d80:	40 03 00 d0 	.long     0xd0000340 ->-805305536  [!!!@4@:JMP       $+4247552             ;->0x80822d80
80008d84:	70 5a 00 80 	.long     0x80005a70 ->-2147460496  [!!!@2@:MOV       R19, R16	@@: LD.B      R0, [R0]
80008d88:	cc 56 00 80 	.long     0x800056cc ->-2147461428  [!!!@4@:TBNZ      R12, #25, $  +0;		->C address:0x80008d88
80008d8c:	48 03 00 d0 	.long     0xd0000348 ->-805305528  [!!!@4@:JMP       $+4771840             ;->0x80922d8c
80008d90:	58 03 00 d0 	.long     0xd0000358 ->-805305512  [!!!@4@:JMP       $+5820416             ;->0x80b22d90
80008d94:	5c 03 00 d0 	.long     0xd000035c ->-805305508  [!!!@4@:JMP       $+6082560             ;->0x80ba2d94
80008d98:	54 03 00 d0 	.long     0xd0000354 ->-805305516  [!!!@4@:JMP       $+5558272             ;->0x80aa2d98
80008d9c:	30 57 00 80 	.long     0x80005730 ->-2147461328  [!!!@4@:TBNZ      R19, #1, $  +0;		->C address:0x80008d9c

80008da0 <pxPortInitialiseStack>:
##@@@F_:pxPortInitialiseStack():
##@@@P_:port.c:138
##@@@L0133_:        ;   
##@@@L0134_:}   
##@@@L0135_:
##@@@L0136_:extern unsigned int __INTTAB_CPU0[];   
##@@@L0137_:StackType_t        *pxPortInitialiseStack(portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters)   
##@@@L0138_:{   
80008da0:	07 5f       	PUSH      {R6-R8}
80008da2:	e4 30       	SUB       SP, #4			;->0x04
80008da4:	02 59       	MOV       R8, R2
80008da6:	0d 45       	LD        R5, [PC + #13]        ;->0x80008dd8  :=0xffffff7c
##@@@P_:port.c:141
##@@@L0139_:    /* Simulate the stack frame as it would be created by a context switch   
##@@@L0140_:    interrupt. */   
##@@@L0141_:    pxTopOfStack--;                   /* Offset added to account for the way the MCU uses the   
80008da8:	20 cd       	SUB       R4, R0, #4
##@@@P_:port.c:147
##@@@L0142_:                                         stack on entry/exit of interrupts. */   
##@@@L0143_:    *pxTopOfStack = portINITIAL_XPSR; /* xPSR */   
##@@@L0144_:    pxTopOfStack--;   
##@@@L0145_:    /** @attention 该LR是任务的返回地址；由于任务不允许返回，只能销毁，因此该LR指向prvTaskExitError */   
##@@@L0146_:    *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */   
##@@@L0147_:    pxTopOfStack--;   
80008daa:	60 58       	MOV       R3, R0
##@@@P_:port.c:153
##@@@L0148_:    *pxTopOfStack = (StackType_t)pvParameters; /* R0 */   
##@@@L0149_:    pxTopOfStack -= 4;                         /* R4, R3, R2 and R1. */   
##@@@L0150_:
##@@@L0151_:    /** @attention R5是由中断引导程序在跳转时压栈，按照自动压栈处理 */   
##@@@L0152_:    pxTopOfStack--; /* R5. */   
##@@@L0153_:    pxTopOfStack--; /* LR */   
80008dac:	c0 58       	MOV       R6, R0
##@@@P_:port.c:158
##@@@L0154_:    /** @attention 该LR是中断引导程序MRET返回时使用的LR，即任务函数地址 */   
##@@@L0155_:    /** @attention 该LR在中断引导程序跳转时压栈，按照自动压栈处理 */   
##@@@L0156_:    /** @attention MRET指令中POP操作和JMP LR操作并行，POP的LR为任务的返回地址，JMP LR使用的LR为当前中断的返回地址 */   
##@@@L0157_:    *pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* LR */   
##@@@L0158_:    pxTopOfStack--;                                                 /* LR */   
80008dae:	e0 58       	MOV       R7, R0
##@@@P_:port.c:164
##@@@L0159_:    /** @attention 该LR是中断服务程序返回时使用的LR，即中断引导程序中POP LR地址 */   
##@@@L0160_:    /** @attention 该LR在Systick或Gpsr中断服务程序入口出压栈，返回前出栈 */   
##@@@L0161_:    /** @attention 该LR初始化为Systick或Gpsr中断引导程序的相应位置，由于中断引导程序的后续指令都一样，因此可以任意指定   
##@@@L0162_:     */   
##@@@L0163_:    *pxTopOfStack = (portSTACK_TYPE)__INTTAB_CPU0 + 0x20 * portLOWEST_INTERRUPT_PRIORITY + 0x0E;   
##@@@L0164_:    pxTopOfStack -= 23; /* 手动压栈 R31, R30, R29, R28, R27, R26, R25, R24, R23, R22, R21, R20, R19,   
80008db0:	50 c3       	ADD       R2, R0, R5
##@@@P_:port.c:146
##@@@L0141_:    pxTopOfStack--;                   /* Offset added to account for the way the MCU uses the   
##@@@L0142_:                                         stack on entry/exit of interrupts. */   
##@@@L0143_:    *pxTopOfStack = portINITIAL_XPSR; /* xPSR */   
##@@@L0144_:    pxTopOfStack--;   
##@@@L0145_:    /** @attention 该LR是任务的返回地址；由于任务不允许返回，只能销毁，因此该LR指向prvTaskExitError */   
##@@@L0146_:    *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */   
80008db2:	0b 45       	LD        R5, [PC + #11]        ;->0x80008ddc  :=0x80008de8
##@@@P_:port.c:144
##@@@L0139_:    /* Simulate the stack frame as it would be created by a context switch   
##@@@L0140_:    interrupt. */   
##@@@L0141_:    pxTopOfStack--;                   /* Offset added to account for the way the MCU uses the   
##@@@L0142_:                                         stack on entry/exit of interrupts. */   
##@@@L0143_:    *pxTopOfStack = portINITIAL_XPSR; /* xPSR */   
##@@@L0144_:    pxTopOfStack--;   
80008db4:	08 30       	SUB       R0, #8			;->0x08
##@@@P_:port.c:146
##@@@L0145_:    /** @attention 该LR是任务的返回地址；由于任务不允许返回，只能销毁，因此该LR指向prvTaskExitError */   
##@@@L0146_:    *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */   
80008db6:	05 85       	ST.W      [R0], R5
80008db8:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:port.c:143
##@@@L0138_:{   
##@@@L0139_:    /* Simulate the stack frame as it would be created by a context switch   
##@@@L0140_:    interrupt. */   
##@@@L0141_:    pxTopOfStack--;                   /* Offset added to account for the way the MCU uses the   
##@@@L0142_:                                         stack on entry/exit of interrupts. */   
##@@@L0143_:    *pxTopOfStack = portINITIAL_XPSR; /* xPSR */   
80008dba:	45 85       	ST.W      [R4], R5
##@@@P_:port.c:147
##@@@L0144_:    pxTopOfStack--;   
##@@@L0145_:    /** @attention 该LR是任务的返回地址；由于任务不允许返回，只能销毁，因此该LR指向prvTaskExitError */   
##@@@L0146_:    *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */   
##@@@L0147_:    pxTopOfStack--;   
80008dbc:	3c 30       	SUB       R3, #12			;->0x0C
80008dbe:	09 45       	LD        R5, [PC + #9]         ;->0x80008de0  :=0xfffffffe
##@@@P_:port.c:148
##@@@L0148_:    *pxTopOfStack = (StackType_t)pvParameters; /* R0 */   
80008dc0:	38 85       	ST.W      [R3], R8
##@@@P_:port.c:157
##@@@L0152_:    pxTopOfStack--; /* R5. */   
##@@@L0153_:    pxTopOfStack--; /* LR */   
##@@@L0154_:    /** @attention 该LR是中断引导程序MRET返回时使用的LR，即任务函数地址 */   
##@@@L0155_:    /** @attention 该LR在中断引导程序跳转时压栈，按照自动压栈处理 */   
##@@@L0156_:    /** @attention MRET指令中POP操作和JMP LR操作并行，POP的LR为任务的返回地址，JMP LR使用的LR为当前中断的返回地址 */   
##@@@L0157_:    *pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* LR */   
80008dc2:	15 69       	ANL       R1, R5
##@@@P_:port.c:153
##@@@L0148_:    *pxTopOfStack = (StackType_t)pvParameters; /* R0 */   
##@@@L0149_:    pxTopOfStack -= 4;                         /* R4, R3, R2 and R1. */   
##@@@L0150_:
##@@@L0151_:    /** @attention R5是由中断引导程序在跳转时压栈，按照自动压栈处理 */   
##@@@L0152_:    pxTopOfStack--; /* R5. */   
##@@@L0153_:    pxTopOfStack--; /* LR */   
80008dc4:	64 32       	SUB       R6, #36			;->0x24
##@@@P_:port.c:157
##@@@L0154_:    /** @attention 该LR是中断引导程序MRET返回时使用的LR，即任务函数地址 */   
##@@@L0155_:    /** @attention 该LR在中断引导程序跳转时压栈，按照自动压栈处理 */   
##@@@L0156_:    /** @attention MRET指令中POP操作和JMP LR操作并行，POP的LR为任务的返回地址，JMP LR使用的LR为当前中断的返回地址 */   
##@@@L0157_:    *pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* LR */   
80008dc6:	61 85       	ST.W      [R6], R1
##@@@P_:port.c:163
##@@@L0158_:    pxTopOfStack--;                                                 /* LR */   
##@@@L0159_:    /** @attention 该LR是中断服务程序返回时使用的LR，即中断引导程序中POP LR地址 */   
##@@@L0160_:    /** @attention 该LR在Systick或Gpsr中断服务程序入口出压栈，返回前出栈 */   
##@@@L0161_:    /** @attention 该LR初始化为Systick或Gpsr中断引导程序的相应位置，由于中断引导程序的后续指令都一样，因此可以任意指定   
##@@@L0162_:     */   
##@@@L0163_:    *pxTopOfStack = (portSTACK_TYPE)__INTTAB_CPU0 + 0x20 * portLOWEST_INTERRUPT_PRIORITY + 0x0E;   
80008dc8:	07 45       	LD        R5, [PC + #7]         ;->0x80008de4  :=0x8001e00e
##@@@P_:port.c:158
##@@@L0153_:    pxTopOfStack--; /* LR */   
##@@@L0154_:    /** @attention 该LR是中断引导程序MRET返回时使用的LR，即任务函数地址 */   
##@@@L0155_:    /** @attention 该LR在中断引导程序跳转时压栈，按照自动压栈处理 */   
##@@@L0156_:    /** @attention MRET指令中POP操作和JMP LR操作并行，POP的LR为任务的返回地址，JMP LR使用的LR为当前中断的返回地址 */   
##@@@L0157_:    *pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* LR */   
##@@@L0158_:    pxTopOfStack--;                                                 /* LR */   
80008dca:	78 32       	SUB       R7, #40			;->0x28
##@@@P_:port.c:163
##@@@L0159_:    /** @attention 该LR是中断服务程序返回时使用的LR，即中断引导程序中POP LR地址 */   
##@@@L0160_:    /** @attention 该LR在Systick或Gpsr中断服务程序入口出压栈，返回前出栈 */   
##@@@L0161_:    /** @attention 该LR初始化为Systick或Gpsr中断引导程序的相应位置，由于中断引导程序的后续指令都一样，因此可以任意指定   
##@@@L0162_:     */   
##@@@L0163_:    *pxTopOfStack = (portSTACK_TYPE)__INTTAB_CPU0 + 0x20 * portLOWEST_INTERRUPT_PRIORITY + 0x0E;   
80008dcc:	75 85       	ST.W      [R7], R5
##@@@P_:port.c:167
##@@@L0164_:    pxTopOfStack -= 23; /* 手动压栈 R31, R30, R29, R28, R27, R26, R25, R24, R23, R22, R21, R20, R19,   
##@@@L0165_:                                           R18, R17, R16, R12, R11, R10, R9, R8, R7, R6. */   
##@@@L0166_:
##@@@L0167_:    return pxTopOfStack;   
80008dce:	02 58       	MOV       R0, R2
80008dd0:	e4 28       	ADD       SP, #4			;->0x04
80008dd2:	07 5e       	POP       {R6-R8}
80008dd4:	1d 5c       	JMP       LR
80008dd6:	00 00       	NOP      NOP      
80008dd8:	7c ff ff ff 	.long     0xffffff7c ->-00000132 
80008ddc:	e8 8d 00 80 	.long     0x80008de8 ->-2147447320  [!!!@2@:LD.B      R5, [R0 + #23]	@@: LD.B      R0, [R0]
80008de0:	fe ff ff ff 	.long     0xfffffffe ->-00000002 
80008de4:	0e e0 01 80 	.long     0x8001e00e ->-2147360754  [!!!@2@:LD.H      R0, [SP + #14]	@@: LD.B      R0, [R1]

80008de8 <prvTaskExitError>:
##@@@F_:prvTaskExitError():
##@@@P_:port.c:131
##@@@L0126_:    its caller as there is nothing to return to.  If a task wants to exit it   
##@@@L0127_:    should instead call vTaskDelete( NULL ).   
##@@@L0128_:
##@@@L0129_:    Artificially force an assert() to be triggered if configASSERT() is   
##@@@L0130_:    defined, then stop here so application writers can catch the error. */   
##@@@L0131_:    portDISABLE_INTERRUPTS();   
80008de8:	20 5d       	PUSH      R0
80008dea:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008dee:	08 00       	SYNC     SYNC     
80008df0:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008df4:	08 00       	SYNC     SYNC     
80008df6:	00 5d       	POP       R0
80008df8:	20 5d       	PUSH      R0
80008dfa:	21 5d       	PUSH      R1
80008dfc:	0c 45       	LD        R5, [PC + #12]        ;->0x80008e2c  :=0x1ff
80008dfe:	80 5d 87 01 	CSRR      R0, #0x0187  // @imm 391
80008e02:	25 58       	MOV       R1, R5
80008e04:	11 68       	NOT       R1, R1
80008e06:	01 69       	ANL       R0, R1
80008e08:	5f 11       	MOV       R5, #31			;->0x001F
80008e0a:	25 58       	MOV       R1, R5
80008e0c:	01 6a       	ORL       R0, R1
80008e0e:	90 5d 87 01 	CSRW      R0, #0x0187  // @imm 391
80008e12:	08 00       	SYNC     SYNC     
80008e14:	01 5d       	POP       R1
80008e16:	00 5d       	POP       R0
80008e18:	20 5d       	PUSH      R0
80008e1a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008e1e:	08 00       	SYNC     SYNC     
80008e20:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008e24:	08 00       	SYNC     SYNC     
80008e26:	00 5d       	POP       R0
##@@@P_:port.c:132
##@@@L0132_:    for (;;)   
80008e28:	00 04       	SJMP      $+0                   ;->0x80008e28
80008e2a:	00 00       	NOP      NOP      
80008e2c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      

80008e30 <xPortStartScheduler>:
##@@@F_:xPortStartScheduler():
##@@@P_:port.c:173
##@@@L0168_:}   
##@@@L0169_:
##@@@L0170_:/*-----------------------------------------------------------*/   
##@@@L0171_:/* TODO: 通过软件中断来开启第一个任务，保证不丢失任务栈初始化的XPSR和R6 */   
##@@@L0172_:BaseType_t __attribute__((optnone)) xPortStartScheduler(void)   
##@@@L0173_:{   
80008e30:	2d 5d       	PUSH      LR
80008e32:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:port.c:174
##@@@L0174_:    DISABLE_INTERRUPT();   
80008e34:	01 04       	SJMP      $+1                   ;->0x80008e36
80008e36:	20 5d       	PUSH      R0
80008e38:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008e3c:	08 00       	SYNC     SYNC     
80008e3e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008e42:	08 00       	SYNC     SYNC     
80008e44:	00 5d       	POP       R0
80008e46:	01 04       	SJMP      $+1                   ;->0x80008e48
80008e48:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:port.c:177
##@@@L0175_:    /* Load the initial SYSCON. */   
##@@@L0176_:    /** @brief 初始化SYSCON*/   
##@@@L0177_:    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)portINITIAL_SYSCON));   
80008e4a:	05 58       	MOV       R0, R5
80008e4c:	90 5d 85 01 	CSRW      R0, #0x0185  // @imm 389
##@@@P_:port.c:178
##@@@L0178_:    __asm__ volatile("CSRW R0, #0x185");   
80008e50:	14 45       	LD        R5, [PC + #20]        ;->0x80008ea0  :=0x4000
##@@@P_:port.c:181
##@@@L0179_:    /** @brief 初始化PSW*/   
##@@@L0180_:    /** @attention PSW.IS=1，中断使用全局栈, 进入中断时压当前的SP，在中断服务内由软件决定使用SP或ISP */   
##@@@L0181_:    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)portSYSTEM_PROGRAM_STATUS_WORD));   
80008e52:	05 58       	MOV       R0, R5
80008e54:	b0 5d 80 01 	CSRSET    R0, R0, #0x0180  // @imm 384
##@@@P_:port.c:184
##@@@L0182_:    __asm__ volatile("CSRSET R0, R0, #0x180");   
##@@@L0183_:    // TriCore__mtcr(TRICORE_CPU_SYSCON, portINITIAL_SYSCON);   
##@@@L0184_:    __asm__ volatile("SYNC");   
80008e58:	08 00       	SYNC     SYNC     
##@@@P_:port.c:190
##@@@L0185_:
##@@@L0186_:    /* TODO: 是否需要解锁CPUENDINIT */   
##@@@L0187_:
##@@@L0188_:    /* Start the timer that generates the tick ISR.  Interrupts are disabled   
##@@@L0189_:    here already. */   
##@@@L0190_:    vPortSetupTimerInterrupt();   
80008e5a:	13 45       	LD        R5, [PC + #19]        ;->0x80008ea4  :=0x80008eac
80008e5c:	05 5c       	LJMP      R5
##@@@P_:port.c:195
##@@@L0191_:
##@@@L0192_:    /* Start the first task. */   
##@@@L0193_:    /* 修改栈指针指向任务栈 */   
##@@@L0194_:    /** @brief R2 = &pxCurrentTCB */   
##@@@L0195_:    __asm__ volatile("LD R2, #pxCurrentTCB" ::: "R2");   
80008e5e:	13 42       	LD        R2, [PC + #19]        ;->0x80008ea8  :=0xd0000040
##@@@P_:port.c:197
##@@@L0196_:    /** @brief R1 = pxCurrentTCB = &CurrentTCB = &CurrentTCB.pxTopOfStack */   
##@@@L0197_:    __asm__ volatile("LD.W R1, [R2]" ::: "R1");   
80008e60:	12 82       	LD.W      R1, [R2]
##@@@P_:port.c:199
##@@@L0198_:    /** @brief R1 = (unsigned int)CurrentTCB.pxTopOfStack */   
##@@@L0199_:    __asm__ volatile("LD.W R1, [R1]");   
80008e62:	11 82       	LD.W      R1, [R1]
##@@@P_:port.c:201
##@@@L0200_:    /** @brief SP = (unsigned int)CurrentTCB.pxTopOfStack */   
##@@@L0201_:    __asm__ volatile("MOV SP, R1");   
80008e64:	c1 59       	MOV       SP, R1
##@@@P_:port.c:202
##@@@L0202_:    __asm__ volatile("SYNC");   
80008e66:	08 00       	SYNC     SYNC     
##@@@P_:port.c:204
##@@@L0203_:    /* 手动出栈 */   
##@@@L0204_:    __asm__ volatile("POP {R6-R12}");   
80008e68:	7f 5e       	POP       {R6-R12}
##@@@P_:port.c:205
##@@@L0205_:    __asm__ volatile("" ::: "memory");   
80008e6a:	ee 00 ff ff 	POP       {R16,R17,R18,R19,R20,R21,R22,R23,R24,R25,R26,R27,R28,R29,R30,R31}
##@@@P_:port.c:209
##@@@L0206_:    __asm__ volatile("POP {R16-R31}");   
##@@@L0207_:    __asm__ volatile("" ::: "memory");   
##@@@L0208_:    /** @note 丢弃掉初始化的中断服务函数返回地址LR */   
##@@@L0209_:    __asm__ volatile("POP R6" ::: "memory");   
80008e6e:	06 5d       	POP       R6
##@@@P_:port.c:211
##@@@L0210_:    /** @note 此处将任务函数地址LR赋值给R6，通过JMP R6跳转任务，此处会丢弃任务函数R6的初始值 */   
##@@@L0211_:    __asm__ volatile("POP R6" ::: "memory");   
80008e70:	06 5d       	POP       R6
##@@@P_:port.c:212
##@@@L0212_:    __asm__ volatile("POP R5" ::: "memory");   
80008e72:	05 5d       	POP       R5
##@@@P_:port.c:213
##@@@L0213_:    __asm__ volatile("POP R4" ::: "memory");   
80008e74:	04 5d       	POP       R4
##@@@P_:port.c:214
##@@@L0214_:    __asm__ volatile("POP R3" ::: "memory");   
80008e76:	03 5d       	POP       R3
##@@@P_:port.c:215
##@@@L0215_:    __asm__ volatile("POP R2" ::: "memory");   
80008e78:	02 5d       	POP       R2
##@@@P_:port.c:216
##@@@L0216_:    __asm__ volatile("POP R1" ::: "memory");   
80008e7a:	01 5d       	POP       R1
##@@@P_:port.c:217
##@@@L0217_:    __asm__ volatile("POP R0" ::: "memory");   
80008e7c:	00 5d       	POP       R0
##@@@P_:port.c:218
##@@@L0218_:    __asm__ volatile("POP LR" ::: "memory");   
80008e7e:	0d 5d       	POP       LR
##@@@P_:port.c:220
##@@@L0219_:
##@@@L0220_:    __asm__ volatile("DSYNC");   
80008e80:	0d 00       	DSYNC    DSYNC    
##@@@P_:port.c:221
##@@@L0221_:    ENABLE_INTERRUPT();   
80008e82:	01 04       	SJMP      $+1                   ;->0x80008e84
80008e84:	20 5d       	PUSH      R0
80008e86:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008e8a:	08 00       	SYNC     SYNC     
80008e8c:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008e90:	08 00       	SYNC     SYNC     
80008e92:	00 5d       	POP       R0
80008e94:	01 04       	SJMP      $+1                   ;->0x80008e96
##@@@P_:port.c:222
##@@@L0222_:    __asm__ volatile("JMP R6");   
80008e96:	16 5c       	JMP       R6
80008e98:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:port.c:225
##@@@L0223_:
##@@@L0224_:    /* Return from function, which would return to the first task selected to execute. */   
##@@@L0225_:    return 0;   
80008e9a:	e4 28       	ADD       SP, #4			;->0x04
80008e9c:	0d 5d       	POP       LR
80008e9e:	1d 5c       	JMP       LR
80008ea0:	00 40 00 00 	.long     0x00004000 ->000016384  [!!!@2@:LD        R0, [PC + #0]         ;->0x80008ea0  :=0x4000	@@: NOP      
80008ea4:	ac 8e 00 80 	.long     0x80008eac ->-2147447124  [!!!@2@:LD.B      R5, [R4 + #26]	@@: LD.B      R0, [R0]
80008ea8:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]

80008eac <vPortSetupTimerInterrupt>:
##@@@F_:vPortSetupTimerInterrupt():
##@@@P_:port.c:396
##@@@L0391_:/*   
##@@@L0392_: * Setup the systick timer to generate the tick interrupts at the required   
##@@@L0393_: * frequency.   
##@@@L0394_: */   
##@@@L0395_:void vPortSetupTimerInterrupt(void)   
##@@@L0396_:{   
80008eac:	81 5f       	PUSH      {R6,LR}
80008eae:	ec 31       	SUB       SP, #28			;->0x1C
##@@@P_:port.c:397
##@@@L0397_:    Systick_CompareConfig_t Config = {   
80008eb0:	20 45       	LD        R5, [PC + #32]        ;->0x80008f30  :=0x80000fac
80008eb2:	65 99       	LD.W      R4, [R5 + #5]
80008eb4:	1d 99       	LD.W      R3, [R5 + #4]
80008eb6:	06 24       	ST.W      [SP + #6], R4
80008eb8:	05 23       	ST.W      [SP + #5], R3
80008eba:	e5 98       	LD.W      R4, [R5 + #3]
80008ebc:	9d 98       	LD.W      R3, [R5 + #2]
80008ebe:	04 24       	ST.W      [SP + #4], R4
80008ec0:	03 23       	ST.W      [SP + #3], R3
80008ec2:	65 98       	LD.W      R4, [R5 + #1]
80008ec4:	55 82       	LD.W      R5, [R5]
80008ec6:	02 24       	ST.W      [SP + #2], R4
80008ec8:	01 25       	ST.W      [SP + #1], R5
80008eca:	1b 46       	LD        R6, [PC + #27]        ;->0x80008f34  :=0xf0000100
80008ecc:	20 10       	MOV       R2, #0			;->0x0000
80008ece:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:port.c:405
##@@@L0400_:      .ComparatorOffset    = SYSTICK_HW_COMPARATOR_OFFSET0,   
##@@@L0401_:      .ComparatorSize      = SYSTICK_HW_COMPARATOR_SIZE_32BITS,   
##@@@L0402_:      .Ticks               = configSTM_CLOCK_HZ / configTICK_RATE_HZ,   
##@@@L0403_:      .EnableInterrupt     = true,   
##@@@L0404_:    };   
##@@@L0405_:    Systick_Hw_IntrRequestNodeInit(   
80008ed0:	06 58       	MOV       R0, R6
80008ed2:	62 58       	MOV       R3, R2
80008ed4:	81 58       	MOV       R4, R1
80008ed6:	19 45       	LD        R5, [PC + #25]        ;->0x80008f38  :=0x8000be6c
80008ed8:	05 5c       	LJMP      R5
##@@@P_:port.c:407
##@@@L0406_:      SYSTICK0_PTR, configKERNEL_INTERRUPT_PRIORITY, INT_SOURCECPU0, SYSTICK_HW_INTERRUPT_LINE_0, true);   
##@@@L0407_:    Systick_Hw_ResetModule(SYSTICK0_PTR);   
80008eda:	06 58       	MOV       R0, R6
80008edc:	18 45       	LD        R5, [PC + #24]        ;->0x80008f3c  :=0x8000baec
80008ede:	05 5c       	LJMP      R5
80008ee0:	18 41       	LD        R1, [PC + #24]        ;->0x80008f40  :=0x4
80008ee2:	1e 64       	ADD       R1, SP
##@@@P_:port.c:408
##@@@L0408_:    Systick_Hw_InitCompare(SYSTICK0_PTR, &Config);   
80008ee4:	06 58       	MOV       R0, R6
80008ee6:	18 45       	LD        R5, [PC + #24]        ;->0x80008f44  :=0x8000ba08
80008ee8:	05 5c       	LJMP      R5
80008eea:	18 45       	LD        R5, [PC + #24]        ;->0x80008f48  :=0xf00307c0
80008eec:	18 43       	LD        R3, [PC + #24]        ;->0x80008f4c  :=0xfffffbff
80008eee:	19 44       	LD        R4, [PC + #25]        ;->0x80008f50  :=0x400
##@@@F_:Int_LL_EnableServiceRequest():
##@@@P_:kf32a13k_drv_int.h:725
##@@@L0720_: */   
##@@@L0721_:KF_INLINE void Int_LL_EnableServiceRequest(const Intr_IrqEnumType IntIndex, const bool Status)   
##@@@L0722_:{   
##@@@L0723_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0724_:    KF_DRV_INT_ASSERT(CHECK_INT_BOOL(Status));   
##@@@L0725_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIE, Status);   
80008ef0:	25 82       	LD.W      R2, [R5]
80008ef2:	23 69       	ANL       R2, R3
80008ef4:	52 85       	ST.W      [R5], R2
##@@@F_:Int_LL_GetServiceRequest():
##@@@P_:kf32a13k_drv_int.h:741
##@@@L0736_: */   
##@@@L0737_:KF_INLINE bool Int_LL_GetServiceRequest(const Intr_IrqEnumType IntIndex)   
##@@@L0738_:{   
##@@@L0739_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0740_:    KF_DRV_INT_ASSERT(CHECK_INT_BOOL(Status));   
##@@@L0741_:    return (REG_READ(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIE));   
80008ef6:	25 82       	LD.W      R2, [R5]
80008ef8:	24 69       	ANL       R2, R4
##@@@F_:vPortSetupTimerInterrupt():
##@@@P_:port.c:415
##@@@L0410_:    /* 初始化软件中断 */   
##@@@L0411_:    Intr_IrqEnumType ServiceRequestNodeIndex = HW_GP0SR0_IRQn;   
##@@@L0412_:    do   
##@@@L0413_:    {   
##@@@L0414_:        Int_LL_EnableServiceRequest(ServiceRequestNodeIndex, false);   
##@@@L0415_:    } while (Int_LL_GetServiceRequest(ServiceRequestNodeIndex));   
80008efa:	20 38       	CMP       R2, #0			;->0x00
80008efc:	fa f1       	JNZ       $-6                   ;->0x80008ef0
80008efe:	16 43       	LD        R3, [PC + #22]        ;->0x80008f54  :=0x2000000
80008f00:	16 42       	LD        R2, [PC + #22]        ;->0x80008f58  :=0x1000000
##@@@F_:Int_LL_ClearIntRequestState():
##@@@P_:kf32a13k_drv_int.h:632
##@@@L0627_: */   
##@@@L0628_:KF_INLINE void Int_LL_ClearIntRequestState(const Intr_IrqEnumType IntIndex, const bool Status)   
##@@@L0629_:{   
##@@@L0630_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0631_:    KF_DRV_INT_ASSERT(CHECK_INT_BOOL(Status));   
##@@@L0632_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIC, Status);   
80008f02:	15 82       	LD.W      R1, [R5]
80008f04:	13 6a       	ORL       R1, R3
80008f06:	51 85       	ST.W      [R5], R1
##@@@F_:Int_LL_GetIntRequestState():
##@@@P_:kf32a13k_drv_int.h:647
##@@@L0642_: *          false:无服务请求等待处理   
##@@@L0643_: */   
##@@@L0644_:KF_INLINE bool Int_LL_GetIntRequestState(const Intr_IrqEnumType IntIndex)   
##@@@L0645_:{   
##@@@L0646_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0647_:    return (REG_READ(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIF));   
80008f08:	15 82       	LD.W      R1, [R5]
80008f0a:	12 69       	ANL       R1, R2
##@@@F_:vPortSetupTimerInterrupt():
##@@@P_:port.c:419
##@@@L0416_:    do   
##@@@L0417_:    {   
##@@@L0418_:        Int_LL_ClearIntRequestState(ServiceRequestNodeIndex, true);   
##@@@L0419_:    } while (Int_LL_GetIntRequestState(ServiceRequestNodeIndex));   
80008f0c:	10 38       	CMP       R1, #0			;->0x00
80008f0e:	fa f1       	JNZ       $-6                   ;->0x80008f02
##@@@F_:Int_LL_SetServiceType():
##@@@P_:kf32a13k_drv_int.h:693
##@@@L0688_: */   
##@@@L0689_:KF_INLINE void Int_LL_SetServiceType(const Intr_IrqEnumType IntIndex, const Int_SourceType_t ServiceType)   
##@@@L0690_:{   
##@@@L0691_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0692_:    KF_DRV_INT_ASSERT(CHECK_INT_SERVICE(ServiceType));   
##@@@L0693_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.TOS, ServiceType);   
80008f10:	35 82       	LD.W      R3, [R5]
80008f12:	13 42       	LD        R2, [PC + #19]        ;->0x80008f5c  :=0xffffc7ff
80008f14:	32 69       	ANL       R3, R2
80008f16:	53 85       	ST.W      [R5], R3
##@@@F_:Int_LL_SetServiceRequestPriority():
##@@@P_:kf32a13k_drv_int.h:756
##@@@L0751_: */   
##@@@L0752_:KF_INLINE void Int_LL_SetServiceRequestPriority(const Intr_IrqEnumType IntIndex, const uint32_t IntPriority)   
##@@@L0753_:{   
##@@@L0754_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0755_:    KF_DRV_INT_ASSERT((IntPriority >> POS_9_SHIFT) == 0U);   
##@@@L0756_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRPN, IntPriority);   
80008f18:	35 82       	LD.W      R3, [R5]
80008f1a:	12 42       	LD        R2, [PC + #18]        ;->0x80008f60  :=0xfffffe00
80008f1c:	32 69       	ANL       R3, R2
80008f1e:	53 85       	ST.W      [R5], R3
##@@@F_:Int_LL_EnableServiceRequest():
##@@@P_:kf32a13k_drv_int.h:725
##@@@L0720_: */   
##@@@L0721_:KF_INLINE void Int_LL_EnableServiceRequest(const Intr_IrqEnumType IntIndex, const bool Status)   
##@@@L0722_:{   
##@@@L0723_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0724_:    KF_DRV_INT_ASSERT(CHECK_INT_BOOL(Status));   
##@@@L0725_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIE, Status);   
80008f20:	35 82       	LD.W      R3, [R5]
80008f22:	34 6a       	ORL       R3, R4
80008f24:	53 85       	ST.W      [R5], R3
##@@@F_:vPortSetupTimerInterrupt():
##@@@P_:port.c:429
##@@@L0424_:    /* TODO: 初始化软件中断作为SVC，用来开启第一个任务 */   
##@@@L0425_:
##@@@L0426_:    /** @attention 优先级决定了服务函数在中断向量表的位置，因此Systick和Svc中断优先级不能一致*/   
##@@@L0427_:    /** @attention Systick优先级应当高于Svc中断优先级，避免Systick中vPortYield引起中断嵌套 */   
##@@@L0428_:    /* TODO: 配置Systick和Svc处于相同的优先级组中，避免互相抢占 */   
##@@@L0429_:}   
80008f26:	ec 29       	ADD       SP, #28			;->0x1C
80008f28:	06 5d       	POP       R6
80008f2a:	0d 5d       	POP       LR
80008f2c:	1d 5c       	JMP       LR
80008f2e:	00 00       	NOP      NOP      
80008f30:	ac 0f 00 80 	.long     0x80000fac ->-2147479636  [!!!@2@:LD.W      R7, [SP + #172]	@@: LD.B      R0, [R0]
80008f34:	00 01 00 f0 	.long     0xf0000100 ->-268435200  [!!!@2@:CMN       R0, R0	@@: JZ        $+0                   ;->0x80008f34
80008f38:	6c be 00 80 	.long     0x8000be6c ->-2147434900 
80008f3c:	ec ba 00 80 	.long     0x8000baec ->-2147435796  [!!!@2@:LDP.W     R5, [R4] << #3	@@: LD.B      R0, [R0]
80008f40:	04 00 00 00 	.long     0x00000004 ->000000004 
80008f44:	08 ba 00 80 	.long     0x8000ba08 ->-2147436024  [!!!@2@:LDP.W     R1, [R0] << #0	@@: LD.B      R0, [R0]
80008f48:	c0 07 03 f0 	.long     0xf00307c0 ->-268236864  [!!!@2@:SJMP      $-64                  ;->0x80008ec8	@@: JZ        $+3                   ;->0x80008f4e
80008f4c:	ff fb ff ff 	.long     0xfffffbff ->-00001025 
80008f50:	00 04 00 00 	.long     0x00000400 ->000001024  [!!!@2@:SJMP      $+0                   ;->0x80008f50	@@: NOP      
80008f54:	00 00 00 02 	.long     0x02000000 ->033554432 
80008f58:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
80008f5c:	ff c7 ff ff 	.long     0xffffc7ff ->-00014337 
80008f60:	00 fe ff ff 	.long     0xfffffe00 ->-00000512 

80008f64 <vPortYield>:
##@@@F_:vPortYield():
##@@@P_:port.c:230
##@@@L0225_:    return 0;   
##@@@L0226_:}   
##@@@L0227_:/*-----------------------------------------------------------*/   
##@@@L0228_:/* 在任务中触发调度 */   
##@@@L0229_:__attribute__((always_inline)) void vPortYield(void)   
##@@@L0230_:{   
80008f64:	03 45       	LD        R5, [PC + #3]         ;->0x80008f70  :=0xf00307c0
##@@@F_:Int_LL_SetIntRequestState():
##@@@P_:kf32a13k_drv_int.h:615
##@@@L0610_: */   
##@@@L0611_:KF_INLINE void Int_LL_SetIntRequestState(const Intr_IrqEnumType IntIndex, const bool Status)   
##@@@L0612_:{   
##@@@L0613_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0614_:    KF_DRV_INT_ASSERT(CHECK_INT_BOOL(Status));   
##@@@L0615_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIS, Status);   
80008f66:	45 82       	LD.W      R4, [R5]
80008f68:	03 43       	LD        R3, [PC + #3]         ;->0x80008f74  :=0x4000000
80008f6a:	43 6a       	ORL       R4, R3
80008f6c:	54 85       	ST.W      [R5], R4
##@@@F_:vPortYield():
##@@@P_:port.c:233
##@@@L0231_:    /* 触发软件中断 */   
##@@@L0232_:    Int_LL_SetIntRequestState(HW_GP0SR0_IRQn, true);   
##@@@L0233_:}   
80008f6e:	1d 5c       	JMP       LR
80008f70:	c0 07 03 f0 	.long     0xf00307c0 ->-268236864  [!!!@2@:SJMP      $-64                  ;->0x80008ef0	@@: JZ        $+3                   ;->0x80008f76
80008f74:	00 00 00 04 	.long     0x04000000 ->067108864  [!!!@2@:NOP      	@@: SJMP      $+0                   ;->0x80008f74

80008f78 <vPortSystemTickHandler>:
##@@@F_:vPortSystemTickHandler():
##@@@P_:port.c:236
##@@@L0234_:
##@@@L0235_:__attribute__((noinline)) void vPortSystemTickHandler(void)   
##@@@L0236_:{   
80008f78:	83 5f       	PUSH      {R6-R7,LR}
80008f7a:	e4 30       	SUB       SP, #4			;->0x04
##@@@F_:uxPortSetInterruptMaskFromISR():
##@@@P_:port.c:368
##@@@L0363_:
##@@@L0364_:unsigned long uxPortSetInterruptMaskFromISR(void)   
##@@@L0365_:{   
##@@@L0366_:    unsigned long uxReturn = 0UL;   
##@@@L0367_:
##@@@L0368_:    DISABLE_INTERRUPT();   
80008f7c:	20 5d       	PUSH      R0
80008f7e:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008f82:	08 00       	SYNC     SYNC     
80008f84:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008f88:	08 00       	SYNC     SYNC     
80008f8a:	00 5d       	POP       R0
80008f8c:	14 45       	LD        R5, [PC + #20]        ;->0x80008fdc  :=0x1ff
80008f8e:	80 5d 87 05 	CSRR      R1, #0x0187  // @imm 391
##@@@P_:port.c:370
##@@@L0369_:    __asm__ volatile("CSRR R1, #0x187" ::: "R1"); /* Get current ICR value. */   
##@@@L0370_:    __asm__ volatile("MOV R2, %0" ::"r"((unsigned int)portCCPN_MASK) : "R2");   
80008f92:	45 58       	MOV       R2, R5
##@@@P_:port.c:371
##@@@L0371_:    __asm__ volatile("NOT R2, R2");   
80008f94:	22 68       	NOT       R2, R2
##@@@P_:port.c:372
##@@@L0372_:    __asm__ volatile("ANL R1, R2"); /* Clear down mask bits. */   
80008f96:	12 69       	ANL       R1, R2
80008f98:	4f 11       	MOV       R4, #31			;->0x001F
##@@@P_:port.c:373
##@@@L0373_:    __asm__ volatile("MOV R2, %0" ::"r"((unsigned int)configMAX_SYSCALL_INTERRUPT_PRIORITY));   
80008f9a:	44 58       	MOV       R2, R4
##@@@P_:port.c:374
##@@@L0374_:    __asm__ volatile("ORL R1, R2");      /* Set mask bits to required priority mask. */   
80008f9c:	12 6a       	ORL       R1, R2
80008f9e:	90 5d 87 05 	CSRW      R1, #0x0187  // @imm 391
##@@@P_:port.c:376
##@@@L0375_:    __asm__ volatile("CSRW R1, #0x187"); /* Write back updated ICR. */   
##@@@L0376_:    __asm__ volatile("SYNC");   
80008fa2:	08 00       	SYNC     SYNC     
##@@@P_:port.c:377
##@@@L0377_:    ENABLE_INTERRUPT();   
80008fa4:	20 5d       	PUSH      R0
80008fa6:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008faa:	08 00       	SYNC     SYNC     
80008fac:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80008fb0:	08 00       	SYNC     SYNC     
80008fb2:	00 5d       	POP       R0
##@@@P_:port.c:378
##@@@L0378_:    __asm__ volatile("MOV %0, R1" : "=r"(uxReturn) : : "memory");   
80008fb4:	c1 58       	MOV       R6, R1
##@@@P_:port.c:381
##@@@L0379_:
##@@@L0380_:    /* Return just the interrupt mask bits. */   
##@@@L0381_:    return (uxReturn & portCCPN_MASK);   
80008fb6:	65 69       	ANL       R6, R5
##@@@F_:vPortSystemTickHandler():
##@@@P_:port.c:243
##@@@L0238_:    long          lYieldRequired;   
##@@@L0239_:    /* Kernel API calls require Critical Sections. */   
##@@@L0240_:    ulSavedInterruptMask = portSET_INTERRUPT_MASK_FROM_ISR();   
##@@@L0241_:    {   
##@@@L0242_:        /* Increment the Tick. */   
##@@@L0243_:        lYieldRequired = xTaskIncrementTick();   
80008fb8:	0a 45       	LD        R5, [PC + #10]        ;->0x80008fe0  :=0x800067d4
80008fba:	05 5c       	LJMP      R5
80008fbc:	e0 58       	MOV       R7, R0
##@@@P_:port.c:246
##@@@L0244_:    }   
##@@@L0245_:
##@@@L0246_:    portCLEAR_INTERRUPT_MASK_FROM_ISR(ulSavedInterruptMask);   
80008fbe:	06 58       	MOV       R0, R6
80008fc0:	09 45       	LD        R5, [PC + #9]         ;->0x80008fe4  :=0x80009034
80008fc2:	05 5c       	LJMP      R5
##@@@P_:port.c:248
##@@@L0247_:
##@@@L0248_:    if (lYieldRequired != pdFALSE)   
80008fc4:	70 38       	CMP       R7, #0			;->0x00
80008fc6:	06 f0       	JZ        $+6                   ;->0x80008fd2
80008fc8:	08 45       	LD        R5, [PC + #8]         ;->0x80008fe8  :=0xf00307c0
##@@@F_:Int_LL_SetIntRequestState():
##@@@P_:kf32a13k_drv_int.h:615
80008fca:	45 82       	LD.W      R4, [R5]
80008fcc:	08 43       	LD        R3, [PC + #8]         ;->0x80008fec  :=0x4000000
80008fce:	43 6a       	ORL       R4, R3
80008fd0:	54 85       	ST.W      [R5], R4
##@@@F_:vPortSystemTickHandler():
##@@@P_:port.c:252
##@@@L0249_:    {   
##@@@L0250_:        vPortYield();   
##@@@L0251_:    }   
##@@@L0252_:}   
80008fd2:	e4 28       	ADD       SP, #4			;->0x04
80008fd4:	03 5e       	POP       {R6-R7}
80008fd6:	0d 5d       	POP       LR
80008fd8:	1d 5c       	JMP       LR
80008fda:	00 00       	NOP      NOP      
80008fdc:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      
80008fe0:	d4 67 00 80 	.long     0x800067d4 ->-2147457068  [!!!@2@:SUBC      LR, R4	@@: LD.B      R0, [R0]
80008fe4:	34 90 00 80 	.long     0x80009034 ->-2147446732  [!!!@2@:ST.B      [R6 + #0], R4	@@: LD.B      R0, [R0]
80008fe8:	c0 07 03 f0 	.long     0xf00307c0 ->-268236864  [!!!@2@:SJMP      $-64                  ;->0x80008f68	@@: JZ        $+3                   ;->0x80008fee
80008fec:	00 00 00 04 	.long     0x04000000 ->067108864  [!!!@2@:NOP      	@@: SJMP      $+0                   ;->0x80008fec

80008ff0 <uxPortSetInterruptMaskFromISR>:
##@@@F_:uxPortSetInterruptMaskFromISR():
##@@@P_:port.c:368
##@@@L0363_:
##@@@L0364_:unsigned long uxPortSetInterruptMaskFromISR(void)   
##@@@L0365_:{   
##@@@L0366_:    unsigned long uxReturn = 0UL;   
##@@@L0367_:
##@@@L0368_:    DISABLE_INTERRUPT();   
80008ff0:	20 5d       	PUSH      R0
80008ff2:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80008ff6:	08 00       	SYNC     SYNC     
80008ff8:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80008ffc:	08 00       	SYNC     SYNC     
80008ffe:	00 5d       	POP       R0
80009000:	0c 45       	LD        R5, [PC + #12]        ;->0x80009030  :=0x1ff
80009002:	80 5d 87 05 	CSRR      R1, #0x0187  // @imm 391
##@@@P_:port.c:370
##@@@L0369_:    __asm__ volatile("CSRR R1, #0x187" ::: "R1"); /* Get current ICR value. */   
##@@@L0370_:    __asm__ volatile("MOV R2, %0" ::"r"((unsigned int)portCCPN_MASK) : "R2");   
80009006:	45 58       	MOV       R2, R5
##@@@P_:port.c:371
##@@@L0371_:    __asm__ volatile("NOT R2, R2");   
80009008:	22 68       	NOT       R2, R2
##@@@P_:port.c:372
##@@@L0372_:    __asm__ volatile("ANL R1, R2"); /* Clear down mask bits. */   
8000900a:	12 69       	ANL       R1, R2
8000900c:	4f 11       	MOV       R4, #31			;->0x001F
##@@@P_:port.c:373
##@@@L0373_:    __asm__ volatile("MOV R2, %0" ::"r"((unsigned int)configMAX_SYSCALL_INTERRUPT_PRIORITY));   
8000900e:	44 58       	MOV       R2, R4
##@@@P_:port.c:374
##@@@L0374_:    __asm__ volatile("ORL R1, R2");      /* Set mask bits to required priority mask. */   
80009010:	12 6a       	ORL       R1, R2
80009012:	90 5d 87 05 	CSRW      R1, #0x0187  // @imm 391
##@@@P_:port.c:376
##@@@L0375_:    __asm__ volatile("CSRW R1, #0x187"); /* Write back updated ICR. */   
##@@@L0376_:    __asm__ volatile("SYNC");   
80009016:	08 00       	SYNC     SYNC     
##@@@P_:port.c:377
##@@@L0377_:    ENABLE_INTERRUPT();   
80009018:	20 5d       	PUSH      R0
8000901a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000901e:	08 00       	SYNC     SYNC     
80009020:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80009024:	08 00       	SYNC     SYNC     
80009026:	00 5d       	POP       R0
##@@@P_:port.c:378
##@@@L0378_:    __asm__ volatile("MOV %0, R1" : "=r"(uxReturn) : : "memory");   
80009028:	01 58       	MOV       R0, R1
##@@@P_:port.c:381
##@@@L0379_:
##@@@L0380_:    /* Return just the interrupt mask bits. */   
##@@@L0381_:    return (uxReturn & portCCPN_MASK);   
8000902a:	05 69       	ANL       R0, R5
8000902c:	1d 5c       	JMP       LR
8000902e:	00 00       	NOP      NOP      
80009030:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      

80009034 <uxPortClearInterruptMaskFromISR>:
##@@@F_:uxPortClearInterruptMaskFromISR():
##@@@P_:port.c:352
##@@@L0347_:
##@@@L0348_:/*-----------------------------------------------------------*/   
##@@@L0349_:
##@@@L0350_:/*-----------------------------------------------------------*/   
##@@@L0351_:__attribute__((noinline)) void uxPortClearInterruptMaskFromISR(unsigned long uxSavedMaskValue)   
##@@@L0352_:{   
80009034:	a0 58       	MOV       R5, R0
##@@@P_:port.c:353
##@@@L0353_:    DISABLE_INTERRUPT();   
80009036:	20 5d       	PUSH      R0
80009038:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000903c:	08 00       	SYNC     SYNC     
8000903e:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80009042:	08 00       	SYNC     SYNC     
80009044:	00 5d       	POP       R0
##@@@P_:port.c:354
##@@@L0354_:    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)uxSavedMaskValue) : "R0");   
80009046:	05 58       	MOV       R0, R5
80009048:	09 45       	LD        R5, [PC + #9]         ;->0x8000906c  :=0x1ff
8000904a:	80 5d 87 05 	CSRR      R1, #0x0187  // @imm 391
##@@@P_:port.c:356
##@@@L0355_:    __asm__ volatile("CSRR R1, #0x187" ::: "R1"); /* Get current ICR value. */   
##@@@L0356_:    __asm__ volatile("MOV R1, %0" ::"r"((unsigned int)portCCPN_MASK) : "R1");   
8000904e:	25 58       	MOV       R1, R5
##@@@P_:port.c:357
##@@@L0357_:    __asm__ volatile("NOT R0, R0");   
80009050:	00 68       	NOT       R0, R0
##@@@P_:port.c:358
##@@@L0358_:    __asm__ volatile("ANL R1, R0");      /* Clear down mask bits. */   
80009052:	10 69       	ANL       R1, R0
80009054:	90 5d 87 05 	CSRW      R1, #0x0187  // @imm 391
##@@@P_:port.c:360
##@@@L0359_:    __asm__ volatile("CSRW R1, #0x187"); /* Write back updated ICR. */   
##@@@L0360_:    __asm__ volatile("SYNC");   
80009058:	08 00       	SYNC     SYNC     
##@@@P_:port.c:361
##@@@L0361_:    ENABLE_INTERRUPT();   
8000905a:	20 5d       	PUSH      R0
8000905c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80009060:	08 00       	SYNC     SYNC     
80009062:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
80009066:	08 00       	SYNC     SYNC     
80009068:	00 5d       	POP       R0
##@@@P_:port.c:362
##@@@L0362_:}   
8000906a:	1d 5c       	JMP       LR
8000906c:	ff 01 00 00 	.long     0x000001ff ->000000511  [!!!@2@:CMN       PC, PC	@@: NOP      

80009070 <interruptSystick>:
##@@@F_:interruptSystick():
80009070:	ef 00 03 00 	PUSH      {R16,R17}
##@@@P_:port.c:255
##@@@L0250_:        vPortYield();   
##@@@L0251_:    }   
##@@@L0252_:}   
##@@@L0253_:
##@@@L0254_:__attribute__((optnone)) void interruptSystick(void)   
##@@@L0255_:{   
80009074:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:port.c:257
##@@@L0256_:    /** @attention 编译器不会因为嵌入汇编使用了LJMP而自动保存LR,因此需要手动PUSH LR */   
##@@@L0257_:    __asm__ volatile("PUSH LR");   
80009076:	2d 5d       	PUSH      LR
##@@@P_:port.c:259
##@@@L0258_:    /** @attention disable global interrupts to avoid preemption by different priority interrupt */   
##@@@L0259_:    DISABLE_INTERRUPT();   
80009078:	01 04       	SJMP      $+1                   ;->0x8000907a
8000907a:	20 5d       	PUSH      R0
8000907c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
80009080:	08 00       	SYNC     SYNC     
80009082:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
80009086:	08 00       	SYNC     SYNC     
80009088:	00 5d       	POP       R0
8000908a:	01 04       	SJMP      $+1                   ;->0x8000908c
8000908c:	ef 00 03 00 	PUSH      {R16,R17}
##@@@P_:port.c:267
##@@@L0262_:    /** @attention 使用R16/R17后，编译器会自动压栈 */   
##@@@L0263_:    /* 将R16,R17压栈入任务栈中 */   
##@@@L0264_:    __asm__ volatile("PUSH {R16,R17}");   
##@@@L0265_:    __asm__ volatile("" ::: "memory");   
##@@@L0266_:    /* 在R16内保存当前的SP */   
##@@@L0267_:    __asm__ volatile("MOV R16, SP" ::: "R16");   
80009090:	0e 5a       	MOV       R16, SP
80009092:	80 5d 89 45 	CSRR      R17, #0x0189  // @imm 393
##@@@P_:port.c:270
##@@@L0268_:    /* 读取ISP, 在R17内保存当前ISP */   
##@@@L0269_:    __asm__ volatile("CSRR R17, #0x189" ::: "R17");   
##@@@L0270_:    __asm__ volatile("SYNC");   
80009096:	08 00       	SYNC     SYNC     
##@@@P_:port.c:272
##@@@L0271_:    /* 更新SP为中断栈ISP */   
##@@@L0272_:    __asm__ volatile("MOV SP, R17");   
80009098:	d1 59       	MOV       SP, R17
##@@@P_:port.c:274
##@@@L0273_:    /* 等待以上指令完成后再执行后续指令 */   
##@@@L0274_:    __asm__ volatile("SYNC");   
8000909a:	08 00       	SYNC     SYNC     
##@@@P_:port.c:276
##@@@L0275_:    /* 等待以上指令完成后再访问内存 */   
##@@@L0276_:    __asm__ volatile("DSYNC");   
8000909c:	0d 00       	DSYNC    DSYNC    
##@@@P_:port.c:281
##@@@L0277_:    /* 内存屏障，保证指令顺序 */   
##@@@L0278_:    __asm__ volatile("" ::: "memory");   
##@@@L0279_:    /*======================中断栈====================*/   
##@@@L0280_:    /* 保存全局寄存器至中断栈，使用全局寄存器存储临时变量 */   
##@@@L0281_:    __asm__ volatile("PUSH {R6-R9}");   
8000909e:	0f 5f       	PUSH      {R6-R9}
##@@@P_:port.c:282
##@@@L0282_:    __asm__ volatile("" ::: "memory");   
800090a0:	20 5c 50 01 	MOVL      R0, #336			;->0x0150
800090a4:	40 5c 00 f0 	MOVH      R0, #61440			;->0xF000
##@@@P_:port.c:285
##@@@L0283_:    /* ISCR.CMP0 = 1 */   
##@@@L0284_:    __asm__ volatile("MOV R0, #0xF0000150");   
##@@@L0285_:    __asm__ volatile("SET [R0], #0");   
800090a8:	00 4c       	SET       [R0], #0			;->0x00
800090aa:	16 45       	LD        R5, [PC + #22]        ;->0x80009100  :=0xf0000100
##@@@P_:port.c:287
##@@@L0286_:
##@@@L0287_:    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)SYSTICK0_PTR));   
800090ac:	05 58       	MOV       R0, R5
##@@@P_:port.c:288
##@@@L0288_:    __asm__ volatile("MOV R6, %0" ::"r"((unsigned int)Systick_LL_GetLowerTimer));   
800090ae:	16 44       	LD        R4, [PC + #22]        ;->0x80009104  :=0x80009114
800090b0:	c4 58       	MOV       R6, R4
##@@@P_:port.c:290
##@@@L0289_:
##@@@L0290_:    __asm__ volatile("LJMP R6");   
800090b2:	06 5c       	LJMP      R6
800090b4:	15 44       	LD        R4, [PC + #21]        ;->0x80009108  :=0xc350
##@@@P_:port.c:298
##@@@L0293_:#if 0   
##@@@L0294_:    __asm__ volatile("MOV R7, %0" ::"r"((unsigned int)configSTM_CLOCK_HZ));   
##@@@L0295_:    __asm__ volatile("MOV R8, %0" ::"r"((unsigned int)configTICK_RATE_HZ));   
##@@@L0296_:    __asm__ volatile("DIVU R9, R7, R8");   
##@@@L0297_:#endif   
##@@@L0298_:    __asm__ volatile("MOV R9, %0" ::"r"((unsigned int)(configSTM_CLOCK_HZ / configTICK_RATE_HZ)));   
800090b6:	24 59       	MOV       R9, R4
800090b8:	e0 00 09 88 	ADD       R2, R0, R9
##@@@P_:port.c:299
##@@@L0299_:    __asm__ volatile("ADD R2, R0, R9"); // stmCount + configSTM_CLOCK_HZ / configTICK_RATE_HZ   
800090bc:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:port.c:300
##@@@L0300_:    __asm__ volatile("MOV R1, %0" ::"r"((unsigned int)SYSTICK_HW_COMPARATOR_0));   
800090be:	24 58       	MOV       R1, R4
##@@@P_:port.c:301
##@@@L0301_:    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)SYSTICK0_PTR));   
800090c0:	05 58       	MOV       R0, R5
##@@@P_:port.c:302
##@@@L0302_:    __asm__ volatile("MOV R6, %0" ::"r"((unsigned int)Systick_Hw_UpdateCompare));   
800090c2:	13 45       	LD        R5, [PC + #19]        ;->0x8000910c  :=0x8000bf44
800090c4:	c5 58       	MOV       R6, R5
##@@@P_:port.c:304
##@@@L0303_:
##@@@L0304_:    __asm__ volatile("LJMP R6");   
800090c6:	06 5c       	LJMP      R6
##@@@P_:port.c:309
##@@@L0305_:    // Systick_Hw_UpdateCompare(SYSTICK0_PTR,   
##@@@L0306_:    //                          SYSTICK_HW_COMPARATOR_0,   
##@@@L0307_:    //                          stmCount + configSTM_CLOCK_HZ / configTICK_RATE_HZ);   
##@@@L0308_:
##@@@L0309_:    __asm__ volatile("MOV R6, %0" ::"r"((unsigned int)vPortSystemTickHandler));   
800090c8:	12 45       	LD        R5, [PC + #18]        ;->0x80009110  :=0x80008f78
800090ca:	c5 58       	MOV       R6, R5
##@@@P_:port.c:310
##@@@L0310_:    __asm__ volatile("LJMP R6");   
800090cc:	06 5c       	LJMP      R6
##@@@P_:port.c:314
##@@@L0311_:    // vPortSystemTickHandler();   
##@@@L0312_:
##@@@L0313_:    /* 全局变量恢复 */   
##@@@L0314_:    __asm__ volatile("POP {R6-R9}");   
800090ce:	0f 5e       	POP       {R6-R9}
##@@@P_:port.c:318
##@@@L0315_:    /* 内存屏障，保证指令顺序 */   
##@@@L0316_:    __asm__ volatile("" ::: "memory");   
##@@@L0317_:    /* 等待以上指令完成后再访问内存 */   
##@@@L0318_:    __asm__ volatile("DSYNC");   
800090d0:	0d 00       	DSYNC    DSYNC    
##@@@P_:port.c:320
##@@@L0319_:    /* 等待以上指令完成后再执行后续指令 */   
##@@@L0320_:    __asm__ volatile("SYNC");   
800090d2:	08 00       	SYNC     SYNC     
800090d4:	90 5d 89 45 	CSRW      R17, #0x0189  // @imm 393
##@@@P_:port.c:325
##@@@L0321_:    /* 准备中断返回 */   
##@@@L0322_:    /* 恢复ISP为中断入口保存的ISP */   
##@@@L0323_:    /** @note 该指令可以去除，因为全程ISP未改变 */   
##@@@L0324_:    __asm__ volatile("CSRW R17, #0x189");   
##@@@L0325_:    __asm__ volatile("SYNC");   
800090d8:	08 00       	SYNC     SYNC     
##@@@P_:port.c:327
##@@@L0326_:    /* 恢复SP为任务栈 */   
##@@@L0327_:    __asm__ volatile("MOV SP, R16");   
800090da:	d0 59       	MOV       SP, R16
800090dc:	ee 00 03 00 	POP       {R16,R17}
##@@@P_:port.c:334
##@@@L0329_:    /** @attention 使用R16/R17后，编译器会自动出栈 */   
##@@@L0330_:    /* 从任务栈内恢复R16, R17 */   
##@@@L0331_:    __asm__ volatile("POP {R16, R17}");   
##@@@L0332_:    __asm__ volatile("" ::: "memory");   
##@@@L0333_:    /*======================任务栈====================*/   
##@@@L0334_:    ENABLE_INTERRUPT();   
800090e0:	01 04       	SJMP      $+1                   ;->0x800090e2
800090e2:	20 5d       	PUSH      R0
800090e4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
800090e8:	08 00       	SYNC     SYNC     
800090ea:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
800090ee:	08 00       	SYNC     SYNC     
800090f0:	00 5d       	POP       R0
800090f2:	01 04       	SJMP      $+1                   ;->0x800090f4
##@@@P_:port.c:335
##@@@L0335_:    __asm__ volatile("POP LR");   
800090f4:	0d 5d       	POP       LR
##@@@P_:port.c:336
##@@@L0336_:}   
800090f6:	e8 28       	ADD       SP, #8			;->0x08
800090f8:	ee 00 03 00 	POP       {R16,R17}
800090fc:	1d 5c       	JMP       LR
800090fe:	00 00       	NOP      NOP      
80009100:	00 01 00 f0 	.long     0xf0000100 ->-268435200  [!!!@2@:CMN       R0, R0	@@: JZ        $+0                   ;->0x80009100
80009104:	14 91 00 80 	.long     0x80009114 ->-2147446508  [!!!@2@:ST.B      [R2 + #4], R4	@@: LD.B      R0, [R0]
80009108:	50 c3 00 00 	.long     0x0000c350 ->000050000  [!!!@2@:ADD       R2, R0, R5	@@: NOP      
8000910c:	44 bf 00 80 	.long     0x8000bf44 ->-2147434684 
80009110:	78 8f 00 80 	.long     0x80008f78 ->-2147446920  [!!!@2@:LD.B      R7, [R0 + #29]	@@: LD.B      R0, [R0]

80009114 <Systick_LL_GetLowerTimer>:
##@@@F_:Systick_LL_GetLowerTimer():
##@@@P_:kf32a13k_drv_systick.h:405
##@@@L0400_: * @retval uint32_t 低32位计数值   
##@@@L0401_: */   
##@@@L0402_:KF_INLINE uint32_t Systick_LL_GetLowerTimer(Systick_RegisterMap_t *const Module)   
##@@@L0403_:{   
##@@@L0404_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0405_:    return (REG_READ(Module->SYSTICK_TIM0.reg));   
80009114:	00 9a       	LD.W      R0, [R0 + #8]
80009116:	1d 5c       	JMP       LR

80009118 <vPortEndScheduler>:
##@@@F_:vPortEndScheduler():
##@@@P_:port.c:345
##@@@L0340_:/*-----------------------------------------------------------*/   
##@@@L0341_:
##@@@L0342_:void vPortEndScheduler(void)   
##@@@L0343_:{   
##@@@L0344_:    /* Nothing to do. Unlikely to want to end. */   
##@@@L0345_:}   
80009118:	1d 5c       	JMP       LR
	...

8000911c <vPortLoopForever>:
##@@@F_:vPortLoopForever():
##@@@P_:port.c:387
##@@@L0382_:}   
##@@@L0383_:/*-----------------------------------------------------------*/   
##@@@L0384_:
##@@@L0385_:__attribute__((__noreturn__)) void vPortLoopForever(void)   
##@@@L0386_:{   
##@@@L0387_:    while (1)   
8000911c:	00 04       	SJMP      $+0                   ;->0x8000911c
	...

80009120 <vApplicationGetIdleTaskMemory>:
##@@@F_:vApplicationGetIdleTaskMemory():
##@@@P_:port.c:440
##@@@L0435_:static StaticTask_t TimerTaskTCB;   
##@@@L0436_:
##@@@L0437_:void vApplicationGetIdleTaskMemory(   
##@@@L0438_:  StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize)   
##@@@L0439_:{   
##@@@L0440_:    *ppxIdleTaskStackBuffer = IdleTaskStack;   
80009120:	04 45       	LD        R5, [PC + #4]         ;->0x80009130  :=0xd0008360
80009122:	15 85       	ST.W      [R1], R5
##@@@P_:port.c:441
##@@@L0441_:    *ppxIdleTaskTCBBuffer   = &IdleTaskTCB;   
80009124:	04 45       	LD        R5, [PC + #4]         ;->0x80009134  :=0xd0008b60
80009126:	05 44       	LD        R4, [PC + #5]         ;->0x80009138  :=0x200
80009128:	05 85       	ST.W      [R0], R5
##@@@P_:port.c:442
##@@@L0442_:    *pulIdleTaskStackSize   = configMINIMAL_STACK_SIZE;   
8000912a:	24 85       	ST.W      [R2], R4
##@@@P_:port.c:443
##@@@L0443_:}   
8000912c:	1d 5c       	JMP       LR
8000912e:	00 00       	NOP      NOP      
80009130:	60 83 00 d0 	.long     0xd0008360 ->-805272736  [!!!@2@:ST.B      [R6], R0	@@: ZXT.H     R0, R0
80009134:	60 8b 00 d0 	.long     0xd0008b60 ->-805270688  [!!!@2@:LD.B      R4, [R0 + #13]	@@: ZXT.H     R0, R0
80009138:	00 02 00 00 	.long     0x00000200 ->000000512 

8000913c <vApplicationGetTimerTaskMemory>:
##@@@F_:vApplicationGetTimerTaskMemory():
##@@@P_:port.c:448
##@@@L0444_:
##@@@L0445_:void vApplicationGetTimerTaskMemory(   
##@@@L0446_:  StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize)   
##@@@L0447_:{   
##@@@L0448_:    *ppxTimerTaskStackBuffer = TimerTaskStack;   
8000913c:	04 45       	LD        R5, [PC + #4]         ;->0x8000914c  :=0xd0008bd8
8000913e:	15 85       	ST.W      [R1], R5
##@@@P_:port.c:449
##@@@L0449_:    *ppxTimerTaskTCBBuffer   = &TimerTaskTCB;   
80009140:	04 45       	LD        R5, [PC + #4]         ;->0x80009150  :=0xd00093d8
80009142:	05 44       	LD        R4, [PC + #5]         ;->0x80009154  :=0x200
80009144:	05 85       	ST.W      [R0], R5
##@@@P_:port.c:450
##@@@L0450_:    *pulTimerTaskStackSize   = configTIMER_TASK_STACK_DEPTH;   
80009146:	24 85       	ST.W      [R2], R4
##@@@P_:port.c:451
##@@@L0451_:}   
80009148:	1d 5c       	JMP       LR
8000914a:	00 00       	NOP      NOP      
8000914c:	d8 8b 00 d0 	.long     0xd0008bd8 ->-805270568  [!!!@2@:LD.B      R3, [R0 + #15]	@@: ZXT.H     R0, R0
80009150:	d8 93 00 d0 	.long     0xd00093d8 ->-805268520  [!!!@2@:ST.B      [R3 + #15], R0	@@: ZXT.H     R0, R0
80009154:	00 02 00 00 	.long     0x00000200 ->000000512 

80009158 <interruptSwGp0Sr0>:
##@@@F_:interruptSwGp0Sr0():
##@@@P_:port_asm.asm:11
##@@@L0006_:    .export interruptSwGp0Sr0   
##@@@L0007_:    .type interruptSwGp0Sr0,@function   
##@@@L0008_:    .func interruptSwGp0Sr0   
##@@@L0009_:interruptSwGp0Sr0:       
##@@@L0010_:    /* DISABLE_INTERRUPT() */   
##@@@L0011_:    PUSH R0   
80009158:	20 5d       	PUSH      R0
8000915a:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
##@@@P_:port_asm.asm:13
##@@@L0012_:    MOV R0,#0x00008000   
##@@@L0013_:    SYNC   
8000915e:	08 00       	SYNC     SYNC     
80009160:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
##@@@P_:port_asm.asm:15
##@@@L0014_:    CSRCLR R0, R0, #0x187   
##@@@L0015_:    SYNC   
80009164:	08 00       	SYNC     SYNC     
##@@@P_:port_asm.asm:16
##@@@L0016_:    POP R0   
80009166:	00 5d       	POP       R0
##@@@P_:port_asm.asm:27
##@@@L0022_:     */   
##@@@L0023_:    /** @attention 若PSW.IS=1，硬件中断压栈也使用SP */   
##@@@L0024_:    /** @attention   
##@@@L0025_:     * 若PSW.IS=0，硬件中断压栈固定使用ISP，将R0-R4,LR,XPSR压入ISP中；中断服务程序中由软件选择使用之前的任务栈SP或ISP(若选择使用ISP，需要手动修改SP=ISP，中断返回时恢复之前的SP)   
##@@@L0026_:     */   
##@@@L0027_:    PUSH LR   
80009168:	2d 5d       	PUSH      LR
8000916a:	ef 00 ff ff 	PUSH      {R16,R17,R18,R19,R20,R21,R22,R23,R24,R25,R26,R27,R28,R29,R30,R31}
##@@@P_:port_asm.asm:30
##@@@L0028_:    /* 手动压栈SP, 保存当前任务的上下文 */   
##@@@L0029_:    PUSH {R16-R31}   
##@@@L0030_:    PUSH {R6-R12}   
8000916e:	7f 5f       	PUSH      {R6-R12}
##@@@P_:port_asm.asm:41
##@@@L0036_:     * 手动压栈 R16-R31   
##@@@L0037_:     * 手动压栈 R6-R12   
##@@@L0038_:     */   
##@@@L0039_:    /* 修改 pxCurrentTCB->pxTopOfStack为新的SP */   
##@@@L0040_:    /** @brief R2 = &pxCurrentTCB */   
##@@@L0041_:    LD R2, #pxCurrentTCB   
80009170:	14 42       	LD        R2, [PC + #20]        ;->0x800091c0  :=0xd0000040
##@@@P_:port_asm.asm:43
##@@@L0042_:    /** @brief R1 = pxCurrentTCB = &CurrentTCB = &CurrentTCB.pxTopOfStack */   
##@@@L0043_:    LD.W R1, [R2]   
80009172:	12 82       	LD.W      R1, [R2]
##@@@P_:port_asm.asm:45
##@@@L0044_:    /** @brief R0 = task A SP with context stored */   
##@@@L0045_:    MOV R0, SP   
80009174:	0e 58       	MOV       R0, SP
##@@@P_:port_asm.asm:47
##@@@L0046_:    /** @brief CurrentTCB.pxTopOfStack = SP */   
##@@@L0047_:    ST.W [R1], R0   
80009176:	10 85       	ST.W      [R1], R0
80009178:	80 5d 89 0d 	CSRR      R3, #0x0189  // @imm 393
##@@@P_:port_asm.asm:52
##@@@L0048_:
##@@@L0049_:    /* 中断内将栈指针手动切换为ISP */   
##@@@L0050_:    /* 读取ISP, 在R3内保存当前ISP */   
##@@@L0051_:    CSRR R3, #0x189   
##@@@L0052_:    SYNC   
8000917c:	08 00       	SYNC     SYNC     
##@@@P_:port_asm.asm:53
##@@@L0053_:    MOV SP, R3   
8000917e:	c3 59       	MOV       SP, R3
##@@@P_:port_asm.asm:54
##@@@L0054_:    SYNC   
80009180:	08 00       	SYNC     SYNC     
##@@@P_:port_asm.asm:55
##@@@L0055_:    DSYNC   
80009182:	0d 00       	DSYNC    DSYNC    
##@@@P_:port_asm.asm:60
##@@@L0056_:
##@@@L0057_:    /** @note 中断栈空间   
##@@@L0058_:     * 压栈LR(vTaskSwitchContext返回地址,即interruptSwGp0Sr0+4)   
##@@@L0059_:    */   
##@@@L0060_:    PUSH LR   
80009184:	2d 5d       	PUSH      LR
##@@@P_:port_asm.asm:62
##@@@L0061_:    /** @attention 汇编内调用函数，编译器不会自动保存调用者使用的寄存器 */   
##@@@L0062_:    PUSH R3   
80009186:	23 5d       	PUSH      R3
##@@@P_:port_asm.asm:63
##@@@L0063_:    LD R2, #vTaskSwitchContext   
80009188:	0f 42       	LD        R2, [PC + #15]        ;->0x800091c4  :=0x80006320
##@@@P_:port_asm.asm:64
##@@@L0064_:    LJMP R2   
8000918a:	02 5c       	LJMP      R2
##@@@P_:port_asm.asm:65
##@@@L0065_:    POP R3   
8000918c:	03 5d       	POP       R3
##@@@P_:port_asm.asm:66
##@@@L0066_:    POP LR   
8000918e:	0d 5d       	POP       LR
##@@@P_:port_asm.asm:68
##@@@L0067_:    /* 恢复ISP */   
##@@@L0068_:    DSYNC   
80009190:	0d 00       	DSYNC    DSYNC    
##@@@P_:port_asm.asm:69
##@@@L0069_:    SYNC   
80009192:	08 00       	SYNC     SYNC     
80009194:	90 5d 89 0d 	CSRW      R3, #0x0189  // @imm 393
##@@@P_:port_asm.asm:71
##@@@L0070_:    CSRW R3, #0x189   
##@@@L0071_:    SYNC   
80009198:	08 00       	SYNC     SYNC     
##@@@P_:port_asm.asm:76
##@@@L0072_:    /** @attention 没有必要将当前使用栈切换回任务A的SP */   
##@@@L0073_:    /* 将SP赋值为新任务的栈顶pxCurrentTCB->pxTopOfStack */   
##@@@L0074_:    /** @brief R2 = &pxCurrentTCB */   
##@@@L0075_:    /** @attention 重新读取pxCurrentTCB地址至R2, 避免vTaskSwitchContext()内使用了R2寄存器*/   
##@@@L0076_:    LD R2, #pxCurrentTCB   
8000919a:	0a 42       	LD        R2, [PC + #10]        ;->0x800091c0  :=0xd0000040
##@@@P_:port_asm.asm:78
##@@@L0077_:    /** @brief R1 = pxCurrentTCB = &CurrentTCB = &CurrentTCB.pxTopOfStack */   
##@@@L0078_:    LD.W R1, [R2]   
8000919c:	12 82       	LD.W      R1, [R2]
##@@@P_:port_asm.asm:80
##@@@L0079_:    /** @brief R1 = (unsigned int)CurrentTCB.pxTopOfStack */   
##@@@L0080_:    LD.W R1, [R1]   
8000919e:	11 82       	LD.W      R1, [R1]
##@@@P_:port_asm.asm:82
##@@@L0081_:    /** @brief SP = (unsigned int)CurrentTCB.pxTopOfStack */   
##@@@L0082_:    MOV SP, R1   
800091a0:	c1 59       	MOV       SP, R1
##@@@P_:port_asm.asm:83
##@@@L0083_:    SYNC   
800091a2:	08 00       	SYNC     SYNC     
##@@@P_:port_asm.asm:93
##@@@L0088_:     * 编译器压栈LR(中断服务程序的返回地址，即中断引导程序的跳转位置+4)   
##@@@L0089_:     * 手动压栈 R16-R31   
##@@@L0090_:     * 手动压栈 R6-R12   
##@@@L0091_:     */   
##@@@L0092_:    /* 从新任务栈中弹出新任务使用的全局寄存器 */   
##@@@L0093_:    POP {R6-R12}   
800091a4:	7f 5e       	POP       {R6-R12}
800091a6:	ee 00 ff ff 	POP       {R16,R17,R18,R19,R20,R21,R22,R23,R24,R25,R26,R27,R28,R29,R30,R31}
##@@@P_:port_asm.asm:96
##@@@L0094_:    POP {R16-R31}   
##@@@L0095_:    /* 手动添加LR (中断服务程序的返回地址) PUSH/POP，需要在此恢复 */   
##@@@L0096_:    POP LR   
800091aa:	0d 5d       	POP       LR
##@@@P_:port_asm.asm:101
##@@@L0097_:    /* __iVecEntry执行LR(任务中断地址) PUSH/POP，不需要在此恢复 */   
##@@@L0098_:    /* __iVecEntry执行R5 PUSH/POP，不需要在此恢复 */   
##@@@L0099_:    /* 中断引导程序返回时MRET自动出栈: LR(任务返回地址) R4 R3 R2 R1 R0 XPSR */   
##@@@L0100_:    /** @attention MRET指令出栈的同时并行JMP LR, 该LR为任务中断地址，而非MRET自动出栈的LR*/   
##@@@L0101_:    PUSH R0                                                                                                   
800091ac:	20 5d       	PUSH      R0
800091ae:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
##@@@P_:port_asm.asm:103
##@@@L0102_:    MOV R0,#0x00008000                                                                                        
##@@@L0103_:    SYNC                                                                                                      
800091b2:	08 00       	SYNC     SYNC     
800091b4:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
##@@@P_:port_asm.asm:105
##@@@L0104_:    CSRSET R0, R0, #0x187                                                                                    
##@@@L0105_:    SYNC                                                                                                      
800091b8:	08 00       	SYNC     SYNC     
##@@@P_:port_asm.asm:106
##@@@L0106_:    POP R0    
800091ba:	00 5d       	POP       R0
##@@@P_:port_asm.asm:108
##@@@L0107_:
##@@@L0108_:    JMP LR   
800091bc:	1d 5c       	JMP       LR
800091be:	00 00       	NOP      NOP      
800091c0:	40 00 00 d0 	.long     0xd0000040 ->-805306304  [!!!@4@:LD.W      R0, [R0 + #52]
800091c4:	20 63 00 80 	.long     0x80006320 ->-2147458272  [!!!@2@:XCH       R2, R0	@@: LD.B      R0, [R0]

800091c8 <TaskTc00>:
##@@@F_:TaskTc00():
##@@@P_:RtosTc00.c:10
##@@@L0005_:
##@@@L0006_:static StackType_t  Tc00Stack[TC00_STACK_SIZE];   
##@@@L0007_:static StaticTask_t Tc00StaticTCB;   
##@@@L0008_:
##@@@L0009_:void TaskTc00(void *pvParameters)   
##@@@L0010_:{   
800091c8:	87 5f       	PUSH      {R6-R8,LR}
800091ca:	e8 30       	SUB       SP, #8			;->0x08
800091cc:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:RtosTc00.c:11
##@@@L0011_:    volatile uint32_t cnt = 0;   
800091ce:	01 25       	ST.W      [SP + #1], R5
800091d0:	07 47       	LD        R7, [PC + #7]         ;->0x800091ec  :=0x3e8
800091d2:	81 10       	MOV       R8, #1			;->0x0001
800091d4:	c5 58       	MOV       R6, R5
##@@@P_:RtosTc00.c:16
##@@@L0012_:    while (1)   
##@@@L0013_:    {   
##@@@L0014_:        for (uint32_t i = 0; i < 1000; i++)   
##@@@L0015_:        {   
##@@@L0016_:            cnt += 1;   
800091d6:	01 0c       	LD.W      R4, [SP + #1]
800091d8:	64 c0       	ADD       R4, R4, #1
##@@@P_:RtosTc00.c:14
##@@@L0009_:void TaskTc00(void *pvParameters)   
##@@@L0010_:{   
##@@@L0011_:    volatile uint32_t cnt = 0;   
##@@@L0012_:    while (1)   
##@@@L0013_:    {   
##@@@L0014_:        for (uint32_t i = 0; i < 1000; i++)   
800091da:	6d c0       	ADD       R5, R5, #1
800091dc:	57 70       	CMP       R5, R7
##@@@P_:RtosTc00.c:16
##@@@L0015_:        {   
##@@@L0016_:            cnt += 1;   
800091de:	01 24       	ST.W      [SP + #1], R4
##@@@P_:RtosTc00.c:14
##@@@L0009_:void TaskTc00(void *pvParameters)   
##@@@L0010_:{   
##@@@L0011_:    volatile uint32_t cnt = 0;   
##@@@L0012_:    while (1)   
##@@@L0013_:    {   
##@@@L0014_:        for (uint32_t i = 0; i < 1000; i++)   
800091e0:	fb f1       	JNZ       $-5                   ;->0x800091d6
##@@@P_:RtosTc00.c:18
##@@@L0015_:        {   
##@@@L0016_:            cnt += 1;   
##@@@L0017_:        }   
##@@@L0018_:        os_sleep(1U);   
800091e2:	08 58       	MOV       R0, R8
800091e4:	03 45       	LD        R5, [PC + #3]         ;->0x800091f0  :=0x80001984
800091e6:	05 5c       	LJMP      R5
800091e8:	a6 58       	MOV       R5, R6
800091ea:	f6 07       	SJMP      $-10                  ;->0x800091d6
800091ec:	e8 03 00 00 	.long     0x000003e8 ->000001000  [!!!@4@:JMP       $-1572864             ;->0x7fd091ec
800091f0:	84 19 00 80 	.long     0x80001984 ->-2147477116  [!!!@2@:MOV       R8, #148	@@: LD.B      R0, [R0]

800091f4 <RtosTc00>:
##@@@F_:RtosTc00():
##@@@P_:RtosTc00.c:24
##@@@L0019_:    }   
##@@@L0020_:}   
##@@@L0021_:
##@@@L0022_:/* 静态创建单一任务，主动挂起 */   
##@@@L0023_:void RtosTc00()   
##@@@L0024_:{   
800091f4:	81 5f       	PUSH      {R6,LR}
800091f6:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:RtosTc00.c:25
##@@@L0025_:    xTaskCreateStatic(TaskTc00, "TaskTc00", TC00_STACK_SIZE, NULL, TASK_START_PRIO_3, Tc00Stack, &Tc00StaticTCB);   
800091f8:	09 45       	LD        R5, [PC + #9]         ;->0x8000921c  :=0xd0009c50
800091fa:	ce 58       	MOV       R6, SP
800091fc:	75 a0       	ST.W      [R6 + #1], R5
800091fe:	09 45       	LD        R5, [PC + #9]         ;->0x80009220  :=0xd0009450
80009200:	09 40       	LD        R0, [PC + #9]         ;->0x80009224  :=0x800091c8
80009202:	0a 41       	LD        R1, [PC + #10]        ;->0x80009228  :=0x80000fc4
80009204:	0a 42       	LD        R2, [PC + #10]        ;->0x8000922c  :=0x200
80009206:	30 10       	MOV       R3, #0			;->0x0000
80009208:	43 10       	MOV       R4, #3			;->0x0003
8000920a:	65 85       	ST.W      [R6], R5
8000920c:	09 45       	LD        R5, [PC + #9]         ;->0x80009230  :=0x80005088
8000920e:	05 5c       	LJMP      R5
##@@@P_:RtosTc00.c:26
##@@@L0026_:    vTaskStartScheduler();   
80009210:	09 45       	LD        R5, [PC + #9]         ;->0x80009234  :=0x8000667c
80009212:	05 5c       	LJMP      R5
##@@@P_:RtosTc00.c:27
80009214:	ec 28       	ADD       SP, #12			;->0x0C
80009216:	06 5d       	POP       R6
80009218:	0d 5d       	POP       LR
8000921a:	1d 5c       	JMP       LR
8000921c:	50 9c 00 d0 	.long     0xd0009c50 ->-805266352  [!!!@2@:LD.W      R2, [R0 + #17]	@@: ZXT.H     R0, R0
80009220:	50 94 00 d0 	.long     0xd0009450 ->-805268400  [!!!@2@:ST.B      [R2 + #17], R0	@@: ZXT.H     R0, R0
80009224:	c8 91 00 80 	.long     0x800091c8 ->-2147446328  [!!!@2@:ST.B      [R1 + #7], R0	@@: LD.B      R0, [R0]
80009228:	c4 0f 00 80 	.long     0x80000fc4 ->-2147479612  [!!!@2@:LD.W      R7, [SP + #196]	@@: LD.B      R0, [R0]
8000922c:	00 02 00 00 	.long     0x00000200 ->000000512 
80009230:	88 50 00 80 	.long     0x80005088 ->-2147463032 
80009234:	7c 66 00 80 	.long     0x8000667c ->-2147457412  [!!!@2@:SUB       R7, R12	@@: LD.B      R0, [R0]

80009238 <RtosTc01>:
##@@@F_:RtosTc01():
##@@@P_:RtosTc01.c:30
##@@@L0025_:    }   
##@@@L0026_:}   
##@@@L0027_:
##@@@L0028_:/* 静态创建相同优先级任务，时间片轮转 */   
##@@@L0029_:void RtosTc01()   
##@@@L0030_:{   
80009238:	87 5f       	PUSH      {R6-R8,LR}
8000923a:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:RtosTc01.c:31
##@@@L0031_:    xTaskCreateStatic(   
8000923c:	11 45       	LD        R5, [PC + #17]        ;->0x80009280  :=0xd000a4c8
8000923e:	8e 58       	MOV       R4, SP
80009240:	65 a0       	ST.W      [R4 + #1], R5
80009242:	11 45       	LD        R5, [PC + #17]        ;->0x80009284  :=0xd0009cc8
80009244:	11 40       	LD        R0, [PC + #17]        ;->0x80009288  :=0x800092ac
80009246:	12 41       	LD        R1, [PC + #18]        ;->0x8000928c  :=0x80000fcd
80009248:	12 46       	LD        R6, [PC + #18]        ;->0x80009290  :=0x200
8000924a:	70 10       	MOV       R7, #0			;->0x0000
8000924c:	85 10       	MOV       R8, #5			;->0x0005
8000924e:	45 85       	ST.W      [R4], R5
80009250:	46 58       	MOV       R2, R6
80009252:	67 58       	MOV       R3, R7
80009254:	88 58       	MOV       R4, R8
80009256:	10 45       	LD        R5, [PC + #16]        ;->0x80009294  :=0x80005088
80009258:	05 5c       	LJMP      R5
##@@@P_:RtosTc01.c:33
##@@@L0032_:      TaskTc01_1, "TaskTc01_1", TC01_STACK_SIZE, NULL, TASK_START_PRIO_5, Tc01_1_Stack, &Tc01_1_StaticTCB);   
##@@@L0033_:    xTaskCreateStatic(   
8000925a:	ae 58       	MOV       R5, SP
8000925c:	0f 44       	LD        R4, [PC + #15]        ;->0x80009298  :=0xd000ad40
8000925e:	10 43       	LD        R3, [PC + #16]        ;->0x8000929c  :=0xd000a540
80009260:	10 40       	LD        R0, [PC + #16]        ;->0x800092a0  :=0x800092bc
80009262:	11 41       	LD        R1, [PC + #17]        ;->0x800092a4  :=0x80000fd8
80009264:	6c a0       	ST.W      [R5 + #1], R4
80009266:	53 85       	ST.W      [R5], R3
80009268:	46 58       	MOV       R2, R6
8000926a:	67 58       	MOV       R3, R7
8000926c:	88 58       	MOV       R4, R8
8000926e:	0a 45       	LD        R5, [PC + #10]        ;->0x80009294  :=0x80005088
80009270:	05 5c       	LJMP      R5
##@@@P_:RtosTc01.c:35
##@@@L0034_:      TaskTc01_2, "TaskTc01_2", TC01_STACK_SIZE, NULL, TASK_START_PRIO_5, Tc01_2_Stack, &Tc01_2_StaticTCB);   
##@@@L0035_:    vTaskStartScheduler();   
80009272:	0e 45       	LD        R5, [PC + #14]        ;->0x800092a8  :=0x8000667c
80009274:	05 5c       	LJMP      R5
##@@@P_:RtosTc01.c:36
80009276:	ec 28       	ADD       SP, #12			;->0x0C
80009278:	07 5e       	POP       {R6-R8}
8000927a:	0d 5d       	POP       LR
8000927c:	1d 5c       	JMP       LR
8000927e:	00 00       	NOP      NOP      
80009280:	c8 a4 00 d0 	.long     0xd000a4c8 ->-805264184  [!!!@2@:ST.W      [R1 + #19], R0	@@: ZXT.H     R0, R0
80009284:	c8 9c 00 d0 	.long     0xd0009cc8 ->-805266232  [!!!@2@:LD.W      R1, [R0 + #19]	@@: ZXT.H     R0, R0
80009288:	ac 92 00 80 	.long     0x800092ac ->-2147446100  [!!!@2@:ST.B      [R5 + #10], R4	@@: LD.B      R0, [R0]
8000928c:	cd 0f 00 80 	.long     0x80000fcd ->-2147479603  [!!!@2@:LD.W      R7, [SP + #205]	@@: LD.B      R0, [R0]
80009290:	00 02 00 00 	.long     0x00000200 ->000000512 
80009294:	88 50 00 80 	.long     0x80005088 ->-2147463032 
80009298:	40 ad 00 d0 	.long     0xd000ad40 ->-805262016  [!!!@2@:LD.H      R0, [R0 + #21]	@@: ZXT.H     R0, R0
8000929c:	40 a5 00 d0 	.long     0xd000a540 ->-805264064  [!!!@2@:ST.W      [R0 + #21], R0	@@: ZXT.H     R0, R0
800092a0:	bc 92 00 80 	.long     0x800092bc ->-2147446084  [!!!@2@:ST.B      [R7 + #10], R4	@@: LD.B      R0, [R0]
800092a4:	d8 0f 00 80 	.long     0x80000fd8 ->-2147479592  [!!!@2@:LD.W      R7, [SP + #216]	@@: LD.B      R0, [R0]
800092a8:	7c 66 00 80 	.long     0x8000667c ->-2147457412  [!!!@2@:SUB       R7, R12	@@: LD.B      R0, [R0]

800092ac <TaskTc01_1>:
##@@@F_:TaskTc01_1():
##@@@P_:RtosTc01.c:12
##@@@L0007_:static StaticTask_t Tc01_1_StaticTCB;   
##@@@L0008_:static StackType_t  Tc01_2_Stack[TC01_STACK_SIZE];   
##@@@L0009_:static StaticTask_t Tc01_2_StaticTCB;   
##@@@L0010_:
##@@@L0011_:static void TaskTc01_1(void *pvParameters)   
##@@@L0012_:{   
800092ac:	e8 30       	SUB       SP, #8			;->0x08
800092ae:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:RtosTc01.c:13
##@@@L0013_:    volatile uint32_t cnt = 0;   
800092b0:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc01.c:16
##@@@L0014_:    while (1)   
##@@@L0015_:    {   
##@@@L0016_:        cnt += 1;   
800092b2:	01 0d       	LD.W      R5, [SP + #1]
800092b4:	6d c0       	ADD       R5, R5, #1
800092b6:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc01.c:14
##@@@L0009_:static StaticTask_t Tc01_2_StaticTCB;   
##@@@L0010_:
##@@@L0011_:static void TaskTc01_1(void *pvParameters)   
##@@@L0012_:{   
##@@@L0013_:    volatile uint32_t cnt = 0;   
##@@@L0014_:    while (1)   
800092b8:	fd 07       	SJMP      $-3                   ;->0x800092b2
	...

800092bc <TaskTc01_2>:
##@@@F_:TaskTc01_2():
##@@@P_:RtosTc01.c:20
##@@@L0015_:    {   
##@@@L0016_:        cnt += 1;   
##@@@L0017_:    }   
##@@@L0018_:}   
##@@@L0019_:static void TaskTc01_2(void *pvParameters)   
##@@@L0020_:{   
800092bc:	e8 30       	SUB       SP, #8			;->0x08
800092be:	04 45       	LD        R5, [PC + #4]         ;->0x800092cc  :=0xffffffff
##@@@P_:RtosTc01.c:21
##@@@L0021_:    volatile uint32_t cnt = 0xFFFFFFFF;   
800092c0:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc01.c:24
##@@@L0022_:    while (1)   
##@@@L0023_:    {   
##@@@L0024_:        cnt -= 1;   
800092c2:	01 0d       	LD.W      R5, [SP + #1]
800092c4:	6d cc       	SUB       R5, R5, #1
800092c6:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc01.c:22
##@@@L0017_:    }   
##@@@L0018_:}   
##@@@L0019_:static void TaskTc01_2(void *pvParameters)   
##@@@L0020_:{   
##@@@L0021_:    volatile uint32_t cnt = 0xFFFFFFFF;   
##@@@L0022_:    while (1)   
800092c8:	fd 07       	SJMP      $-3                   ;->0x800092c2
800092ca:	00 00       	NOP      NOP      
800092cc:	ff ff ff ff 	.long     0xffffffff ->-00000001 

800092d0 <RtosTc02>:
##@@@F_:RtosTc02():
##@@@P_:RtosTc02.c:30
##@@@L0025_:    }   
##@@@L0026_:}   
##@@@L0027_:
##@@@L0028_:/* 高优先级任务始终调度 */   
##@@@L0029_:void RtosTc02()   
##@@@L0030_:{   
800092d0:	83 5f       	PUSH      {R6-R7,LR}
800092d2:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:RtosTc02.c:31
##@@@L0031_:    xTaskCreateStatic(   
800092d4:	10 45       	LD        R5, [PC + #16]        ;->0x80009314  :=0xd000b5b8
800092d6:	6e 58       	MOV       R3, SP
800092d8:	5d a0       	ST.W      [R3 + #1], R5
800092da:	10 45       	LD        R5, [PC + #16]        ;->0x80009318  :=0xd000adb8
800092dc:	10 40       	LD        R0, [PC + #16]        ;->0x8000931c  :=0x80009340
800092de:	11 41       	LD        R1, [PC + #17]        ;->0x80009320  :=0x80000fe3
800092e0:	11 46       	LD        R6, [PC + #17]        ;->0x80009324  :=0x200
800092e2:	70 10       	MOV       R7, #0			;->0x0000
800092e4:	45 10       	MOV       R4, #5			;->0x0005
800092e6:	35 85       	ST.W      [R3], R5
800092e8:	46 58       	MOV       R2, R6
800092ea:	67 58       	MOV       R3, R7
800092ec:	0f 45       	LD        R5, [PC + #15]        ;->0x80009328  :=0x80005088
800092ee:	05 5c       	LJMP      R5
##@@@P_:RtosTc02.c:33
##@@@L0032_:      TaskTc02_1, "TaskTc02_1", TC02_STACK_SIZE, NULL, TASK_START_PRIO_5, Tc02_1_Stack, &Tc02_1_StaticTCB);   
##@@@L0033_:    xTaskCreateStatic(   
800092f0:	0f 45       	LD        R5, [PC + #15]        ;->0x8000932c  :=0xd000be30
800092f2:	6e 58       	MOV       R3, SP
800092f4:	5d a0       	ST.W      [R3 + #1], R5
800092f6:	0f 45       	LD        R5, [PC + #15]        ;->0x80009330  :=0xd000b630
800092f8:	0f 40       	LD        R0, [PC + #15]        ;->0x80009334  :=0x80009350
800092fa:	10 41       	LD        R1, [PC + #16]        ;->0x80009338  :=0x80000fee
800092fc:	44 10       	MOV       R4, #4			;->0x0004
800092fe:	35 85       	ST.W      [R3], R5
80009300:	46 58       	MOV       R2, R6
80009302:	67 58       	MOV       R3, R7
80009304:	09 45       	LD        R5, [PC + #9]         ;->0x80009328  :=0x80005088
80009306:	05 5c       	LJMP      R5
##@@@P_:RtosTc02.c:35
##@@@L0034_:      TaskTc02_2, "TaskTc02_2", TC02_STACK_SIZE, NULL, TASK_START_PRIO_4, Tc02_2_Stack, &Tc02_2_StaticTCB);   
##@@@L0035_:    vTaskStartScheduler();   
80009308:	0d 45       	LD        R5, [PC + #13]        ;->0x8000933c  :=0x8000667c
8000930a:	05 5c       	LJMP      R5
##@@@P_:RtosTc02.c:36
8000930c:	ec 28       	ADD       SP, #12			;->0x0C
8000930e:	03 5e       	POP       {R6-R7}
80009310:	0d 5d       	POP       LR
80009312:	1d 5c       	JMP       LR
80009314:	b8 b5 00 d0 	.long     0xd000b5b8 ->-805259848  [!!!@2@:ST.H      [R7 + #22], R0	@@: ZXT.H     R0, R0
80009318:	b8 ad 00 d0 	.long     0xd000adb8 ->-805261896  [!!!@2@:LD.H      R7, [R0 + #22]	@@: ZXT.H     R0, R0
8000931c:	40 93 00 80 	.long     0x80009340 ->-2147445952  [!!!@2@:ST.B      [R0 + #13], R0	@@: LD.B      R0, [R0]
80009320:	e3 0f 00 80 	.long     0x80000fe3 ->-2147479581  [!!!@2@:LD.W      R7, [SP + #227]	@@: LD.B      R0, [R0]
80009324:	00 02 00 00 	.long     0x00000200 ->000000512 
80009328:	88 50 00 80 	.long     0x80005088 ->-2147463032 
8000932c:	30 be 00 d0 	.long     0xd000be30 ->-805257680 
80009330:	30 b6 00 d0 	.long     0xd000b630 ->-805259728  [!!!@2@:ST.H      [R6 + #24], R0	@@: ZXT.H     R0, R0
80009334:	50 93 00 80 	.long     0x80009350 ->-2147445936  [!!!@2@:ST.B      [R2 + #13], R0	@@: LD.B      R0, [R0]
80009338:	ee 0f 00 80 	.long     0x80000fee ->-2147479570  [!!!@2@:LD.W      R7, [SP + #238]	@@: LD.B      R0, [R0]
8000933c:	7c 66 00 80 	.long     0x8000667c ->-2147457412  [!!!@2@:SUB       R7, R12	@@: LD.B      R0, [R0]

80009340 <TaskTc02_1>:
##@@@F_:TaskTc02_1():
##@@@P_:RtosTc02.c:12
##@@@L0007_:static StaticTask_t Tc02_1_StaticTCB;   
##@@@L0008_:static StackType_t  Tc02_2_Stack[TC02_STACK_SIZE];   
##@@@L0009_:static StaticTask_t Tc02_2_StaticTCB;   
##@@@L0010_:
##@@@L0011_:static void TaskTc02_1(void *pvParameters)   
##@@@L0012_:{   
80009340:	e8 30       	SUB       SP, #8			;->0x08
80009342:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:RtosTc02.c:13
##@@@L0013_:    volatile uint32_t cnt = 0;   
80009344:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc02.c:16
##@@@L0014_:    while (1)   
##@@@L0015_:    {   
##@@@L0016_:        cnt += 1;   
80009346:	01 0d       	LD.W      R5, [SP + #1]
80009348:	6d c0       	ADD       R5, R5, #1
8000934a:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc02.c:14
##@@@L0009_:static StaticTask_t Tc02_2_StaticTCB;   
##@@@L0010_:
##@@@L0011_:static void TaskTc02_1(void *pvParameters)   
##@@@L0012_:{   
##@@@L0013_:    volatile uint32_t cnt = 0;   
##@@@L0014_:    while (1)   
8000934c:	fd 07       	SJMP      $-3                   ;->0x80009346
	...

80009350 <TaskTc02_2>:
##@@@F_:TaskTc02_2():
##@@@P_:RtosTc02.c:20
##@@@L0015_:    {   
##@@@L0016_:        cnt += 1;   
##@@@L0017_:    }   
##@@@L0018_:}   
##@@@L0019_:static void TaskTc02_2(void *pvParameters)   
##@@@L0020_:{   
80009350:	e8 30       	SUB       SP, #8			;->0x08
80009352:	04 45       	LD        R5, [PC + #4]         ;->0x80009360  :=0xffffffff
##@@@P_:RtosTc02.c:21
##@@@L0021_:    volatile uint32_t cnt = 0xFFFFFFFF;   
80009354:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc02.c:24
##@@@L0022_:    while (1)   
##@@@L0023_:    {   
##@@@L0024_:        cnt -= 1;   
80009356:	01 0d       	LD.W      R5, [SP + #1]
80009358:	6d cc       	SUB       R5, R5, #1
8000935a:	01 25       	ST.W      [SP + #1], R5
##@@@P_:RtosTc02.c:22
##@@@L0017_:    }   
##@@@L0018_:}   
##@@@L0019_:static void TaskTc02_2(void *pvParameters)   
##@@@L0020_:{   
##@@@L0021_:    volatile uint32_t cnt = 0xFFFFFFFF;   
##@@@L0022_:    while (1)   
8000935c:	fd 07       	SJMP      $-3                   ;->0x80009356
8000935e:	00 00       	NOP      NOP      
80009360:	ff ff ff ff 	.long     0xffffffff ->-00000001 

80009364 <RtosTc03>:
##@@@F_:RtosTc03():
##@@@P_:RtosTc03.c:38
##@@@L0033_:    }   
##@@@L0034_:}   
##@@@L0035_:
##@@@L0036_:/* 同优先级任务主动挂起 */   
##@@@L0037_:void RtosTc03()   
##@@@L0038_:{   
80009364:	83 5f       	PUSH      {R6-R7,LR}
80009366:	ec 30       	SUB       SP, #12			;->0x0C
##@@@P_:RtosTc03.c:39
##@@@L0039_:    xTaskCreateStatic(   
80009368:	10 45       	LD        R5, [PC + #16]        ;->0x800093a8  :=0xd000c6a8
8000936a:	6e 58       	MOV       R3, SP
8000936c:	5d a0       	ST.W      [R3 + #1], R5
8000936e:	10 45       	LD        R5, [PC + #16]        ;->0x800093ac  :=0xd000bea8
80009370:	10 40       	LD        R0, [PC + #16]        ;->0x800093b0  :=0x800093d4
80009372:	11 41       	LD        R1, [PC + #17]        ;->0x800093b4  :=0x80000ff9
80009374:	11 46       	LD        R6, [PC + #17]        ;->0x800093b8  :=0x200
80009376:	70 10       	MOV       R7, #0			;->0x0000
80009378:	45 10       	MOV       R4, #5			;->0x0005
8000937a:	35 85       	ST.W      [R3], R5
8000937c:	46 58       	MOV       R2, R6
8000937e:	67 58       	MOV       R3, R7
80009380:	0f 45       	LD        R5, [PC + #15]        ;->0x800093bc  :=0x80005088
80009382:	05 5c       	LJMP      R5
##@@@P_:RtosTc03.c:41
##@@@L0040_:      TaskTc03_1, "TaskTc03_1", TC03_STACK_SIZE, NULL, TASK_START_PRIO_5, Tc03_1_Stack, &Tc03_1_StaticTCB);   
##@@@L0041_:    xTaskCreateStatic(   
80009384:	0f 45       	LD        R5, [PC + #15]        ;->0x800093c0  :=0xd000cf20
80009386:	6e 58       	MOV       R3, SP
80009388:	5d a0       	ST.W      [R3 + #1], R5
8000938a:	0f 45       	LD        R5, [PC + #15]        ;->0x800093c4  :=0xd000c720
8000938c:	0f 40       	LD        R0, [PC + #15]        ;->0x800093c8  :=0x80009414
8000938e:	10 41       	LD        R1, [PC + #16]        ;->0x800093cc  :=0x80001004
80009390:	44 10       	MOV       R4, #4			;->0x0004
80009392:	35 85       	ST.W      [R3], R5
80009394:	46 58       	MOV       R2, R6
80009396:	67 58       	MOV       R3, R7
80009398:	09 45       	LD        R5, [PC + #9]         ;->0x800093bc  :=0x80005088
8000939a:	05 5c       	LJMP      R5
##@@@P_:RtosTc03.c:43
##@@@L0042_:      TaskTc03_2, "TaskTc03_2", TC03_STACK_SIZE, NULL, TASK_START_PRIO_4, Tc03_2_Stack, &Tc03_2_StaticTCB);   
##@@@L0043_:    vTaskStartScheduler();   
8000939c:	0d 45       	LD        R5, [PC + #13]        ;->0x800093d0  :=0x8000667c
8000939e:	05 5c       	LJMP      R5
##@@@P_:RtosTc03.c:44
800093a0:	ec 28       	ADD       SP, #12			;->0x0C
800093a2:	03 5e       	POP       {R6-R7}
800093a4:	0d 5d       	POP       LR
800093a6:	1d 5c       	JMP       LR
800093a8:	a8 c6 00 d0 	.long     0xd000c6a8 ->-805255512  [!!!@2@:SUB       R5, R0, R2	@@: ZXT.H     R0, R0
800093ac:	a8 be 00 d0 	.long     0xd000bea8 ->-805257560 
800093b0:	d4 93 00 80 	.long     0x800093d4 ->-2147445804  [!!!@2@:ST.B      [R2 + #15], R4	@@: LD.B      R0, [R0]
800093b4:	f9 0f 00 80 	.long     0x80000ff9 ->-2147479559  [!!!@2@:LD.W      R7, [SP + #249]	@@: LD.B      R0, [R0]
800093b8:	00 02 00 00 	.long     0x00000200 ->000000512 
800093bc:	88 50 00 80 	.long     0x80005088 ->-2147463032 
800093c0:	20 cf 00 d0 	.long     0xd000cf20 ->-805253344  [!!!@2@:DIVS      R4, R0, R4	@@: ZXT.H     R0, R0
800093c4:	20 c7 00 d0 	.long     0xd000c720 ->-805255392  [!!!@2@:SUB       R4, R0, R4	@@: ZXT.H     R0, R0
800093c8:	14 94 00 80 	.long     0x80009414 ->-2147445740  [!!!@2@:ST.B      [R2 + #16], R4	@@: LD.B      R0, [R0]
800093cc:	04 10 00 80 	.long     0x80001004 ->-2147479548  [!!!@2@:MOV       R0, #4	@@: LD.B      R0, [R0]
800093d0:	7c 66 00 80 	.long     0x8000667c ->-2147457412  [!!!@2@:SUB       R7, R12	@@: LD.B      R0, [R0]

800093d4 <TaskTc03_1>:
##@@@F_:TaskTc03_1():
##@@@P_:RtosTc03.c:12
##@@@L0007_:static StaticTask_t Tc03_1_StaticTCB;   
##@@@L0008_:static StackType_t  Tc03_2_Stack[TC03_STACK_SIZE];   
##@@@L0009_:static StaticTask_t Tc03_2_StaticTCB;   
##@@@L0010_:
##@@@L0011_:static void TaskTc03_1(void *pvParameters)   
##@@@L0012_:{   
800093d4:	87 5f       	PUSH      {R6-R8,LR}
800093d6:	ec 30       	SUB       SP, #12			;->0x0C
800093d8:	70 10       	MOV       R7, #0			;->0x0000
800093da:	0c 45       	LD        R5, [PC + #12]        ;->0x80009408  :=0x3e7
800093dc:	01 25       	ST.W      [SP + #1], R5
800093de:	0c 46       	LD        R6, [PC + #12]        ;->0x8000940c  :=0x3e8
800093e0:	81 10       	MOV       R8, #1			;->0x0001
800093e2:	04 04       	SJMP      $+4                   ;->0x800093ea
##@@@P_:RtosTc03.c:20
##@@@L0015_:        volatile uint32_t cnt = 0;   
##@@@L0016_:        for (cnt = 0; cnt < 1000; cnt++)   
##@@@L0017_:        {   
##@@@L0018_:            __asm__ volatile("NOP");   
##@@@L0019_:        }   
##@@@L0020_:        os_sleep(1);   
800093e4:	08 58       	MOV       R0, R8
800093e6:	0b 45       	LD        R5, [PC + #11]        ;->0x80009410  :=0x80001984
800093e8:	05 5c       	LJMP      R5
##@@@P_:RtosTc03.c:15
##@@@L0010_:
##@@@L0011_:static void TaskTc03_1(void *pvParameters)   
##@@@L0012_:{   
##@@@L0013_:    while (1)   
##@@@L0014_:    {   
##@@@L0015_:        volatile uint32_t cnt = 0;   
800093ea:	02 27       	ST.W      [SP + #2], R7
##@@@P_:RtosTc03.c:16
##@@@L0016_:        for (cnt = 0; cnt < 1000; cnt++)   
800093ec:	02 27       	ST.W      [SP + #2], R7
800093ee:	02 0d       	LD.W      R5, [SP + #2]
800093f0:	01 0c       	LD.W      R4, [SP + #1]
800093f2:	54 70       	CMP       R5, R4
800093f4:	f8 f8       	JHI       $-8                   ;->0x800093e4
##@@@P_:RtosTc03.c:18
##@@@L0017_:        {   
##@@@L0018_:            __asm__ volatile("NOP");   
800093f6:	00 00       	NOP      NOP      
##@@@P_:RtosTc03.c:16
##@@@L0011_:static void TaskTc03_1(void *pvParameters)   
##@@@L0012_:{   
##@@@L0013_:    while (1)   
##@@@L0014_:    {   
##@@@L0015_:        volatile uint32_t cnt = 0;   
##@@@L0016_:        for (cnt = 0; cnt < 1000; cnt++)   
800093f8:	02 0d       	LD.W      R5, [SP + #2]
800093fa:	6d c0       	ADD       R5, R5, #1
800093fc:	02 25       	ST.W      [SP + #2], R5
800093fe:	02 0d       	LD.W      R5, [SP + #2]
80009400:	56 70       	CMP       R5, R6
80009402:	fa f3       	JNC       $-6                   ;->0x800093f6
80009404:	f0 07       	SJMP      $-16                  ;->0x800093e4
80009406:	00 00       	NOP      NOP      
80009408:	e7 03 00 00 	.long     0x000003e7 ->000000999  [!!!@4@:JMP       $-1638400             ;->0x7fce9408
8000940c:	e8 03 00 00 	.long     0x000003e8 ->000001000  [!!!@4@:JMP       $-1572864             ;->0x7fd0940c
80009410:	84 19 00 80 	.long     0x80001984 ->-2147477116  [!!!@2@:MOV       R8, #148	@@: LD.B      R0, [R0]

80009414 <TaskTc03_2>:
##@@@F_:TaskTc03_2():
##@@@P_:RtosTc03.c:24
##@@@L0019_:        }   
##@@@L0020_:        os_sleep(1);   
##@@@L0021_:    }   
##@@@L0022_:}   
##@@@L0023_:static void TaskTc03_2(void *pvParameters)   
##@@@L0024_:{   
80009414:	83 5f       	PUSH      {R6-R7,LR}
80009416:	ec 30       	SUB       SP, #12			;->0x0C
80009418:	50 10       	MOV       R5, #0			;->0x0000
8000941a:	01 25       	ST.W      [SP + #1], R5
8000941c:	09 47       	LD        R7, [PC + #9]         ;->0x80009440  :=0x3e8
8000941e:	61 10       	MOV       R6, #1			;->0x0001
80009420:	04 04       	SJMP      $+4                   ;->0x80009428
##@@@P_:RtosTc03.c:32
##@@@L0027_:        volatile uint32_t cnt = 0;   
##@@@L0028_:        for (cnt = 1000; cnt > 0; cnt--)   
##@@@L0029_:        {   
##@@@L0030_:            __asm__ volatile("NOP");   
##@@@L0031_:        }   
##@@@L0032_:        os_sleep(1);   
80009422:	06 58       	MOV       R0, R6
80009424:	08 45       	LD        R5, [PC + #8]         ;->0x80009444  :=0x80001984
80009426:	05 5c       	LJMP      R5
##@@@P_:RtosTc03.c:27
##@@@L0022_:}   
##@@@L0023_:static void TaskTc03_2(void *pvParameters)   
##@@@L0024_:{   
##@@@L0025_:    while (1)   
##@@@L0026_:    {   
##@@@L0027_:        volatile uint32_t cnt = 0;   
80009428:	01 0d       	LD.W      R5, [SP + #1]
8000942a:	02 25       	ST.W      [SP + #2], R5
##@@@P_:RtosTc03.c:28
##@@@L0028_:        for (cnt = 1000; cnt > 0; cnt--)   
8000942c:	02 27       	ST.W      [SP + #2], R7
8000942e:	02 0d       	LD.W      R5, [SP + #2]
80009430:	50 38       	CMP       R5, #0			;->0x00
80009432:	f8 f0       	JZ        $-8                   ;->0x80009422
##@@@P_:RtosTc03.c:30
##@@@L0029_:        {   
##@@@L0030_:            __asm__ volatile("NOP");   
80009434:	00 00       	NOP      NOP      
##@@@P_:RtosTc03.c:28
##@@@L0023_:static void TaskTc03_2(void *pvParameters)   
##@@@L0024_:{   
##@@@L0025_:    while (1)   
##@@@L0026_:    {   
##@@@L0027_:        volatile uint32_t cnt = 0;   
##@@@L0028_:        for (cnt = 1000; cnt > 0; cnt--)   
80009436:	02 0d       	LD.W      R5, [SP + #2]
80009438:	6d cc       	SUB       R5, R5, #1
8000943a:	02 25       	ST.W      [SP + #2], R5
8000943c:	f9 07       	SJMP      $-7                   ;->0x8000942e
8000943e:	00 00       	NOP      NOP      
80009440:	e8 03 00 00 	.long     0x000003e8 ->000001000  [!!!@4@:JMP       $-1572864             ;->0x7fd09440
80009444:	84 19 00 80 	.long     0x80001984 ->-2147477116  [!!!@2@:MOV       R8, #148	@@: LD.B      R0, [R0]

80009448 <Clk_ConfigPLLInitialStep>:
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:200
##@@@L0195_: *   
##@@@L0196_: * @param PLLInitStepCfg   
##@@@L0197_: * @return   
##@@@L0198_: */   
##@@@L0199_:bool Clk_ConfigPLLInitialStep(const Clk_PLLInitialStepConfig_t *PLLInitStepCfg)   
##@@@L0200_:{   
80009448:	3f 5f       	PUSH      {R6-R11}
8000944a:	e4 32       	SUB       SP, #36			;->0x24
8000944c:	bf 42       	LD        R2, [PC + #191]       ;->0x80009748  :=0x1000
##@@@P_:kf32a13k_hw_clk.c:203
##@@@L0201_:    bool initError = false;   
##@@@L0202_:    /* 超时时间，防止编译器优化*/   
##@@@L0203_:    volatile uint32_t timeoutCycleCount = CLK_DOMAIN_LCK_BIT_TIMEOUT_COUNT;   
8000944e:	08 22       	ST.W      [SP + #8], R2
80009450:	bf 45       	LD        R5, [PC + #191]       ;->0x8000974c  :=0xf000f43c
80009452:	c0 44       	LD        R4, [PC + #192]       ;->0x80009750  :=0xffffffff
##@@@P_:kf32a13k_hw_clk.c:207
##@@@L0204_:
##@@@L0205_:    /* 时钟域设置*/   
##@@@L0206_:    {   
##@@@L0207_:        timeoutCycleCount = CLK_DOMAIN_LCK_BIT_TIMEOUT_COUNT;   
80009454:	08 22       	ST.W      [SP + #8], R2
##@@@F_:Clk_LL_GetDomainCtlRegLockStatus():
##@@@P_:kf32a13k_drv_clk.h:1350
##@@@L1345_: *        false: 寄存器未被锁定可以更新   
##@@@L1346_: *        true: 寄存器锁定不可以被更新   
##@@@L1347_: */   
##@@@L1348_:KF_INLINE bool Clk_LL_GetDomainCtlRegLockStatus()   
##@@@L1349_:{   
##@@@L1350_:    return (bool)(CLK_PTR->DOMAIN_CTL.bits.LCKSTA);   
80009456:	35 82       	LD.W      R3, [R5]
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:208
##@@@L0208_:        while (Clk_LL_GetDomainCtlRegLockStatus())   
80009458:	34 70       	CMP       R3, R4
8000945a:	06 fc       	JGT       $+6                   ;->0x80009466
##@@@P_:kf32a13k_hw_clk.c:210
##@@@L0209_:        {   
##@@@L0210_:            CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
8000945c:	08 09       	LD.W      R1, [SP + #8]
8000945e:	49 cc       	SUB       R1, R1, #1
80009460:	10 38       	CMP       R1, #0			;->0x00
80009462:	08 21       	ST.W      [SP + #8], R1
80009464:	f9 fc       	JGT       $-7                   ;->0x80009456
##@@@F_:Clk_LL_SelectSource0ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1282
##@@@L1277_: * @return   
##@@@L1278_: */   
##@@@L1279_:KF_INLINE void Clk_LL_SelectSource0ClockSource(const Clk_DomainClockSource0_t Source0Source)   
##@@@L1280_:{   
##@@@L1281_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source0Source));   
##@@@L1282_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL0, Source0Source);   
80009466:	15 82       	LD.W      R1, [R5]
80009468:	bb 46       	LD        R6, [PC + #187]       ;->0x80009754  :=0xfffffff8
8000946a:	03 26       	ST.W      [SP + #3], R6
8000946c:	16 69       	ANL       R1, R6
8000946e:	51 85       	ST.W      [R5], R1
##@@@F_:Clk_LL_SelectSource1ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1303
##@@@L1298_: * @return   
##@@@L1299_: */   
##@@@L1300_:KF_INLINE void Clk_LL_SelectSource1ClockSource(const Clk_DomainClockSource1_t Source1Source)   
##@@@L1301_:{   
##@@@L1302_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source1Source));   
##@@@L1303_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL1, Source1Source);   
80009470:	15 82       	LD.W      R1, [R5]
80009472:	ba 47       	LD        R7, [PC + #186]       ;->0x80009758  :=0xfffff8ff
80009474:	17 69       	ANL       R1, R7
80009476:	51 85       	ST.W      [R5], R1
80009478:	b9 41       	LD        R1, [PC + #185]       ;->0x8000975c  :=0xfff8ffff
##@@@F_:Clk_LL_SelectSource2ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1338
##@@@L1333_: * @return   
##@@@L1334_: */   
##@@@L1335_:KF_INLINE void Clk_LL_SelectSource2ClockSource(const Clk_DomainClockSource2_t Source2Source)   
##@@@L1336_:{   
##@@@L1337_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source2Source));   
##@@@L1338_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL2, Source2Source);   
8000947a:	65 82       	LD.W      R6, [R5]
##@@@F_:Clk_ConfigPLLInitialStep():
8000947c:	9f 7d       	LSR       R3, #31			;->0x1F
##@@@F_:Clk_LL_SelectSource2ClockSource():
8000947e:	61 69       	ANL       R6, R1
80009480:	56 85       	ST.W      [R5], R6
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:217
##@@@L0212_:        /* PLL配置期间设置fsource0/1/2时钟源为INTHF100*/   
##@@@L0213_:        Clk_LL_SelectSource0ClockSource(CLK_DOMAIN_SOURCE0_INTHF100);   
##@@@L0214_:        Clk_LL_SelectSource1ClockSource(CLK_DOMAIN_SOURCE1_INTHF100);   
##@@@L0215_:        Clk_LL_SelectSource2ClockSource(CLK_DOMAIN_SOURCE2_INTHF100);   
##@@@L0216_:        /* 等待LKSTA清零*/   
##@@@L0217_:        timeoutCycleCount = CLK_DOMAIN_LCK_BIT_TIMEOUT_COUNT;   
80009482:	08 22       	ST.W      [SP + #8], R2
80009484:	91 10       	MOV       R9, #1			;->0x0001
80009486:	05 27       	ST.W      [SP + #5], R7
##@@@F_:Clk_LL_GetDomainCtlRegLockStatus():
##@@@P_:kf32a13k_drv_clk.h:1350
##@@@L1345_: *        false: 寄存器未被锁定可以更新   
##@@@L1346_: *        true: 寄存器锁定不可以被更新   
##@@@L1347_: */   
##@@@L1348_:KF_INLINE bool Clk_LL_GetDomainCtlRegLockStatus()   
##@@@L1349_:{   
##@@@L1350_:    return (bool)(CLK_PTR->DOMAIN_CTL.bits.LCKSTA);   
80009488:	25 82       	LD.W      R2, [R5]
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:218
##@@@L0218_:        while (Clk_LL_GetDomainCtlRegLockStatus())   
8000948a:	24 70       	CMP       R2, R4
8000948c:	07 fc       	JGT       $+7                   ;->0x8000949a
##@@@P_:kf32a13k_hw_clk.c:220
##@@@L0219_:        {   
##@@@L0220_:            CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
8000948e:	08 0a       	LD.W      R2, [SP + #8]
80009490:	52 cc       	SUB       R2, R2, #1
80009492:	20 38       	CMP       R2, #0			;->0x00
80009494:	08 22       	ST.W      [SP + #8], R2
80009496:	f9 fc       	JGT       $-7                   ;->0x80009488
80009498:	02 04       	SJMP      $+2                   ;->0x8000949c
8000949a:	23 59       	MOV       R9, R3
8000949c:	b1 43       	LD        R3, [PC + #177]       ;->0x80009760  :=0xf000f424
##@@@F_:Clk_LL_SetSysPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:1036
##@@@L1031_: *        true: 正常工作模式   
##@@@L1032_: * @retval void   
##@@@L1033_: */   
##@@@L1034_:KF_INLINE void Clk_LL_SetSysPLLLowPowerStatus(const bool Status)   
##@@@L1035_:{   
##@@@L1036_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.PSMOD, Status);   
8000949e:	53 82       	LD.W      R5, [R3]
800094a0:	b1 44       	LD        R4, [PC + #177]       ;->0x80009764  :=0xfeffffff
800094a2:	54 69       	ANL       R5, R4
800094a4:	b1 42       	LD        R2, [PC + #177]       ;->0x80009768  :=0xf000f434
800094a6:	07 23       	ST.W      [SP + #7], R3
800094a8:	35 85       	ST.W      [R3], R5
##@@@F_:Clk_LL_SetPerPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:1189
##@@@L1184_: *        true: 正常工作模式   
##@@@L1185_: * @retval void   
##@@@L1186_: */   
##@@@L1187_:KF_INLINE void Clk_LL_SetPerPLLLowPowerStatus(const bool Status)   
##@@@L1188_:{   
##@@@L1189_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.PSMOD, Status);   
800094aa:	52 82       	LD.W      R5, [R2]
800094ac:	b0 44       	LD        R4, [PC + #176]       ;->0x8000976c  :=0xfffeffff
800094ae:	54 69       	ANL       R5, R4
800094b0:	b0 43       	LD        R3, [PC + #176]       ;->0x80009770  :=0x1f000
800094b2:	06 22       	ST.W      [SP + #6], R2
800094b4:	25 85       	ST.W      [R2], R5
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:230
##@@@L0225_:    /* 配置PLL寄存器前设置PLL模块掉电，以保证异步PLL寄存器更新不会造成毛刺*/   
##@@@L0226_:    Clk_LL_SetSysPLLLowPowerStatus(false);   
##@@@L0227_:    Clk_LL_SetPerPLLLowPowerStatus(false);   
##@@@L0228_:
##@@@L0229_:    /* 等待PLL模块进入节能模式*/   
##@@@L0230_:    timeoutCycleCount = CLK_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;   
800094b6:	08 23       	ST.W      [SP + #8], R3
800094b8:	af 45       	LD        R5, [PC + #175]       ;->0x80009774  :=0xf000f420
800094ba:	82 10       	MOV       R8, #2			;->0x0002
800094bc:	af 46       	LD        R6, [PC + #175]       ;->0x80009778  :=0xf000f430
800094be:	71 10       	MOV       R7, #1			;->0x0001
800094c0:	02 23       	ST.W      [SP + #2], R3
800094c2:	06 04       	SJMP      $+6                   ;->0x800094ce
##@@@P_:kf32a13k_hw_clk.c:233
##@@@L0231_:    while (!Clk_LL_GetSysPLLLowPowerStatus() || !Clk_LL_GetPerPLLLowPowerStatus())   
##@@@L0232_:    {   
##@@@L0233_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
800094c4:	08 0c       	LD.W      R4, [SP + #8]
800094c6:	64 cc       	SUB       R4, R4, #1
800094c8:	40 38       	CMP       R4, #0			;->0x00
800094ca:	08 24       	ST.W      [SP + #8], R4
800094cc:	0a fd       	JLE       $+10                  ;->0x800094e0
##@@@F_:Clk_LL_GetSysPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:945
##@@@L0940_: *        false: 系统 PLL 没有进入节能模式   
##@@@L0941_: *        true: 系统 PLL 进入节能模式   
##@@@L0942_: */   
##@@@L0943_:KF_INLINE bool Clk_LL_GetSysPLLLowPowerStatus()   
##@@@L0944_:{   
##@@@L0945_:    return (bool)(CLK_PTR->SYSPLL_STA.bits.PSSTA);   
800094ce:	45 82       	LD.W      R4, [R5]
800094d0:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:231
##@@@L0226_:    Clk_LL_SetSysPLLLowPowerStatus(false);   
##@@@L0227_:    Clk_LL_SetPerPLLLowPowerStatus(false);   
##@@@L0228_:
##@@@L0229_:    /* 等待PLL模块进入节能模式*/   
##@@@L0230_:    timeoutCycleCount = CLK_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;   
##@@@L0231_:    while (!Clk_LL_GetSysPLLLowPowerStatus() || !Clk_LL_GetPerPLLLowPowerStatus())   
800094d2:	40 38       	CMP       R4, #0			;->0x00
800094d4:	f8 f0       	JZ        $-8                   ;->0x800094c4
##@@@F_:Clk_LL_GetPerPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:1128
##@@@L1123_: *        false: 外设 PLL 没有进入节能模式   
##@@@L1124_: *        true: 外设 PLL 进入节能模式   
##@@@L1125_: */   
##@@@L1126_:KF_INLINE bool Clk_LL_GetPerPLLLowPowerStatus()   
##@@@L1127_:{   
##@@@L1128_:    return (bool)(CLK_PTR->PERPLL_STA.bits.PSSTA);   
800094d6:	46 82       	LD.W      R4, [R6]
800094d8:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:231
800094da:	40 38       	CMP       R4, #0			;->0x00
800094dc:	f4 f0       	JZ        $-12                  ;->0x800094c4
800094de:	02 04       	SJMP      $+2                   ;->0x800094e2
800094e0:	27 59       	MOV       R9, R7
##@@@P_:kf32a13k_hw_clk.c:237
##@@@L0232_:    {   
##@@@L0233_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
##@@@L0234_:    }   
##@@@L0235_:
##@@@L0236_:    /* 时钟源为外部晶振时配置晶振 */   
##@@@L0237_:    if ((PLLInitStepCfg->PLLParameters.PLLInputSource == CLK_PLL_SOURCE_EXTHF) ||   
800094e2:	50 98       	LD.W      R2, [R0 + #1]
800094e4:	62 cc       	SUB       R4, R2, #1
800094e6:	41 38       	CMP       R4, #1			;->0x01
800094e8:	0a f8       	JHI       $+10                  ;->0x800094fc
800094ea:	a5 41       	LD        R1, [PC + #165]       ;->0x8000977c  :=0xf000f400
800094ec:	a1 82       	LD.W      R10, [R1]
800094ee:	a5 44       	LD        R4, [PC + #165]       ;->0x80009780  :=0xffffff9f
800094f0:	a4 69       	ANL       R10, R4
##@@@P_:kf32a13k_hw_clk.c:241
##@@@L0238_:        (PLLInitStepCfg->PLLParameters.PLLInputSource == CLK_PLL_SOURCE_EXTCK))   
##@@@L0239_:    {   
##@@@L0240_:        /* 外部输入时钟模式，OSC 进入节能模式 */   
##@@@L0241_:        if (PLLInitStepCfg->PLLParameters.PLLInputSource == CLK_PLL_SOURCE_EXTCK)   
800094f2:	22 38       	CMP       R2, #2			;->0x02
800094f4:	03 f1       	JNZ       $+3                   ;->0x800094fa
800094f6:	40 14       	MOV       R4, #64			;->0x0040
800094f8:	a4 6a       	ORL       R10, R4
800094fa:	1a 85       	ST.W      [R1], R10
##@@@P_:kf32a13k_hw_clk.c:258
##@@@L0253_:    else   
##@@@L0254_:    {   
##@@@L0255_:    }   
##@@@L0256_:
##@@@L0257_:    /* 选择PLL时钟源 */   
##@@@L0258_:    Clk_LL_SelectPLLClockSource((Clk_PLLClockSource_t)PLLInitStepCfg->PLLParameters.PLLInputSource);   
800094fc:	60 98       	LD.W      R4, [R0 + #1]
800094fe:	07 0b       	LD.W      R3, [SP + #7]
##@@@F_:Clk_LL_SelectPLLClockSource():
##@@@P_:kf32a13k_drv_clk.h:1085
##@@@L1080_: * @return   
##@@@L1081_: */   
##@@@L1082_:KF_INLINE void Clk_LL_SelectPLLClockSource(const Clk_PLLClockSource_t PLLSource)   
##@@@L1083_:{   
##@@@L1084_:    KF_CLK_ASSERT(CHECK_CLK_PLL_CLOCKSOURCE(PLLSource));   
##@@@L1085_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL, PLLSource);   
80009500:	23 82       	LD.W      R2, [R3]
80009502:	a1 41       	LD        R1, [PC + #161]       ;->0x80009784  :=0x3fffffff
80009504:	21 69       	ANL       R2, R1
80009506:	a6 7b       	LSL       R4, #30			;->0x1E
80009508:	24 6a       	ORL       R2, R4
8000950a:	32 85       	ST.W      [R3], R2
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:262
##@@@L0259_:
##@@@L0260_:    /* 使能PLL输入时钟 */   
##@@@L0261_:    {   
##@@@L0262_:        switch (PLLInitStepCfg->PLLParameters.PLLInputSource)   
8000950c:	50 98       	LD.W      R2, [R0 + #1]
8000950e:	62 cc       	SUB       R4, R2, #1
80009510:	42 38       	CMP       R4, #2			;->0x02
80009512:	11 f3       	JNC       $+17                  ;->0x80009534
80009514:	20 38       	CMP       R2, #0			;->0x00
80009516:	1b f0       	JZ        $+27                  ;->0x8000954c
80009518:	23 38       	CMP       R2, #3			;->0x03
8000951a:	18 f1       	JNZ       $+24                  ;->0x8000954a
8000951c:	9b 41       	LD        R1, [PC + #155]       ;->0x80009788  :=0xf000f40c
##@@@F_:Clk_LL_SetClkSysEnabled():
##@@@P_:kf32a13k_drv_clk.h:818
##@@@L0813_: * @retval void   
##@@@L0814_: */   
##@@@L0815_:KF_INLINE void Clk_LL_SetClkSysEnabled(const Clk_ClkSysSetIndex_t Index)   
##@@@L0816_:{   
##@@@L0817_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0818_:    REG_BITS_WRITE(CLK_PTR->CLKSYS_CTL0.reg, (1U << (uint32_t)Index), (1U << (uint32_t)Index));   
8000951e:	71 82       	LD.W      R7, [R1]
80009520:	40 11       	MOV       R4, #16			;->0x0010
80009522:	74 6a       	ORL       R7, R4
80009524:	9a 42       	LD        R2, [PC + #154]       ;->0x8000978c  :=0xf000f418
80009526:	9b 44       	LD        R4, [PC + #155]       ;->0x80009790  :=0x100000
80009528:	17 85       	ST.W      [R1], R7
##@@@F_:Clk_LL_GetClkSysSteadyStatus():
##@@@P_:kf32a13k_drv_clk.h:913
##@@@L0908_: * @retval bool true: 时钟稳定; false: 时钟未稳定   
##@@@L0909_: */   
##@@@L0910_:KF_INLINE bool Clk_LL_GetClkSysSteadyStatus(const Clk_ClkSysSetIndex_t Index)   
##@@@L0911_:{   
##@@@L0912_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0913_:    return (REG_BITS_READ(CLK_PTR->CLKSYS_STA.reg, (1U << ((uint32_t)Index + 16)), ((uint32_t)Index + 16)) != 0U);   
8000952a:	12 82       	LD.W      R1, [R2]
8000952c:	14 69       	ANL       R1, R4
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:277
##@@@L0272_:            break;   
##@@@L0273_:        case CLK_PLL_SOURCE_INTHF32:   
##@@@L0274_:            ClkSource = CLK_CLKSYS_SET_INTHF32;   
##@@@L0275_:            Clk_LL_SetClkSysEnabled(ClkSource);   
##@@@L0276_:            /* 等待时钟稳定 */   
##@@@L0277_:            while (!Clk_LL_GetClkSysSteadyStatus(ClkSource))   
8000952e:	10 38       	CMP       R1, #0			;->0x00
80009530:	fd f0       	JZ        $-3                   ;->0x8000952a
80009532:	0d 04       	SJMP      $+13                  ;->0x8000954c
80009534:	95 41       	LD        R1, [PC + #149]       ;->0x80009788  :=0xf000f40c
##@@@F_:Clk_LL_SetClkSysEnabled():
##@@@P_:kf32a13k_drv_clk.h:818
##@@@L0813_: * @retval void   
##@@@L0814_: */   
##@@@L0815_:KF_INLINE void Clk_LL_SetClkSysEnabled(const Clk_ClkSysSetIndex_t Index)   
##@@@L0816_:{   
##@@@L0817_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0818_:    REG_BITS_WRITE(CLK_PTR->CLKSYS_CTL0.reg, (1U << (uint32_t)Index), (1U << (uint32_t)Index));   
80009536:	a1 82       	LD.W      R10, [R1]
80009538:	a7 6a       	ORL       R10, R7
8000953a:	95 42       	LD        R2, [PC + #149]       ;->0x8000978c  :=0xf000f418
8000953c:	96 44       	LD        R4, [PC + #150]       ;->0x80009794  :=0x10000
8000953e:	1a 85       	ST.W      [R1], R10
##@@@F_:Clk_LL_GetClkSysSteadyStatus():
##@@@P_:kf32a13k_drv_clk.h:913
##@@@L0908_: * @retval bool true: 时钟稳定; false: 时钟未稳定   
##@@@L0909_: */   
##@@@L0910_:KF_INLINE bool Clk_LL_GetClkSysSteadyStatus(const Clk_ClkSysSetIndex_t Index)   
##@@@L0911_:{   
##@@@L0912_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0913_:    return (REG_BITS_READ(CLK_PTR->CLKSYS_STA.reg, (1U << ((uint32_t)Index + 16)), ((uint32_t)Index + 16)) != 0U);   
80009540:	12 82       	LD.W      R1, [R2]
80009542:	14 69       	ANL       R1, R4
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:270
##@@@L0265_:        case CLK_PLL_SOURCE_EXTHF:   
##@@@L0266_:        case CLK_PLL_SOURCE_EXTCK:   
##@@@L0267_:            ClkSource = CLK_CLKSYS_SET_EXTHF;   
##@@@L0268_:            Clk_LL_SetClkSysEnabled(ClkSource);   
##@@@L0269_:            /* 等待时钟稳定 */   
##@@@L0270_:            while (!Clk_LL_GetClkSysSteadyStatus(ClkSource))   
80009544:	10 38       	CMP       R1, #0			;->0x00
80009546:	fd f0       	JZ        $-3                   ;->0x80009540
80009548:	02 04       	SJMP      $+2                   ;->0x8000954c
8000954a:	91 10       	MOV       R9, #1			;->0x0001
8000954c:	8c 44       	LD        R4, [PC + #140]       ;->0x8000977c  :=0xf000f400
##@@@P_:kf32a13k_hw_clk.c:290
##@@@L0285_:            break;   
##@@@L0286_:        }   
##@@@L0287_:    }   
##@@@L0288_:    /*XTAL 范围16MHz - 40MHz*/   
##@@@L0289_:    /* 看门狗监测的参考时钟频率值 */   
##@@@L0290_:    Clk_LL_SetOscWDGRefFrequency(PLLInitStepCfg->PLLParameters.XtalFrequency / 1000000U - 15U);   
8000954e:	20 82       	LD.W      R2, [R0]
##@@@F_:Clk_LL_SetOscWDGRefFrequency():
##@@@P_:kf32a13k_drv_clk.h:609
##@@@L0604_:KF_INLINE void Clk_LL_SetOscWDGRefFrequency(const uint32_t RefFreq)   
##@@@L0605_:{   
##@@@L0606_:    /* EXTHF= (OSCCTL.OSCVAL - 1 + 16) MHz */   
##@@@L0607_:    /* EXTHF范围16MHz~40MHz */   
##@@@L0608_:    KF_CLK_ASSERT(((uint32_t)RefFreq >= 1U) && ((uint32_t)RefFreq <= 25U));   
##@@@L0609_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.OSCVAL, RefFreq);   
80009550:	14 82       	LD.W      R1, [R4]
80009552:	92 47       	LD        R7, [PC + #146]       ;->0x80009798  :=0xf4240
80009554:	92 43       	LD        R3, [PC + #146]       ;->0x8000979c  :=0xffe0ffff
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:290
80009556:	d2 d3       	DIVU      R2, R2, R7
##@@@F_:Clk_LL_SetOscWDGRefFrequency():
##@@@P_:kf32a13k_drv_clk.h:609
80009558:	13 69       	ANL       R1, R3
8000955a:	10 7b       	LSL       R2, #16			;->0x10
8000955c:	91 43       	LD        R3, [PC + #145]       ;->0x800097a0  :=0x110000
8000955e:	92 47       	LD        R7, [PC + #146]       ;->0x800097a4  :=0x1f0000
80009560:	da c2       	ADD       R3, R2, R3
80009562:	37 69       	ANL       R3, R7
80009564:	31 6a       	ORL       R3, R1
80009566:	43 85       	ST.W      [R4], R3
80009568:	90 41       	LD        R1, [PC + #144]       ;->0x800097a8  :=0xffefffff
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:296
##@@@L0291_:
##@@@L0292_:    /* PLL断电状态下不需要重启看门狗（竞品注释） */   
##@@@L0293_:    // Clk_LL_SetOscWatachDogResetStatus(true);   
##@@@L0294_:
##@@@L0295_:    /* 设置系统PLL输入时钟2分频*/   
##@@@L0296_:    Clk_LL_SetSysPLLFreq2DivStatus(PLLInitStepCfg->PLLParameters.SysPLLConfigPtr.InputFreq2Divide);   
8000956a:	18 8d       	LD.B      R3, [R0 + #20]
8000956c:	07 0c       	LD.W      R4, [SP + #7]
##@@@F_:Clk_LL_SetSysPLLFreq2DivStatus():
##@@@P_:kf32a13k_drv_clk.h:1010
##@@@L1005_: *       treu: 输入时钟源2分频   
##@@@L1006_: * @return   
##@@@L1007_: */   
##@@@L1008_:KF_INLINE void Clk_LL_SetSysPLLFreq2DivStatus(const bool Status)   
##@@@L1009_:{   
##@@@L1010_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.PLLDIV, Status);   
8000956e:	24 82       	LD.W      R2, [R4]
80009570:	21 69       	ANL       R2, R1
80009572:	1c 7b       	LSL       R3, #20			;->0x14
80009574:	23 6a       	ORL       R2, R3
80009576:	42 85       	ST.W      [R4], R2
80009578:	20 58       	MOV       R1, R0
8000957a:	04 20       	ST.W      [SP + #4], R0
8000957c:	8c 40       	LD        R0, [PC + #140]       ;->0x800097ac  :=0x3fff
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:300
##@@@L0297_:    /* 设置系统PLL初始值 */   
##@@@L0298_:    {   
##@@@L0299_:        Clk_LL_SetSysPLLMultipleValue(   
##@@@L0300_:          PLLInitStepCfg->PLLParameters.SysPLLConfigPtr.PLLmultiple_M,   
8000957e:	d9 98       	LD.W      R3, [R1 + #3]
80009580:	8c 42       	LD        R2, [PC + #140]       ;->0x800097b0  :=0xffffc000
##@@@P_:kf32a13k_hw_clk.c:301
##@@@L0301_:          PLLInitStepCfg->PLLParameters.SysPLLConfigPtr.PLLdivide_N);   
80009582:	b9 98       	LD.W      R7, [R1 + #2]
##@@@F_:Clk_LL_SetSysPLLMultipleValue():
##@@@P_:kf32a13k_drv_clk.h:995
##@@@L0990_: */   
##@@@L0991_:KF_INLINE void Clk_LL_SetSysPLLMultipleValue(const uint32_t PLLmultiple_M, const uint32_t PLLdivide_N)   
##@@@L0992_:{   
##@@@L0993_:    KF_CLK_ASSERT(CHECK_PLL_MULTIPLE_MValue(PLLmultiple_M));   
##@@@L0994_:    KF_CLK_ASSERT(CHECK_PLL_MULTIPLE_NValue(PLLdivide_N));   
##@@@L0995_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.M, PLLmultiple_M);   
80009584:	14 82       	LD.W      R1, [R4]
80009586:	30 69       	ANL       R3, R0
80009588:	12 69       	ANL       R1, R2
8000958a:	13 6a       	ORL       R1, R3
8000958c:	41 85       	ST.W      [R4], R1
##@@@P_:kf32a13k_drv_clk.h:996
##@@@L0996_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.N, PLLdivide_N);   
8000958e:	38 7b       	LSL       R7, #16			;->0x10
80009590:	89 41       	LD        R1, [PC + #137]       ;->0x800097b4  :=0xf0000
80009592:	8a 43       	LD        R3, [PC + #138]       ;->0x800097b8  :=0xfff0ffff
80009594:	04 58       	MOV       R0, R4
80009596:	24 82       	LD.W      R2, [R4]
80009598:	71 69       	ANL       R7, R1
8000959a:	23 69       	ANL       R2, R3
8000959c:	27 6a       	ORL       R2, R7
8000959e:	42 85       	ST.W      [R4], R2
800095a0:	87 44       	LD        R4, [PC + #135]       ;->0x800097bc  :=0x20000000
##@@@F_:Clk_LL_SetSysPLLReset():
##@@@P_:kf32a13k_drv_clk.h:1068
##@@@L1063_: * @attention 当 PLL 的参考频率 N<3:0>、M<13:0>、PLLDIV变化后都需要初始化PLL，PDRST位自动清零   
##@@@L1064_: * @return   
##@@@L1065_: */   
##@@@L1066_:KF_INLINE void Clk_LL_SetSysPLLReset()   
##@@@L1067_:{   
##@@@L1068_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.PDRST, true);   
800095a2:	30 82       	LD.W      R3, [R0]
800095a4:	34 6a       	ORL       R3, R4
800095a6:	03 85       	ST.W      [R0], R3
800095a8:	86 44       	LD        R4, [PC + #134]       ;->0x800097c0  :=0xfffdffff
800095aa:	04 09       	LD.W      R1, [SP + #4]
##@@@F_:Clk_ConfigPLLInitialStep():
800095ac:	50 00 23 a0 	LD.B      R3, [R1 + #40]			;->0x28
##@@@P_:kf32a13k_hw_clk.c:305
##@@@L0302_:        Clk_LL_SetSysPLLReset();   
##@@@L0303_:    }   
##@@@L0304_:    /* 设置外设PLL输入时钟2分频 */   
##@@@L0305_:    Clk_LL_SetPerPLLFreq2DivStatus(PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.InputFreq2Divide);   
800095b0:	06 08       	LD.W      R0, [SP + #6]
##@@@F_:Clk_LL_SetPerPLLFreq2DivStatus():
##@@@P_:kf32a13k_drv_clk.h:1203
##@@@L1198_: *       true: 输入时钟源2分频   
##@@@L1199_: * @return   
##@@@L1200_: */   
##@@@L1201_:KF_INLINE void Clk_LL_SetPerPLLFreq2DivStatus(const bool Status)   
##@@@L1202_:{   
##@@@L1203_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.PLLDIV, Status);   
800095b2:	20 82       	LD.W      R2, [R0]
800095b4:	24 69       	ANL       R2, R4
800095b6:	19 7b       	LSL       R3, #17			;->0x11
800095b8:	23 6a       	ORL       R2, R3
800095ba:	02 85       	ST.W      [R0], R2
800095bc:	82 44       	LD        R4, [PC + #130]       ;->0x800097c4  :=0xfffffffe
##@@@F_:Clk_ConfigPLLInitialStep():
800095be:	50 00 23 a4 	LD.B      R3, [R1 + #41]			;->0x29
##@@@F_:Clk_LL_SetPerPLLDivBypassStatus():
##@@@P_:kf32a13k_drv_clk.h:1177
##@@@L1172_: *        true: K3 分频器之前的 1.6 分频器被绕过, 经过含有 2 分频器的另一条支路, 进入 K3 分频器之前的频率为 fDCO/2   
##@@@L1173_: * @return   
##@@@L1174_: */   
##@@@L1175_:KF_INLINE void Clk_LL_SetPerPLLDivBypassStatus(const bool Status)   
##@@@L1176_:{   
##@@@L1177_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.DIVBYEN, Status);   
800095c2:	20 82       	LD.W      R2, [R0]
800095c4:	24 69       	ANL       R2, R4
800095c6:	23 6a       	ORL       R2, R3
800095c8:	02 85       	ST.W      [R0], R2
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:311
##@@@L0306_:    /* 设置K3旁路 */   
##@@@L0307_:    Clk_LL_SetPerPLLDivBypassStatus(PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.K3DivBypass);   
##@@@L0308_:    /* 设置外设PLL初始值 */   
##@@@L0309_:    {   
##@@@L0310_:        Clk_LL_SetPerPLLMultipleValue(   
##@@@L0311_:          PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.PLLmultiple_M,   
800095ca:	81 58       	MOV       R4, R1
800095cc:	4c 29       	ADD       R4, #28			;->0x1C
##@@@F_:Clk_LL_SetPerPLLMultipleValue():
##@@@P_:kf32a13k_drv_clk.h:1230
##@@@L1225_:KF_INLINE void Clk_LL_SetPerPLLMultipleValue(const uint32_t PLLmultiple_M, const uint32_t PLLdivide_N)   
##@@@L1226_:{   
##@@@L1227_:    /*TODO: 外设PLL是否与系统PLL要求一致？*/   
##@@@L1228_:    KF_CLK_ASSERT(CHECK_PLL_MULTIPLE_MValue(PLLmultiple_M));   
##@@@L1229_:    KF_CLK_ASSERT(CHECK_PLL_MULTIPLE_NValue(PLLdivide_N));   
##@@@L1230_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.M, PLLmultiple_M);   
800095ce:	a4 ba       	LDP.W     R4, [R4] << #2
800095d0:	7e 43       	LD        R3, [PC + #126]       ;->0x800097c8  :=0xfffc
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:312
##@@@L0312_:          PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.PLLdivide_N);   
800095d2:	b9 99       	LD.W      R7, [R1 + #6]
800095d4:	7e 42       	LD        R2, [PC + #126]       ;->0x800097cc  :=0xffff0003
##@@@F_:Clk_LL_SetPerPLLMultipleValue():
##@@@P_:kf32a13k_drv_clk.h:1230
800095d6:	10 82       	LD.W      R1, [R0]
800095d8:	43 69       	ANL       R4, R3
800095da:	12 69       	ANL       R1, R2
800095dc:	14 6a       	ORL       R1, R4
800095de:	01 85       	ST.W      [R0], R1
##@@@P_:kf32a13k_drv_clk.h:1231
##@@@L1231_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.N, PLLdivide_N);   
800095e0:	b8 7b       	LSL       R7, #24			;->0x18
800095e2:	7c 44       	LD        R4, [PC + #124]       ;->0x800097d0  :=0xf000000
800095e4:	7c 43       	LD        R3, [PC + #124]       ;->0x800097d4  :=0xf0ffffff
800095e6:	20 82       	LD.W      R2, [R0]
800095e8:	74 69       	ANL       R7, R4
800095ea:	23 69       	ANL       R2, R3
800095ec:	27 6a       	ORL       R2, R7
800095ee:	02 85       	ST.W      [R0], R2
800095f0:	7a 42       	LD        R2, [PC + #122]       ;->0x800097d8  :=0x10000000
##@@@F_:Clk_LL_SetPerPLLReset():
##@@@P_:kf32a13k_drv_clk.h:1213
##@@@L1208_: * @attention 当 PLL 的参考频率 N<3:0>、M<13:0>、PLLDIV变化后都需要初始化PLL，PDRST位自动清零   
##@@@L1209_: * @return   
##@@@L1210_: */   
##@@@L1211_:KF_INLINE void Clk_LL_SetPerPLLReset()   
##@@@L1212_:{   
##@@@L1213_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.PDRST, true);   
800095f2:	40 82       	LD.W      R4, [R0]
800095f4:	42 6a       	ORL       R4, R2
800095f6:	04 85       	ST.W      [R0], R4
800095f8:	79 44       	LD        R4, [PC + #121]       ;->0x800097dc  :=0x1000000
800095fa:	07 09       	LD.W      R1, [SP + #7]
##@@@F_:Clk_LL_SetSysPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:1036
##@@@L1031_: *        true: 正常工作模式   
##@@@L1032_: * @retval void   
##@@@L1033_: */   
##@@@L1034_:KF_INLINE void Clk_LL_SetSysPLLLowPowerStatus(const bool Status)   
##@@@L1035_:{   
##@@@L1036_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.PSMOD, Status);   
800095fc:	31 82       	LD.W      R3, [R1]
800095fe:	34 6a       	ORL       R3, R4
80009600:	13 85       	ST.W      [R1], R3
80009602:	65 44       	LD        R4, [PC + #101]       ;->0x80009794  :=0x10000
##@@@F_:Clk_LL_SetPerPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:1189
##@@@L1184_: *        true: 正常工作模式   
##@@@L1185_: * @retval void   
##@@@L1186_: */   
##@@@L1187_:KF_INLINE void Clk_LL_SetPerPLLLowPowerStatus(const bool Status)   
##@@@L1188_:{   
##@@@L1189_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.PSMOD, Status);   
80009604:	30 82       	LD.W      R3, [R0]
80009606:	34 6a       	ORL       R3, R4
80009608:	03 85       	ST.W      [R0], R3
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:319
##@@@L0314_:    }   
##@@@L0315_:    /* 设置系统PLL+外设PLL模块上电 */   
##@@@L0316_:    Clk_LL_SetSysPLLLowPowerStatus(true);   
##@@@L0317_:    Clk_LL_SetPerPLLLowPowerStatus(true);   
##@@@L0318_:
##@@@L0319_:    timeoutCycleCount = CLK_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;   
8000960a:	02 0c       	LD.W      R4, [SP + #2]
8000960c:	08 24       	ST.W      [SP + #8], R4
8000960e:	a1 10       	MOV       R10, #1			;->0x0001
80009610:	05 0b       	LD.W      R3, [SP + #5]
80009612:	06 04       	SJMP      $+6                   ;->0x8000961e
##@@@P_:kf32a13k_hw_clk.c:323
##@@@L0320_:    /* 等待PLL模块退出节能模式*/   
##@@@L0321_:    while (Clk_LL_GetSysPLLLowPowerStatus() || Clk_LL_GetPerPLLLowPowerStatus())   
##@@@L0322_:    {   
##@@@L0323_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009614:	08 0c       	LD.W      R4, [SP + #8]
80009616:	64 cc       	SUB       R4, R4, #1
80009618:	40 38       	CMP       R4, #0			;->0x00
8000961a:	08 24       	ST.W      [SP + #8], R4
8000961c:	0a fd       	JLE       $+10                  ;->0x80009630
##@@@F_:Clk_LL_GetSysPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:945
##@@@L0940_: *        false: 系统 PLL 没有进入节能模式   
##@@@L0941_: *        true: 系统 PLL 进入节能模式   
##@@@L0942_: */   
##@@@L0943_:KF_INLINE bool Clk_LL_GetSysPLLLowPowerStatus()   
##@@@L0944_:{   
##@@@L0945_:    return (bool)(CLK_PTR->SYSPLL_STA.bits.PSSTA);   
8000961e:	45 82       	LD.W      R4, [R5]
80009620:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:321
##@@@L0316_:    Clk_LL_SetSysPLLLowPowerStatus(true);   
##@@@L0317_:    Clk_LL_SetPerPLLLowPowerStatus(true);   
##@@@L0318_:
##@@@L0319_:    timeoutCycleCount = CLK_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;   
##@@@L0320_:    /* 等待PLL模块退出节能模式*/   
##@@@L0321_:    while (Clk_LL_GetSysPLLLowPowerStatus() || Clk_LL_GetPerPLLLowPowerStatus())   
80009622:	40 38       	CMP       R4, #0			;->0x00
80009624:	f8 f1       	JNZ       $-8                   ;->0x80009614
##@@@F_:Clk_LL_GetPerPLLLowPowerStatus():
##@@@P_:kf32a13k_drv_clk.h:1128
##@@@L1123_: *        false: 外设 PLL 没有进入节能模式   
##@@@L1124_: *        true: 外设 PLL 进入节能模式   
##@@@L1125_: */   
##@@@L1126_:KF_INLINE bool Clk_LL_GetPerPLLLowPowerStatus()   
##@@@L1127_:{   
##@@@L1128_:    return (bool)(CLK_PTR->PERPLL_STA.bits.PSSTA);   
80009626:	46 82       	LD.W      R4, [R6]
80009628:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:321
8000962a:	40 38       	CMP       R4, #0			;->0x00
8000962c:	f4 f1       	JNZ       $-12                  ;->0x80009614
8000962e:	49 59       	MOV       R10, R9
80009630:	04 08       	LD.W      R0, [SP + #4]
80009632:	6c 44       	LD        R4, [PC + #108]       ;->0x800097e0  :=0x6000
##@@@P_:kf32a13k_hw_clk.c:327
##@@@L0322_:    {   
##@@@L0323_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
##@@@L0324_:    }   
##@@@L0325_:
##@@@L0326_:    /* 等待K2、K3分频器就绪*/   
##@@@L0327_:    timeoutCycleCount = CLK_PLL_KRDY_TIMEOUT_COUNT;   
80009634:	08 24       	ST.W      [SP + #8], R4
80009636:	80 12       	MOV       R8, #32			;->0x0020
80009638:	b1 10       	MOV       R11, #1			;->0x0001
8000963a:	90 11       	MOV       R9, #16			;->0x0010
8000963c:	01 22       	ST.W      [SP + #1], R2
8000963e:	06 04       	SJMP      $+6                   ;->0x8000964a
##@@@P_:kf32a13k_hw_clk.c:330
##@@@L0328_:    while (!Clk_LL_GetSysPLLK2Status() || !Clk_LL_GetPerPLLK2Status() || !Clk_LL_GetPerPLLK3Status())   
##@@@L0329_:    {   
##@@@L0330_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009640:	08 0c       	LD.W      R4, [SP + #8]
80009642:	64 cc       	SUB       R4, R4, #1
80009644:	40 38       	CMP       R4, #0			;->0x00
80009646:	08 24       	ST.W      [SP + #8], R4
80009648:	0e fd       	JLE       $+14                  ;->0x80009664
##@@@F_:Clk_LL_GetSysPLLK2Status():
##@@@P_:kf32a13k_drv_clk.h:967
##@@@L0962_: *        false: K2 分频器没有以一个新的值工作   
##@@@L0963_: *        true: K2 分频器以一个新的值工作   
##@@@L0964_: */   
##@@@L0965_:KF_INLINE bool Clk_LL_GetSysPLLK2Status()   
##@@@L0966_:{   
##@@@L0967_:    return (bool)(CLK_PTR->SYSPLL_STA.bits.K2RDYSTA);   
8000964a:	45 82       	LD.W      R4, [R5]
8000964c:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:328
##@@@L0323_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
##@@@L0324_:    }   
##@@@L0325_:
##@@@L0326_:    /* 等待K2、K3分频器就绪*/   
##@@@L0327_:    timeoutCycleCount = CLK_PLL_KRDY_TIMEOUT_COUNT;   
##@@@L0328_:    while (!Clk_LL_GetSysPLLK2Status() || !Clk_LL_GetPerPLLK2Status() || !Clk_LL_GetPerPLLK3Status())   
8000964e:	40 38       	CMP       R4, #0			;->0x00
80009650:	f8 f0       	JZ        $-8                   ;->0x80009640
##@@@F_:Clk_LL_GetPerPLLK2Status():
##@@@P_:kf32a13k_drv_clk.h:1150
##@@@L1145_: *        false: K2 分频器没有以一个新的值工作   
##@@@L1146_: *        true: K2 分频器以一个新的值工作   
##@@@L1147_: */   
##@@@L1148_:KF_INLINE bool Clk_LL_GetPerPLLK2Status()   
##@@@L1149_:{   
##@@@L1150_:    return (bool)(CLK_PTR->PERPLL_STA.bits.K2RDYSTA);   
80009652:	46 82       	LD.W      R4, [R6]
80009654:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:328
80009656:	40 38       	CMP       R4, #0			;->0x00
80009658:	f4 f0       	JZ        $-12                  ;->0x80009640
##@@@F_:Clk_LL_GetPerPLLK3Status():
##@@@P_:kf32a13k_drv_clk.h:1161
##@@@L1156_: *        false: K3 分频器没有以一个新的值工作   
##@@@L1157_: *        true: K3 分频器以一个新的值工作   
##@@@L1158_: */   
##@@@L1159_:KF_INLINE bool Clk_LL_GetPerPLLK3Status()   
##@@@L1160_:{   
##@@@L1161_:    return (bool)(CLK_PTR->PERPLL_STA.bits.K3RDYSTA);   
8000965a:	46 82       	LD.W      R4, [R6]
8000965c:	49 69       	ANL       R4, R9
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:328
8000965e:	40 38       	CMP       R4, #0			;->0x00
80009660:	f0 f0       	JZ        $-16                  ;->0x80009640
80009662:	6a 59       	MOV       R11, R10
##@@@P_:kf32a13k_hw_clk.c:332
##@@@L0329_:    {   
##@@@L0330_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
##@@@L0331_:    }   
##@@@L0332_:    Clk_LL_SetSysPLLK2Value(PLLInitStepCfg->PLLParameters.SysPLLConfigPtr.PLLdivide_K2);   
80009664:	20 99       	LD.W      R4, [R0 + #4]
80009666:	60 43       	LD        R3, [PC + #96]        ;->0x800097e4  :=0xf000f428
80009668:	17 10       	MOV       R1, #7			;->0x0007
##@@@F_:Clk_LL_SetSysPLLK2Value():
##@@@P_:kf32a13k_drv_clk.h:1100
##@@@L1095_: * @return   
##@@@L1096_: */   
##@@@L1097_:KF_INLINE void Clk_LL_SetSysPLLK2Value(const uint32_t PLLdivide_K2)   
##@@@L1098_:{   
##@@@L1099_:    KF_CLK_ASSERT(CHECK_PLL_MULTIPLE_K2Value(PLLdivide_K2));   
##@@@L1100_:    REG_WRITE(CLK_PTR->SYSPLL_CTL1.bits.K2CLKDIV, PLLdivide_K2);   
8000966a:	23 82       	LD.W      R2, [R3]
8000966c:	41 69       	ANL       R4, R1
8000966e:	03 0f       	LD.W      R7, [SP + #3]
80009670:	27 69       	ANL       R2, R7
80009672:	24 6a       	ORL       R2, R4
80009674:	32 85       	ST.W      [R3], R2
80009676:	5d 42       	LD        R2, [PC + #93]        ;->0x800097e8  :=0xf000f438
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:333
##@@@L0333_:    Clk_LL_SetPerPLL1K2Value(PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.PLLdivide_K2);   
80009678:	20 9a       	LD.W      R4, [R0 + #8]
##@@@F_:Clk_LL_SetPerPLL1K2Value():
##@@@P_:kf32a13k_drv_clk.h:1246
##@@@L1241_: * @return   
##@@@L1242_: */   
##@@@L1243_:KF_INLINE void Clk_LL_SetPerPLL1K2Value(const uint32_t PLLdivide_K2)   
##@@@L1244_:{   
##@@@L1245_:    KF_CLK_ASSERT(CHECK_PLL_MULTIPLE_K2Value(PLLdivide_K2));   
##@@@L1246_:    REG_WRITE(CLK_PTR->PERPLL_CTL1.bits.K2CLKDIV, PLLdivide_K2);   
8000967a:	32 82       	LD.W      R3, [R2]
8000967c:	41 69       	ANL       R4, R1
8000967e:	37 69       	ANL       R3, R7
80009680:	34 6a       	ORL       R3, R4
80009682:	23 85       	ST.W      [R2], R3
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:334
##@@@L0334_:    Clk_LL_SetPerPLL2K3Value(PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.PLLdivide_K3);   
80009684:	60 9a       	LD.W      R4, [R0 + #9]
##@@@F_:Clk_LL_SetPerPLL2K3Value():
##@@@P_:kf32a13k_drv_clk.h:1259
##@@@L1254_: * @return   
##@@@L1255_: */   
##@@@L1256_:KF_INLINE void Clk_LL_SetPerPLL2K3Value(const uint32_t PLLmultiple_K3)   
##@@@L1257_:{   
##@@@L1258_:    KF_CLK_ASSERT(CHECK_PLL_MULTIPLE_K3Value(PLLmultiple_K3));   
##@@@L1259_:    REG_WRITE(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV, PLLmultiple_K3);   
80009686:	a0 7a       	LSL       R4, #8			;->0x08
80009688:	59 43       	LD        R3, [PC + #89]        ;->0x800097ec  :=0x700
8000968a:	12 82       	LD.W      R1, [R2]
8000968c:	43 69       	ANL       R4, R3
8000968e:	05 0b       	LD.W      R3, [SP + #5]
80009690:	13 69       	ANL       R1, R3
80009692:	14 6a       	ORL       R1, R4
80009694:	21 85       	ST.W      [R2], R1
80009696:	11 10       	MOV       R1, #1			;->0x0001
80009698:	06 04       	SJMP      $+6                   ;->0x800096a4
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:337
##@@@L0335_:    while (!Clk_LL_GetSysPLLK2Status() || !Clk_LL_GetPerPLLK2Status() || !Clk_LL_GetPerPLLK3Status())   
##@@@L0336_:    {   
##@@@L0337_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
8000969a:	08 0c       	LD.W      R4, [SP + #8]
8000969c:	64 cc       	SUB       R4, R4, #1
8000969e:	40 38       	CMP       R4, #0			;->0x00
800096a0:	08 24       	ST.W      [SP + #8], R4
800096a2:	0e fd       	JLE       $+14                  ;->0x800096be
##@@@F_:Clk_LL_GetSysPLLK2Status():
##@@@P_:kf32a13k_drv_clk.h:967
##@@@L0962_: *        false: K2 分频器没有以一个新的值工作   
##@@@L0963_: *        true: K2 分频器以一个新的值工作   
##@@@L0964_: */   
##@@@L0965_:KF_INLINE bool Clk_LL_GetSysPLLK2Status()   
##@@@L0966_:{   
##@@@L0967_:    return (bool)(CLK_PTR->SYSPLL_STA.bits.K2RDYSTA);   
800096a4:	45 82       	LD.W      R4, [R5]
800096a6:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:335
##@@@L0330_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
##@@@L0331_:    }   
##@@@L0332_:    Clk_LL_SetSysPLLK2Value(PLLInitStepCfg->PLLParameters.SysPLLConfigPtr.PLLdivide_K2);   
##@@@L0333_:    Clk_LL_SetPerPLL1K2Value(PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.PLLdivide_K2);   
##@@@L0334_:    Clk_LL_SetPerPLL2K3Value(PLLInitStepCfg->PLLParameters.PeriPLLConfigPtr.PLLdivide_K3);   
##@@@L0335_:    while (!Clk_LL_GetSysPLLK2Status() || !Clk_LL_GetPerPLLK2Status() || !Clk_LL_GetPerPLLK3Status())   
800096a8:	40 38       	CMP       R4, #0			;->0x00
800096aa:	f8 f0       	JZ        $-8                   ;->0x8000969a
##@@@F_:Clk_LL_GetPerPLLK2Status():
##@@@P_:kf32a13k_drv_clk.h:1150
##@@@L1145_: *        false: K2 分频器没有以一个新的值工作   
##@@@L1146_: *        true: K2 分频器以一个新的值工作   
##@@@L1147_: */   
##@@@L1148_:KF_INLINE bool Clk_LL_GetPerPLLK2Status()   
##@@@L1149_:{   
##@@@L1150_:    return (bool)(CLK_PTR->PERPLL_STA.bits.K2RDYSTA);   
800096ac:	46 82       	LD.W      R4, [R6]
800096ae:	48 69       	ANL       R4, R8
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:335
800096b0:	40 38       	CMP       R4, #0			;->0x00
800096b2:	f4 f0       	JZ        $-12                  ;->0x8000969a
##@@@F_:Clk_LL_GetPerPLLK3Status():
##@@@P_:kf32a13k_drv_clk.h:1161
##@@@L1156_: *        false: K3 分频器没有以一个新的值工作   
##@@@L1157_: *        true: K3 分频器以一个新的值工作   
##@@@L1158_: */   
##@@@L1159_:KF_INLINE bool Clk_LL_GetPerPLLK3Status()   
##@@@L1160_:{   
##@@@L1161_:    return (bool)(CLK_PTR->PERPLL_STA.bits.K3RDYSTA);   
800096b4:	46 82       	LD.W      R4, [R6]
800096b6:	49 69       	ANL       R4, R9
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:335
800096b8:	40 38       	CMP       R4, #0			;->0x00
800096ba:	f0 f0       	JZ        $-16                  ;->0x8000969a
800096bc:	02 04       	SJMP      $+2                   ;->0x800096c0
800096be:	61 59       	MOV       R11, R1
800096c0:	32 42       	LD        R2, [PC + #50]        ;->0x80009788  :=0xf000f40c
##@@@F_:Clk_LL_SetClkSysEnabled():
##@@@P_:kf32a13k_drv_clk.h:818
##@@@L0813_: * @retval void   
##@@@L0814_: */   
##@@@L0815_:KF_INLINE void Clk_LL_SetClkSysEnabled(const Clk_ClkSysSetIndex_t Index)   
##@@@L0816_:{   
##@@@L0817_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0818_:    REG_BITS_WRITE(CLK_PTR->CLKSYS_CTL0.reg, (1U << (uint32_t)Index), (1U << (uint32_t)Index));   
800096c2:	42 82       	LD.W      R4, [R2]
800096c4:	64 10       	MOV       R6, #4			;->0x0004
800096c6:	46 6a       	ORL       R4, R6
800096c8:	31 47       	LD        R7, [PC + #49]        ;->0x8000978c  :=0xf000f418
800096ca:	4a 40       	LD        R0, [PC + #74]        ;->0x800097f0  :=0x40000
800096cc:	24 85       	ST.W      [R2], R4
##@@@F_:Clk_LL_GetClkSysSteadyStatus():
##@@@P_:kf32a13k_drv_clk.h:913
##@@@L0908_: * @retval bool true: 时钟稳定; false: 时钟未稳定   
##@@@L0909_: */   
##@@@L0910_:KF_INLINE bool Clk_LL_GetClkSysSteadyStatus(const Clk_ClkSysSetIndex_t Index)   
##@@@L0911_:{   
##@@@L0912_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0913_:    return (REG_BITS_READ(CLK_PTR->CLKSYS_STA.reg, (1U << ((uint32_t)Index + 16)), ((uint32_t)Index + 16)) != 0U);   
800096ce:	47 82       	LD.W      R4, [R7]
800096d0:	40 69       	ANL       R4, R0
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:343
##@@@L0338_:    }   
##@@@L0339_:
##@@@L0340_:    /* 使能系统PLL*/   
##@@@L0341_:    Clk_LL_SetClkSysEnabled(CLK_CLKSYS_SET_SYSPLL);   
##@@@L0342_:    /* 等待时钟稳定 */   
##@@@L0343_:    while (!Clk_LL_GetClkSysSteadyStatus(CLK_CLKSYS_SET_SYSPLL))   
800096d2:	40 38       	CMP       R4, #0			;->0x00
800096d4:	fd f0       	JZ        $-3                   ;->0x800096ce
##@@@F_:Clk_LL_SetClkSysEnabled():
##@@@P_:kf32a13k_drv_clk.h:818
##@@@L0813_: * @retval void   
##@@@L0814_: */   
##@@@L0815_:KF_INLINE void Clk_LL_SetClkSysEnabled(const Clk_ClkSysSetIndex_t Index)   
##@@@L0816_:{   
##@@@L0817_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0818_:    REG_BITS_WRITE(CLK_PTR->CLKSYS_CTL0.reg, (1U << (uint32_t)Index), (1U << (uint32_t)Index));   
800096d6:	32 82       	LD.W      R3, [R2]
800096d8:	48 10       	MOV       R4, #8			;->0x0008
800096da:	34 6a       	ORL       R3, R4
800096dc:	46 44       	LD        R4, [PC + #70]        ;->0x800097f4  :=0x80000
800096de:	23 85       	ST.W      [R2], R3
##@@@F_:Clk_LL_GetClkSysSteadyStatus():
##@@@P_:kf32a13k_drv_clk.h:913
##@@@L0908_: * @retval bool true: 时钟稳定; false: 时钟未稳定   
##@@@L0909_: */   
##@@@L0910_:KF_INLINE bool Clk_LL_GetClkSysSteadyStatus(const Clk_ClkSysSetIndex_t Index)   
##@@@L0911_:{   
##@@@L0912_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0913_:    return (REG_BITS_READ(CLK_PTR->CLKSYS_STA.reg, (1U << ((uint32_t)Index + 16)), ((uint32_t)Index + 16)) != 0U);   
800096e0:	37 82       	LD.W      R3, [R7]
800096e2:	34 69       	ANL       R3, R4
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:348
##@@@L0344_:        ;   
##@@@L0345_:    /* 使能外设PLL*/   
##@@@L0346_:    Clk_LL_SetClkSysEnabled(CLK_CLKSYS_SET_PERPLL);   
##@@@L0347_:    /* 等待时钟稳定 */   
##@@@L0348_:    while (!Clk_LL_GetClkSysSteadyStatus(CLK_CLKSYS_SET_PERPLL))   
800096e4:	30 38       	CMP       R3, #0			;->0x00
800096e6:	fd f0       	JZ        $-3                   ;->0x800096e0
800096e8:	44 44       	LD        R4, [PC + #68]        ;->0x800097f8  :=0x493e0
800096ea:	45 42       	LD        R2, [PC + #69]        ;->0x800097fc  :=0xf000f408
##@@@P_:kf32a13k_hw_clk.c:352
##@@@L0349_:        ;   
##@@@L0350_:
##@@@L0351_:    /* 检查EXTHF频率是否处于上下限范围内，由看门狗使用 INTHF100 进行检查*/   
##@@@L0352_:    timeoutCycleCount = CLK_PLL_LOW_OR_HIGH_TIMEOUT_COUNT;   
800096ec:	08 24       	ST.W      [SP + #8], R4
##@@@F_:Clk_LL_GetXTHFlag():
##@@@P_:kf32a13k_drv_clk.h:799
##@@@L0794_: * @retval bool OSC频率可用状态   
##@@@L0795_: */   
##@@@L0796_:KF_INLINE bool Clk_LL_GetXTHFlag(const Clk_XTHFlagGetIndex_t Index)   
##@@@L0797_:{   
##@@@L0798_:    KF_CLK_ASSERT(CHECK_CLK_XTHFLAG_GET(Index));   
##@@@L0799_:    return (REG_BITS_READ(CLK_PTR->OSC_STA.reg, (1U << (uint32_t)Index), (uint32_t)Index) != 0U);   
800096ee:	42 82       	LD.W      R4, [R2]
800096f0:	41 69       	ANL       R4, R1
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:356
##@@@L0353_:    /* fLV = foscnom * 0.75 - 0.31 MHz */   
##@@@L0354_:    /* fHV = foscnom * 1.86 + 0.21 MHz */   
##@@@L0355_:    /* 竞品逻辑：只要有一个处于范围内，就认为检查通过*/   
##@@@L0356_:    while (!Clk_LL_GetXTHFlag(CLK_XTH_GET_PLLLSTA) && !Clk_LL_GetXTHFlag(CLK_XTH_GET_PLLLSTA))   
800096f2:	40 38       	CMP       R4, #0			;->0x00
800096f4:	0b f1       	JNZ       $+11                  ;->0x8000970a
##@@@F_:Clk_LL_GetXTHFlag():
##@@@P_:kf32a13k_drv_clk.h:799
800096f6:	42 82       	LD.W      R4, [R2]
800096f8:	41 69       	ANL       R4, R1
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:356
800096fa:	40 38       	CMP       R4, #0			;->0x00
800096fc:	07 f1       	JNZ       $+7                   ;->0x8000970a
##@@@P_:kf32a13k_hw_clk.c:358
##@@@L0357_:    {   
##@@@L0358_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
800096fe:	08 0c       	LD.W      R4, [SP + #8]
80009700:	64 cc       	SUB       R4, R4, #1
80009702:	40 38       	CMP       R4, #0			;->0x00
80009704:	08 24       	ST.W      [SP + #8], R4
80009706:	f4 fc       	JGT       $-12                  ;->0x800096ee
80009708:	02 04       	SJMP      $+2                   ;->0x8000970c
8000970a:	2b 58       	MOV       R1, R11
8000970c:	01 0a       	LD.W      R2, [SP + #1]
8000970e:	07 0b       	LD.W      R3, [SP + #7]
##@@@F_:Clk_LL_ResetSysPLLDCO():
##@@@P_:kf32a13k_drv_clk.h:1047
##@@@L1042_: *        false:   
##@@@L1043_: *        true:   
##@@@L1044_: */   
##@@@L1045_:KF_INLINE void Clk_LL_ResetSysPLLDCO(const bool Status)   
##@@@L1046_:{   
##@@@L1047_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.DCOLDRST, Status);   
80009710:	43 82       	LD.W      R4, [R3]
80009712:	42 6a       	ORL       R4, R2
80009714:	34 85       	ST.W      [R3], R4
80009716:	06 0a       	LD.W      R2, [SP + #6]
##@@@F_:Clk_LL_ResetPerPLLDCO():
##@@@P_:kf32a13k_drv_clk.h:1058
##@@@L1053_: *        false:   
##@@@L1054_: *        true:   
##@@@L1055_: */   
##@@@L1056_:KF_INLINE void Clk_LL_ResetPerPLLDCO(const bool Status)   
##@@@L1057_:{   
##@@@L1058_:    REG_WRITE(CLK_PTR->PERPLL_CTL0.bits.RESLD, Status);   
80009718:	42 82       	LD.W      R4, [R2]
8000971a:	40 6a       	ORL       R4, R0
8000971c:	39 43       	LD        R3, [PC + #57]        ;->0x80009800  :=0x3000
8000971e:	24 85       	ST.W      [R2], R4
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:364
##@@@L0359_:    }   
##@@@L0360_:    /* 开启PLL锁定*/   
##@@@L0361_:    {   
##@@@L0362_:        Clk_LL_ResetSysPLLDCO(true);   
##@@@L0363_:        Clk_LL_ResetPerPLLDCO(true);   
##@@@L0364_:        timeoutCycleCount = CLK_PLL_LOCK_TIMEOUT_COUNT;   
80009720:	08 23       	ST.W      [SP + #8], R3
80009722:	01 10       	MOV       R0, #1			;->0x0001
80009724:	06 04       	SJMP      $+6                   ;->0x80009730
##@@@P_:kf32a13k_hw_clk.c:367
##@@@L0365_:        while (!Clk_LL_GetSysPLLLockStatus() || !Clk_LL_GetPerPLLLockStatus())   
##@@@L0366_:        {   
##@@@L0367_:            CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009726:	08 0c       	LD.W      R4, [SP + #8]
80009728:	64 cc       	SUB       R4, R4, #1
8000972a:	40 38       	CMP       R4, #0			;->0x00
8000972c:	08 24       	ST.W      [SP + #8], R4
8000972e:	0a fd       	JLE       $+10                  ;->0x80009742
##@@@F_:Clk_LL_GetSysPLLLockStatus():
##@@@P_:kf32a13k_drv_clk.h:956
##@@@L0951_: *        false: 系统 PLL 频率不稳定   
##@@@L0952_: *        true: 系统 PLL 频率稳定   
##@@@L0953_: */   
##@@@L0954_:KF_INLINE bool Clk_LL_GetSysPLLLockStatus()   
##@@@L0955_:{   
##@@@L0956_:    return (bool)(CLK_PTR->SYSPLL_STA.bits.LOCKSTA);   
80009730:	45 82       	LD.W      R4, [R5]
80009732:	46 69       	ANL       R4, R6
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:365
##@@@L0360_:    /* 开启PLL锁定*/   
##@@@L0361_:    {   
##@@@L0362_:        Clk_LL_ResetSysPLLDCO(true);   
##@@@L0363_:        Clk_LL_ResetPerPLLDCO(true);   
##@@@L0364_:        timeoutCycleCount = CLK_PLL_LOCK_TIMEOUT_COUNT;   
##@@@L0365_:        while (!Clk_LL_GetSysPLLLockStatus() || !Clk_LL_GetPerPLLLockStatus())   
80009734:	40 38       	CMP       R4, #0			;->0x00
80009736:	f8 f0       	JZ        $-8                   ;->0x80009726
##@@@F_:Clk_LL_GetPerPLLLockStatus():
##@@@P_:kf32a13k_drv_clk.h:1139
##@@@L1134_: *        false: 外设 PLL 频率不稳定   
##@@@L1135_: *        true: 外设 PLL 频率稳定   
##@@@L1136_: */   
##@@@L1137_:KF_INLINE bool Clk_LL_GetPerPLLLockStatus()   
##@@@L1138_:{   
##@@@L1139_:    return (bool)(CLK_PTR->SYSPLL_STA.bits.LOCKSTA);   
80009738:	45 82       	LD.W      R4, [R5]
8000973a:	46 69       	ANL       R4, R6
##@@@F_:Clk_ConfigPLLInitialStep():
##@@@P_:kf32a13k_hw_clk.c:365
8000973c:	40 38       	CMP       R4, #0			;->0x00
8000973e:	f4 f0       	JZ        $-12                  ;->0x80009726
80009740:	01 58       	MOV       R0, R1
##@@@P_:kf32a13k_hw_clk.c:371
##@@@L0366_:        {   
##@@@L0367_:            CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
##@@@L0368_:        }   
##@@@L0369_:    }   
##@@@L0370_:    /* TODO: 使能SMU报警*/   
##@@@L0371_:    return (bool)initError;   
80009742:	e4 2a       	ADD       SP, #36			;->0x24
80009744:	3f 5e       	POP       {R6-R11}
80009746:	1d 5c       	JMP       LR
80009748:	00 10 00 00 	.long     0x00001000 ->000004096  [!!!@2@:MOV       R0, #0	@@: NOP      
8000974c:	3c f4 00 f0 	.long     0xf000f43c ->-268372932  [!!!@2@:JMI       $+60                  ;->0x800097c4	@@: JZ        $+0                   ;->0x8000974c
80009750:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80009754:	f8 ff ff ff 	.long     0xfffffff8 ->-00000008 
80009758:	ff f8 ff ff 	.long     0xfffff8ff ->-00001793 
8000975c:	ff ff f8 ff 	.long     0xfff8ffff ->-00458753 
80009760:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x800097a8	@@: JZ        $+0                   ;->0x80009760
80009764:	ff ff ff fe 	.long     0xfeffffff ->-16777217 
80009768:	34 f4 00 f0 	.long     0xf000f434 ->-268372940  [!!!@2@:JMI       $+52                  ;->0x800097d0	@@: JZ        $+0                   ;->0x80009768
8000976c:	ff ff fe ff 	.long     0xfffeffff ->-00065537 
80009770:	00 f0 01 00 	.long     0x0001f000 ->000126976  [!!!@2@:JZ        $+0                   ;->0x80009770	@@: .short    0x0001
80009774:	20 f4 00 f0 	.long     0xf000f420 ->-268372960  [!!!@2@:JMI       $+32                  ;->0x800097b4	@@: JZ        $+0                   ;->0x80009774
80009778:	30 f4 00 f0 	.long     0xf000f430 ->-268372944  [!!!@2@:JMI       $+48                  ;->0x800097d8	@@: JZ        $+0                   ;->0x80009778
8000977c:	00 f4 00 f0 	.long     0xf000f400 ->-268372992  [!!!@2@:JMI       $+0                   ;->0x8000977c	@@: JZ        $+0                   ;->0x8000977c
80009780:	9f ff ff ff 	.long     0xffffff9f ->-00000097 
80009784:	ff ff ff 3f 	.long     0x3fffffff ->1073741823 
80009788:	0c f4 00 f0 	.long     0xf000f40c ->-268372980  [!!!@2@:JMI       $+12                  ;->0x800097a0	@@: JZ        $+0                   ;->0x80009788
8000978c:	18 f4 00 f0 	.long     0xf000f418 ->-268372968  [!!!@2@:JMI       $+24                  ;->0x800097bc	@@: JZ        $+0                   ;->0x8000978c
80009790:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16
80009794:	00 00 01 00 	.long     0x00010000 ->000065536  [!!!@2@:NOP      	@@: .short    0x0001
80009798:	40 42 0f 00 	.long     0x000f4240 ->001000000 
8000979c:	ff ff e0 ff 	.long     0xffe0ffff ->-02031617 
800097a0:	00 00 11 00 	.long     0x00110000 ->001114112  [!!!@2@:NOP      	@@: DMACF16LL ACC0, ACC0, R0, R17
800097a4:	00 00 1f 00 	.long     0x001f0000 ->002031616  [!!!@2@:NOP      	@@: FST.W           [R31++], S0
800097a8:	ff ff ef ff 	.long     0xffefffff ->-01048577 
800097ac:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
800097b0:	00 c0 ff ff 	.long     0xffffc000 ->-00016384 
800097b4:	00 00 0f 00 	.long     0x000f0000 ->000983040 
800097b8:	ff ff f0 ff 	.long     0xfff0ffff ->-00983041 
800097bc:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
800097c0:	ff ff fd ff 	.long     0xfffdffff ->-00131073 
800097c4:	fe ff ff ff 	.long     0xfffffffe ->-00000002 
800097c8:	fc ff 00 00 	.long     0x0000fffc ->000065532 
800097cc:	03 00 ff ff 	.long     0xffff0003 ->-00065533 
800097d0:	00 00 00 0f 	.long     0x0f000000 ->251658240  [!!!@2@:NOP      	@@: LD.W      R7, [SP + #0]
800097d4:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
800097d8:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
800097dc:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
800097e0:	00 60 00 00 	.long     0x00006000 ->000024576  [!!!@2@:REV       R0, R0	@@: NOP      
800097e4:	28 f4 00 f0 	.long     0xf000f428 ->-268372952  [!!!@2@:JMI       $+40                  ;->0x80009834	@@: JZ        $+0                   ;->0x800097e4
800097e8:	38 f4 00 f0 	.long     0xf000f438 ->-268372936  [!!!@2@:JMI       $+56                  ;->0x80009858	@@: JZ        $+0                   ;->0x800097e8
800097ec:	00 07 00 00 	.long     0x00000700 ->000001792  [!!!@2@:SJMP      $-256                 ;->0x800095ec	@@: NOP      
800097f0:	00 00 04 00 	.long     0x00040000 ->000262144 
800097f4:	00 00 08 00 	.long     0x00080000 ->000524288  [!!!@2@:NOP      	@@: SYNC     
800097f8:	e0 93 04 00 	.long     0x000493e0 ->000300000 
800097fc:	08 f4 00 f0 	.long     0xf000f408 ->-268372984  [!!!@2@:JMI       $+8                   ;->0x8000980c	@@: JZ        $+0                   ;->0x800097fc
80009800:	00 30 00 00 	.long     0x00003000 ->000012288  [!!!@2@:SUB       R0, #0	@@: NOP      

80009804 <Clk_ConfigDomainClockSource>:
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:391
##@@@L0386_: *   
##@@@L0387_: * @param DomainClockConfigPtr   
##@@@L0388_: * @return KF_INLINE   
##@@@L0389_: */   
##@@@L0390_:bool Clk_ConfigDomainClockSource(const Clk_DomainClockConfig_t *DomainClockConfigPtr)   
##@@@L0391_:{   
80009804:	e8 30       	SUB       SP, #8			;->0x08
80009806:	19 45       	LD        R5, [PC + #25]        ;->0x80009868  :=0x1000
##@@@P_:kf32a13k_hw_clk.c:394
##@@@L0392_:    bool initError = false;   
##@@@L0393_:    /* 超时时间，防止编译器优化*/   
##@@@L0394_:    volatile uint32_t timeoutCycleCount = CLK_DOMAIN_LCK_BIT_TIMEOUT_COUNT;   
80009808:	01 25       	ST.W      [SP + #1], R5
##@@@P_:kf32a13k_hw_clk.c:395
##@@@L0395_:    Clk_LL_SelectSource0ClockSource((Clk_DomainClockSource0_t)DomainClockConfigPtr->Source0ClockSource);   
8000980a:	40 82       	LD.W      R4, [R0]
8000980c:	18 45       	LD        R5, [PC + #24]        ;->0x8000986c  :=0xf000f43c
8000980e:	37 10       	MOV       R3, #7			;->0x0007
##@@@F_:Clk_LL_SelectSource0ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1282
##@@@L1277_: * @return   
##@@@L1278_: */   
##@@@L1279_:KF_INLINE void Clk_LL_SelectSource0ClockSource(const Clk_DomainClockSource0_t Source0Source)   
##@@@L1280_:{   
##@@@L1281_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source0Source));   
##@@@L1282_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL0, Source0Source);   
80009810:	25 82       	LD.W      R2, [R5]
80009812:	18 41       	LD        R1, [PC + #24]        ;->0x80009870  :=0xfffffff8
80009814:	43 69       	ANL       R4, R3
80009816:	21 69       	ANL       R2, R1
80009818:	24 6a       	ORL       R2, R4
8000981a:	52 85       	ST.W      [R5], R2
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:396
##@@@L0396_:    Clk_LL_SelectSource1ClockSource((Clk_DomainClockSource1_t)DomainClockConfigPtr->Source1ClockSource);   
8000981c:	60 98       	LD.W      R4, [R0 + #1]
##@@@F_:Clk_LL_SelectSource1ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1303
##@@@L1298_: * @return   
##@@@L1299_: */   
##@@@L1300_:KF_INLINE void Clk_LL_SelectSource1ClockSource(const Clk_DomainClockSource1_t Source1Source)   
##@@@L1301_:{   
##@@@L1302_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source1Source));   
##@@@L1303_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL1, Source1Source);   
8000981e:	a0 7a       	LSL       R4, #8			;->0x08
80009820:	15 43       	LD        R3, [PC + #21]        ;->0x80009874  :=0x700
80009822:	16 42       	LD        R2, [PC + #22]        ;->0x80009878  :=0xfffff8ff
80009824:	15 82       	LD.W      R1, [R5]
80009826:	43 69       	ANL       R4, R3
80009828:	12 69       	ANL       R1, R2
8000982a:	14 6a       	ORL       R1, R4
8000982c:	51 85       	ST.W      [R5], R1
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:397
##@@@L0397_:    Clk_LL_SelectSource2ClockSource((Clk_DomainClockSource2_t)DomainClockConfigPtr->Source2ClockSource);   
8000982e:	a0 98       	LD.W      R4, [R0 + #2]
##@@@F_:Clk_LL_SelectSource2ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1338
##@@@L1333_: * @return   
##@@@L1334_: */   
##@@@L1335_:KF_INLINE void Clk_LL_SelectSource2ClockSource(const Clk_DomainClockSource2_t Source2Source)   
##@@@L1336_:{   
##@@@L1337_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source2Source));   
##@@@L1338_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL2, Source2Source);   
80009830:	20 7b       	LSL       R4, #16			;->0x10
80009832:	13 43       	LD        R3, [PC + #19]        ;->0x8000987c  :=0x70000
80009834:	13 42       	LD        R2, [PC + #19]        ;->0x80009880  :=0xfff8ffff
80009836:	15 82       	LD.W      R1, [R5]
80009838:	43 69       	ANL       R4, R3
8000983a:	12 69       	ANL       R1, R2
8000983c:	14 6a       	ORL       R1, R4
8000983e:	51 85       	ST.W      [R5], R1
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:398
##@@@L0398_:    Clk_LL_SetFsource1Freq2DivStatus(DomainClockConfigPtr->Source1Freq2Divide);   
80009840:	20 8b       	LD.B      R4, [R0 + #12]
80009842:	11 43       	LD        R3, [PC + #17]        ;->0x80009884  :=0xfffff7ff
##@@@F_:Clk_LL_SetFsource1Freq2DivStatus():
##@@@P_:kf32a13k_drv_clk.h:1317
##@@@L1312_: *       true:  fsource1输入时钟源2分频   
##@@@L1313_: * @return   
##@@@L1314_: */   
##@@@L1315_:KF_INLINE void Clk_LL_SetFsource1Freq2DivStatus(const bool Status)   
##@@@L1316_:{   
##@@@L1317_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.PLL1DIV, Status);   
80009844:	25 82       	LD.W      R2, [R5]
80009846:	23 69       	ANL       R2, R3
80009848:	a3 7a       	LSL       R4, #11			;->0x0B
8000984a:	24 6a       	ORL       R2, R4
8000984c:	0f 44       	LD        R4, [PC + #15]        ;->0x80009888  :=0xffffffff
8000984e:	52 85       	ST.W      [R5], R2
##@@@F_:Clk_LL_GetDomainCtlRegLockStatus():
##@@@P_:kf32a13k_drv_clk.h:1350
##@@@L1345_: *        false: 寄存器未被锁定可以更新   
##@@@L1346_: *        true: 寄存器锁定不可以被更新   
##@@@L1347_: */   
##@@@L1348_:KF_INLINE bool Clk_LL_GetDomainCtlRegLockStatus()   
##@@@L1349_:{   
##@@@L1350_:    return (bool)(CLK_PTR->DOMAIN_CTL.bits.LCKSTA);   
80009850:	05 82       	LD.W      R0, [R5]
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:400
##@@@L0399_:    /* 等待LKSTA清零 */   
##@@@L0400_:    while (Clk_LL_GetDomainCtlRegLockStatus())   
80009852:	04 70       	CMP       R0, R4
80009854:	06 fc       	JGT       $+6                   ;->0x80009860
##@@@P_:kf32a13k_hw_clk.c:402
##@@@L0401_:    {   
##@@@L0402_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009856:	01 0b       	LD.W      R3, [SP + #1]
80009858:	5b cc       	SUB       R3, R3, #1
8000985a:	30 38       	CMP       R3, #0			;->0x00
8000985c:	01 23       	ST.W      [SP + #1], R3
8000985e:	f9 fc       	JGT       $-7                   ;->0x80009850
##@@@P_:kf32a13k_hw_clk.c:404
##@@@L0403_:    }   
##@@@L0404_:    return (bool)initError;   
80009860:	87 7d       	LSR       R0, #31			;->0x1F
80009862:	e8 28       	ADD       SP, #8			;->0x08
80009864:	1d 5c       	JMP       LR
80009866:	00 00       	NOP      NOP      
80009868:	00 10 00 00 	.long     0x00001000 ->000004096  [!!!@2@:MOV       R0, #0	@@: NOP      
8000986c:	3c f4 00 f0 	.long     0xf000f43c ->-268372932  [!!!@2@:JMI       $+60                  ;->0x800098e4	@@: JZ        $+0                   ;->0x8000986c
80009870:	f8 ff ff ff 	.long     0xfffffff8 ->-00000008 
80009874:	00 07 00 00 	.long     0x00000700 ->000001792  [!!!@2@:SJMP      $-256                 ;->0x80009674	@@: NOP      
80009878:	ff f8 ff ff 	.long     0xfffff8ff ->-00001793 
8000987c:	00 00 07 00 	.long     0x00070000 ->000458752  [!!!@2@:NOP      	@@: BREAK    
80009880:	ff ff f8 ff 	.long     0xfff8ffff ->-00458753 
80009884:	ff f7 ff ff 	.long     0xfffff7ff ->-00002049 
80009888:	ff ff ff ff 	.long     0xffffffff ->-00000001 

8000988c <Clk_ModulationInit>:
##@@@F_:Clk_ModulationInit():
##@@@P_:kf32a13k_hw_clk.c:414
##@@@L0409_: *   
##@@@L0410_: *   
##@@@L0411_: * @param ModulateConfigPtr   
##@@@L0412_: */   
##@@@L0413_:void Clk_ModulationInit(const Clk_ModulateConfig_t *ModulateConfigPtr)   
##@@@L0414_:{   
8000988c:	0c 45       	LD        R5, [PC + #12]        ;->0x800098bc  :=0xf000f424
##@@@P_:kf32a13k_hw_clk.c:415
##@@@L0415_:    Clk_LL_SetSysPLLFreqModulationStatus(ModulateConfigPtr->FreqModulateEnable);   
8000988e:	40 80       	LD.B      R4, [R0]
##@@@F_:Clk_LL_SetSysPLLFreqModulationStatus():
##@@@P_:kf32a13k_drv_clk.h:1024
##@@@L1019_: *       treu: 频率调制使能   
##@@@L1020_: * @return   
##@@@L1021_: */   
##@@@L1022_:KF_INLINE void Clk_LL_SetSysPLLFreqModulationStatus(const bool Status)   
##@@@L1023_:{   
##@@@L1024_:    REG_WRITE(CLK_PTR->SYSPLL_CTL0.bits.MODEN, Status);   
80009890:	35 82       	LD.W      R3, [R5]
80009892:	0c 42       	LD        R2, [PC + #12]        ;->0x800098c0  :=0xffdfffff
80009894:	32 69       	ANL       R3, R2
80009896:	25 7b       	LSL       R4, #21			;->0x15
80009898:	34 6a       	ORL       R3, R4
8000989a:	53 85       	ST.W      [R5], R3
##@@@F_:Clk_ModulationInit():
##@@@P_:kf32a13k_hw_clk.c:416
##@@@L0416_:    Clk_LL_SetSysPLLModulationValue(ModulateConfigPtr->FreqModulateIntPart, ModulateConfigPtr->FreqModulateDecPart);   
8000989c:	a8 98       	LD.W      R5, [R0 + #2]
8000989e:	60 98       	LD.W      R4, [R0 + #1]
800098a0:	09 43       	LD        R3, [PC + #9]         ;->0x800098c4  :=0xf000f42c
800098a2:	0a 42       	LD        R2, [PC + #10]        ;->0x800098c8  :=0xffff0000
##@@@F_:Clk_LL_SetSysPLLModulationValue():
##@@@P_:kf32a13k_drv_clk.h:1115
##@@@L1110_: */   
##@@@L1111_:KF_INLINE void Clk_LL_SetSysPLLModulationValue(const uint32_t IntegerPart, const uint32_t DecimalPart)   
##@@@L1112_:{   
##@@@L1113_:    KF_CLK_ASSERT(CHECK_SYSPLL_MODULATIONVALUE_INT(IntegerPart));   
##@@@L1114_:    KF_CLK_ASSERT(CHECK_SYSPLL_MODULATIONVALUE_DEC(DecimalPart));   
##@@@L1115_:    CLK_PTR->SYSPLL_CTL2.bits.MODCFG = (((uint32_t)0x3D << 10) | (IntegerPart << 5) | (DecimalPart));   
800098a4:	13 82       	LD.W      R1, [R3]
800098a6:	12 69       	ANL       R1, R2
800098a8:	25 7a       	LSL       R4, #5			;->0x05
800098aa:	09 42       	LD        R2, [PC + #9]         ;->0x800098cc  :=0xbff
800098ac:	45 6a       	ORL       R4, R5
800098ae:	42 69       	ANL       R4, R2
800098b0:	08 45       	LD        R5, [PC + #8]         ;->0x800098d0  :=0xf400
800098b2:	14 6a       	ORL       R1, R4
800098b4:	15 6a       	ORL       R1, R5
800098b6:	31 85       	ST.W      [R3], R1
##@@@F_:Clk_ModulationInit():
##@@@P_:kf32a13k_hw_clk.c:417
##@@@L0417_:}   
800098b8:	1d 5c       	JMP       LR
800098ba:	00 00       	NOP      NOP      
800098bc:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x80009904	@@: JZ        $+0                   ;->0x800098bc
800098c0:	ff ff df ff 	.long     0xffdfffff ->-02097153 
800098c4:	2c f4 00 f0 	.long     0xf000f42c ->-268372948  [!!!@2@:JMI       $+44                  ;->0x8000991c	@@: JZ        $+0                   ;->0x800098c4
800098c8:	00 00 ff ff 	.long     0xffff0000 ->-00065536 
800098cc:	ff 0b 00 00 	.long     0x00000bff ->000003071  [!!!@2@:LD.W      R3, [SP + #255]	@@: NOP      
800098d0:	00 f4 00 00 	.long     0x0000f400 ->000062464  [!!!@2@:JMI       $+0                   ;->0x800098d0	@@: NOP      

800098d4 <Clk_DistributeClock>:
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:427
##@@@L0422_: *   
##@@@L0423_: * @param ClockDistributionPtr   
##@@@L0424_: * @return   
##@@@L0425_: */   
##@@@L0426_:bool Clk_DistributeClock(const Clk_ClockDistributeConfig_t *ClockDistributionPtr)   
##@@@L0427_:{   
800098d4:	3f 5f       	PUSH      {R6-R11}
800098d6:	e8 31       	SUB       SP, #24			;->0x18
800098d8:	a0 45       	LD        R5, [PC + #160]       ;->0x80009b58  :=0x1000
800098da:	a1 42       	LD        R2, [PC + #161]       ;->0x80009b5c  :=0xf000f440
800098dc:	a1 44       	LD        R4, [PC + #161]       ;->0x80009b60  :=0xffffffff
##@@@P_:kf32a13k_hw_clk.c:433
##@@@L0428_:    bool       initError = false;   
##@@@L0429_:    CDU_CTL0_T tempReg0;   
##@@@L0430_:    CDU_CTL1_T tempReg1;   
##@@@L0431_:    CDU_CTL2_T tempReg2;   
##@@@L0432_:    /* 超时时间，防止编译器优化*/   
##@@@L0433_:    volatile uint32_t timeoutCycleCount = CLK_DOMAIN_LCK_BIT_TIMEOUT_COUNT;   
800098de:	02 25       	ST.W      [SP + #2], R5
##@@@F_:Clk_LL_GetCDUCTL0LockStatus():
##@@@P_:kf32a13k_drv_clk.h:1478
##@@@L1473_: *        false: 寄存器未被锁定可以更新   
##@@@L1474_: *        true: 寄存器锁定不可以被更新   
##@@@L1475_: */   
##@@@L1476_:KF_INLINE bool Clk_LL_GetCDUCTL0LockStatus()   
##@@@L1477_:{   
##@@@L1478_:    return (bool)(CLK_PTR->CDU_CTL0.bits.LCKSTA);   
800098e0:	12 82       	LD.W      R1, [R2]
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:437
##@@@L0434_:
##@@@L0435_:    /* CDU_CTL0 */   
##@@@L0436_:    /* 等待，直至寄存器可被更新 */   
##@@@L0437_:    while (Clk_LL_GetCDUCTL0LockStatus())   
800098e2:	14 70       	CMP       R1, R4
800098e4:	06 fc       	JGT       $+6                   ;->0x800098f0
##@@@P_:kf32a13k_hw_clk.c:439
##@@@L0438_:    {   
##@@@L0439_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
800098e6:	02 0d       	LD.W      R5, [SP + #2]
800098e8:	6d cc       	SUB       R5, R5, #1
800098ea:	50 38       	CMP       R5, #0			;->0x00
800098ec:	02 25       	ST.W      [SP + #2], R5
800098ee:	f9 fc       	JGT       $-7                   ;->0x800098e0
##@@@P_:kf32a13k_hw_clk.c:443
##@@@L0440_:    }   
##@@@L0441_:    /*TODO: 是否需要整字写入?*/   
##@@@L0442_:
##@@@L0443_:    tempReg0.bits.LPCLKDIV   = ClockDistributionPtr->LPClkDivision;   
800098f0:	50 82       	LD.W      R5, [R0]
800098f2:	ac 7a       	LSL       R5, #12			;->0x0C
800098f4:	9c 43       	LD        R3, [PC + #156]       ;->0x80009b64  :=0x7000
800098f6:	9d 46       	LD        R6, [PC + #157]       ;->0x80009b68  :=0xffff8fff
800098f8:	05 0f       	LD.W      R7, [SP + #5]
800098fa:	53 69       	ANL       R5, R3
800098fc:	76 69       	ANL       R7, R6
800098fe:	75 6a       	ORL       R7, R5
80009900:	05 27       	ST.W      [SP + #5], R7
##@@@P_:kf32a13k_hw_clk.c:444
##@@@L0444_:    tempReg0.bits.TMRCLKDIV  = ClockDistributionPtr->TmrClkDivision;   
80009902:	68 98       	LD.W      R5, [R0 + #1]
80009904:	a8 7a       	LSL       R5, #8			;->0x08
80009906:	9a 43       	LD        R3, [PC + #154]       ;->0x80009b6c  :=0xf00
80009908:	9a 46       	LD        R6, [PC + #154]       ;->0x80009b70  :=0xfffff0ff
8000990a:	05 0f       	LD.W      R7, [SP + #5]
8000990c:	53 69       	ANL       R5, R3
8000990e:	76 69       	ANL       R7, R6
80009910:	75 6a       	ORL       R7, R5
80009912:	05 27       	ST.W      [SP + #5], R7
##@@@P_:kf32a13k_hw_clk.c:445
##@@@L0445_:    tempReg0.bits.SYSCLKDIV  = ClockDistributionPtr->SysClkDivision;   
80009914:	a8 98       	LD.W      R5, [R0 + #2]
80009916:	2c 7a       	LSL       R5, #4			;->0x04
80009918:	b0 1f       	MOV       R11, #240			;->0x00F0
8000991a:	97 47       	LD        R7, [PC + #151]       ;->0x80009b74  :=0xffffff0f
8000991c:	05 0b       	LD.W      R3, [SP + #5]
8000991e:	5b 69       	ANL       R5, R11
80009920:	37 69       	ANL       R3, R7
80009922:	35 6a       	ORL       R3, R5
80009924:	05 23       	ST.W      [SP + #5], R3
##@@@P_:kf32a13k_hw_clk.c:446
##@@@L0446_:    tempReg0.bits.PERICLKDIV = ClockDistributionPtr->PeriClkDivision;   
80009926:	e8 98       	LD.W      R5, [R0 + #3]
80009928:	9f 10       	MOV       R9, #15			;->0x000F
8000992a:	94 46       	LD        R6, [PC + #148]       ;->0x80009b78  :=0xfffffff0
8000992c:	05 0b       	LD.W      R3, [SP + #5]
8000992e:	59 69       	ANL       R5, R9
80009930:	01 26       	ST.W      [SP + #1], R6
80009932:	36 69       	ANL       R3, R6
80009934:	35 6a       	ORL       R3, R5
80009936:	05 23       	ST.W      [SP + #5], R3
##@@@P_:kf32a13k_hw_clk.c:447
##@@@L0447_:    CLK_PTR->CDU_CTL0.reg    = tempReg0.reg;   
80009938:	05 0d       	LD.W      R5, [SP + #5]
8000993a:	25 85       	ST.W      [R2], R5
8000993c:	90 45       	LD        R5, [PC + #144]       ;->0x80009b7c  :=0x40000000
##@@@F_:Clk_LL_SetCDUCTLUpdate():
##@@@P_:kf32a13k_drv_clk.h:1466
##@@@L1461_: *   
##@@@L1462_: * @return   
##@@@L1463_: */   
##@@@L1464_:KF_INLINE void Clk_LL_SetCDUCTLUpdate()   
##@@@L1465_:{   
##@@@L1466_:    REG_WRITE(CLK_PTR->CDU_CTL0.bits.UP, 1U);   
8000993e:	32 82       	LD.W      R3, [R2]
##@@@F_:Clk_DistributeClock():
80009940:	8f 7d       	LSR       R1, #31			;->0x1F
##@@@F_:Clk_LL_SetCDUCTLUpdate():
80009942:	35 6a       	ORL       R3, R5
80009944:	23 85       	ST.W      [R2], R3
80009946:	81 10       	MOV       R8, #1			;->0x0001
##@@@F_:Clk_LL_GetCDUCTL0LockStatus():
##@@@P_:kf32a13k_drv_clk.h:1478
##@@@L1473_: *        false: 寄存器未被锁定可以更新   
##@@@L1474_: *        true: 寄存器锁定不可以被更新   
##@@@L1475_: */   
##@@@L1476_:KF_INLINE bool Clk_LL_GetCDUCTL0LockStatus()   
##@@@L1477_:{   
##@@@L1478_:    return (bool)(CLK_PTR->CDU_CTL0.bits.LCKSTA);   
80009948:	52 82       	LD.W      R5, [R2]
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:450
##@@@L0448_:    Clk_LL_SetCDUCTLUpdate();   
##@@@L0449_:    /* 等待更新完成 */   
##@@@L0450_:    while (Clk_LL_GetCDUCTL0LockStatus())   
8000994a:	54 70       	CMP       R5, R4
8000994c:	07 fc       	JGT       $+7                   ;->0x8000995a
##@@@P_:kf32a13k_hw_clk.c:452
##@@@L0451_:    {   
##@@@L0452_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
8000994e:	02 0d       	LD.W      R5, [SP + #2]
80009950:	6d cc       	SUB       R5, R5, #1
80009952:	50 38       	CMP       R5, #0			;->0x00
80009954:	02 25       	ST.W      [SP + #2], R5
80009956:	f9 fc       	JGT       $-7                   ;->0x80009948
80009958:	02 04       	SJMP      $+2                   ;->0x8000995c
8000995a:	01 59       	MOV       R8, R1
8000995c:	89 42       	LD        R2, [PC + #137]       ;->0x80009b80  :=0xf000f444
8000995e:	a1 10       	MOV       R10, #1			;->0x0001
##@@@F_:Clk_LL_GetCDUCTL1LockStatus():
##@@@P_:kf32a13k_drv_clk.h:1738
##@@@L1733_: *        false: 寄存器未被锁定可以更新   
##@@@L1734_: *        true: 寄存器锁定不可以被更新   
##@@@L1735_: */   
##@@@L1736_:KF_INLINE bool Clk_LL_GetCDUCTL1LockStatus()   
##@@@L1737_:{   
##@@@L1738_:    return (bool)(CLK_PTR->CDU_CTL1.bits.LCKSTA);   
80009960:	52 82       	LD.W      R5, [R2]
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:457
##@@@L0453_:    }   
##@@@L0454_:
##@@@L0455_:    /* CDU_CTL1 */   
##@@@L0456_:    /* 等待，直至寄存器可被更新 */   
##@@@L0457_:    while (Clk_LL_GetCDUCTL1LockStatus())   
80009962:	54 70       	CMP       R5, R4
80009964:	07 fc       	JGT       $+7                   ;->0x80009972
##@@@P_:kf32a13k_hw_clk.c:459
##@@@L0458_:    {   
##@@@L0459_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009966:	02 0d       	LD.W      R5, [SP + #2]
80009968:	6d cc       	SUB       R5, R5, #1
8000996a:	50 38       	CMP       R5, #0			;->0x00
8000996c:	02 25       	ST.W      [SP + #2], R5
8000996e:	f9 fc       	JGT       $-7                   ;->0x80009960
80009970:	02 04       	SJMP      $+2                   ;->0x80009974
80009972:	48 59       	MOV       R10, R8
##@@@P_:kf32a13k_hw_clk.c:462
##@@@L0460_:    }   
##@@@L0461_:    /*TODO: 是否需要整字写入?*/   
##@@@L0462_:    tempReg1.bits.STCLKDIV      = ClockDistributionPtr->SystickClkConfig.SysticktClkDivision;   
80009974:	28 9b       	LD.W      R5, [R0 + #12]
80009976:	04 0b       	LD.W      R3, [SP + #4]
80009978:	59 69       	ANL       R5, R9
8000997a:	01 09       	LD.W      R1, [SP + #1]
8000997c:	31 69       	ANL       R3, R1
8000997e:	35 6a       	ORL       R3, R5
80009980:	04 23       	ST.W      [SP + #4], R3
##@@@P_:kf32a13k_hw_clk.c:463
##@@@L0463_:    tempReg1.bits.CANHCLKDIV    = ClockDistributionPtr->CANHClkConfig.CANHClkDivision;   
80009982:	e8 9a       	LD.W      R5, [R0 + #11]
80009984:	2c 7a       	LSL       R5, #4			;->0x04
80009986:	04 0b       	LD.W      R3, [SP + #4]
80009988:	5b 69       	ANL       R5, R11
8000998a:	37 69       	ANL       R3, R7
8000998c:	35 6a       	ORL       R3, R5
8000998e:	04 23       	ST.W      [SP + #4], R3
##@@@P_:kf32a13k_hw_clk.c:464
##@@@L0464_:    tempReg1.bits.REFCLK1CLKDIV = ClockDistributionPtr->RefClk1Config.RefClk1Division;   
80009990:	a8 9a       	LD.W      R5, [R0 + #10]
80009992:	a8 7a       	LSL       R5, #8			;->0x08
80009994:	7c 43       	LD        R3, [PC + #124]       ;->0x80009b84  :=0x1f00
80009996:	7d 46       	LD        R6, [PC + #125]       ;->0x80009b88  :=0xffffe0ff
80009998:	04 0f       	LD.W      R7, [SP + #4]
8000999a:	53 69       	ANL       R5, R3
8000999c:	76 69       	ANL       R7, R6
8000999e:	75 6a       	ORL       R7, R5
800099a0:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_hw_clk.c:465
##@@@L0465_:    tempReg1.bits.REFCLK2CLKDIV = ClockDistributionPtr->RefClk2Config.RefClk2Division;   
800099a2:	68 9a       	LD.W      R5, [R0 + #9]
800099a4:	ad 7a       	LSL       R5, #13			;->0x0D
800099a6:	7a 43       	LD        R3, [PC + #122]       ;->0x80009b8c  :=0x3e000
800099a8:	7a 46       	LD        R6, [PC + #122]       ;->0x80009b90  :=0xfffc1fff
800099aa:	04 0f       	LD.W      R7, [SP + #4]
800099ac:	53 69       	ANL       R5, R3
800099ae:	76 69       	ANL       R7, R6
800099b0:	75 6a       	ORL       R7, R5
800099b2:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_hw_clk.c:466
##@@@L0466_:    tempReg1.bits.MSCCLKDIV     = ClockDistributionPtr->MscClkConfig.MscClkDivision;   
800099b4:	e8 99       	LD.W      R5, [R0 + #7]
800099b6:	2b 7b       	LSL       R5, #19			;->0x13
800099b8:	77 43       	LD        R3, [PC + #119]       ;->0x80009b94  :=0x780000
800099ba:	78 46       	LD        R6, [PC + #120]       ;->0x80009b98  :=0xff87ffff
800099bc:	04 0f       	LD.W      R7, [SP + #4]
800099be:	53 69       	ANL       R5, R3
800099c0:	76 69       	ANL       R7, R6
800099c2:	75 6a       	ORL       R7, R5
800099c4:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_hw_clk.c:467
##@@@L0467_:    tempReg1.bits.RTCCLKDIV     = ClockDistributionPtr->RtcClkConfig.RTCClkDivision;   
800099c6:	68 99       	LD.W      R5, [R0 + #5]
800099c8:	a8 7b       	LSL       R5, #24			;->0x18
800099ca:	75 43       	LD        R3, [PC + #117]       ;->0x80009b9c  :=0xf000000
800099cc:	75 46       	LD        R6, [PC + #117]       ;->0x80009ba0  :=0xf0ffffff
800099ce:	04 0f       	LD.W      R7, [SP + #4]
800099d0:	53 69       	ANL       R5, R3
800099d2:	76 69       	ANL       R7, R6
800099d4:	75 6a       	ORL       R7, R5
800099d6:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_hw_clk.c:470
##@@@L0468_:    /*TODO: 需确认，先设置分频，再选择时钟源?*/   
##@@@L0469_:    /*TODO: 需确认，竞品时钟源切换时，需要先关闭时钟，再选择新的时钟源*/   
##@@@L0470_:    tempReg1.bits.REFCLK2SEL = ClockDistributionPtr->RefClk2Config.RefClk2Source;   
800099d8:	28 9a       	LD.W      R5, [R0 + #8]
800099da:	2a 7b       	LSL       R5, #18			;->0x12
800099dc:	72 43       	LD        R3, [PC + #114]       ;->0x80009ba4  :=0x40000
800099de:	73 46       	LD        R6, [PC + #115]       ;->0x80009ba8  :=0xfffbffff
800099e0:	04 0f       	LD.W      R7, [SP + #4]
800099e2:	53 69       	ANL       R5, R3
800099e4:	76 69       	ANL       R7, R6
800099e6:	75 6a       	ORL       R7, R5
800099e8:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_hw_clk.c:471
##@@@L0471_:    tempReg1.bits.MSCCLKSEL  = ClockDistributionPtr->MscClkConfig.MSCClkSource;   
800099ea:	a8 99       	LD.W      R5, [R0 + #6]
800099ec:	2f 7b       	LSL       R5, #23			;->0x17
800099ee:	70 43       	LD        R3, [PC + #112]       ;->0x80009bac  :=0x800000
800099f0:	70 46       	LD        R6, [PC + #112]       ;->0x80009bb0  :=0xff7fffff
800099f2:	04 0f       	LD.W      R7, [SP + #4]
800099f4:	53 69       	ANL       R5, R3
800099f6:	76 69       	ANL       R7, R6
800099f8:	75 6a       	ORL       R7, R5
800099fa:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_hw_clk.c:472
##@@@L0472_:    tempReg1.bits.RTCCLKSEL  = ClockDistributionPtr->RtcClkConfig.RTCClkSource;   
800099fc:	28 99       	LD.W      R5, [R0 + #4]
800099fe:	ac 7b       	LSL       R5, #28			;->0x1C
80009a00:	6d 43       	LD        R3, [PC + #109]       ;->0x80009bb4  :=0x10000000
80009a02:	6e 46       	LD        R6, [PC + #110]       ;->0x80009bb8  :=0xefffffff
80009a04:	04 0f       	LD.W      R7, [SP + #4]
80009a06:	53 69       	ANL       R5, R3
80009a08:	76 69       	ANL       R7, R6
80009a0a:	75 6a       	ORL       R7, R5
80009a0c:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_hw_clk.c:473
##@@@L0473_:    CLK_PTR->CDU_CTL1.reg    = tempReg1.reg;   
80009a0e:	04 0d       	LD.W      R5, [SP + #4]
80009a10:	25 85       	ST.W      [R2], R5
80009a12:	61 10       	MOV       R6, #1			;->0x0001
##@@@F_:Clk_LL_GetCDUCTL1LockStatus():
##@@@P_:kf32a13k_drv_clk.h:1738
80009a14:	52 82       	LD.W      R5, [R2]
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:475
##@@@L0474_:    /* 等待更新完成 */   
##@@@L0475_:    while (Clk_LL_GetCDUCTL1LockStatus())   
80009a16:	54 70       	CMP       R5, R4
80009a18:	07 fc       	JGT       $+7                   ;->0x80009a26
##@@@P_:kf32a13k_hw_clk.c:477
##@@@L0476_:    {   
##@@@L0477_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009a1a:	02 0d       	LD.W      R5, [SP + #2]
80009a1c:	6d cc       	SUB       R5, R5, #1
80009a1e:	50 38       	CMP       R5, #0			;->0x00
80009a20:	02 25       	ST.W      [SP + #2], R5
80009a22:	f9 fc       	JGT       $-7                   ;->0x80009a14
80009a24:	02 04       	SJMP      $+2                   ;->0x80009a28
80009a26:	ca 58       	MOV       R6, R10
80009a28:	65 42       	LD        R2, [PC + #101]       ;->0x80009bbc  :=0xf000f448
80009a2a:	11 10       	MOV       R1, #1			;->0x0001
##@@@F_:Clk_LL_GetCDUCTL2LockStatus():
##@@@P_:kf32a13k_drv_clk.h:2004
##@@@L1999_: *        false: 寄存器未被锁定可以更新   
##@@@L2000_: *        true: 寄存器锁定不可以被更新   
##@@@L2001_: */   
##@@@L2002_:KF_INLINE bool Clk_LL_GetCDUCTL2LockStatus()   
##@@@L2003_:{   
##@@@L2004_:    return (bool)(CLK_PTR->CDU_CTL2.bits.LCKSTA);   
80009a2c:	52 82       	LD.W      R5, [R2]
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:482
##@@@L0478_:    }   
##@@@L0479_:
##@@@L0480_:    /* CDU_CTL2 */   
##@@@L0481_:    /* 等待，直至寄存器可被更新 */   
##@@@L0482_:    while (Clk_LL_GetCDUCTL2LockStatus())   
80009a2e:	54 70       	CMP       R5, R4
80009a30:	07 fc       	JGT       $+7                   ;->0x80009a3e
##@@@P_:kf32a13k_hw_clk.c:484
##@@@L0483_:    {   
##@@@L0484_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009a32:	02 0d       	LD.W      R5, [SP + #2]
80009a34:	6d cc       	SUB       R5, R5, #1
80009a36:	50 38       	CMP       R5, #0			;->0x00
80009a38:	02 25       	ST.W      [SP + #2], R5
80009a3a:	f9 fc       	JGT       $-7                   ;->0x80009a2c
80009a3c:	02 04       	SJMP      $+2                   ;->0x80009a40
80009a3e:	26 58       	MOV       R1, R6
##@@@P_:kf32a13k_hw_clk.c:487
##@@@L0485_:    }   
##@@@L0486_:    /*TODO: 是否需要整字写入?*/   
##@@@L0487_:    tempReg2.bits.SPICLKDIV    = ClockDistributionPtr->SpiClkConfig.SpiClkDivision;   
80009a40:	28 9e       	LD.W      R5, [R0 + #24]
80009a42:	03 0b       	LD.W      R3, [SP + #3]
80009a44:	59 69       	ANL       R5, R9
80009a46:	01 0e       	LD.W      R6, [SP + #1]
80009a48:	36 69       	ANL       R3, R6
80009a4a:	35 6a       	ORL       R3, R5
80009a4c:	03 23       	ST.W      [SP + #3], R3
##@@@P_:kf32a13k_hw_clk.c:488
##@@@L0488_:    tempReg2.bits.ADCCLKDIV    = ClockDistributionPtr->AdcClkConfig.AdcClkDivision;   
80009a4e:	a8 9d       	LD.W      R5, [R0 + #22]
80009a50:	2d 7a       	LSL       R5, #5			;->0x05
80009a52:	5c 43       	LD        R3, [PC + #92]        ;->0x80009bc0  :=0x1e0
80009a54:	5c 46       	LD        R6, [PC + #92]        ;->0x80009bc4  :=0xfffffe1f
80009a56:	03 0f       	LD.W      R7, [SP + #3]
80009a58:	53 69       	ANL       R5, R3
80009a5a:	76 69       	ANL       R7, R6
80009a5c:	75 6a       	ORL       R7, R5
80009a5e:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:489
##@@@L0489_:    tempReg2.bits.I2CCLKDIV    = ClockDistributionPtr->I2CClkConfig.I2CClkDivision;   
80009a60:	28 9d       	LD.W      R5, [R0 + #20]
80009a62:	aa 7a       	LSL       R5, #10			;->0x0A
80009a64:	59 43       	LD        R3, [PC + #89]        ;->0x80009bc8  :=0x3c00
80009a66:	5a 46       	LD        R6, [PC + #90]        ;->0x80009bcc  :=0xffffc3ff
80009a68:	03 0f       	LD.W      R7, [SP + #3]
80009a6a:	53 69       	ANL       R5, R3
80009a6c:	76 69       	ANL       R7, R6
80009a6e:	75 6a       	ORL       R7, R5
80009a70:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:490
##@@@L0490_:    tempReg2.bits.CANCLKDIV    = ClockDistributionPtr->CanClkConfig.CANClkDivision;   
80009a72:	a8 9c       	LD.W      R5, [R0 + #18]
80009a74:	af 7a       	LSL       R5, #15			;->0x0F
80009a76:	57 43       	LD        R3, [PC + #87]        ;->0x80009bd0  :=0x78000
80009a78:	57 46       	LD        R6, [PC + #87]        ;->0x80009bd4  :=0xfff87fff
80009a7a:	03 0f       	LD.W      R7, [SP + #3]
80009a7c:	53 69       	ANL       R5, R3
80009a7e:	76 69       	ANL       R7, R6
80009a80:	75 6a       	ORL       R7, R5
80009a82:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:491
##@@@L0491_:    tempReg2.bits.UTLINFCLKDIV = ClockDistributionPtr->UTLINFClkConfig.UTLINFClkDivision;   
80009a84:	28 9c       	LD.W      R5, [R0 + #16]
80009a86:	2c 7b       	LSL       R5, #20			;->0x14
80009a88:	54 43       	LD        R3, [PC + #84]        ;->0x80009bd8  :=0xf00000
80009a8a:	55 46       	LD        R6, [PC + #85]        ;->0x80009bdc  :=0xff0fffff
80009a8c:	03 0f       	LD.W      R7, [SP + #3]
80009a8e:	53 69       	ANL       R5, R3
80009a90:	76 69       	ANL       R7, R6
80009a92:	75 6a       	ORL       R7, R5
80009a94:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:492
##@@@L0492_:    tempReg2.bits.UTLINSCLKDIV = ClockDistributionPtr->UTLINClkConfig.UTLINSClkDivision;   
80009a96:	a8 9b       	LD.W      R5, [R0 + #14]
80009a98:	a9 7b       	LSL       R5, #25			;->0x19
80009a9a:	52 43       	LD        R3, [PC + #82]        ;->0x80009be0  :=0x1e000000
80009a9c:	52 46       	LD        R6, [PC + #82]        ;->0x80009be4  :=0xe1ffffff
80009a9e:	03 0f       	LD.W      R7, [SP + #3]
80009aa0:	53 69       	ANL       R5, R3
80009aa2:	76 69       	ANL       R7, R6
80009aa4:	75 6a       	ORL       R7, R5
80009aa6:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:495
##@@@L0493_:    /*TODO: 需确认，先设置分频，再选择时钟源?*/   
##@@@L0494_:    /*TODO: 需确认，竞品时钟源切换时，需要先关闭时钟，再选择新的时钟源*/   
##@@@L0495_:    tempReg2.bits.SPICLKSEL    = ClockDistributionPtr->SpiClkConfig.SpiClkSource;   
80009aa8:	e8 9d       	LD.W      R5, [R0 + #23]
80009aaa:	2c 7a       	LSL       R5, #4			;->0x04
80009aac:	30 11       	MOV       R3, #16			;->0x0010
80009aae:	4f 46       	LD        R6, [PC + #79]        ;->0x80009be8  :=0xffffffef
80009ab0:	03 0f       	LD.W      R7, [SP + #3]
80009ab2:	53 69       	ANL       R5, R3
80009ab4:	76 69       	ANL       R7, R6
80009ab6:	75 6a       	ORL       R7, R5
80009ab8:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:496
##@@@L0496_:    tempReg2.bits.ADCCLKSEL    = ClockDistributionPtr->AdcClkConfig.AdcClkSource;   
80009aba:	68 9d       	LD.W      R5, [R0 + #21]
80009abc:	a9 7a       	LSL       R5, #9			;->0x09
80009abe:	4c 43       	LD        R3, [PC + #76]        ;->0x80009bec  :=0x200
80009ac0:	4c 46       	LD        R6, [PC + #76]        ;->0x80009bf0  :=0xfffffdff
80009ac2:	03 0f       	LD.W      R7, [SP + #3]
80009ac4:	53 69       	ANL       R5, R3
80009ac6:	76 69       	ANL       R7, R6
80009ac8:	75 6a       	ORL       R7, R5
80009aca:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:497
##@@@L0497_:    tempReg2.bits.I2CCLKSEL    = ClockDistributionPtr->I2CClkConfig.I2CClkSource;   
80009acc:	e8 9c       	LD.W      R5, [R0 + #19]
80009ace:	ae 7a       	LSL       R5, #14			;->0x0E
80009ad0:	49 43       	LD        R3, [PC + #73]        ;->0x80009bf4  :=0x4000
80009ad2:	4a 46       	LD        R6, [PC + #74]        ;->0x80009bf8  :=0xffffbfff
80009ad4:	03 0f       	LD.W      R7, [SP + #3]
80009ad6:	53 69       	ANL       R5, R3
80009ad8:	76 69       	ANL       R7, R6
80009ada:	75 6a       	ORL       R7, R5
80009adc:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:498
##@@@L0498_:    tempReg2.bits.CANCLKSEL    = ClockDistributionPtr->CanClkConfig.CANClkSource;   
80009ade:	68 9c       	LD.W      R5, [R0 + #17]
80009ae0:	2b 7b       	LSL       R5, #19			;->0x13
80009ae2:	47 43       	LD        R3, [PC + #71]        ;->0x80009bfc  :=0x80000
80009ae4:	47 46       	LD        R6, [PC + #71]        ;->0x80009c00  :=0xfff7ffff
80009ae6:	03 0f       	LD.W      R7, [SP + #3]
80009ae8:	53 69       	ANL       R5, R3
80009aea:	76 69       	ANL       R7, R6
80009aec:	75 6a       	ORL       R7, R5
80009aee:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:499
##@@@L0499_:    tempReg2.bits.UTLINFCLKSEL = ClockDistributionPtr->UTLINFClkConfig.UTLINFClkSource;   
80009af0:	e8 9b       	LD.W      R5, [R0 + #15]
80009af2:	a8 7b       	LSL       R5, #24			;->0x18
80009af4:	44 43       	LD        R3, [PC + #68]        ;->0x80009c04  :=0x1000000
80009af6:	45 46       	LD        R6, [PC + #69]        ;->0x80009c08  :=0xfeffffff
80009af8:	03 0f       	LD.W      R7, [SP + #3]
80009afa:	53 69       	ANL       R5, R3
80009afc:	76 69       	ANL       R7, R6
80009afe:	75 6a       	ORL       R7, R5
80009b00:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:500
##@@@L0500_:    tempReg2.bits.UTLINSCLKSEL = ClockDistributionPtr->UTLINClkConfig.UTLINSClkSource;   
80009b02:	68 9b       	LD.W      R5, [R0 + #13]
80009b04:	ad 7b       	LSL       R5, #29			;->0x1D
80009b06:	42 43       	LD        R3, [PC + #66]        ;->0x80009c0c  :=0x20000000
80009b08:	42 46       	LD        R6, [PC + #66]        ;->0x80009c10  :=0xdfffffff
80009b0a:	03 0f       	LD.W      R7, [SP + #3]
80009b0c:	53 69       	ANL       R5, R3
80009b0e:	76 69       	ANL       R7, R6
80009b10:	75 6a       	ORL       R7, R5
80009b12:	03 27       	ST.W      [SP + #3], R7
##@@@P_:kf32a13k_hw_clk.c:501
##@@@L0501_:    CLK_PTR->CDU_CTL2.reg      = tempReg2.reg;   
80009b14:	03 0d       	LD.W      R5, [SP + #3]
80009b16:	25 85       	ST.W      [R2], R5
80009b18:	51 10       	MOV       R5, #1			;->0x0001
##@@@F_:Clk_LL_GetCDUCTL2LockStatus():
##@@@P_:kf32a13k_drv_clk.h:2004
80009b1a:	32 82       	LD.W      R3, [R2]
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:503
##@@@L0502_:    /* 等待更新完成 */   
##@@@L0503_:    while (Clk_LL_GetCDUCTL2LockStatus())   
80009b1c:	34 70       	CMP       R3, R4
80009b1e:	07 fc       	JGT       $+7                   ;->0x80009b2c
##@@@P_:kf32a13k_hw_clk.c:505
##@@@L0504_:    {   
##@@@L0505_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009b20:	02 0b       	LD.W      R3, [SP + #2]
80009b22:	5b cc       	SUB       R3, R3, #1
80009b24:	30 38       	CMP       R3, #0			;->0x00
80009b26:	02 23       	ST.W      [SP + #2], R3
80009b28:	f9 fc       	JGT       $-7                   ;->0x80009b1a
80009b2a:	02 04       	SJMP      $+2                   ;->0x80009b2e
80009b2c:	a1 58       	MOV       R5, R1
##@@@P_:kf32a13k_hw_clk.c:509
##@@@L0506_:    }   
##@@@L0507_:
##@@@L0508_:    /* CDU_CTL3 */   
##@@@L0509_:    Clk_LL_SetCpu0ClkDivision(ClockDistributionPtr->Cpu0ClkDivision);   
80009b2e:	60 9e       	LD.W      R4, [R0 + #25]
80009b30:	39 43       	LD        R3, [PC + #57]        ;->0x80009c14  :=0xf000f44c
80009b32:	2f 13       	MOV       R2, #63			;->0x003F
##@@@F_:Clk_LL_SetCpu0ClkDivision():
##@@@P_:kf32a13k_drv_clk.h:2021
##@@@L2016_: * @return   
##@@@L2017_: */   
##@@@L2018_:KF_INLINE void Clk_LL_SetCpu0ClkDivision(const uint32_t Cpu0ClkDiv)   
##@@@L2019_:{   
##@@@L2020_:    KF_CLK_ASSERT(CHECK_CDU_CUP0CLK_DIVISION(Cpu0ClkDiv));   
##@@@L2021_:    REG_WRITE(CLK_PTR->CDU_CTL3.bits.CPU0CLKDIV, Cpu0ClkDiv);   
80009b34:	13 82       	LD.W      R1, [R3]
80009b36:	39 46       	LD        R6, [PC + #57]        ;->0x80009c18  :=0xffffffc0
80009b38:	42 69       	ANL       R4, R2
80009b3a:	16 69       	ANL       R1, R6
80009b3c:	14 6a       	ORL       R1, R4
80009b3e:	31 85       	ST.W      [R3], R1
80009b40:	37 44       	LD        R4, [PC + #55]        ;->0x80009c1c  :=0xf000f450
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:511
##@@@L0510_:    /* CDU_CTL4 */   
##@@@L0511_:    Clk_LL_SetCpu1ClkDivision(ClockDistributionPtr->Cpu1ClkDivision);   
80009b42:	98 9e       	LD.W      R3, [R0 + #26]
##@@@F_:Clk_LL_SetCpu1ClkDivision():
##@@@P_:kf32a13k_drv_clk.h:2038
##@@@L2033_: * @return   
##@@@L2034_: */   
##@@@L2035_:KF_INLINE void Clk_LL_SetCpu1ClkDivision(const uint32_t Cpu1ClkDiv)   
##@@@L2036_:{   
##@@@L2037_:    KF_CLK_ASSERT(CHECK_CDU_CUP1CLK_DIVISION(Cpu1ClkDiv));   
##@@@L2038_:    REG_WRITE(CLK_PTR->CDU_CTL4.bits.CPU1CLKDIV, Cpu1ClkDiv);   
80009b44:	14 82       	LD.W      R1, [R4]
80009b46:	32 69       	ANL       R3, R2
80009b48:	16 69       	ANL       R1, R6
80009b4a:	13 6a       	ORL       R1, R3
80009b4c:	41 85       	ST.W      [R4], R1
##@@@F_:Clk_DistributeClock():
##@@@P_:kf32a13k_hw_clk.c:513
##@@@L0512_:
##@@@L0513_:    return (bool)initError;   
80009b4e:	05 58       	MOV       R0, R5
80009b50:	e8 29       	ADD       SP, #24			;->0x18
80009b52:	3f 5e       	POP       {R6-R11}
80009b54:	1d 5c       	JMP       LR
80009b56:	00 00       	NOP      NOP      
80009b58:	00 10 00 00 	.long     0x00001000 ->000004096  [!!!@2@:MOV       R0, #0	@@: NOP      
80009b5c:	40 f4 00 f0 	.long     0xf000f440 ->-268372928  [!!!@2@:JMI       $+64                  ;->0x80009bdc	@@: JZ        $+0                   ;->0x80009b5c
80009b60:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80009b64:	00 70 00 00 	.long     0x00007000 ->000028672  [!!!@2@:CMP       R0, R0	@@: NOP      
80009b68:	ff 8f ff ff 	.long     0xffff8fff ->-00028673 
80009b6c:	00 0f 00 00 	.long     0x00000f00 ->000003840  [!!!@2@:LD.W      R7, [SP + #0]	@@: NOP      
80009b70:	ff f0 ff ff 	.long     0xfffff0ff ->-00003841 
80009b74:	0f ff ff ff 	.long     0xffffff0f ->-00000241 
80009b78:	f0 ff ff ff 	.long     0xfffffff0 ->-00000016 
80009b7c:	00 00 00 40 	.long     0x40000000 ->1073741824  [!!!@2@:NOP      	@@: LD        R0, [PC + #0]         ;->0x80009b7c  :=0x40000000
80009b80:	44 f4 00 f0 	.long     0xf000f444 ->-268372924  [!!!@2@:JMI       $+68                  ;->0x80009c08	@@: JZ        $+0                   ;->0x80009b80
80009b84:	00 1f 00 00 	.long     0x00001f00 ->000007936  [!!!@2@:MOV       R0, #240	@@: NOP      
80009b88:	ff e0 ff ff 	.long     0xffffe0ff ->-00007937 
80009b8c:	00 e0 03 00 	.long     0x0003e000 ->000253952 
80009b90:	ff 1f fc ff 	.long     0xfffc1fff ->-00253953 
80009b94:	00 00 78 00 	.long     0x00780000 ->007864320  [!!!@2@:NOP      	@@: ST.B      [R3 + #0], R24
80009b98:	ff ff 87 ff 	.long     0xff87ffff ->-07864321 
80009b9c:	00 00 00 0f 	.long     0x0f000000 ->251658240  [!!!@2@:NOP      	@@: LD.W      R7, [SP + #0]
80009ba0:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
80009ba4:	00 00 04 00 	.long     0x00040000 ->000262144 
80009ba8:	ff ff fb ff 	.long     0xfffbffff ->-00262145 
80009bac:	00 00 80 00 	.long     0x00800000 ->008388608  [!!!@2@:NOP      	@@: LJMP      $+128                 ;->0x80009cac
80009bb0:	ff ff 7f ff 	.long     0xff7fffff ->-08388609 
80009bb4:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
80009bb8:	ff ff ff ef 	.long     0xefffffff ->-268435457 
80009bbc:	48 f4 00 f0 	.long     0xf000f448 ->-268372920  [!!!@2@:JMI       $+72                  ;->0x80009c4c	@@: JZ        $+0                   ;->0x80009bbc
80009bc0:	e0 01 00 00 	.long     0x000001e0 ->000000480  [!!!@2@:CMN       SP, R0	@@: NOP      
80009bc4:	1f fe ff ff 	.long     0xfffffe1f ->-00000481 
80009bc8:	00 3c 00 00 	.long     0x00003c00 ->000015360  [!!!@2@:CMP       R0, #64	@@: NOP      
80009bcc:	ff c3 ff ff 	.long     0xffffc3ff ->-00015361 
80009bd0:	00 80 07 00 	.long     0x00078000 ->000491520  [!!!@2@:LD.B      R0, [R0]	@@: BREAK    
80009bd4:	ff 7f f8 ff 	.long     0xfff87fff ->-00491521 
80009bd8:	00 00 f0 00 	.long     0x00f00000 ->015728640  [!!!@2@:NOP      	@@: QAVRHL    R3, ACC6, ACC0, #0, #0, #0, #0
80009bdc:	ff ff 0f ff 	.long     0xff0fffff ->-15728641 
80009be0:	00 00 00 1e 	.long     0x1e000000 ->503316480  [!!!@2@:NOP      	@@: MOV       R0, #224
80009be4:	ff ff ff e1 	.long     0xe1ffffff ->-503316481 
80009be8:	ef ff ff ff 	.long     0xffffffef ->-00000017 
80009bec:	00 02 00 00 	.long     0x00000200 ->000000512 
80009bf0:	ff fd ff ff 	.long     0xfffffdff ->-00000513 
80009bf4:	00 40 00 00 	.long     0x00004000 ->000016384  [!!!@2@:LD        R0, [PC + #0]         ;->0x80009bf4  :=0x4000	@@: NOP      
80009bf8:	ff bf ff ff 	.long     0xffffbfff ->-00016385 
80009bfc:	00 00 08 00 	.long     0x00080000 ->000524288  [!!!@2@:NOP      	@@: SYNC     
80009c00:	ff ff f7 ff 	.long     0xfff7ffff ->-00524289 
80009c04:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
80009c08:	ff ff ff fe 	.long     0xfeffffff ->-16777217 
80009c0c:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
80009c10:	ff ff ff df 	.long     0xdfffffff ->-536870913 
80009c14:	4c f4 00 f0 	.long     0xf000f44c ->-268372916  [!!!@2@:JMI       $+76                  ;->0x80009cac	@@: JZ        $+0                   ;->0x80009c14
80009c18:	c0 ff ff ff 	.long     0xffffffc0 ->-00000064 
80009c1c:	50 f4 00 f0 	.long     0xf000f450 ->-268372912  [!!!@2@:JMI       $+80                  ;->0x80009cbc	@@: JZ        $+0                   ;->0x80009c1c

80009c20 <Delay_us>:
##@@@F_:Delay_us():
##@@@P_:kf32a13k_hw_clk.c:569
##@@@L0564_: *   
##@@@L0565_: * @param DelayTime 延时时间，单位us.   
##@@@L0566_: * @retval void   
##@@@L0567_: */   
##@@@L0568_:void Delay_us(const uint32_t DelayTime)   
##@@@L0569_:{   
80009c20:	2d 5d       	PUSH      LR
80009c22:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kf32a13k_hw_clk.c:571
##@@@L0570_:    uint32_t sysPLLFreq = CLK_SYS_PLL_FREQUENCY / 1000000;   
##@@@L0571_:    if (DelayTime > 0)   
80009c24:	00 38       	CMP       R0, #0			;->0x00
80009c26:	0a f0       	JZ        $+10                  ;->0x80009c3a
80009c28:	06 45       	LD        R5, [PC + #6]         ;->0x80009c40  :=0xda740d
##@@@P_:kf32a13k_hw_clk.c:573
##@@@L0572_:    {   
##@@@L0573_:        if (DelayTime > (0xFFFFFFFFU / sysPLLFreq))   
80009c2a:	05 70       	CMP       R0, R5
80009c2c:	04 f8       	JHI       $+4                   ;->0x80009c34
80009c2e:	06 45       	LD        R5, [PC + #6]         ;->0x80009c44  :=0x12c
80009c30:	40 cb       	MULS      R0, R0, R5
80009c32:	02 04       	SJMP      $+2                   ;->0x80009c36
80009c34:	05 40       	LD        R0, [PC + #5]         ;->0x80009c48  :=0xffffff3c
80009c36:	06 45       	LD        R5, [PC + #6]         ;->0x80009c4c  :=0xd000d7a8
80009c38:	05 5c       	LJMP      R5
##@@@P_:kf32a13k_hw_clk.c:585
##@@@L0580_:        }   
##@@@L0581_:    }   
##@@@L0582_:    else   
##@@@L0583_:    {   
##@@@L0584_:    }   
##@@@L0585_:}   
80009c3a:	e4 28       	ADD       SP, #4			;->0x04
80009c3c:	0d 5d       	POP       LR
80009c3e:	1d 5c       	JMP       LR
80009c40:	0d 74 da 00 	.long     0x00da740d ->014316557 
80009c44:	2c 01 00 00 	.long     0x0000012c ->000000300  [!!!@2@:CMN       R2, R12	@@: NOP      
80009c48:	3c ff ff ff 	.long     0xffffff3c ->-00000196 
80009c4c:	a8 d7 00 d0 	.long     0xd000d7a8 ->-805251160  [!!!@2@:ORL       R5, R0, R6	@@: ZXT.H     R0, R0

80009c50 <Clk_Hw_InitClock>:
##@@@F_:Clk_Hw_InitClock():
##@@@P_:kf32a13k_hw_clk.c:597
##@@@L0592_: * @retval bool   
##@@@L0593_: *              false 初始化成功   
##@@@L0594_: *              true 初始化失败   
##@@@L0595_: */   
##@@@L0596_:bool Clk_Hw_InitClock(const Clk_ClockConfig_t *ClockConfigPtr)   
##@@@L0597_:{   
80009c50:	83 5f       	PUSH      {R6-R7,LR}
80009c52:	e8 30       	SUB       SP, #8			;->0x08
80009c54:	e0 58       	MOV       R7, R0
##@@@P_:kf32a13k_hw_clk.c:599
##@@@L0598_:    bool     status   = false;   
##@@@L0599_:    uint32_t password = Scu_Hw_WdtGetSafetyPassword();   
80009c56:	21 45       	LD        R5, [PC + #33]        ;->0x80009cd8  :=0x8000b930
80009c58:	05 5c       	LJMP      R5
80009c5a:	c0 58       	MOV       R6, R0
##@@@P_:kf32a13k_hw_clk.c:600
##@@@L0600_:    Scu_Hw_WdtClearSafetyEndinit(password);   
80009c5c:	20 45       	LD        R5, [PC + #32]        ;->0x80009cdc  :=0x8000af64
80009c5e:	05 5c       	LJMP      R5
80009c60:	20 45       	LD        R5, [PC + #32]        ;->0x80009ce0  :=0x1000
##@@@P_:kf32a13k_hw_clk.c:633
##@@@L0628_:    else   
##@@@L0629_:    {   
##@@@L0630_:    }   
##@@@L0631_:#else   
##@@@L0632_:    /* CDU输入时钟选择 */   
##@@@L0633_:    status = Clk_ConfigDomainClockSource(ClockConfigPtr->DomainClockConfigPtr);   
80009c62:	67 98       	LD.W      R4, [R7 + #1]
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:394
##@@@L0389_: */   
##@@@L0390_:bool Clk_ConfigDomainClockSource(const Clk_DomainClockConfig_t *DomainClockConfigPtr)   
##@@@L0391_:{   
##@@@L0392_:    bool initError = false;   
##@@@L0393_:    /* 超时时间，防止编译器优化*/   
##@@@L0394_:    volatile uint32_t timeoutCycleCount = CLK_DOMAIN_LCK_BIT_TIMEOUT_COUNT;   
80009c64:	01 25       	ST.W      [SP + #1], R5
80009c66:	37 10       	MOV       R3, #7			;->0x0007
##@@@P_:kf32a13k_hw_clk.c:395
##@@@L0395_:    Clk_LL_SelectSource0ClockSource((Clk_DomainClockSource0_t)DomainClockConfigPtr->Source0ClockSource);   
80009c68:	24 82       	LD.W      R2, [R4]
80009c6a:	1f 45       	LD        R5, [PC + #31]        ;->0x80009ce4  :=0xf000f43c
80009c6c:	1f 41       	LD        R1, [PC + #31]        ;->0x80009ce8  :=0xfffffff8
##@@@F_:Clk_LL_SelectSource0ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1282
##@@@L1277_: * @return   
##@@@L1278_: */   
##@@@L1279_:KF_INLINE void Clk_LL_SelectSource0ClockSource(const Clk_DomainClockSource0_t Source0Source)   
##@@@L1280_:{   
##@@@L1281_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source0Source));   
##@@@L1282_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL0, Source0Source);   
80009c6e:	05 82       	LD.W      R0, [R5]
80009c70:	23 69       	ANL       R2, R3
80009c72:	01 69       	ANL       R0, R1
80009c74:	02 6a       	ORL       R0, R2
80009c76:	50 85       	ST.W      [R5], R0
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:396
##@@@L0396_:    Clk_LL_SelectSource1ClockSource((Clk_DomainClockSource1_t)DomainClockConfigPtr->Source1ClockSource);   
80009c78:	5c 98       	LD.W      R3, [R4 + #1]
##@@@F_:Clk_LL_SelectSource1ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1303
##@@@L1298_: * @return   
##@@@L1299_: */   
##@@@L1300_:KF_INLINE void Clk_LL_SelectSource1ClockSource(const Clk_DomainClockSource1_t Source1Source)   
##@@@L1301_:{   
##@@@L1302_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source1Source));   
##@@@L1303_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL1, Source1Source);   
80009c7a:	98 7a       	LSL       R3, #8			;->0x08
80009c7c:	1c 42       	LD        R2, [PC + #28]        ;->0x80009cec  :=0x700
80009c7e:	1d 41       	LD        R1, [PC + #29]        ;->0x80009cf0  :=0xfffff8ff
80009c80:	05 82       	LD.W      R0, [R5]
80009c82:	32 69       	ANL       R3, R2
80009c84:	01 69       	ANL       R0, R1
80009c86:	03 6a       	ORL       R0, R3
80009c88:	50 85       	ST.W      [R5], R0
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:397
##@@@L0397_:    Clk_LL_SelectSource2ClockSource((Clk_DomainClockSource2_t)DomainClockConfigPtr->Source2ClockSource);   
80009c8a:	9c 98       	LD.W      R3, [R4 + #2]
##@@@F_:Clk_LL_SelectSource2ClockSource():
##@@@P_:kf32a13k_drv_clk.h:1338
##@@@L1333_: * @return   
##@@@L1334_: */   
##@@@L1335_:KF_INLINE void Clk_LL_SelectSource2ClockSource(const Clk_DomainClockSource2_t Source2Source)   
##@@@L1336_:{   
##@@@L1337_:    KF_CLK_ASSERT(CHECK_CLK_DOMAIN_CLOCKSOURCE(Source2Source));   
##@@@L1338_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.CLKSEL2, Source2Source);   
80009c8c:	18 7b       	LSL       R3, #16			;->0x10
80009c8e:	1a 42       	LD        R2, [PC + #26]        ;->0x80009cf4  :=0x70000
80009c90:	1a 41       	LD        R1, [PC + #26]        ;->0x80009cf8  :=0xfff8ffff
80009c92:	05 82       	LD.W      R0, [R5]
80009c94:	32 69       	ANL       R3, R2
80009c96:	01 69       	ANL       R0, R1
80009c98:	03 6a       	ORL       R0, R3
80009c9a:	50 85       	ST.W      [R5], R0
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:398
##@@@L0398_:    Clk_LL_SetFsource1Freq2DivStatus(DomainClockConfigPtr->Source1Freq2Divide);   
80009c9c:	24 8b       	LD.B      R4, [R4 + #12]
80009c9e:	18 43       	LD        R3, [PC + #24]        ;->0x80009cfc  :=0xfffff7ff
##@@@F_:Clk_LL_SetFsource1Freq2DivStatus():
##@@@P_:kf32a13k_drv_clk.h:1317
##@@@L1312_: *       true:  fsource1输入时钟源2分频   
##@@@L1313_: * @return   
##@@@L1314_: */   
##@@@L1315_:KF_INLINE void Clk_LL_SetFsource1Freq2DivStatus(const bool Status)   
##@@@L1316_:{   
##@@@L1317_:    REG_WRITE(CLK_PTR->DOMAIN_CTL.bits.PLL1DIV, Status);   
80009ca0:	25 82       	LD.W      R2, [R5]
80009ca2:	23 69       	ANL       R2, R3
80009ca4:	a3 7a       	LSL       R4, #11			;->0x0B
80009ca6:	24 6a       	ORL       R2, R4
80009ca8:	16 44       	LD        R4, [PC + #22]        ;->0x80009d00  :=0xffffffff
80009caa:	52 85       	ST.W      [R5], R2
##@@@F_:Clk_LL_GetDomainCtlRegLockStatus():
##@@@P_:kf32a13k_drv_clk.h:1350
##@@@L1345_: *        false: 寄存器未被锁定可以更新   
##@@@L1346_: *        true: 寄存器锁定不可以被更新   
##@@@L1347_: */   
##@@@L1348_:KF_INLINE bool Clk_LL_GetDomainCtlRegLockStatus()   
##@@@L1349_:{   
##@@@L1350_:    return (bool)(CLK_PTR->DOMAIN_CTL.bits.LCKSTA);   
80009cac:	35 82       	LD.W      R3, [R5]
##@@@F_:Clk_ConfigDomainClockSource():
##@@@P_:kf32a13k_hw_clk.c:400
##@@@L0399_:    /* 等待LKSTA清零 */   
##@@@L0400_:    while (Clk_LL_GetDomainCtlRegLockStatus())   
80009cae:	34 70       	CMP       R3, R4
80009cb0:	08 fc       	JGT       $+8                   ;->0x80009cc0
##@@@P_:kf32a13k_hw_clk.c:402
##@@@L0401_:    {   
##@@@L0402_:        CLK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);   
80009cb2:	01 0b       	LD.W      R3, [SP + #1]
80009cb4:	5b cc       	SUB       R3, R3, #1
80009cb6:	30 38       	CMP       R3, #0			;->0x00
80009cb8:	01 23       	ST.W      [SP + #1], R3
80009cba:	f9 fc       	JGT       $-7                   ;->0x80009cac
##@@@F_:Clk_Hw_InitClock():
80009cbc:	71 10       	MOV       R7, #1			;->0x0001
80009cbe:	05 04       	SJMP      $+5                   ;->0x80009cc8
##@@@P_:kf32a13k_hw_clk.c:637
##@@@L0632_:    /* CDU输入时钟选择 */   
##@@@L0633_:    status = Clk_ConfigDomainClockSource(ClockConfigPtr->DomainClockConfigPtr);   
##@@@L0634_:    if (!status)   
##@@@L0635_:    {   
##@@@L0636_:        /* 时钟分配 */   
##@@@L0637_:        status = Clk_DistributeClock(ClockConfigPtr->ClockDistributionPtr);   
80009cc0:	07 82       	LD.W      R0, [R7]
80009cc2:	11 45       	LD        R5, [PC + #17]        ;->0x80009d04  :=0x800098d4
80009cc4:	05 5c       	LJMP      R5
80009cc6:	e0 58       	MOV       R7, R0
##@@@P_:kf32a13k_hw_clk.c:643
##@@@L0638_:    }   
##@@@L0639_:    else   
##@@@L0640_:    {   
##@@@L0641_:    }   
##@@@L0642_:#endif   
##@@@L0643_:    Scu_Hw_WdtSetSafetyEndinit(password);   
80009cc8:	06 58       	MOV       R0, R6
80009cca:	10 45       	LD        R5, [PC + #16]        ;->0x80009d08  :=0x8000af90
80009ccc:	05 5c       	LJMP      R5
##@@@P_:kf32a13k_hw_clk.c:645
##@@@L0644_:    /* TODO: 设置寄存器保护*/   
##@@@L0645_:    return status;   
80009cce:	07 58       	MOV       R0, R7
80009cd0:	e8 28       	ADD       SP, #8			;->0x08
80009cd2:	03 5e       	POP       {R6-R7}
80009cd4:	0d 5d       	POP       LR
80009cd6:	1d 5c       	JMP       LR
80009cd8:	30 b9 00 80 	.long     0x8000b930 ->-2147436240  [!!!@2@:STP.B     [R0], R6 << #0	@@: LD.B      R0, [R0]
80009cdc:	64 af 00 80 	.long     0x8000af64 ->-2147438748  [!!!@2@:LD.H      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80009ce0:	00 10 00 00 	.long     0x00001000 ->000004096  [!!!@2@:MOV       R0, #0	@@: NOP      
80009ce4:	3c f4 00 f0 	.long     0xf000f43c ->-268372932  [!!!@2@:JMI       $+60                  ;->0x80009d5c	@@: JZ        $+0                   ;->0x80009ce4
80009ce8:	f8 ff ff ff 	.long     0xfffffff8 ->-00000008 
80009cec:	00 07 00 00 	.long     0x00000700 ->000001792  [!!!@2@:SJMP      $-256                 ;->0x80009aec	@@: NOP      
80009cf0:	ff f8 ff ff 	.long     0xfffff8ff ->-00001793 
80009cf4:	00 00 07 00 	.long     0x00070000 ->000458752  [!!!@2@:NOP      	@@: BREAK    
80009cf8:	ff ff f8 ff 	.long     0xfff8ffff ->-00458753 
80009cfc:	ff f7 ff ff 	.long     0xfffff7ff ->-00002049 
80009d00:	ff ff ff ff 	.long     0xffffffff ->-00000001 
80009d04:	d4 98 00 80 	.long     0x800098d4 ->-2147444524  [!!!@2@:LD.W      R2, [R4 + #3]	@@: LD.B      R0, [R0]
80009d08:	90 af 00 80 	.long     0x8000af90 ->-2147438704  [!!!@2@:LD.H      R2, [R0 + #30]	@@: LD.B      R0, [R0]

80009d0c <Clk_Hw_InitClockByDefaultConfig>:
##@@@F_:Clk_Hw_InitClockByDefaultConfig():
##@@@P_:kf32a13k_hw_clk.c:655
##@@@L0650_: * @retval bool   
##@@@L0651_: *              false 初始化成功   
##@@@L0652_: *              true 初始化失败   
##@@@L0653_: */   
##@@@L0654_:bool Clk_Hw_InitClockByDefaultConfig()   
##@@@L0655_:{   
80009d0c:	2d 5d       	PUSH      LR
80009d0e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kf32a13k_hw_clk.c:656
##@@@L0656_:    return (Clk_Hw_InitClock(&Clk_DefaultClockConfig));   
80009d10:	03 40       	LD        R0, [PC + #3]         ;->0x80009d1c  :=0x80001190
80009d12:	04 45       	LD        R5, [PC + #4]         ;->0x80009d20  :=0x80009c50
80009d14:	05 5c       	LJMP      R5
80009d16:	e4 28       	ADD       SP, #4			;->0x04
80009d18:	0d 5d       	POP       LR
80009d1a:	1d 5c       	JMP       LR
80009d1c:	90 11 00 80 	.long     0x80001190 ->-2147479152  [!!!@2@:MOV       R9, #16	@@: LD.B      R0, [R0]
80009d20:	50 9c 00 80 	.long     0x80009c50 ->-2147443632  [!!!@2@:LD.W      R2, [R0 + #17]	@@: LD.B      R0, [R0]

80009d24 <Clk_Hw_ExthfInit>:
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:668
##@@@L0663_: * @param ConfigPtr   
##@@@L0664_: * @return true   
##@@@L0665_: * @return false   
##@@@L0666_: */   
##@@@L0667_:bool Clk_Hw_ExthfInit(uint32_t Timeout, const Clk_ExthfConfig_t *ConfigPtr)   
##@@@L0668_:{   
80009d24:	9f 5f       	PUSH      {R6-R10,LR}
80009d26:	e8 30       	SUB       SP, #8			;->0x08
80009d28:	c1 58       	MOV       R6, R1
80009d2a:	e0 58       	MOV       R7, R0
80009d2c:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:kf32a13k_hw_clk.c:670
##@@@L0669_:    bool              ret            = false;   
##@@@L0670_:    volatile uint32_t TimeOutCounter = 0;   
80009d2e:	01 25       	ST.W      [SP + #1], R5
##@@@P_:kf32a13k_hw_clk.c:671
##@@@L0671_:    uint32_t          password       = Scu_Hw_WdtGetSafetyPassword();   
80009d30:	6a 45       	LD        R5, [PC + #106]       ;->0x80009ed8  :=0x8000b930
80009d32:	05 5c       	LJMP      R5
80009d34:	20 59       	MOV       R9, R0
##@@@P_:kf32a13k_hw_clk.c:672
##@@@L0672_:    Scu_Hw_WdtClearSafetyEndinit(password);   
80009d36:	6a 45       	LD        R5, [PC + #106]       ;->0x80009edc  :=0x8000af64
80009d38:	05 5c       	LJMP      R5
80009d3a:	6a 45       	LD        R5, [PC + #106]       ;->0x80009ee0  :=0xf000f418
##@@@F_:Clk_LL_GetClkSysStatus():
##@@@P_:kf32a13k_drv_clk.h:896
##@@@L0891_: * @retval bool   
##@@@L0892_: */   
##@@@L0893_:KF_INLINE bool Clk_LL_GetClkSysStatus(const Clk_ClkSysSetIndex_t Index)   
##@@@L0894_:{   
##@@@L0895_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0896_:    return (REG_BITS_READ(CLK_PTR->CLKSYS_STA.reg, (1U << (uint32_t)Index), (uint32_t)Index) != 0U);   
80009d3c:	45 82       	LD.W      R4, [R5]
80009d3e:	81 10       	MOV       R8, #1			;->0x0001
80009d40:	48 69       	ANL       R4, R8
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:673
##@@@L0673_:    if (Clk_LL_GetClkSysStatus(CLK_CLKSYS_SET_EXTHF))   
80009d42:	40 38       	CMP       R4, #0			;->0x00
80009d44:	02 f0       	JZ        $+2                   ;->0x80009d48
80009d46:	c1 04       	SJMP      $+193                 ;->0x80009ec8
##@@@F_:Clk_LL_SelectOscGainMode():
##@@@P_:kf32a13k_drv_clk.h:527
##@@@L0522_: * @retval void   
##@@@L0523_: */   
##@@@L0524_:KF_INLINE void Clk_LL_SelectOscGainMode(const Clk_OscGainMod_t OscGainMode)   
##@@@L0525_:{   
##@@@L0526_:    KF_CLK_ASSERT(CHECK_CLK_GAIN_MODE(OscGainMode));   
##@@@L0527_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.GAINMOD, OscGainMode);   
80009d48:	de ba       	LDP.W     R3, [R6] << #3
80009d4a:	67 44       	LD        R4, [PC + #103]       ;->0x80009ee4  :=0xf000f400
80009d4c:	28 11       	MOV       R2, #24			;->0x0018
80009d4e:	14 82       	LD.W      R1, [R4]
80009d50:	66 40       	LD        R0, [PC + #102]       ;->0x80009ee8  :=0xffffffe7
80009d52:	32 69       	ANL       R3, R2
80009d54:	10 69       	ANL       R1, R0
80009d56:	13 6a       	ORL       R1, R3
80009d58:	41 85       	ST.W      [R4], R1
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:680
##@@@L0675_:        ret = true;   
##@@@L0676_:    }   
##@@@L0677_:    else   
##@@@L0678_:    {   
##@@@L0679_:        Clk_LL_SelectOscGainMode((Clk_OscGainMod_t)ConfigPtr->OscGainMode);   
##@@@L0680_:        Clk_LL_SelectOscMode((Clk_OscMod_t)ConfigPtr->OscMode);   
80009d5a:	5e 98       	LD.W      R3, [R6 + #1]
##@@@F_:Clk_LL_SelectOscMode():
##@@@P_:kf32a13k_drv_clk.h:542
##@@@L0537_: * @retval void   
##@@@L0538_: */   
##@@@L0539_:KF_INLINE void Clk_LL_SelectOscMode(const Clk_OscMod_t OscMode)   
##@@@L0540_:{   
##@@@L0541_:    KF_CLK_ASSERT(CHECK_CLK_MODE(OscMode));   
##@@@L0542_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.OSCMOD, OscMode);   
80009d5c:	1d 7a       	LSL       R3, #5			;->0x05
80009d5e:	20 16       	MOV       R2, #96			;->0x0060
80009d60:	63 41       	LD        R1, [PC + #99]        ;->0x80009eec  :=0xffffff9f
80009d62:	04 82       	LD.W      R0, [R4]
80009d64:	32 69       	ANL       R3, R2
80009d66:	01 69       	ANL       R0, R1
80009d68:	03 6a       	ORL       R0, R3
80009d6a:	40 85       	ST.W      [R4], R0
80009d6c:	61 43       	LD        R3, [PC + #97]        ;->0x80009ef0  :=0xffffff7f
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:681
##@@@L0681_:        Clk_LL_SetOscShaperBypassStatus(ConfigPtr->OscShaperBypass);   
80009d6e:	16 8a       	LD.B      R2, [R6 + #8]
##@@@F_:Clk_LL_SetOscShaperBypassStatus():
##@@@P_:kf32a13k_drv_clk.h:554
##@@@L0549_: *          true   整形器被绕过   
##@@@L0550_: * @retval void   
##@@@L0551_: */   
##@@@L0552_:KF_INLINE void Clk_LL_SetOscShaperBypassStatus(const bool Status)   
##@@@L0553_:{   
##@@@L0554_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.SHBYEN, Status);   
80009d70:	14 82       	LD.W      R1, [R4]
80009d72:	13 69       	ANL       R1, R3
80009d74:	17 7a       	LSL       R2, #7			;->0x07
80009d76:	12 6a       	ORL       R1, R2
80009d78:	41 85       	ST.W      [R4], R1
80009d7a:	5f 43       	LD        R3, [PC + #95]        ;->0x80009ef4  :=0xfffffdff
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:682
##@@@L0682_:        Clk_LL_SetOscHysteresisStatus(ConfigPtr->OscHysteresis);   
80009d7c:	56 8a       	LD.B      R2, [R6 + #9]
##@@@F_:Clk_LL_SetOscHysteresisStatus():
##@@@P_:kf32a13k_drv_clk.h:566
##@@@L0561_: *          true   滞后使能   
##@@@L0562_: * @retval void   
##@@@L0563_: */   
##@@@L0564_:KF_INLINE void Clk_LL_SetOscHysteresisStatus(const bool Status)   
##@@@L0565_:{   
##@@@L0566_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.HYSEN, Status);   
80009d7e:	14 82       	LD.W      R1, [R4]
80009d80:	13 69       	ANL       R1, R3
80009d82:	91 7a       	LSL       R2, #9			;->0x09
80009d84:	12 6a       	ORL       R1, R2
80009d86:	41 85       	ST.W      [R4], R1
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:683
##@@@L0683_:        Clk_LL_SelectOscHysteresisMode((Clk_OscHysteresisMod_t)ConfigPtr->OscHysMode);   
80009d88:	d6 98       	LD.W      R2, [R6 + #3]
##@@@F_:Clk_LL_SelectOscHysteresisMode():
##@@@P_:kf32a13k_drv_clk.h:581
##@@@L0576_: * @retval void   
##@@@L0577_: */   
##@@@L0578_:KF_INLINE void Clk_LL_SelectOscHysteresisMode(const Clk_OscHysteresisMod_t OscHysMode)   
##@@@L0579_:{   
##@@@L0580_:    KF_CLK_ASSERT(CHECK_CLK_HYSMOD(OscHysMode));   
##@@@L0581_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.HYSMOD, OscHysMode);   
80009d8a:	92 7a       	LSL       R2, #10			;->0x0A
80009d8c:	5b 41       	LD        R1, [PC + #91]        ;->0x80009ef8  :=0xc00
80009d8e:	5c 40       	LD        R0, [PC + #92]        ;->0x80009efc  :=0xfffff3ff
80009d90:	a4 82       	LD.W      R10, [R4]
80009d92:	21 69       	ANL       R2, R1
80009d94:	a0 69       	ANL       R10, R0
80009d96:	a2 6a       	ORL       R10, R2
80009d98:	4a 85       	ST.W      [R4], R10
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:684
##@@@L0684_:        Clk_LL_SelectOscAmpMode((Clk_OscAmpMod_t)ConfigPtr->OscAmpMode);   
80009d9a:	16 99       	LD.W      R2, [R6 + #4]
##@@@F_:Clk_LL_SelectOscAmpMode():
##@@@P_:kf32a13k_drv_clk.h:596
##@@@L0591_: * @retval void   
##@@@L0592_: */   
##@@@L0593_:KF_INLINE void Clk_LL_SelectOscAmpMode(const Clk_OscAmpMod_t OscAmpMode)   
##@@@L0594_:{   
##@@@L0595_:    KF_CLK_ASSERT(CHECK_CLK_AMPMOD(OscAmpMode));   
##@@@L0596_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.AMPMOD, OscAmpMode);   
80009d9c:	94 7a       	LSL       R2, #12			;->0x0C
80009d9e:	59 41       	LD        R1, [PC + #89]        ;->0x80009f00  :=0x3000
80009da0:	59 40       	LD        R0, [PC + #89]        ;->0x80009f04  :=0xffffcfff
80009da2:	a4 82       	LD.W      R10, [R4]
80009da4:	21 69       	ANL       R2, R1
80009da6:	a0 69       	ANL       R10, R0
80009da8:	a2 6a       	ORL       R10, R2
80009daa:	4a 85       	ST.W      [R4], R10
80009dac:	57 42       	LD        R2, [PC + #87]        ;->0x80009f08  :=0xff7fffff
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:685
##@@@L0685_:        Clk_LL_SetOscAmpRegulatorStatus(ConfigPtr->OscAmpRegulator);   
80009dae:	0e 8d       	LD.B      R1, [R6 + #20]
##@@@F_:Clk_LL_SetOscAmpRegulatorStatus():
##@@@P_:kf32a13k_drv_clk.h:621
##@@@L0616_: *          true   OSC 振幅调节使能   
##@@@L0617_: * @retval void   
##@@@L0618_: */   
##@@@L0619_:KF_INLINE void Clk_LL_SetOscAmpRegulatorStatus(const bool Status)   
##@@@L0620_:{   
##@@@L0621_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.APREN, Status);   
80009db0:	04 82       	LD.W      R0, [R4]
80009db2:	02 69       	ANL       R0, R2
80009db4:	0f 7b       	LSL       R1, #23			;->0x17
80009db6:	01 6a       	ORL       R0, R1
80009db8:	40 85       	ST.W      [R4], R0
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:686
##@@@L0686_:        Clk_LL_SetOscWDGRefFrequency(ConfigPtr->WdgRefFreq);   
80009dba:	96 99       	LD.W      R2, [R6 + #6]
##@@@F_:Clk_LL_SetOscWDGRefFrequency():
##@@@P_:kf32a13k_drv_clk.h:609
##@@@L0604_:KF_INLINE void Clk_LL_SetOscWDGRefFrequency(const uint32_t RefFreq)   
##@@@L0605_:{   
##@@@L0606_:    /* EXTHF= (OSCCTL.OSCVAL - 1 + 16) MHz */   
##@@@L0607_:    /* EXTHF范围16MHz~40MHz */   
##@@@L0608_:    KF_CLK_ASSERT(((uint32_t)RefFreq >= 1U) && ((uint32_t)RefFreq <= 25U));   
##@@@L0609_:    REG_WRITE(CLK_PTR->OSC_CTL0.bits.OSCVAL, RefFreq);   
80009dbc:	10 7b       	LSL       R2, #16			;->0x10
80009dbe:	54 41       	LD        R1, [PC + #84]        ;->0x80009f0c  :=0x1f0000
80009dc0:	54 40       	LD        R0, [PC + #84]        ;->0x80009f10  :=0xffe0ffff
80009dc2:	a4 82       	LD.W      R10, [R4]
80009dc4:	21 69       	ANL       R2, R1
80009dc6:	a0 69       	ANL       R10, R0
80009dc8:	a2 6a       	ORL       R10, R2
80009dca:	4a 85       	ST.W      [R4], R10
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:687
##@@@L0687_:        Clk_LL_SelectHSEMode((Clk_HseMode_t)ConfigPtr->HseMode);   
80009dcc:	86 58       	MOV       R4, R6
80009dce:	4c 29       	ADD       R4, #28			;->0x1C
##@@@F_:Clk_LL_SelectHSEMode():
##@@@P_:kf32a13k_drv_clk.h:648
##@@@L0643_: * @retval void   
##@@@L0644_: */   
##@@@L0645_:KF_INLINE void Clk_LL_SelectHSEMode(const Clk_HseMode_t HseMode)   
##@@@L0646_:{   
##@@@L0647_:    KF_CLK_ASSERT(CHECK_CLK_HSEMOD(HseMode));   
##@@@L0648_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.HSEMODESEL, HseMode);   
80009dd0:	54 ba       	LDP.W     R2, [R4] << #1
80009dd2:	12 10       	MOV       R1, #2			;->0x0002
80009dd4:	50 44       	LD        R4, [PC + #80]        ;->0x80009f14  :=0xf000f404
80009dd6:	51 40       	LD        R0, [PC + #81]        ;->0x80009f18  :=0xfffffffd
80009dd8:	a4 82       	LD.W      R10, [R4]
80009dda:	21 69       	ANL       R2, R1
80009ddc:	a0 69       	ANL       R10, R0
80009dde:	a2 6a       	ORL       R10, R2
80009de0:	4a 85       	ST.W      [R4], R10
80009de2:	4f 42       	LD        R2, [PC + #79]        ;->0x80009f1c  :=0xfffffffe
##@@@F_:Clk_Hw_ExthfInit():
80009de4:	50 00 c1 80 	LD.B      R1, [R6 + #32]			;->0x20
##@@@F_:Clk_LL_SetXTHStatus():
##@@@P_:kf32a13k_drv_clk.h:635
##@@@L0630_: *          true   外部高频晶振不可以从 XTH_IN 输入外部时钟源   
##@@@L0631_: * @retval void   
##@@@L0632_: */   
##@@@L0633_:KF_INLINE void Clk_LL_SetXTHStatus(const bool Status)   
##@@@L0634_:{   
##@@@L0635_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.HSXTALEXEN, Status);   
80009de8:	04 82       	LD.W      R0, [R4]
80009dea:	02 69       	ANL       R0, R2
80009dec:	01 6a       	ORL       R0, R1
80009dee:	40 85       	ST.W      [R4], R0
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:689
##@@@L0688_:        Clk_LL_SetXTHStatus(ConfigPtr->XTHEn);   
##@@@L0689_:        Clk_LL_SelectGmMode((Clk_GmMode_t)ConfigPtr->GmMode);   
80009df0:	46 58       	MOV       R2, R6
80009df2:	24 2a       	ADD       R2, #36			;->0x24
##@@@F_:Clk_LL_SelectGmMode():
##@@@P_:kf32a13k_drv_clk.h:675
##@@@L0670_: * @retval void   
##@@@L0671_: */   
##@@@L0672_:KF_INLINE void Clk_LL_SelectGmMode(const Clk_GmMode_t GmMode)   
##@@@L0673_:{   
##@@@L0674_:    KF_CLK_ASSERT(CHECK_CLK_GMMOD(GmMode));   
##@@@L0675_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.GMBOOST, GmMode);   
80009df4:	92 ba       	LDP.W     R2, [R2] << #2
80009df6:	1c 13       	MOV       R1, #60			;->0x003C
80009df8:	4a 40       	LD        R0, [PC + #74]        ;->0x80009f20  :=0xffffffc3
80009dfa:	a4 82       	LD.W      R10, [R4]
80009dfc:	21 69       	ANL       R2, R1
80009dfe:	a0 69       	ANL       R10, R0
80009e00:	a2 6a       	ORL       R10, R2
80009e02:	4a 85       	ST.W      [R4], R10
##@@@F_:Clk_Hw_ExthfInit():
80009e04:	50 00 c2 a0 	LD.B      R2, [R6 + #40]			;->0x28
##@@@F_:Clk_LL_SetXTH2MOhmStatus():
##@@@P_:kf32a13k_drv_clk.h:687
##@@@L0682_: *          true   外部高频晶振内部并联 2MΩ开启   
##@@@L0683_: * @retval void   
##@@@L0684_: */   
##@@@L0685_:KF_INLINE void Clk_LL_SetXTH2MOhmStatus(const bool Status)   
##@@@L0686_:{   
##@@@L0687_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.XTHR2M, Status);   
80009e08:	14 82       	LD.W      R1, [R4]
80009e0a:	13 69       	ANL       R1, R3
80009e0c:	91 7a       	LSL       R2, #9			;->0x09
80009e0e:	12 6a       	ORL       R1, R2
80009e10:	41 85       	ST.W      [R4], R1
80009e12:	45 43       	LD        R3, [PC + #69]        ;->0x80009f24  :=0xfffffbff
##@@@F_:Clk_Hw_ExthfInit():
80009e14:	50 00 c2 a4 	LD.B      R2, [R6 + #41]			;->0x29
##@@@F_:Clk_LL_SetXTH470kOhmStatus():
##@@@P_:kf32a13k_drv_clk.h:699
##@@@L0694_: *          true   外部高频晶振内部并联 470kΩ开启   
##@@@L0695_: * @retval void   
##@@@L0696_: */   
##@@@L0697_:KF_INLINE void Clk_LL_SetXTH470kOhmStatus(const bool Status)   
##@@@L0698_:{   
##@@@L0699_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.XTHR470K, Status);   
80009e18:	14 82       	LD.W      R1, [R4]
80009e1a:	13 69       	ANL       R1, R3
80009e1c:	92 7a       	LSL       R2, #10			;->0x0A
80009e1e:	12 6a       	ORL       R1, R2
80009e20:	41 85       	ST.W      [R4], R1
80009e22:	42 43       	LD        R3, [PC + #66]        ;->0x80009f28  :=0xfffff7ff
##@@@F_:Clk_Hw_ExthfInit():
80009e24:	50 00 c2 a8 	LD.B      R2, [R6 + #42]			;->0x2A
##@@@F_:Clk_LL_SetXTH200kOhmStatus():
##@@@P_:kf32a13k_drv_clk.h:711
##@@@L0706_: *          true   外部高频晶振内部并联 200kΩ开启   
##@@@L0707_: * @retval void   
##@@@L0708_: */   
##@@@L0709_:KF_INLINE void Clk_LL_SetXTH200kOhmStatus(const bool Status)   
##@@@L0710_:{   
##@@@L0711_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.XTHR200K, Status);   
80009e28:	14 82       	LD.W      R1, [R4]
80009e2a:	13 69       	ANL       R1, R3
80009e2c:	93 7a       	LSL       R2, #11			;->0x0B
80009e2e:	12 6a       	ORL       R1, R2
80009e30:	41 85       	ST.W      [R4], R1
80009e32:	3f 43       	LD        R3, [PC + #63]        ;->0x80009f2c  :=0xffffdfff
##@@@F_:Clk_Hw_ExthfInit():
80009e34:	50 00 c2 ac 	LD.B      R2, [R6 + #43]			;->0x2B
##@@@F_:Clk_LL_SetXTHComparatorShaperStatus():
##@@@P_:kf32a13k_drv_clk.h:723
##@@@L0718_: *          true   外部高频晶振的比较器时钟整形开启   
##@@@L0719_: * @retval void   
##@@@L0720_: */   
##@@@L0721_:KF_INLINE void Clk_LL_SetXTHComparatorShaperStatus(const bool Status)   
##@@@L0722_:{   
##@@@L0723_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.XTHCOMPEN, Status);   
80009e38:	14 82       	LD.W      R1, [R4]
80009e3a:	13 69       	ANL       R1, R3
80009e3c:	95 7a       	LSL       R2, #13			;->0x0D
80009e3e:	12 6a       	ORL       R1, R2
80009e40:	41 85       	ST.W      [R4], R1
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:694
##@@@L0690_:        Clk_LL_SetXTH2MOhmStatus(ConfigPtr->XTH2MOhmEn);   
##@@@L0691_:        Clk_LL_SetXTH470kOhmStatus(ConfigPtr->XTH470kOhmEn);   
##@@@L0692_:        Clk_LL_SetXTH200kOhmStatus(ConfigPtr->XTH200kOhmEn);   
##@@@L0693_:        Clk_LL_SetXTHComparatorShaperStatus(ConfigPtr->XTHCmpShaper);   
##@@@L0694_:        Clk_LL_SelectXTHComparatorCurrent((Clk_XTHCurrent_t)ConfigPtr->CmpCurrent);   
80009e42:	de 9a       	LD.W      R3, [R6 + #11]
##@@@F_:Clk_LL_SelectXTHComparatorCurrent():
##@@@P_:kf32a13k_drv_clk.h:736
##@@@L0731_: * @retval void   
##@@@L0732_: */   
##@@@L0733_:KF_INLINE void Clk_LL_SelectXTHComparatorCurrent(const Clk_XTHCurrent_t Current)   
##@@@L0734_:{   
##@@@L0735_:    KF_CLK_ASSERT(CHECK_CLK_XTHCURRENT(Current));   
##@@@L0736_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.XTHCOMPI, Current);   
80009e44:	9e 7a       	LSL       R3, #14			;->0x0E
80009e46:	3b 42       	LD        R2, [PC + #59]        ;->0x80009f30  :=0xc000
80009e48:	3b 41       	LD        R1, [PC + #59]        ;->0x80009f34  :=0xffff3fff
80009e4a:	04 82       	LD.W      R0, [R4]
80009e4c:	32 69       	ANL       R3, R2
80009e4e:	01 69       	ANL       R0, R1
80009e50:	03 6a       	ORL       R0, R3
80009e52:	40 85       	ST.W      [R4], R0
80009e54:	50 00 c3 c0 	LD.B      R3, [R6 + #48]			;->0x30
80009e58:	23 62       	SXT.B     R2, R3
80009e5a:	38 43       	LD        R3, [PC + #56]        ;->0x80009f38  :=0xfeffffff
##@@@F_:Clk_LL_SetXTHCapacitor0Status():
##@@@P_:kf32a13k_drv_clk.h:748
##@@@L0743_: *          true   电容 0 使能   
##@@@L0744_: * @retval void   
##@@@L0745_: */   
##@@@L0746_:KF_INLINE void Clk_LL_SetXTHCapacitor0Status(const bool Status)   
##@@@L0747_:{   
##@@@L0748_:    REG_WRITE(CLK_PTR->OSC_CTL1.bits.CAP0EN, Status);   
80009e5c:	14 82       	LD.W      R1, [R4]
80009e5e:	13 69       	ANL       R1, R3
80009e60:	90 7b       	LSL       R2, #24			;->0x18
80009e62:	12 6a       	ORL       R1, R2
80009e64:	41 85       	ST.W      [R4], R1
80009e66:	50 00 c2 c4 	LD.B      R2, [R6 + #49]			;->0x31
80009e6a:	22 62       	SXT.B     R2, R2
80009e6c:	14 82       	LD.W      R1, [R4]
80009e6e:	13 69       	ANL       R1, R3
80009e70:	90 7b       	LSL       R2, #24			;->0x18
80009e72:	12 6a       	ORL       R1, R2
80009e74:	41 85       	ST.W      [R4], R1
80009e76:	50 00 c2 c8 	LD.B      R2, [R6 + #50]			;->0x32
80009e7a:	22 62       	SXT.B     R2, R2
80009e7c:	14 82       	LD.W      R1, [R4]
80009e7e:	13 69       	ANL       R1, R3
80009e80:	90 7b       	LSL       R2, #24			;->0x18
80009e82:	12 6a       	ORL       R1, R2
80009e84:	41 85       	ST.W      [R4], R1
80009e86:	50 00 c2 cc 	LD.B      R2, [R6 + #51]			;->0x33
80009e8a:	22 62       	SXT.B     R2, R2
80009e8c:	14 82       	LD.W      R1, [R4]
80009e8e:	13 69       	ANL       R1, R3
80009e90:	90 7b       	LSL       R2, #24			;->0x18
80009e92:	12 6a       	ORL       R1, R2
80009e94:	2a 43       	LD        R3, [PC + #42]        ;->0x80009f3c  :=0xf000f40c
80009e96:	41 85       	ST.W      [R4], R1
##@@@F_:Clk_LL_SetClkSysEnabled():
##@@@P_:kf32a13k_drv_clk.h:818
##@@@L0813_: * @retval void   
##@@@L0814_: */   
##@@@L0815_:KF_INLINE void Clk_LL_SetClkSysEnabled(const Clk_ClkSysSetIndex_t Index)   
##@@@L0816_:{   
##@@@L0817_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0818_:    REG_BITS_WRITE(CLK_PTR->CLKSYS_CTL0.reg, (1U << (uint32_t)Index), (1U << (uint32_t)Index));   
80009e98:	43 82       	LD.W      R4, [R3]
80009e9a:	48 6a       	ORL       R4, R8
80009e9c:	34 85       	ST.W      [R3], R4
##@@@F_:Clk_LL_GetClkSysStatus():
##@@@P_:kf32a13k_drv_clk.h:896
##@@@L0891_: * @retval bool   
##@@@L0892_: */   
##@@@L0893_:KF_INLINE bool Clk_LL_GetClkSysStatus(const Clk_ClkSysSetIndex_t Index)   
##@@@L0894_:{   
##@@@L0895_:    KF_CLK_ASSERT(CHECK_CLK_CLKSYS_SETINDEX(Index));   
##@@@L0896_:    return (REG_BITS_READ(CLK_PTR->CLKSYS_STA.reg, (1U << (uint32_t)Index), (uint32_t)Index) != 0U);   
80009e9e:	45 82       	LD.W      R4, [R5]
80009ea0:	48 69       	ANL       R4, R8
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:700
##@@@L0695_:        Clk_LL_SetXTHCapacitor0Status(ConfigPtr->XTHCap0En);   
##@@@L0696_:        Clk_LL_SetXTHCapacitor0Status(ConfigPtr->XTHCap1En);   
##@@@L0697_:        Clk_LL_SetXTHCapacitor0Status(ConfigPtr->XTHCap2En);   
##@@@L0698_:        Clk_LL_SetXTHCapacitor0Status(ConfigPtr->XTHCap3En);   
##@@@L0699_:        Clk_LL_SetClkSysEnabled(CLK_CLKSYS_SET_EXTHF);   
##@@@L0700_:        while (!Clk_LL_GetClkSysStatus(CLK_CLKSYS_SET_EXTHF))   
80009ea2:	40 38       	CMP       R4, #0			;->0x00
80009ea4:	11 f1       	JNZ       $+17                  ;->0x80009ec6
80009ea6:	40 10       	MOV       R4, #0			;->0x0000
80009ea8:	05 04       	SJMP      $+5                   ;->0x80009eb2
##@@@F_:Clk_LL_GetClkSysStatus():
##@@@P_:kf32a13k_drv_clk.h:896
80009eaa:	35 82       	LD.W      R3, [R5]
80009eac:	38 69       	ANL       R3, R8
##@@@F_:Clk_Hw_ExthfInit():
##@@@P_:kf32a13k_hw_clk.c:700
80009eae:	30 38       	CMP       R3, #0			;->0x00
80009eb0:	09 f1       	JNZ       $+9                   ;->0x80009ec2
##@@@P_:kf32a13k_hw_clk.c:703
##@@@L0701_:        {   
##@@@L0702_:            /** Timeout为0则不执行超时 **/   
##@@@L0703_:            if (Timeout == 0)   
80009eb2:	70 38       	CMP       R7, #0			;->0x00
80009eb4:	fb f0       	JZ        $-5                   ;->0x80009eaa
##@@@P_:kf32a13k_hw_clk.c:707
##@@@L0704_:            {   
##@@@L0705_:                continue;   
##@@@L0706_:            }   
##@@@L0707_:            TimeOutCounter++;   
80009eb6:	01 0b       	LD.W      R3, [SP + #1]
80009eb8:	5b c0       	ADD       R3, R3, #1
80009eba:	01 23       	ST.W      [SP + #1], R3
##@@@P_:kf32a13k_hw_clk.c:708
##@@@L0708_:            if (TimeOutCounter >= Timeout)   
80009ebc:	01 0b       	LD.W      R3, [SP + #1]
80009ebe:	37 70       	CMP       R3, R7
80009ec0:	f5 f3       	JNC       $-11                  ;->0x80009eaa
80009ec2:	04 59       	MOV       R8, R4
80009ec4:	02 04       	SJMP      $+2                   ;->0x80009ec8
80009ec6:	80 10       	MOV       R8, #0			;->0x0000
##@@@P_:kf32a13k_hw_clk.c:715
##@@@L0710_:                ret = false;   
##@@@L0711_:                break;   
##@@@L0712_:            }   
##@@@L0713_:        }   
##@@@L0714_:    }   
##@@@L0715_:    Scu_Hw_WdtSetSafetyEndinit(password);   
80009ec8:	09 58       	MOV       R0, R9
80009eca:	1e 45       	LD        R5, [PC + #30]        ;->0x80009f40  :=0x8000af90
80009ecc:	05 5c       	LJMP      R5
##@@@P_:kf32a13k_hw_clk.c:716
##@@@L0716_:    return ret;   
80009ece:	08 58       	MOV       R0, R8
80009ed0:	e8 28       	ADD       SP, #8			;->0x08
80009ed2:	1f 5e       	POP       {R6-R10}
80009ed4:	0d 5d       	POP       LR
80009ed6:	1d 5c       	JMP       LR
80009ed8:	30 b9 00 80 	.long     0x8000b930 ->-2147436240  [!!!@2@:STP.B     [R0], R6 << #0	@@: LD.B      R0, [R0]
80009edc:	64 af 00 80 	.long     0x8000af64 ->-2147438748  [!!!@2@:LD.H      R4, [R4 + #29]	@@: LD.B      R0, [R0]
80009ee0:	18 f4 00 f0 	.long     0xf000f418 ->-268372968  [!!!@2@:JMI       $+24                  ;->0x80009f10	@@: JZ        $+0                   ;->0x80009ee0
80009ee4:	00 f4 00 f0 	.long     0xf000f400 ->-268372992  [!!!@2@:JMI       $+0                   ;->0x80009ee4	@@: JZ        $+0                   ;->0x80009ee4
80009ee8:	e7 ff ff ff 	.long     0xffffffe7 ->-00000025 
80009eec:	9f ff ff ff 	.long     0xffffff9f ->-00000097 
80009ef0:	7f ff ff ff 	.long     0xffffff7f ->-00000129 
80009ef4:	ff fd ff ff 	.long     0xfffffdff ->-00000513 
80009ef8:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
80009efc:	ff f3 ff ff 	.long     0xfffff3ff ->-00003073 
80009f00:	00 30 00 00 	.long     0x00003000 ->000012288  [!!!@2@:SUB       R0, #0	@@: NOP      
80009f04:	ff cf ff ff 	.long     0xffffcfff ->-00012289 
80009f08:	ff ff 7f ff 	.long     0xff7fffff ->-08388609 
80009f0c:	00 00 1f 00 	.long     0x001f0000 ->002031616  [!!!@2@:NOP      	@@: FST.W           [R31++], S0
80009f10:	ff ff e0 ff 	.long     0xffe0ffff ->-02031617 
80009f14:	04 f4 00 f0 	.long     0xf000f404 ->-268372988  [!!!@2@:JMI       $+4                   ;->0x80009f1c	@@: JZ        $+0                   ;->0x80009f14
80009f18:	fd ff ff ff 	.long     0xfffffffd ->-00000003 
80009f1c:	fe ff ff ff 	.long     0xfffffffe ->-00000002 
80009f20:	c3 ff ff ff 	.long     0xffffffc3 ->-00000061 
80009f24:	ff fb ff ff 	.long     0xfffffbff ->-00001025 
80009f28:	ff f7 ff ff 	.long     0xfffff7ff ->-00002049 
80009f2c:	ff df ff ff 	.long     0xffffdfff ->-00008193 
80009f30:	00 c0 00 00 	.long     0x0000c000 ->000049152  [!!!@2@:ADD       R0, R0, #0	@@: NOP      
80009f34:	ff 3f ff ff 	.long     0xffff3fff ->-00049153 
80009f38:	ff ff ff fe 	.long     0xfeffffff ->-16777217 
80009f3c:	0c f4 00 f0 	.long     0xf000f40c ->-268372980  [!!!@2@:JMI       $+12                  ;->0x80009f54	@@: JZ        $+0                   ;->0x80009f3c
80009f40:	90 af 00 80 	.long     0x8000af90 ->-2147438704  [!!!@2@:LD.H      R2, [R0 + #30]	@@: LD.B      R0, [R0]

80009f44 <Clk_Hw_GetPLLClockSourceFrequency>:
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:726
##@@@L0721_: *   
##@@@L0722_: *   
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
80009f44:	05 45       	LD        R5, [PC + #5]         ;->0x80009f58  :=0xf000f424
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
80009f46:	55 82       	LD.W      R5, [R5]
80009f48:	ac 7d       	LSR       R5, #28			;->0x1C
80009f4a:	4c 10       	MOV       R4, #12			;->0x000C
80009f4c:	04 43       	LD        R3, [PC + #4]         ;->0x80009f5c  :=0x80001198
80009f4e:	54 69       	ANL       R5, R4
80009f50:	2f 00 60 94 	FLD.W           S0 , 	[ R3  + R5  ]
##@@@P_:kf32a13k_hw_clk.c:745
##@@@L0740_:    default:   
##@@@L0741_:        /* Reserved values, this */   
##@@@L0742_:        freq = 0.0;   
##@@@L0743_:        break;   
##@@@L0744_:    }   
##@@@L0745_:    return freq;   
80009f54:	1d 5c       	JMP       LR
80009f56:	00 00       	NOP      NOP      
80009f58:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x80009fa0	@@: JZ        $+0                   ;->0x80009f58
80009f5c:	98 11 00 80 	.long     0x80001198 ->-2147479144  [!!!@2@:MOV       R9, #24	@@: LD.B      R0, [R0]

80009f60 <Clk_Hw_GetSysPLLFrequency>:
##@@@F_:Clk_Hw_GetSysPLLFrequency():
##@@@P_:kf32a13k_hw_clk.c:754
##@@@L0749_: * @brief 获取系统PLL(即PLL0)输出频率   
##@@@L0750_: *   
##@@@L0751_: * @return float 系统PLL频率，单位Hz   
##@@@L0752_: */   
##@@@L0753_:float Clk_Hw_GetSysPLLFrequency(void)   
##@@@L0754_:{   
80009f60:	1c 45       	LD        R5, [PC + #28]        ;->0x80009fd0  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
80009f62:	45 82       	LD.W      R4, [R5]
##@@@F_:Clk_Hw_GetSysPLLFrequency():
##@@@P_:kf32a13k_hw_clk.c:757
##@@@L0752_: */   
##@@@L0753_:float Clk_Hw_GetSysPLLFrequency(void)   
##@@@L0754_:{   
##@@@L0755_:    float freq;   
##@@@L0756_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0757_:    if (CLK_PTR->SYSPLL_CTL0.bits.N > 0)   
80009f64:	35 82       	LD.W      R3, [R5]
80009f66:	1c 42       	LD        R2, [PC + #28]        ;->0x80009fd4  :=0xf0000
80009f68:	32 69       	ANL       R3, R2
80009f6a:	30 38       	CMP       R3, #0			;->0x00
80009f6c:	3c f0       	JZ        $+60                  ;->0x80009fe4
80009f6e:	a4 7d       	LSR       R4, #28			;->0x1C
80009f70:	3c 10       	MOV       R3, #12			;->0x000C
80009f72:	43 69       	ANL       R4, R3
80009f74:	19 43       	LD        R3, [PC + #25]        ;->0x80009fd8  :=0x80001198
##@@@P_:kf32a13k_hw_clk.c:760
##@@@L0758_:    {   
##@@@L0759_:        /*TODO: 确认系统PLL的M和N参数是否需要+1操作*/   
##@@@L0760_:        freq = inputFreq / (float)(CLK_PTR->SYSPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->SYSPLL_CTL0.bits.M) /   
80009f76:	25 82       	LD.W      R2, [R5]
80009f78:	2f 00 60 90 	FLD.W           S0 , 	[ R3  + R4  ]
80009f7c:	14 7d       	LSR       R2, #20			;->0x14
80009f7e:	41 10       	MOV       R4, #1			;->0x0001
80009f80:	24 69       	ANL       R2, R4
80009f82:	62 c0       	ADD       R4, R2, #1
80009f84:	1f 00 81 1c 	FMOV            S1 ,	R4
80009f88:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
80009f8c:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
80009f90:	45 82       	LD.W      R4, [R5]
80009f92:	13 43       	LD        R3, [PC + #19]        ;->0x80009fdc  :=0x3fff
80009f94:	43 69       	ANL       R4, R3
80009f96:	1f 00 81 1c 	FMOV            S1 ,	R4
80009f9a:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
##@@@P_:kf32a13k_hw_clk.c:761
##@@@L0761_:               (float)(CLK_PTR->SYSPLL_CTL0.bits.N) / (float)(CLK_PTR->SYSPLL_CTL1.bits.K2CLKDIV + 1);   
80009f9e:	55 82       	LD.W      R5, [R5]
80009fa0:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
80009fa4:	28 7d       	LSR       R5, #16			;->0x10
80009fa6:	4f 10       	MOV       R4, #15			;->0x000F
80009fa8:	54 69       	ANL       R5, R4
80009faa:	1f 00 a1 1c 	FMOV            S1 ,	R5
80009fae:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
80009fb2:	0c 45       	LD        R5, [PC + #12]        ;->0x80009fe0  :=0xf000f428
80009fb4:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
80009fb8:	55 82       	LD.W      R5, [R5]
80009fba:	47 10       	MOV       R4, #7			;->0x0007
80009fbc:	54 69       	ANL       R5, R4
80009fbe:	6d c0       	ADD       R5, R5, #1
80009fc0:	1f 00 a1 1c 	FMOV            S1 ,	R5
80009fc4:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
80009fc8:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:766
##@@@L0762_:    }   
##@@@L0763_:    else   
##@@@L0764_:    {   
##@@@L0765_:    }   
##@@@L0766_:    return freq;   
80009fcc:	1d 5c       	JMP       LR
80009fce:	00 00       	NOP      NOP      
80009fd0:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x8000a018	@@: JZ        $+0                   ;->0x80009fd0
80009fd4:	00 00 0f 00 	.long     0x000f0000 ->000983040 
80009fd8:	98 11 00 80 	.long     0x80001198 ->-2147479144  [!!!@2@:MOV       R9, #24	@@: LD.B      R0, [R0]
80009fdc:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
80009fe0:	28 f4 00 f0 	.long     0xf000f428 ->-268372952  [!!!@2@:JMI       $+40                  ;->0x8000a030	@@: JZ        $+0                   ;->0x80009fe0
80009fe4:	1d 5c       	JMP       LR
	...

80009fe8 <Clk_Hw_GetPerPLL1Frequency>:
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:775
##@@@L0770_: * @brief 获取PLL1输出频率   
##@@@L0771_: *   
##@@@L0772_: * @return float PLL1频率，单位Hz   
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
80009fe8:	1b 45       	LD        R5, [PC + #27]        ;->0x8000a054  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
80009fea:	35 82       	LD.W      R3, [R5]
80009fec:	9c 7d       	LSR       R3, #28			;->0x1C
80009fee:	1b 42       	LD        R2, [PC + #27]        ;->0x8000a058  :=0xf000f434
80009ff0:	1c 10       	MOV       R1, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
80009ff2:	42 82       	LD.W      R4, [R2]
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
80009ff4:	52 82       	LD.W      R5, [R2]
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
80009ff6:	31 69       	ANL       R3, R1
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
80009ff8:	29 7d       	LSR       R5, #17			;->0x11
80009ffa:	11 10       	MOV       R1, #1			;->0x0001
80009ffc:	22 82       	LD.W      R2, [R2]
80009ffe:	51 69       	ANL       R5, R1
8000a000:	90 7d       	LSR       R2, #24			;->0x18
8000a002:	1f 10       	MOV       R1, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a004:	16 40       	LD        R0, [PC + #22]        ;->0x8000a05c  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a006:	21 69       	ANL       R2, R1
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a008:	2f 00 00 8c 	FLD.W           S0 , 	[ R0  + R3  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a00c:	15 43       	LD        R3, [PC + #21]        ;->0x8000a060  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a00e:	22 7c       	LSR       R4, #2			;->0x02
8000a010:	43 69       	ANL       R4, R3
8000a012:	64 c0       	ADD       R4, R4, #1
8000a014:	1f 00 81 1c 	FMOV            S1 ,	R4
8000a018:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a01c:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a020:	1f 00 41 1c 	FMOV            S1 ,	R2
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a024:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a028:	6d c0       	ADD       R5, R5, #1
8000a02a:	1f 00 a2 1c 	FMOV            S2 ,	R5
8000a02e:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a032:	0d 45       	LD        R5, [PC + #13]        ;->0x8000a064  :=0xf000f438
8000a034:	29 00 41 04 	FMUL.F32        S1 , 	S2 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:780
##@@@L0780_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K2CLKDIV + 1));   
8000a038:	55 82       	LD.W      R5, [R5]
8000a03a:	47 10       	MOV       R4, #7			;->0x0007
8000a03c:	54 69       	ANL       R5, R4
8000a03e:	6d c0       	ADD       R5, R5, #1
8000a040:	1f 00 a2 1c 	FMOV            S2 ,	R5
8000a044:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a048:	29 00 21 08 	FMUL.F32        S1 , 	S1 , 	S2 
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a04c:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:781
##@@@L0780_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K2CLKDIV + 1));   
##@@@L0781_:    return freq;   
8000a050:	1d 5c       	JMP       LR
8000a052:	00 00       	NOP      NOP      
8000a054:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x8000a09c	@@: JZ        $+0                   ;->0x8000a054
8000a058:	34 f4 00 f0 	.long     0xf000f434 ->-268372940  [!!!@2@:JMI       $+52                  ;->0x8000a0c0	@@: JZ        $+0                   ;->0x8000a058
8000a05c:	98 11 00 80 	.long     0x80001198 ->-2147479144  [!!!@2@:MOV       R9, #24	@@: LD.B      R0, [R0]
8000a060:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
8000a064:	38 f4 00 f0 	.long     0xf000f438 ->-268372936  [!!!@2@:JMI       $+56                  ;->0x8000a0d4	@@: JZ        $+0                   ;->0x8000a064

8000a068 <Clk_Hw_GetPerPLL2Frequency>:
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:790
##@@@L0785_: * @brief 获取PLL2输出频率   
##@@@L0786_: *   
##@@@L0787_: * @return float PLL2频率，单位Hz   
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
8000a068:	26 5d       	PUSH      R6
8000a06a:	e4 30       	SUB       SP, #4			;->0x04
8000a06c:	22 45       	LD        R5, [PC + #34]        ;->0x8000a0f4  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a06e:	45 82       	LD.W      R4, [R5]
8000a070:	a4 7d       	LSR       R4, #28			;->0x1C
8000a072:	22 42       	LD        R2, [PC + #34]        ;->0x8000a0f8  :=0xf000f434
8000a074:	5c 10       	MOV       R5, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a076:	32 82       	LD.W      R3, [R2]
8000a078:	01 10       	MOV       R0, #1			;->0x0001
8000a07a:	30 69       	ANL       R3, R0
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a07c:	45 69       	ANL       R4, R5
8000a07e:	a0 58       	MOV       R5, R0
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a080:	30 38       	CMP       R3, #0			;->0x00
8000a082:	02 f0       	JZ        $+2                   ;->0x8000a086
8000a084:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a086:	12 82       	LD.W      R1, [R2]
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a088:	32 82       	LD.W      R3, [R2]
8000a08a:	19 7d       	LSR       R3, #17			;->0x11
8000a08c:	22 82       	LD.W      R2, [R2]
8000a08e:	30 69       	ANL       R3, R0
8000a090:	90 7d       	LSR       R2, #24			;->0x18
8000a092:	0f 10       	MOV       R0, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a094:	1a 46       	LD        R6, [PC + #26]        ;->0x8000a0fc  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a096:	20 69       	ANL       R2, R0
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a098:	2f 00 c0 90 	FLD.W           S0 , 	[ R6  + R4  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a09c:	19 44       	LD        R4, [PC + #25]        ;->0x8000a100  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a09e:	0a 7c       	LSR       R1, #2			;->0x02
8000a0a0:	14 69       	ANL       R1, R4
8000a0a2:	61 c0       	ADD       R4, R1, #1
8000a0a4:	1f 00 81 1c 	FMOV            S1 ,	R4
8000a0a8:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a0ac:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a0b0:	1f 00 41 1c 	FMOV            S1 ,	R2
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a0b4:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a0b8:	63 c0       	ADD       R4, R3, #1
8000a0ba:	1f 00 82 1c 	FMOV            S2 ,	R4
8000a0be:	12 44       	LD        R4, [PC + #18]        ;->0x8000a104  :=0xf000f438
8000a0c0:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a0c4:	44 82       	LD.W      R4, [R4]
8000a0c6:	29 00 41 04 	FMUL.F32        S1 , 	S2 , 	S1 
8000a0ca:	a0 7c       	LSR       R4, #8			;->0x08
8000a0cc:	37 10       	MOV       R3, #7			;->0x0007
8000a0ce:	43 69       	ANL       R4, R3
8000a0d0:	64 c0       	ADD       R4, R4, #1
8000a0d2:	1f 00 82 1c 	FMOV            S2 ,	R4
8000a0d6:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a0da:	0c 44       	LD        R4, [PC + #12]        ;->0x8000a108  :=0x80001010
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a0dc:	2a 7a       	LSL       R5, #2			;->0x02
8000a0de:	2f 00 83 94 	FLD.W           S3 , 	[ R4  + R5  ]
8000a0e2:	29 00 21 08 	FMUL.F32        S1 , 	S1 , 	S2 
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a0e6:	29 00 61 04 	FMUL.F32        S1 , 	S3 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a0ea:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:797
##@@@L0797_:    return freq;   
8000a0ee:	e4 28       	ADD       SP, #4			;->0x04
8000a0f0:	06 5d       	POP       R6
8000a0f2:	1d 5c       	JMP       LR
8000a0f4:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x8000a13c	@@: JZ        $+0                   ;->0x8000a0f4
8000a0f8:	34 f4 00 f0 	.long     0xf000f434 ->-268372940  [!!!@2@:JMI       $+52                  ;->0x8000a160	@@: JZ        $+0                   ;->0x8000a0f8
8000a0fc:	98 11 00 80 	.long     0x80001198 ->-2147479144  [!!!@2@:MOV       R9, #24	@@: LD.B      R0, [R0]
8000a100:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
8000a104:	38 f4 00 f0 	.long     0xf000f438 ->-268372936  [!!!@2@:JMI       $+56                  ;->0x8000a174	@@: JZ        $+0                   ;->0x8000a104
8000a108:	10 10 00 80 	.long     0x80001010 ->-2147479536  [!!!@2@:MOV       R1, #0	@@: LD.B      R0, [R0]

8000a10c <Clk_Hw_GetFsource0Frequency>:
##@@@F_:Clk_Hw_GetFsource0Frequency():
##@@@P_:kf32a13k_hw_clk.c:808
##@@@L0803_: *   
##@@@L0804_: * @param   
##@@@L0805_: * @return   
##@@@L0806_: */   
##@@@L0807_:float Clk_Hw_GetFsource0Frequency(void)   
##@@@L0808_:{   
8000a10c:	03 5f       	PUSH      {R6-R7}
8000a10e:	e4 30       	SUB       SP, #4			;->0x04
8000a110:	63 45       	LD        R5, [PC + #99]        ;->0x8000a29c  :=0xf000f43c
##@@@P_:kf32a13k_hw_clk.c:810
##@@@L0809_:    float freq;   
##@@@L0810_:    switch ((Clk_DomainClockSource0_t)CLK_PTR->DOMAIN_CTL.bits.CLKSEL0)   
8000a112:	45 82       	LD.W      R4, [R5]
8000a114:	57 10       	MOV       R5, #7			;->0x0007
8000a116:	45 69       	ANL       R4, R5
8000a118:	46 38       	CMP       R4, #6			;->0x06
8000a11a:	02 f9       	JLS       $+2                   ;->0x8000a11e
8000a11c:	43 04       	SJMP      $+67                  ;->0x8000a1a2
8000a11e:	61 43       	LD        R3, [PC + #97]        ;->0x8000a2a0  :=0x80001040
8000a120:	24 00 60 00 	FLD.W           S0, 	[R3 +#0  ]
8000a124:	60 43       	LD        R3, [PC + #96]        ;->0x8000a2a4  :=0x800010c0
8000a126:	22 7a       	LSL       R4, #2			;->0x02
8000a128:	23 e9       	LD.W      R4, [R3 + R4]
8000a12a:	14 5c       	JMP       R4
8000a12c:	5f 44       	LD        R4, [PC + #95]        ;->0x8000a2a8  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a12e:	34 82       	LD.W      R3, [R4]
##@@@F_:Clk_Hw_GetSysPLLFrequency():
##@@@P_:kf32a13k_hw_clk.c:757
##@@@L0752_: */   
##@@@L0753_:float Clk_Hw_GetSysPLLFrequency(void)   
##@@@L0754_:{   
##@@@L0755_:    float freq;   
##@@@L0756_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0757_:    if (CLK_PTR->SYSPLL_CTL0.bits.N > 0)   
8000a130:	24 82       	LD.W      R2, [R4]
8000a132:	5f 41       	LD        R1, [PC + #95]        ;->0x8000a2ac  :=0xf0000
8000a134:	21 69       	ANL       R2, R1
8000a136:	20 38       	CMP       R2, #0			;->0x00
8000a138:	02 f1       	JNZ       $+2                   ;->0x8000a13c
8000a13a:	ad 04       	SJMP      $+173                 ;->0x8000a294
8000a13c:	9c 7d       	LSR       R3, #28			;->0x1C
8000a13e:	2c 10       	MOV       R2, #12			;->0x000C
8000a140:	32 69       	ANL       R3, R2
8000a142:	5c 42       	LD        R2, [PC + #92]        ;->0x8000a2b0  :=0x80001198
##@@@P_:kf32a13k_hw_clk.c:760
##@@@L0758_:    {   
##@@@L0759_:        /*TODO: 确认系统PLL的M和N参数是否需要+1操作*/   
##@@@L0760_:        freq = inputFreq / (float)(CLK_PTR->SYSPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->SYSPLL_CTL0.bits.M) /   
8000a144:	14 82       	LD.W      R1, [R4]
8000a146:	2f 00 40 8c 	FLD.W           S0 , 	[ R2  + R3  ]
8000a14a:	0c 7d       	LSR       R1, #20			;->0x14
8000a14c:	31 10       	MOV       R3, #1			;->0x0001
8000a14e:	13 69       	ANL       R1, R3
8000a150:	59 c0       	ADD       R3, R1, #1
8000a152:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a156:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a15a:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a15e:	34 82       	LD.W      R3, [R4]
8000a160:	55 42       	LD        R2, [PC + #85]        ;->0x8000a2b4  :=0x3fff
8000a162:	32 69       	ANL       R3, R2
8000a164:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a168:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
##@@@P_:kf32a13k_hw_clk.c:761
##@@@L0761_:               (float)(CLK_PTR->SYSPLL_CTL0.bits.N) / (float)(CLK_PTR->SYSPLL_CTL1.bits.K2CLKDIV + 1);   
8000a16c:	44 82       	LD.W      R4, [R4]
8000a16e:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a172:	20 7d       	LSR       R4, #16			;->0x10
8000a174:	3f 10       	MOV       R3, #15			;->0x000F
8000a176:	43 69       	ANL       R4, R3
8000a178:	1f 00 81 1c 	FMOV            S1 ,	R4
8000a17c:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a180:	4e 44       	LD        R4, [PC + #78]        ;->0x8000a2b8  :=0xf000f428
8000a182:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a186:	44 82       	LD.W      R4, [R4]
8000a188:	45 69       	ANL       R4, R5
8000a18a:	6c c0       	ADD       R5, R4, #1
8000a18c:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a190:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a194:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a198:	7e 04       	SJMP      $+126                 ;->0x8000a294
##@@@F_:Clk_Hw_GetFsource0Frequency():
8000a19a:	49 45       	LD        R5, [PC + #73]        ;->0x8000a2bc  :=0x80001048
8000a19c:	04 04       	SJMP      $+4                   ;->0x8000a1a4
8000a19e:	49 45       	LD        R5, [PC + #73]        ;->0x8000a2c0  :=0x80001044
8000a1a0:	02 04       	SJMP      $+2                   ;->0x8000a1a4
8000a1a2:	49 45       	LD        R5, [PC + #73]        ;->0x8000a2c4  :=0x8000104c
8000a1a4:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
8000a1a8:	76 04       	SJMP      $+118                 ;->0x8000a294
8000a1aa:	40 44       	LD        R4, [PC + #64]        ;->0x8000a2a8  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a1ac:	24 82       	LD.W      R2, [R4]
8000a1ae:	94 7d       	LSR       R2, #28			;->0x1C
8000a1b0:	46 41       	LD        R1, [PC + #70]        ;->0x8000a2c8  :=0xf000f434
8000a1b2:	0c 10       	MOV       R0, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a1b4:	31 82       	LD.W      R3, [R1]
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a1b6:	41 82       	LD.W      R4, [R1]
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a1b8:	20 69       	ANL       R2, R0
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a1ba:	21 7d       	LSR       R4, #17			;->0x11
8000a1bc:	01 10       	MOV       R0, #1			;->0x0001
8000a1be:	11 82       	LD.W      R1, [R1]
8000a1c0:	40 69       	ANL       R4, R0
8000a1c2:	88 7d       	LSR       R1, #24			;->0x18
8000a1c4:	0f 10       	MOV       R0, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a1c6:	3b 46       	LD        R6, [PC + #59]        ;->0x8000a2b0  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a1c8:	10 69       	ANL       R1, R0
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a1ca:	2f 00 c0 88 	FLD.W           S0 , 	[ R6  + R2  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a1ce:	3a 42       	LD        R2, [PC + #58]        ;->0x8000a2b4  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a1d0:	1a 7c       	LSR       R3, #2			;->0x02
8000a1d2:	32 69       	ANL       R3, R2
8000a1d4:	5b c0       	ADD       R3, R3, #1
8000a1d6:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a1da:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a1de:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a1e2:	1f 00 21 1c 	FMOV            S1 ,	R1
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a1e6:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a1ea:	64 c0       	ADD       R4, R4, #1
8000a1ec:	1f 00 82 1c 	FMOV            S2 ,	R4
8000a1f0:	37 44       	LD        R4, [PC + #55]        ;->0x8000a2cc  :=0xf000f438
8000a1f2:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
##@@@P_:kf32a13k_hw_clk.c:780
##@@@L0780_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K2CLKDIV + 1));   
8000a1f6:	44 82       	LD.W      R4, [R4]
8000a1f8:	29 00 41 04 	FMUL.F32        S1 , 	S2 , 	S1 
8000a1fc:	45 69       	ANL       R4, R5
8000a1fe:	6c c0       	ADD       R5, R4, #1
8000a200:	1f 00 a2 1c 	FMOV            S2 ,	R5
8000a204:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a208:	29 00 21 08 	FMUL.F32        S1 , 	S1 , 	S2 
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a20c:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a210:	42 04       	SJMP      $+66                  ;->0x8000a294
##@@@F_:Clk_Hw_GetFsource0Frequency():
8000a212:	26 44       	LD        R4, [PC + #38]        ;->0x8000a2a8  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a214:	34 82       	LD.W      R3, [R4]
8000a216:	9c 7d       	LSR       R3, #28			;->0x1C
8000a218:	2c 41       	LD        R1, [PC + #44]        ;->0x8000a2c8  :=0xf000f434
8000a21a:	4c 10       	MOV       R4, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a21c:	21 82       	LD.W      R2, [R1]
8000a21e:	61 10       	MOV       R6, #1			;->0x0001
8000a220:	26 69       	ANL       R2, R6
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a222:	34 69       	ANL       R3, R4
8000a224:	86 58       	MOV       R4, R6
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a226:	20 38       	CMP       R2, #0			;->0x00
8000a228:	02 f0       	JZ        $+2                   ;->0x8000a22c
8000a22a:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a22c:	01 82       	LD.W      R0, [R1]
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a22e:	21 82       	LD.W      R2, [R1]
8000a230:	11 7d       	LSR       R2, #17			;->0x11
8000a232:	11 82       	LD.W      R1, [R1]
8000a234:	26 69       	ANL       R2, R6
8000a236:	88 7d       	LSR       R1, #24			;->0x18
8000a238:	6f 10       	MOV       R6, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a23a:	1e 47       	LD        R7, [PC + #30]        ;->0x8000a2b0  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a23c:	16 69       	ANL       R1, R6
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a23e:	2f 00 e0 8c 	FLD.W           S0 , 	[ R7  + R3  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a242:	1d 43       	LD        R3, [PC + #29]        ;->0x8000a2b4  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a244:	02 7c       	LSR       R0, #2			;->0x02
8000a246:	03 69       	ANL       R0, R3
8000a248:	58 c0       	ADD       R3, R0, #1
8000a24a:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a24e:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a252:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a256:	1f 00 21 1c 	FMOV            S1 ,	R1
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a25a:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a25e:	5a c0       	ADD       R3, R2, #1
8000a260:	1f 00 62 1c 	FMOV            S2 ,	R3
8000a264:	1a 43       	LD        R3, [PC + #26]        ;->0x8000a2cc  :=0xf000f438
8000a266:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a26a:	33 82       	LD.W      R3, [R3]
8000a26c:	29 00 41 04 	FMUL.F32        S1 , 	S2 , 	S1 
8000a270:	98 7c       	LSR       R3, #8			;->0x08
8000a272:	35 69       	ANL       R3, R5
8000a274:	6b c0       	ADD       R5, R3, #1
8000a276:	1f 00 a2 1c 	FMOV            S2 ,	R5
8000a27a:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a27e:	15 45       	LD        R5, [PC + #21]        ;->0x8000a2d0  :=0x80001018
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a280:	22 7a       	LSL       R4, #2			;->0x02
8000a282:	2f 00 a3 90 	FLD.W           S3 , 	[ R5  + R4  ]
8000a286:	29 00 21 08 	FMUL.F32        S1 , 	S1 , 	S2 
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a28a:	29 00 61 04 	FMUL.F32        S1 , 	S3 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a28e:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a292:	01 04       	SJMP      $+1                   ;->0x8000a294
##@@@F_:Clk_Hw_GetFsource0Frequency():
##@@@P_:kf32a13k_hw_clk.c:835
##@@@L0830_:    default:   
##@@@L0831_:        /* Reserved values, this */   
##@@@L0832_:        freq = 0.0;   
##@@@L0833_:        break;   
##@@@L0834_:    }   
##@@@L0835_:    return freq;   
8000a294:	e4 28       	ADD       SP, #4			;->0x04
8000a296:	03 5e       	POP       {R6-R7}
8000a298:	1d 5c       	JMP       LR
8000a29a:	00 00       	NOP      NOP      
8000a29c:	3c f4 00 f0 	.long     0xf000f43c ->-268372932  [!!!@2@:JMI       $+60                  ;->0x8000a314	@@: JZ        $+0                   ;->0x8000a29c
8000a2a0:	40 10 00 80 	.long     0x80001040 ->-2147479488  [!!!@2@:MOV       R4, #0	@@: LD.B      R0, [R0]
8000a2a4:	c0 10 00 80 	.long     0x800010c0 ->-2147479360  [!!!@2@:MOV       R12, #0	@@: LD.B      R0, [R0]
8000a2a8:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x8000a2f0	@@: JZ        $+0                   ;->0x8000a2a8
8000a2ac:	00 00 0f 00 	.long     0x000f0000 ->000983040 
8000a2b0:	98 11 00 80 	.long     0x80001198 ->-2147479144  [!!!@2@:MOV       R9, #24	@@: LD.B      R0, [R0]
8000a2b4:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
8000a2b8:	28 f4 00 f0 	.long     0xf000f428 ->-268372952  [!!!@2@:JMI       $+40                  ;->0x8000a308	@@: JZ        $+0                   ;->0x8000a2b8
8000a2bc:	48 10 00 80 	.long     0x80001048 ->-2147479480  [!!!@2@:MOV       R4, #8	@@: LD.B      R0, [R0]
8000a2c0:	44 10 00 80 	.long     0x80001044 ->-2147479484  [!!!@2@:MOV       R4, #4	@@: LD.B      R0, [R0]
8000a2c4:	4c 10 00 80 	.long     0x8000104c ->-2147479476  [!!!@2@:MOV       R4, #12	@@: LD.B      R0, [R0]
8000a2c8:	34 f4 00 f0 	.long     0xf000f434 ->-268372940  [!!!@2@:JMI       $+52                  ;->0x8000a330	@@: JZ        $+0                   ;->0x8000a2c8
8000a2cc:	38 f4 00 f0 	.long     0xf000f438 ->-268372936  [!!!@2@:JMI       $+56                  ;->0x8000a33c	@@: JZ        $+0                   ;->0x8000a2cc
8000a2d0:	18 10 00 80 	.long     0x80001018 ->-2147479528  [!!!@2@:MOV       R1, #8	@@: LD.B      R0, [R0]

8000a2d4 <Clk_Hw_GetFsource1Frequency>:
##@@@F_:Clk_Hw_GetFsource1Frequency():
##@@@P_:kf32a13k_hw_clk.c:846
##@@@L0841_: *   
##@@@L0842_: * @param   
##@@@L0843_: * @return   
##@@@L0844_: */   
##@@@L0845_:float Clk_Hw_GetFsource1Frequency(void)   
##@@@L0846_:{   
8000a2d4:	03 5f       	PUSH      {R6-R7}
8000a2d6:	e4 30       	SUB       SP, #4			;->0x04
8000a2d8:	6a 45       	LD        R5, [PC + #106]       ;->0x8000a480  :=0xf000f43c
##@@@P_:kf32a13k_hw_clk.c:848
##@@@L0847_:    float freq;   
##@@@L0848_:    float div = CLK_PTR->DOMAIN_CTL.bits.PLL1DIV ? 2.0 : 1.0;   
8000a2da:	45 82       	LD.W      R4, [R5]
8000a2dc:	6a 43       	LD        R3, [PC + #106]       ;->0x8000a484  :=0x800
8000a2de:	43 69       	ANL       R4, R3
8000a2e0:	40 38       	CMP       R4, #0			;->0x00
8000a2e2:	03 f0       	JZ        $+3                   ;->0x8000a2e8
8000a2e4:	40 10       	MOV       R4, #0			;->0x0000
8000a2e6:	02 04       	SJMP      $+2                   ;->0x8000a2ea
8000a2e8:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_hw_clk.c:849
##@@@L0849_:    switch ((Clk_DomainClockSource1_t)CLK_PTR->DOMAIN_CTL.bits.CLKSEL1)   
8000a2ea:	35 82       	LD.W      R3, [R5]
8000a2ec:	98 7c       	LSR       R3, #8			;->0x08
8000a2ee:	57 10       	MOV       R5, #7			;->0x0007
8000a2f0:	66 42       	LD        R2, [PC + #102]       ;->0x8000a488  :=0x80001050
8000a2f2:	35 69       	ANL       R3, R5
8000a2f4:	24 00 40 00 	FLD.W           S0, 	[R2 +#0  ]
8000a2f8:	36 38       	CMP       R3, #6			;->0x06
8000a2fa:	02 f9       	JLS       $+2                   ;->0x8000a2fe
8000a2fc:	be 04       	SJMP      $+190                 ;->0x8000a478
8000a2fe:	22 7a       	LSL       R4, #2			;->0x02
8000a300:	63 42       	LD        R2, [PC + #99]        ;->0x8000a48c  :=0x80001020
8000a302:	64 41       	LD        R1, [PC + #100]       ;->0x8000a490  :=0x800010dc
8000a304:	1a 7a       	LSL       R3, #2			;->0x02
8000a306:	d9 e8       	LD.W      R3, [R1 + R3]
8000a308:	2f 00 41 90 	FLD.W           S1 , 	[ R2  + R4  ]
8000a30c:	13 5c       	JMP       R3
8000a30e:	62 45       	LD        R5, [PC + #98]        ;->0x8000a494  :=0x8000105c
8000a310:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
8000a314:	b0 04       	SJMP      $+176                 ;->0x8000a474
8000a316:	61 44       	LD        R4, [PC + #97]        ;->0x8000a498  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a318:	24 82       	LD.W      R2, [R4]
8000a31a:	94 7d       	LSR       R2, #28			;->0x1C
8000a31c:	60 41       	LD        R1, [PC + #96]        ;->0x8000a49c  :=0xf000f434
8000a31e:	0c 10       	MOV       R0, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a320:	31 82       	LD.W      R3, [R1]
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a322:	41 82       	LD.W      R4, [R1]
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a324:	20 69       	ANL       R2, R0
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a326:	21 7d       	LSR       R4, #17			;->0x11
8000a328:	01 10       	MOV       R0, #1			;->0x0001
8000a32a:	11 82       	LD.W      R1, [R1]
8000a32c:	40 69       	ANL       R4, R0
8000a32e:	88 7d       	LSR       R1, #24			;->0x18
8000a330:	0f 10       	MOV       R0, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a332:	5c 46       	LD        R6, [PC + #92]        ;->0x8000a4a0  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a334:	10 69       	ANL       R1, R0
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a336:	2f 00 c0 88 	FLD.W           S0 , 	[ R6  + R2  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a33a:	5b 42       	LD        R2, [PC + #91]        ;->0x8000a4a4  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a33c:	1a 7c       	LSR       R3, #2			;->0x02
8000a33e:	32 69       	ANL       R3, R2
8000a340:	5b c0       	ADD       R3, R3, #1
8000a342:	1f 00 62 1c 	FMOV            S2 ,	R3
8000a346:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a34a:	29 00 00 08 	FMUL.F32        S0 , 	S0 , 	S2 
8000a34e:	1f 00 22 1c 	FMOV            S2 ,	R1
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a352:	1f 00 42 5c 	FCVTR.F32.U32  S2 ,	S2
8000a356:	64 c0       	ADD       R4, R4, #1
8000a358:	1f 00 83 1c 	FMOV            S3 ,	R4
8000a35c:	53 44       	LD        R4, [PC + #83]        ;->0x8000a4a8  :=0xf000f438
8000a35e:	1f 00 63 58 	FCVTR.F32.S32  S3 ,	S3
##@@@P_:kf32a13k_hw_clk.c:780
##@@@L0780_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K2CLKDIV + 1));   
8000a362:	44 82       	LD.W      R4, [R4]
8000a364:	29 00 62 08 	FMUL.F32        S2 , 	S3 , 	S2 
8000a368:	45 69       	ANL       R4, R5
8000a36a:	6c c0       	ADD       R5, R4, #1
8000a36c:	1f 00 a3 1c 	FMOV            S3 ,	R5
8000a370:	1f 00 63 58 	FCVTR.F32.S32  S3 ,	S3
8000a374:	29 00 42 0c 	FMUL.F32        S2 , 	S2 , 	S3 
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a378:	7c 04       	SJMP      $+124                 ;->0x8000a470
##@@@F_:Clk_Hw_GetFsource1Frequency():
8000a37a:	4d 45       	LD        R5, [PC + #77]        ;->0x8000a4ac  :=0x80001058
8000a37c:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
8000a380:	7a 04       	SJMP      $+122                 ;->0x8000a474
8000a382:	4c 45       	LD        R5, [PC + #76]        ;->0x8000a4b0  :=0x80001054
8000a384:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
8000a388:	76 04       	SJMP      $+118                 ;->0x8000a474
8000a38a:	44 44       	LD        R4, [PC + #68]        ;->0x8000a498  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a38c:	34 82       	LD.W      R3, [R4]
##@@@F_:Clk_Hw_GetSysPLLFrequency():
##@@@P_:kf32a13k_hw_clk.c:757
##@@@L0752_: */   
##@@@L0753_:float Clk_Hw_GetSysPLLFrequency(void)   
##@@@L0754_:{   
##@@@L0755_:    float freq;   
##@@@L0756_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0757_:    if (CLK_PTR->SYSPLL_CTL0.bits.N > 0)   
8000a38e:	24 82       	LD.W      R2, [R4]
8000a390:	49 41       	LD        R1, [PC + #73]        ;->0x8000a4b4  :=0xf0000
8000a392:	21 69       	ANL       R2, R1
8000a394:	20 38       	CMP       R2, #0			;->0x00
8000a396:	02 f1       	JNZ       $+2                   ;->0x8000a39a
8000a398:	94 04       	SJMP      $+148                 ;->0x8000a4c0
8000a39a:	9c 7d       	LSR       R3, #28			;->0x1C
8000a39c:	2c 10       	MOV       R2, #12			;->0x000C
8000a39e:	32 69       	ANL       R3, R2
8000a3a0:	40 42       	LD        R2, [PC + #64]        ;->0x8000a4a0  :=0x80001198
##@@@P_:kf32a13k_hw_clk.c:760
##@@@L0758_:    {   
##@@@L0759_:        /*TODO: 确认系统PLL的M和N参数是否需要+1操作*/   
##@@@L0760_:        freq = inputFreq / (float)(CLK_PTR->SYSPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->SYSPLL_CTL0.bits.M) /   
8000a3a2:	14 82       	LD.W      R1, [R4]
8000a3a4:	2f 00 40 8c 	FLD.W           S0 , 	[ R2  + R3  ]
8000a3a8:	0c 7d       	LSR       R1, #20			;->0x14
8000a3aa:	31 10       	MOV       R3, #1			;->0x0001
8000a3ac:	13 69       	ANL       R1, R3
8000a3ae:	59 c0       	ADD       R3, R1, #1
8000a3b0:	1f 00 62 1c 	FMOV            S2 ,	R3
8000a3b4:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a3b8:	ea 00 00 88 	FDIV.F32        S0 , 	S0 , 	S2 
8000a3bc:	34 82       	LD.W      R3, [R4]
8000a3be:	3a 42       	LD        R2, [PC + #58]        ;->0x8000a4a4  :=0x3fff
8000a3c0:	32 69       	ANL       R3, R2
8000a3c2:	1f 00 62 1c 	FMOV            S2 ,	R3
8000a3c6:	1f 00 42 5c 	FCVTR.F32.U32  S2 ,	S2
##@@@P_:kf32a13k_hw_clk.c:761
##@@@L0761_:               (float)(CLK_PTR->SYSPLL_CTL0.bits.N) / (float)(CLK_PTR->SYSPLL_CTL1.bits.K2CLKDIV + 1);   
8000a3ca:	44 82       	LD.W      R4, [R4]
8000a3cc:	29 00 00 08 	FMUL.F32        S0 , 	S0 , 	S2 
8000a3d0:	20 7d       	LSR       R4, #16			;->0x10
8000a3d2:	3f 10       	MOV       R3, #15			;->0x000F
8000a3d4:	43 69       	ANL       R4, R3
8000a3d6:	1f 00 82 1c 	FMOV            S2 ,	R4
8000a3da:	1f 00 42 5c 	FCVTR.F32.U32  S2 ,	S2
8000a3de:	37 44       	LD        R4, [PC + #55]        ;->0x8000a4b8  :=0xf000f428
8000a3e0:	ea 00 00 88 	FDIV.F32        S0 , 	S0 , 	S2 
8000a3e4:	44 82       	LD.W      R4, [R4]
8000a3e6:	45 69       	ANL       R4, R5
8000a3e8:	6c c0       	ADD       R5, R4, #1
8000a3ea:	1f 00 a2 1c 	FMOV            S2 ,	R5
8000a3ee:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a3f2:	3f 04       	SJMP      $+63                  ;->0x8000a470
##@@@F_:Clk_Hw_GetFsource1Frequency():
8000a3f4:	29 44       	LD        R4, [PC + #41]        ;->0x8000a498  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a3f6:	34 82       	LD.W      R3, [R4]
8000a3f8:	9c 7d       	LSR       R3, #28			;->0x1C
8000a3fa:	29 41       	LD        R1, [PC + #41]        ;->0x8000a49c  :=0xf000f434
8000a3fc:	4c 10       	MOV       R4, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a3fe:	21 82       	LD.W      R2, [R1]
8000a400:	61 10       	MOV       R6, #1			;->0x0001
8000a402:	26 69       	ANL       R2, R6
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a404:	34 69       	ANL       R3, R4
8000a406:	86 58       	MOV       R4, R6
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a408:	20 38       	CMP       R2, #0			;->0x00
8000a40a:	02 f0       	JZ        $+2                   ;->0x8000a40e
8000a40c:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a40e:	01 82       	LD.W      R0, [R1]
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a410:	21 82       	LD.W      R2, [R1]
8000a412:	11 7d       	LSR       R2, #17			;->0x11
8000a414:	11 82       	LD.W      R1, [R1]
8000a416:	26 69       	ANL       R2, R6
8000a418:	88 7d       	LSR       R1, #24			;->0x18
8000a41a:	6f 10       	MOV       R6, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a41c:	21 47       	LD        R7, [PC + #33]        ;->0x8000a4a0  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a41e:	16 69       	ANL       R1, R6
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a420:	2f 00 e0 8c 	FLD.W           S0 , 	[ R7  + R3  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a424:	20 43       	LD        R3, [PC + #32]        ;->0x8000a4a4  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a426:	02 7c       	LSR       R0, #2			;->0x02
8000a428:	03 69       	ANL       R0, R3
8000a42a:	58 c0       	ADD       R3, R0, #1
8000a42c:	1f 00 62 1c 	FMOV            S2 ,	R3
8000a430:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a434:	29 00 00 08 	FMUL.F32        S0 , 	S0 , 	S2 
8000a438:	1f 00 22 1c 	FMOV            S2 ,	R1
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a43c:	1f 00 42 5c 	FCVTR.F32.U32  S2 ,	S2
8000a440:	5a c0       	ADD       R3, R2, #1
8000a442:	1f 00 63 1c 	FMOV            S3 ,	R3
8000a446:	19 43       	LD        R3, [PC + #25]        ;->0x8000a4a8  :=0xf000f438
8000a448:	1f 00 63 58 	FCVTR.F32.S32  S3 ,	S3
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a44c:	33 82       	LD.W      R3, [R3]
8000a44e:	29 00 62 08 	FMUL.F32        S2 , 	S3 , 	S2 
8000a452:	98 7c       	LSR       R3, #8			;->0x08
8000a454:	35 69       	ANL       R3, R5
8000a456:	6b c0       	ADD       R5, R3, #1
8000a458:	1f 00 a3 1c 	FMOV            S3 ,	R5
8000a45c:	1f 00 63 58 	FCVTR.F32.S32  S3 ,	S3
8000a460:	17 45       	LD        R5, [PC + #23]        ;->0x8000a4bc  :=0x80001028
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a462:	22 7a       	LSL       R4, #2			;->0x02
8000a464:	2f 00 a4 90 	FLD.W           S4 , 	[ R5  + R4  ]
8000a468:	29 00 42 0c 	FMUL.F32        S2 , 	S2 , 	S3 
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a46c:	29 00 82 08 	FMUL.F32        S2 , 	S4 , 	S2 
##@@@F_:Clk_Hw_GetFsource1Frequency():
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a470:	ea 00 00 88 	FDIV.F32        S0 , 	S0 , 	S2 
8000a474:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:874
##@@@L0869_:    default:   
##@@@L0870_:        /* Reserved values, this */   
##@@@L0871_:        freq = 0.0;   
##@@@L0872_:        break;   
##@@@L0873_:    }   
##@@@L0874_:    return freq;   
8000a478:	e4 28       	ADD       SP, #4			;->0x04
8000a47a:	03 5e       	POP       {R6-R7}
8000a47c:	1d 5c       	JMP       LR
8000a47e:	00 00       	NOP      NOP      
8000a480:	3c f4 00 f0 	.long     0xf000f43c ->-268372932  [!!!@2@:JMI       $+60                  ;->0x8000a4f8	@@: JZ        $+0                   ;->0x8000a480
8000a484:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000a488:	50 10 00 80 	.long     0x80001050 ->-2147479472  [!!!@2@:MOV       R5, #0	@@: LD.B      R0, [R0]
8000a48c:	20 10 00 80 	.long     0x80001020 ->-2147479520  [!!!@2@:MOV       R2, #0	@@: LD.B      R0, [R0]
8000a490:	dc 10 00 80 	.long     0x800010dc ->-2147479332  [!!!@2@:MOV       LR, #12	@@: LD.B      R0, [R0]
8000a494:	5c 10 00 80 	.long     0x8000105c ->-2147479460  [!!!@2@:MOV       R5, #12	@@: LD.B      R0, [R0]
8000a498:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x8000a4e0	@@: JZ        $+0                   ;->0x8000a498
8000a49c:	34 f4 00 f0 	.long     0xf000f434 ->-268372940  [!!!@2@:JMI       $+52                  ;->0x8000a504	@@: JZ        $+0                   ;->0x8000a49c
8000a4a0:	98 11 00 80 	.long     0x80001198 ->-2147479144  [!!!@2@:MOV       R9, #24	@@: LD.B      R0, [R0]
8000a4a4:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
8000a4a8:	38 f4 00 f0 	.long     0xf000f438 ->-268372936  [!!!@2@:JMI       $+56                  ;->0x8000a518	@@: JZ        $+0                   ;->0x8000a4a8
8000a4ac:	58 10 00 80 	.long     0x80001058 ->-2147479464  [!!!@2@:MOV       R5, #8	@@: LD.B      R0, [R0]
8000a4b0:	54 10 00 80 	.long     0x80001054 ->-2147479468  [!!!@2@:MOV       R5, #4	@@: LD.B      R0, [R0]
8000a4b4:	00 00 0f 00 	.long     0x000f0000 ->000983040 
8000a4b8:	28 f4 00 f0 	.long     0xf000f428 ->-268372952  [!!!@2@:JMI       $+40                  ;->0x8000a508	@@: JZ        $+0                   ;->0x8000a4b8
8000a4bc:	28 10 00 80 	.long     0x80001028 ->-2147479512  [!!!@2@:MOV       R2, #8	@@: LD.B      R0, [R0]
8000a4c0:	da 07       	SJMP      $-38                  ;->0x8000a474
	...

8000a4c4 <Clk_Hw_GetFsource2Frequency>:
##@@@F_:Clk_Hw_GetFsource2Frequency():
##@@@P_:kf32a13k_hw_clk.c:885
##@@@L0880_: *   
##@@@L0881_: * @param   
##@@@L0882_: * @return   
##@@@L0883_: */   
##@@@L0884_:float Clk_Hw_GetFsource2Frequency(void)   
##@@@L0885_:{   
8000a4c4:	03 5f       	PUSH      {R6-R7}
8000a4c6:	e4 30       	SUB       SP, #4			;->0x04
8000a4c8:	63 45       	LD        R5, [PC + #99]        ;->0x8000a654  :=0xf000f43c
##@@@P_:kf32a13k_hw_clk.c:887
##@@@L0886_:    float freq;   
##@@@L0887_:    switch ((Clk_DomainClockSource0_t)CLK_PTR->DOMAIN_CTL.bits.CLKSEL2)   
8000a4ca:	45 82       	LD.W      R4, [R5]
8000a4cc:	20 7d       	LSR       R4, #16			;->0x10
8000a4ce:	57 10       	MOV       R5, #7			;->0x0007
8000a4d0:	45 69       	ANL       R4, R5
8000a4d2:	46 38       	CMP       R4, #6			;->0x06
8000a4d4:	02 f9       	JLS       $+2                   ;->0x8000a4d8
8000a4d6:	4d 04       	SJMP      $+77                  ;->0x8000a570
8000a4d8:	60 43       	LD        R3, [PC + #96]        ;->0x8000a658  :=0x80001060
8000a4da:	24 00 60 00 	FLD.W           S0, 	[R3 +#0  ]
8000a4de:	60 43       	LD        R3, [PC + #96]        ;->0x8000a65c  :=0x800010f8
8000a4e0:	22 7a       	LSL       R4, #2			;->0x02
8000a4e2:	23 e9       	LD.W      R4, [R3 + R4]
8000a4e4:	14 5c       	JMP       R4
8000a4e6:	5f 44       	LD        R4, [PC + #95]        ;->0x8000a660  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a4e8:	34 82       	LD.W      R3, [R4]
8000a4ea:	9c 7d       	LSR       R3, #28			;->0x1C
8000a4ec:	5e 41       	LD        R1, [PC + #94]        ;->0x8000a664  :=0xf000f434
8000a4ee:	4c 10       	MOV       R4, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a4f0:	21 82       	LD.W      R2, [R1]
8000a4f2:	61 10       	MOV       R6, #1			;->0x0001
8000a4f4:	26 69       	ANL       R2, R6
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a4f6:	34 69       	ANL       R3, R4
8000a4f8:	86 58       	MOV       R4, R6
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a4fa:	20 38       	CMP       R2, #0			;->0x00
8000a4fc:	02 f0       	JZ        $+2                   ;->0x8000a500
8000a4fe:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a500:	01 82       	LD.W      R0, [R1]
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a502:	21 82       	LD.W      R2, [R1]
8000a504:	11 7d       	LSR       R2, #17			;->0x11
8000a506:	11 82       	LD.W      R1, [R1]
8000a508:	26 69       	ANL       R2, R6
8000a50a:	88 7d       	LSR       R1, #24			;->0x18
8000a50c:	6f 10       	MOV       R6, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a50e:	57 47       	LD        R7, [PC + #87]        ;->0x8000a668  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a510:	16 69       	ANL       R1, R6
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a512:	2f 00 e0 8c 	FLD.W           S0 , 	[ R7  + R3  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a516:	56 43       	LD        R3, [PC + #86]        ;->0x8000a66c  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL2Frequency():
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a518:	02 7c       	LSR       R0, #2			;->0x02
8000a51a:	03 69       	ANL       R0, R3
8000a51c:	58 c0       	ADD       R3, R0, #1
8000a51e:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a522:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a526:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a52a:	1f 00 21 1c 	FMOV            S1 ,	R1
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a52e:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a532:	5a c0       	ADD       R3, R2, #1
8000a534:	1f 00 62 1c 	FMOV            S2 ,	R3
8000a538:	4e 43       	LD        R3, [PC + #78]        ;->0x8000a670  :=0xf000f438
8000a53a:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a53e:	33 82       	LD.W      R3, [R3]
8000a540:	29 00 41 04 	FMUL.F32        S1 , 	S2 , 	S1 
8000a544:	98 7c       	LSR       R3, #8			;->0x08
8000a546:	35 69       	ANL       R3, R5
8000a548:	6b c0       	ADD       R5, R3, #1
8000a54a:	1f 00 a2 1c 	FMOV            S2 ,	R5
8000a54e:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a552:	49 45       	LD        R5, [PC + #73]        ;->0x8000a674  :=0x80001030
##@@@P_:kf32a13k_hw_clk.c:793
##@@@L0788_: */   
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
8000a554:	22 7a       	LSL       R4, #2			;->0x02
8000a556:	2f 00 a3 90 	FLD.W           S3 , 	[ R5  + R4  ]
8000a55a:	29 00 21 08 	FMUL.F32        S1 , 	S1 , 	S2 
##@@@P_:kf32a13k_hw_clk.c:795
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0795_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a55e:	29 00 61 04 	FMUL.F32        S1 , 	S3 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:796
##@@@L0796_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K3CLKDIV + 1) * k3divider);   
8000a562:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:794
##@@@L0789_:float Clk_Hw_GetPerPLL2Frequency(void)   
##@@@L0790_:{   
##@@@L0791_:    float freq;   
##@@@L0792_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0793_:    float k3divider = (CLK_PTR->PERPLL_CTL0.bits.DIVBYEN ? 2.0 : 1.6);   
##@@@L0794_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a566:	74 04       	SJMP      $+116                 ;->0x8000a64e
##@@@F_:Clk_Hw_GetFsource2Frequency():
8000a568:	44 45       	LD        R5, [PC + #68]        ;->0x8000a678  :=0x80001068
8000a56a:	04 04       	SJMP      $+4                   ;->0x8000a572
8000a56c:	44 45       	LD        R5, [PC + #68]        ;->0x8000a67c  :=0x80001064
8000a56e:	02 04       	SJMP      $+2                   ;->0x8000a572
8000a570:	44 45       	LD        R5, [PC + #68]        ;->0x8000a680  :=0x8000106c
8000a572:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
8000a576:	6c 04       	SJMP      $+108                 ;->0x8000a64e
8000a578:	3a 44       	LD        R4, [PC + #58]        ;->0x8000a660  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a57a:	34 82       	LD.W      R3, [R4]
##@@@F_:Clk_Hw_GetSysPLLFrequency():
##@@@P_:kf32a13k_hw_clk.c:757
##@@@L0752_: */   
##@@@L0753_:float Clk_Hw_GetSysPLLFrequency(void)   
##@@@L0754_:{   
##@@@L0755_:    float freq;   
##@@@L0756_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0757_:    if (CLK_PTR->SYSPLL_CTL0.bits.N > 0)   
8000a57c:	24 82       	LD.W      R2, [R4]
8000a57e:	42 41       	LD        R1, [PC + #66]        ;->0x8000a684  :=0xf0000
8000a580:	21 69       	ANL       R2, R1
8000a582:	20 38       	CMP       R2, #0			;->0x00
8000a584:	02 f1       	JNZ       $+2                   ;->0x8000a588
8000a586:	64 04       	SJMP      $+100                 ;->0x8000a64e
8000a588:	9c 7d       	LSR       R3, #28			;->0x1C
8000a58a:	2c 10       	MOV       R2, #12			;->0x000C
8000a58c:	32 69       	ANL       R3, R2
8000a58e:	37 42       	LD        R2, [PC + #55]        ;->0x8000a668  :=0x80001198
##@@@P_:kf32a13k_hw_clk.c:760
##@@@L0758_:    {   
##@@@L0759_:        /*TODO: 确认系统PLL的M和N参数是否需要+1操作*/   
##@@@L0760_:        freq = inputFreq / (float)(CLK_PTR->SYSPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->SYSPLL_CTL0.bits.M) /   
8000a590:	14 82       	LD.W      R1, [R4]
8000a592:	2f 00 40 8c 	FLD.W           S0 , 	[ R2  + R3  ]
8000a596:	0c 7d       	LSR       R1, #20			;->0x14
8000a598:	31 10       	MOV       R3, #1			;->0x0001
8000a59a:	13 69       	ANL       R1, R3
8000a59c:	59 c0       	ADD       R3, R1, #1
8000a59e:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a5a2:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a5a6:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a5aa:	34 82       	LD.W      R3, [R4]
8000a5ac:	30 42       	LD        R2, [PC + #48]        ;->0x8000a66c  :=0x3fff
8000a5ae:	32 69       	ANL       R3, R2
8000a5b0:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a5b4:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
##@@@P_:kf32a13k_hw_clk.c:761
##@@@L0761_:               (float)(CLK_PTR->SYSPLL_CTL0.bits.N) / (float)(CLK_PTR->SYSPLL_CTL1.bits.K2CLKDIV + 1);   
8000a5b8:	44 82       	LD.W      R4, [R4]
8000a5ba:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a5be:	20 7d       	LSR       R4, #16			;->0x10
8000a5c0:	3f 10       	MOV       R3, #15			;->0x000F
8000a5c2:	43 69       	ANL       R4, R3
8000a5c4:	1f 00 81 1c 	FMOV            S1 ,	R4
8000a5c8:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a5cc:	2f 44       	LD        R4, [PC + #47]        ;->0x8000a688  :=0xf000f428
8000a5ce:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a5d2:	44 82       	LD.W      R4, [R4]
8000a5d4:	45 69       	ANL       R4, R5
8000a5d6:	6c c0       	ADD       R5, R4, #1
8000a5d8:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a5dc:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a5e0:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a5e4:	35 04       	SJMP      $+53                  ;->0x8000a64e
##@@@F_:Clk_Hw_GetFsource2Frequency():
8000a5e6:	1f 44       	LD        R4, [PC + #31]        ;->0x8000a660  :=0xf000f424
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a5e8:	24 82       	LD.W      R2, [R4]
8000a5ea:	94 7d       	LSR       R2, #28			;->0x1C
8000a5ec:	1e 41       	LD        R1, [PC + #30]        ;->0x8000a664  :=0xf000f434
8000a5ee:	0c 10       	MOV       R0, #12			;->0x000C
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a5f0:	31 82       	LD.W      R3, [R1]
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a5f2:	41 82       	LD.W      R4, [R1]
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a5f4:	20 69       	ANL       R2, R0
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a5f6:	21 7d       	LSR       R4, #17			;->0x11
8000a5f8:	01 10       	MOV       R0, #1			;->0x0001
8000a5fa:	11 82       	LD.W      R1, [R1]
8000a5fc:	40 69       	ANL       R4, R0
8000a5fe:	88 7d       	LSR       R1, #24			;->0x18
8000a600:	0f 10       	MOV       R0, #15			;->0x000F
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a602:	1a 46       	LD        R6, [PC + #26]        ;->0x8000a668  :=0x80001198
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a604:	10 69       	ANL       R1, R0
##@@@F_:Clk_Hw_GetPLLClockSourceFrequency():
8000a606:	2f 00 c0 88 	FLD.W           S0 , 	[ R6  + R2  ]
##@@@P_:kf32a13k_hw_clk.c:728
##@@@L0723_: * @retval 时钟频率，单位Hz   
##@@@L0724_: */   
##@@@L0725_:float Clk_Hw_GetPLLClockSourceFrequency(void)   
##@@@L0726_:{   
##@@@L0727_:    float freq;   
##@@@L0728_:    switch ((Clk_PLLClockSource_t)CLK_PTR->SYSPLL_CTL0.bits.INCLKSEL)   
8000a60a:	19 42       	LD        R2, [PC + #25]        ;->0x8000a66c  :=0x3fff
##@@@F_:Clk_Hw_GetPerPLL1Frequency():
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a60c:	1a 7c       	LSR       R3, #2			;->0x02
8000a60e:	32 69       	ANL       R3, R2
8000a610:	5b c0       	ADD       R3, R3, #1
8000a612:	1f 00 61 1c 	FMOV            S1 ,	R3
8000a616:	1f 00 21 58 	FCVTR.F32.S32  S1 ,	S1
8000a61a:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000a61e:	1f 00 21 1c 	FMOV            S1 ,	R1
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a622:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a626:	64 c0       	ADD       R4, R4, #1
8000a628:	1f 00 82 1c 	FMOV            S2 ,	R4
8000a62c:	11 44       	LD        R4, [PC + #17]        ;->0x8000a670  :=0xf000f438
8000a62e:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
##@@@P_:kf32a13k_hw_clk.c:780
##@@@L0780_:            (float)(CLK_PTR->PERPLL_CTL1.bits.K2CLKDIV + 1));   
8000a632:	44 82       	LD.W      R4, [R4]
8000a634:	29 00 41 04 	FMUL.F32        S1 , 	S2 , 	S1 
8000a638:	45 69       	ANL       R4, R5
8000a63a:	6c c0       	ADD       R5, R4, #1
8000a63c:	1f 00 a2 1c 	FMOV            S2 ,	R5
8000a640:	1f 00 42 58 	FCVTR.F32.S32  S2 ,	S2
8000a644:	29 00 21 08 	FMUL.F32        S1 , 	S1 , 	S2 
##@@@P_:kf32a13k_hw_clk.c:779
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
##@@@L0779_:           ((float)(CLK_PTR->PERPLL_CTL0.bits.PLLDIV + 1) * (float)(CLK_PTR->PERPLL_CTL0.bits.N) *   
8000a648:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
##@@@P_:kf32a13k_hw_clk.c:778
##@@@L0773_: */   
##@@@L0774_:float Clk_Hw_GetPerPLL1Frequency(void)   
##@@@L0775_:{   
##@@@L0776_:    float freq;   
##@@@L0777_:    float inputFreq = Clk_Hw_GetPLLClockSourceFrequency();   
##@@@L0778_:    freq            = inputFreq * (float)(CLK_PTR->PERPLL_CTL0.bits.M + 1) /   
8000a64c:	01 04       	SJMP      $+1                   ;->0x8000a64e
##@@@F_:Clk_Hw_GetFsource2Frequency():
##@@@P_:kf32a13k_hw_clk.c:912
##@@@L0907_:    default:   
##@@@L0908_:        /* Reserved values, this */   
##@@@L0909_:        freq = 0.0;   
##@@@L0910_:        break;   
##@@@L0911_:    }   
##@@@L0912_:    return freq;   
8000a64e:	e4 28       	ADD       SP, #4			;->0x04
8000a650:	03 5e       	POP       {R6-R7}
8000a652:	1d 5c       	JMP       LR
8000a654:	3c f4 00 f0 	.long     0xf000f43c ->-268372932  [!!!@2@:JMI       $+60                  ;->0x8000a6cc	@@: JZ        $+0                   ;->0x8000a654
8000a658:	60 10 00 80 	.long     0x80001060 ->-2147479456  [!!!@2@:MOV       R6, #0	@@: LD.B      R0, [R0]
8000a65c:	f8 10 00 80 	.long     0x800010f8 ->-2147479304  [!!!@2@:MOV       PC, #8	@@: LD.B      R0, [R0]
8000a660:	24 f4 00 f0 	.long     0xf000f424 ->-268372956  [!!!@2@:JMI       $+36                  ;->0x8000a6a8	@@: JZ        $+0                   ;->0x8000a660
8000a664:	34 f4 00 f0 	.long     0xf000f434 ->-268372940  [!!!@2@:JMI       $+52                  ;->0x8000a6cc	@@: JZ        $+0                   ;->0x8000a664
8000a668:	98 11 00 80 	.long     0x80001198 ->-2147479144  [!!!@2@:MOV       R9, #24	@@: LD.B      R0, [R0]
8000a66c:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
8000a670:	38 f4 00 f0 	.long     0xf000f438 ->-268372936  [!!!@2@:JMI       $+56                  ;->0x8000a6e0	@@: JZ        $+0                   ;->0x8000a670
8000a674:	30 10 00 80 	.long     0x80001030 ->-2147479504  [!!!@2@:MOV       R3, #0	@@: LD.B      R0, [R0]
8000a678:	68 10 00 80 	.long     0x80001068 ->-2147479448  [!!!@2@:MOV       R6, #8	@@: LD.B      R0, [R0]
8000a67c:	64 10 00 80 	.long     0x80001064 ->-2147479452  [!!!@2@:MOV       R6, #4	@@: LD.B      R0, [R0]
8000a680:	6c 10 00 80 	.long     0x8000106c ->-2147479444  [!!!@2@:MOV       R6, #12	@@: LD.B      R0, [R0]
8000a684:	00 00 0f 00 	.long     0x000f0000 ->000983040 
8000a688:	28 f4 00 f0 	.long     0xf000f428 ->-268372952  [!!!@2@:JMI       $+40                  ;->0x8000a6d8	@@: JZ        $+0                   ;->0x8000a688

8000a68c <Clk_Hw_GetSysClkFrequency>:
##@@@F_:Clk_Hw_GetSysClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:923
##@@@L0918_: *   
##@@@L0919_: * @param   
##@@@L0920_: * @retval   
##@@@L0921_: */   
##@@@L0922_:float Clk_Hw_GetSysClkFrequency(void)   
##@@@L0923_:{   
8000a68c:	81 5f       	PUSH      {R6,LR}
8000a68e:	e4 30       	SUB       SP, #4			;->0x04
8000a690:	0d 46       	LD        R6, [PC + #13]        ;->0x8000a6c4  :=0xf000f440
##@@@P_:kf32a13k_hw_clk.c:924
##@@@L0924_:    return (CLK_PTR->CDU_CTL0.bits.SYSCLKDIV > 0   
8000a692:	56 82       	LD.W      R5, [R6]
8000a694:	40 1f       	MOV       R4, #240			;->0x00F0
8000a696:	54 69       	ANL       R5, R4
8000a698:	50 38       	CMP       R5, #0			;->0x00
8000a69a:	0e f0       	JZ        $+14                  ;->0x8000a6b6
##@@@P_:kf32a13k_hw_clk.c:925
##@@@L0925_:              ? Clk_Hw_GetFsource0Frequency() / (float)CLK_PTR->CDU_CTL0.bits.SYSCLKDIV   
8000a69c:	0b 45       	LD        R5, [PC + #11]        ;->0x8000a6c8  :=0x8000a10c
8000a69e:	05 5c       	LJMP      R5
8000a6a0:	56 82       	LD.W      R5, [R6]
8000a6a2:	2c 7c       	LSR       R5, #4			;->0x04
8000a6a4:	4f 10       	MOV       R4, #15			;->0x000F
8000a6a6:	54 69       	ANL       R5, R4
8000a6a8:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a6ac:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a6b0:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a6b4:	04 04       	SJMP      $+4                   ;->0x8000a6bc
8000a6b6:	06 45       	LD        R5, [PC + #6]         ;->0x8000a6cc  :=0x80001070
8000a6b8:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:924
##@@@L0919_: * @param   
##@@@L0920_: * @retval   
##@@@L0921_: */   
##@@@L0922_:float Clk_Hw_GetSysClkFrequency(void)   
##@@@L0923_:{   
##@@@L0924_:    return (CLK_PTR->CDU_CTL0.bits.SYSCLKDIV > 0   
8000a6bc:	e4 28       	ADD       SP, #4			;->0x04
8000a6be:	06 5d       	POP       R6
8000a6c0:	0d 5d       	POP       LR
8000a6c2:	1d 5c       	JMP       LR
8000a6c4:	40 f4 00 f0 	.long     0xf000f440 ->-268372928  [!!!@2@:JMI       $+64                  ;->0x8000a744	@@: JZ        $+0                   ;->0x8000a6c4
8000a6c8:	0c a1 00 80 	.long     0x8000a10c ->-2147442420  [!!!@2@:ST.W      [R1 + #4], R4	@@: LD.B      R0, [R0]
8000a6cc:	70 10 00 80 	.long     0x80001070 ->-2147479440  [!!!@2@:MOV       R7, #0	@@: LD.B      R0, [R0]

8000a6d0 <Clk_Hw_GetPeriClkFrequency>:
##@@@F_:Clk_Hw_GetPeriClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:937
##@@@L0932_: *   
##@@@L0933_: * @param   
##@@@L0934_: * @retval   
##@@@L0935_: */   
##@@@L0936_:float Clk_Hw_GetPeriClkFrequency(void)   
##@@@L0937_:{   
8000a6d0:	81 5f       	PUSH      {R6,LR}
8000a6d2:	e4 30       	SUB       SP, #4			;->0x04
8000a6d4:	0d 46       	LD        R6, [PC + #13]        ;->0x8000a708  :=0xf000f440
##@@@P_:kf32a13k_hw_clk.c:938
##@@@L0938_:    return (CLK_PTR->CDU_CTL0.bits.PERICLKDIV > 1   
8000a6d6:	56 82       	LD.W      R5, [R6]
8000a6d8:	4e 10       	MOV       R4, #14			;->0x000E
8000a6da:	54 69       	ANL       R5, R4
8000a6dc:	50 38       	CMP       R5, #0			;->0x00
8000a6de:	0d f0       	JZ        $+13                  ;->0x8000a6f8
##@@@P_:kf32a13k_hw_clk.c:939
##@@@L0939_:              ? Clk_Hw_GetFsource0Frequency() / (float)CLK_PTR->CDU_CTL0.bits.PERICLKDIV   
8000a6e0:	0b 45       	LD        R5, [PC + #11]        ;->0x8000a70c  :=0x8000a10c
8000a6e2:	05 5c       	LJMP      R5
8000a6e4:	56 82       	LD.W      R5, [R6]
8000a6e6:	4f 10       	MOV       R4, #15			;->0x000F
8000a6e8:	54 69       	ANL       R5, R4
8000a6ea:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a6ee:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a6f2:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a6f6:	04 04       	SJMP      $+4                   ;->0x8000a6fe
8000a6f8:	06 45       	LD        R5, [PC + #6]         ;->0x8000a710  :=0x80001074
8000a6fa:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:938
##@@@L0933_: * @param   
##@@@L0934_: * @retval   
##@@@L0935_: */   
##@@@L0936_:float Clk_Hw_GetPeriClkFrequency(void)   
##@@@L0937_:{   
##@@@L0938_:    return (CLK_PTR->CDU_CTL0.bits.PERICLKDIV > 1   
8000a6fe:	e4 28       	ADD       SP, #4			;->0x04
8000a700:	06 5d       	POP       R6
8000a702:	0d 5d       	POP       LR
8000a704:	1d 5c       	JMP       LR
8000a706:	00 00       	NOP      NOP      
8000a708:	40 f4 00 f0 	.long     0xf000f440 ->-268372928  [!!!@2@:JMI       $+64                  ;->0x8000a788	@@: JZ        $+0                   ;->0x8000a708
8000a70c:	0c a1 00 80 	.long     0x8000a10c ->-2147442420  [!!!@2@:ST.W      [R1 + #4], R4	@@: LD.B      R0, [R0]
8000a710:	74 10 00 80 	.long     0x80001074 ->-2147479436  [!!!@2@:MOV       R7, #4	@@: LD.B      R0, [R0]

8000a714 <Clk_Hw_GetSystickClkFrequency>:
##@@@F_:Clk_Hw_GetSystickClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:951
##@@@L0946_: *   
##@@@L0947_: * @param   
##@@@L0948_: * @retval   
##@@@L0949_: */   
##@@@L0950_:float Clk_Hw_GetSystickClkFrequency(void)   
##@@@L0951_:{   
8000a714:	83 5f       	PUSH      {R6-R7,LR}
8000a716:	e4 30       	SUB       SP, #4			;->0x04
8000a718:	0c 46       	LD        R6, [PC + #12]        ;->0x8000a748  :=0xf000f444
##@@@P_:kf32a13k_hw_clk.c:953
##@@@L0952_:    return (   
##@@@L0953_:      CLK_PTR->CDU_CTL1.bits.STCLKDIV > 0 ? Clk_Hw_GetFsource0Frequency() / (float)CLK_PTR->CDU_CTL1.bits.STCLKDIV : 0);   
8000a71a:	56 82       	LD.W      R5, [R6]
8000a71c:	7f 10       	MOV       R7, #15			;->0x000F
8000a71e:	57 69       	ANL       R5, R7
8000a720:	50 38       	CMP       R5, #0			;->0x00
8000a722:	0c f0       	JZ        $+12                  ;->0x8000a73a
8000a724:	0a 45       	LD        R5, [PC + #10]        ;->0x8000a74c  :=0x8000a10c
8000a726:	05 5c       	LJMP      R5
8000a728:	56 82       	LD.W      R5, [R6]
8000a72a:	57 69       	ANL       R5, R7
8000a72c:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a730:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a734:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a738:	04 04       	SJMP      $+4                   ;->0x8000a740
8000a73a:	06 45       	LD        R5, [PC + #6]         ;->0x8000a750  :=0x80001078
8000a73c:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:952
##@@@L0947_: * @param   
##@@@L0948_: * @retval   
##@@@L0949_: */   
##@@@L0950_:float Clk_Hw_GetSystickClkFrequency(void)   
##@@@L0951_:{   
##@@@L0952_:    return (   
8000a740:	e4 28       	ADD       SP, #4			;->0x04
8000a742:	03 5e       	POP       {R6-R7}
8000a744:	0d 5d       	POP       LR
8000a746:	1d 5c       	JMP       LR
8000a748:	44 f4 00 f0 	.long     0xf000f444 ->-268372924  [!!!@2@:JMI       $+68                  ;->0x8000a7d0	@@: JZ        $+0                   ;->0x8000a748
8000a74c:	0c a1 00 80 	.long     0x8000a10c ->-2147442420  [!!!@2@:ST.W      [R1 + #4], R4	@@: LD.B      R0, [R0]
8000a750:	78 10 00 80 	.long     0x80001078 ->-2147479432  [!!!@2@:MOV       R7, #8	@@: LD.B      R0, [R0]

8000a754 <Clk_Hw_GetCanHFrequency>:
##@@@F_:Clk_Hw_GetCanHFrequency():
##@@@P_:kf32a13k_hw_clk.c:964
##@@@L0959_: *   
##@@@L0960_: * @param   
##@@@L0961_: * @retval   
##@@@L0962_: */   
##@@@L0963_:float Clk_Hw_GetCanHFrequency(void)   
##@@@L0964_:{   
8000a754:	81 5f       	PUSH      {R6,LR}
8000a756:	e4 30       	SUB       SP, #4			;->0x04
8000a758:	0d 46       	LD        R6, [PC + #13]        ;->0x8000a78c  :=0xf000f444
##@@@P_:kf32a13k_hw_clk.c:965
##@@@L0965_:    return (CLK_PTR->CDU_CTL1.bits.CANHCLKDIV > 0   
8000a75a:	56 82       	LD.W      R5, [R6]
8000a75c:	40 1f       	MOV       R4, #240			;->0x00F0
8000a75e:	54 69       	ANL       R5, R4
8000a760:	50 38       	CMP       R5, #0			;->0x00
8000a762:	0e f0       	JZ        $+14                  ;->0x8000a77e
##@@@P_:kf32a13k_hw_clk.c:966
##@@@L0966_:              ? Clk_Hw_GetFsource0Frequency() / (float)CLK_PTR->CDU_CTL1.bits.CANHCLKDIV   
8000a764:	0b 45       	LD        R5, [PC + #11]        ;->0x8000a790  :=0x8000a10c
8000a766:	05 5c       	LJMP      R5
8000a768:	56 82       	LD.W      R5, [R6]
8000a76a:	2c 7c       	LSR       R5, #4			;->0x04
8000a76c:	4f 10       	MOV       R4, #15			;->0x000F
8000a76e:	54 69       	ANL       R5, R4
8000a770:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a774:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a778:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a77c:	04 04       	SJMP      $+4                   ;->0x8000a784
8000a77e:	06 45       	LD        R5, [PC + #6]         ;->0x8000a794  :=0x8000107c
8000a780:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:965
##@@@L0960_: * @param   
##@@@L0961_: * @retval   
##@@@L0962_: */   
##@@@L0963_:float Clk_Hw_GetCanHFrequency(void)   
##@@@L0964_:{   
##@@@L0965_:    return (CLK_PTR->CDU_CTL1.bits.CANHCLKDIV > 0   
8000a784:	e4 28       	ADD       SP, #4			;->0x04
8000a786:	06 5d       	POP       R6
8000a788:	0d 5d       	POP       LR
8000a78a:	1d 5c       	JMP       LR
8000a78c:	44 f4 00 f0 	.long     0xf000f444 ->-268372924  [!!!@2@:JMI       $+68                  ;->0x8000a814	@@: JZ        $+0                   ;->0x8000a78c
8000a790:	0c a1 00 80 	.long     0x8000a10c ->-2147442420  [!!!@2@:ST.W      [R1 + #4], R4	@@: LD.B      R0, [R0]
8000a794:	7c 10 00 80 	.long     0x8000107c ->-2147479428  [!!!@2@:MOV       R7, #12	@@: LD.B      R0, [R0]

8000a798 <Clk_Hw_GetRefClk1Frequency>:
##@@@F_:Clk_Hw_GetRefClk1Frequency():
##@@@P_:kf32a13k_hw_clk.c:978
##@@@L0973_: *   
##@@@L0974_: * @param   
##@@@L0975_: * @retval   
##@@@L0976_: */   
##@@@L0977_:float Clk_Hw_GetRefClk1Frequency(void)   
##@@@L0978_:{   
8000a798:	81 5f       	PUSH      {R6,LR}
8000a79a:	e4 30       	SUB       SP, #4			;->0x04
8000a79c:	0d 46       	LD        R6, [PC + #13]        ;->0x8000a7d0  :=0xf000f444
##@@@P_:kf32a13k_hw_clk.c:979
##@@@L0979_:    return (CLK_PTR->CDU_CTL1.bits.REFCLK1CLKDIV > 0   
8000a79e:	56 82       	LD.W      R5, [R6]
8000a7a0:	0d 44       	LD        R4, [PC + #13]        ;->0x8000a7d4  :=0x1f00
8000a7a2:	54 69       	ANL       R5, R4
8000a7a4:	50 38       	CMP       R5, #0			;->0x00
8000a7a6:	0e f0       	JZ        $+14                  ;->0x8000a7c2
##@@@P_:kf32a13k_hw_clk.c:980
##@@@L0980_:              ? Clk_Hw_GetFsource0Frequency() / (float)CLK_PTR->CDU_CTL1.bits.REFCLK1CLKDIV   
8000a7a8:	0c 45       	LD        R5, [PC + #12]        ;->0x8000a7d8  :=0x8000a10c
8000a7aa:	05 5c       	LJMP      R5
8000a7ac:	56 82       	LD.W      R5, [R6]
8000a7ae:	a8 7c       	LSR       R5, #8			;->0x08
8000a7b0:	4f 11       	MOV       R4, #31			;->0x001F
8000a7b2:	54 69       	ANL       R5, R4
8000a7b4:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a7b8:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a7bc:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a7c0:	04 04       	SJMP      $+4                   ;->0x8000a7c8
8000a7c2:	07 45       	LD        R5, [PC + #7]         ;->0x8000a7dc  :=0x80001080
8000a7c4:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:979
##@@@L0974_: * @param   
##@@@L0975_: * @retval   
##@@@L0976_: */   
##@@@L0977_:float Clk_Hw_GetRefClk1Frequency(void)   
##@@@L0978_:{   
##@@@L0979_:    return (CLK_PTR->CDU_CTL1.bits.REFCLK1CLKDIV > 0   
8000a7c8:	e4 28       	ADD       SP, #4			;->0x04
8000a7ca:	06 5d       	POP       R6
8000a7cc:	0d 5d       	POP       LR
8000a7ce:	1d 5c       	JMP       LR
8000a7d0:	44 f4 00 f0 	.long     0xf000f444 ->-268372924  [!!!@2@:JMI       $+68                  ;->0x8000a858	@@: JZ        $+0                   ;->0x8000a7d0
8000a7d4:	00 1f 00 00 	.long     0x00001f00 ->000007936  [!!!@2@:MOV       R0, #240	@@: NOP      
8000a7d8:	0c a1 00 80 	.long     0x8000a10c ->-2147442420  [!!!@2@:ST.W      [R1 + #4], R4	@@: LD.B      R0, [R0]
8000a7dc:	80 10 00 80 	.long     0x80001080 ->-2147479424  [!!!@2@:MOV       R8, #0	@@: LD.B      R0, [R0]

8000a7e0 <Clk_Hw_GetRefClk2Frequency>:
##@@@F_:Clk_Hw_GetRefClk2Frequency():
##@@@P_:kf32a13k_hw_clk.c:992
##@@@L0987_: *   
##@@@L0988_: * @param   
##@@@L0989_: * @retval   
##@@@L0990_: */   
##@@@L0991_:float Clk_Hw_GetRefClk2Frequency(void)   
##@@@L0992_:{   
8000a7e0:	81 5f       	PUSH      {R6,LR}
8000a7e2:	e4 30       	SUB       SP, #4			;->0x04
8000a7e4:	12 46       	LD        R6, [PC + #18]        ;->0x8000a82c  :=0xf000f444
##@@@P_:kf32a13k_hw_clk.c:994
##@@@L0993_:    float ret = 0;   
##@@@L0994_:    if (CLK_PTR->CDU_CTL1.bits.REFCLK2SEL)   
8000a7e6:	46 82       	LD.W      R4, [R6]
8000a7e8:	56 82       	LD.W      R5, [R6]
8000a7ea:	12 43       	LD        R3, [PC + #18]        ;->0x8000a830  :=0x3e000
8000a7ec:	12 42       	LD        R2, [PC + #18]        ;->0x8000a834  :=0x40000
8000a7ee:	53 69       	ANL       R5, R3
8000a7f0:	42 69       	ANL       R4, R2
8000a7f2:	40 38       	CMP       R4, #0			;->0x00
8000a7f4:	06 f1       	JNZ       $+6                   ;->0x8000a800
##@@@P_:kf32a13k_hw_clk.c:1002
##@@@L0997_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL1.bits.REFCLK2CLKDIV   
##@@@L0998_:                 : 0);   
##@@@L0999_:    }   
##@@@L1000_:    else   
##@@@L1001_:    {   
##@@@L1002_:        ret = (CLK_PTR->CDU_CTL1.bits.REFCLK2CLKDIV > 0   
8000a7f6:	50 38       	CMP       R5, #0			;->0x00
8000a7f8:	13 f0       	JZ        $+19                  ;->0x8000a81e
##@@@P_:kf32a13k_hw_clk.c:1003
##@@@L1003_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL1.bits.REFCLK2CLKDIV   
8000a7fa:	10 45       	LD        R5, [PC + #16]        ;->0x8000a838  :=0x8000a4c4
8000a7fc:	05 5c       	LJMP      R5
8000a7fe:	05 04       	SJMP      $+5                   ;->0x8000a808
##@@@P_:kf32a13k_hw_clk.c:996
##@@@L0991_:float Clk_Hw_GetRefClk2Frequency(void)   
##@@@L0992_:{   
##@@@L0993_:    float ret = 0;   
##@@@L0994_:    if (CLK_PTR->CDU_CTL1.bits.REFCLK2SEL)   
##@@@L0995_:    {   
##@@@L0996_:        ret = (CLK_PTR->CDU_CTL1.bits.REFCLK2CLKDIV > 0   
8000a800:	50 38       	CMP       R5, #0			;->0x00
8000a802:	0e f0       	JZ        $+14                  ;->0x8000a81e
##@@@P_:kf32a13k_hw_clk.c:997
##@@@L0997_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL1.bits.REFCLK2CLKDIV   
8000a804:	0e 45       	LD        R5, [PC + #14]        ;->0x8000a83c  :=0x8000a2d4
8000a806:	05 5c       	LJMP      R5
8000a808:	56 82       	LD.W      R5, [R6]
8000a80a:	ad 7c       	LSR       R5, #13			;->0x0D
8000a80c:	4f 11       	MOV       R4, #31			;->0x001F
8000a80e:	54 69       	ANL       R5, R4
8000a810:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a814:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a818:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a81c:	04 04       	SJMP      $+4                   ;->0x8000a824
8000a81e:	09 45       	LD        R5, [PC + #9]         ;->0x8000a840  :=0x80001084
8000a820:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1006
##@@@L1001_:    {   
##@@@L1002_:        ret = (CLK_PTR->CDU_CTL1.bits.REFCLK2CLKDIV > 0   
##@@@L1003_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL1.bits.REFCLK2CLKDIV   
##@@@L1004_:                 : 0);   
##@@@L1005_:    }   
##@@@L1006_:    return ret;   
8000a824:	e4 28       	ADD       SP, #4			;->0x04
8000a826:	06 5d       	POP       R6
8000a828:	0d 5d       	POP       LR
8000a82a:	1d 5c       	JMP       LR
8000a82c:	44 f4 00 f0 	.long     0xf000f444 ->-268372924  [!!!@2@:JMI       $+68                  ;->0x8000a8b4	@@: JZ        $+0                   ;->0x8000a82c
8000a830:	00 e0 03 00 	.long     0x0003e000 ->000253952 
8000a834:	00 00 04 00 	.long     0x00040000 ->000262144 
8000a838:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000a83c:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000a840:	84 10 00 80 	.long     0x80001084 ->-2147479420  [!!!@2@:MOV       R8, #4	@@: LD.B      R0, [R0]

8000a844 <Clk_Hw_GetMscClkFrequency>:
##@@@F_:Clk_Hw_GetMscClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:1017
##@@@L1012_: *   
##@@@L1013_: * @param   
##@@@L1014_: * @retval   
##@@@L1015_: */   
##@@@L1016_:float Clk_Hw_GetMscClkFrequency(void)   
##@@@L1017_:{   
8000a844:	81 5f       	PUSH      {R6,LR}
8000a846:	e4 30       	SUB       SP, #4			;->0x04
8000a848:	12 46       	LD        R6, [PC + #18]        ;->0x8000a890  :=0xf000f444
##@@@P_:kf32a13k_hw_clk.c:1019
##@@@L1018_:    float ret = 0;   
##@@@L1019_:    if (CLK_PTR->CDU_CTL1.bits.MSCCLKSEL)   
8000a84a:	46 82       	LD.W      R4, [R6]
8000a84c:	56 82       	LD.W      R5, [R6]
8000a84e:	12 43       	LD        R3, [PC + #18]        ;->0x8000a894  :=0x780000
8000a850:	12 42       	LD        R2, [PC + #18]        ;->0x8000a898  :=0x800000
8000a852:	53 69       	ANL       R5, R3
8000a854:	42 69       	ANL       R4, R2
8000a856:	40 38       	CMP       R4, #0			;->0x00
8000a858:	06 f1       	JNZ       $+6                   ;->0x8000a864
##@@@P_:kf32a13k_hw_clk.c:1027
##@@@L1022_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL1.bits.MSCCLKDIV   
##@@@L1023_:                 : 0);   
##@@@L1024_:    }   
##@@@L1025_:    else   
##@@@L1026_:    {   
##@@@L1027_:        ret = (CLK_PTR->CDU_CTL1.bits.MSCCLKDIV > 0   
8000a85a:	50 38       	CMP       R5, #0			;->0x00
8000a85c:	13 f0       	JZ        $+19                  ;->0x8000a882
##@@@P_:kf32a13k_hw_clk.c:1028
##@@@L1028_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL1.bits.MSCCLKDIV   
8000a85e:	10 45       	LD        R5, [PC + #16]        ;->0x8000a89c  :=0x8000a4c4
8000a860:	05 5c       	LJMP      R5
8000a862:	05 04       	SJMP      $+5                   ;->0x8000a86c
##@@@P_:kf32a13k_hw_clk.c:1021
##@@@L1016_:float Clk_Hw_GetMscClkFrequency(void)   
##@@@L1017_:{   
##@@@L1018_:    float ret = 0;   
##@@@L1019_:    if (CLK_PTR->CDU_CTL1.bits.MSCCLKSEL)   
##@@@L1020_:    {   
##@@@L1021_:        ret = (CLK_PTR->CDU_CTL1.bits.MSCCLKDIV > 0   
8000a864:	50 38       	CMP       R5, #0			;->0x00
8000a866:	0e f0       	JZ        $+14                  ;->0x8000a882
##@@@P_:kf32a13k_hw_clk.c:1022
##@@@L1022_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL1.bits.MSCCLKDIV   
8000a868:	0e 45       	LD        R5, [PC + #14]        ;->0x8000a8a0  :=0x8000a2d4
8000a86a:	05 5c       	LJMP      R5
8000a86c:	56 82       	LD.W      R5, [R6]
8000a86e:	2b 7d       	LSR       R5, #19			;->0x13
8000a870:	4f 10       	MOV       R4, #15			;->0x000F
8000a872:	54 69       	ANL       R5, R4
8000a874:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a878:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a87c:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a880:	04 04       	SJMP      $+4                   ;->0x8000a888
8000a882:	09 45       	LD        R5, [PC + #9]         ;->0x8000a8a4  :=0x80001088
8000a884:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1031
##@@@L1026_:    {   
##@@@L1027_:        ret = (CLK_PTR->CDU_CTL1.bits.MSCCLKDIV > 0   
##@@@L1028_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL1.bits.MSCCLKDIV   
##@@@L1029_:                 : 0);   
##@@@L1030_:    }   
##@@@L1031_:    return ret;   
8000a888:	e4 28       	ADD       SP, #4			;->0x04
8000a88a:	06 5d       	POP       R6
8000a88c:	0d 5d       	POP       LR
8000a88e:	1d 5c       	JMP       LR
8000a890:	44 f4 00 f0 	.long     0xf000f444 ->-268372924  [!!!@2@:JMI       $+68                  ;->0x8000a918	@@: JZ        $+0                   ;->0x8000a890
8000a894:	00 00 78 00 	.long     0x00780000 ->007864320  [!!!@2@:NOP      	@@: ST.B      [R3 + #0], R24
8000a898:	00 00 80 00 	.long     0x00800000 ->008388608  [!!!@2@:NOP      	@@: LJMP      $+128                 ;->0x8000a998
8000a89c:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000a8a0:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000a8a4:	88 10 00 80 	.long     0x80001088 ->-2147479416  [!!!@2@:MOV       R8, #8	@@: LD.B      R0, [R0]

8000a8a8 <Clk_Hw_GetRtcClkFrequency>:
##@@@F_:Clk_Hw_GetRtcClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:1042
##@@@L1037_: *   
##@@@L1038_: * @param   
##@@@L1039_: * @retval   
##@@@L1040_: */   
##@@@L1041_:float Clk_Hw_GetRtcClkFrequency(void)   
##@@@L1042_:{   
8000a8a8:	09 45       	LD        R5, [PC + #9]         ;->0x8000a8cc  :=0xf000f444
##@@@P_:kf32a13k_hw_clk.c:1044
##@@@L1043_:    float ret = 0;   
##@@@L1044_:    if (CLK_PTR->CDU_CTL1.bits.RTCCLKSEL)   
8000a8aa:	45 82       	LD.W      R4, [R5]
8000a8ac:	35 82       	LD.W      R3, [R5]
8000a8ae:	09 42       	LD        R2, [PC + #9]         ;->0x8000a8d0  :=0xf000000
8000a8b0:	32 69       	ANL       R3, R2
8000a8b2:	30 38       	CMP       R3, #0			;->0x00
8000a8b4:	07 f0       	JZ        $+7                   ;->0x8000a8c2
8000a8b6:	08 43       	LD        R3, [PC + #8]         ;->0x8000a8d4  :=0x10000000
8000a8b8:	43 69       	ANL       R4, R3
8000a8ba:	40 38       	CMP       R4, #0			;->0x00
8000a8bc:	10 f0       	JZ        $+16                  ;->0x8000a8dc
8000a8be:	40 10       	MOV       R4, #0			;->0x0000
8000a8c0:	0f 04       	SJMP      $+15                  ;->0x8000a8de
8000a8c2:	06 45       	LD        R5, [PC + #6]         ;->0x8000a8d8  :=0x8000108c
8000a8c4:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1056
##@@@L1051_:    {   
##@@@L1052_:        ret = (CLK_PTR->CDU_CTL1.bits.RTCCLKDIV > 0   
##@@@L1053_:                 ? (float)CLK_XTAL_FREQUENCY / (float)CLK_PTR->CDU_CTL1.bits.RTCCLKDIV   
##@@@L1054_:                 : 0);   
##@@@L1055_:    }   
##@@@L1056_:    return ret;   
8000a8c8:	1d 5c       	JMP       LR
8000a8ca:	00 00       	NOP      NOP      
8000a8cc:	44 f4 00 f0 	.long     0xf000f444 ->-268372924  [!!!@2@:JMI       $+68                  ;->0x8000a954	@@: JZ        $+0                   ;->0x8000a8cc
8000a8d0:	00 00 00 0f 	.long     0x0f000000 ->251658240  [!!!@2@:NOP      	@@: LD.W      R7, [SP + #0]
8000a8d4:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
8000a8d8:	8c 10 00 80 	.long     0x8000108c ->-2147479412  [!!!@2@:MOV       R8, #12	@@: LD.B      R0, [R0]
8000a8dc:	41 10       	MOV       R4, #1			;->0x0001
8000a8de:	22 7a       	LSL       R4, #2			;->0x02
8000a8e0:	07 43       	LD        R3, [PC + #7]         ;->0x8000a8fc  :=0x80001038
8000a8e2:	55 82       	LD.W      R5, [R5]
8000a8e4:	2f 00 60 90 	FLD.W           S0 , 	[ R3  + R4  ]
8000a8e8:	a8 7d       	LSR       R5, #24			;->0x18
8000a8ea:	4f 10       	MOV       R4, #15			;->0x000F
8000a8ec:	54 69       	ANL       R5, R4
8000a8ee:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a8f2:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a8f6:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a8fa:	1d 5c       	JMP       LR
8000a8fc:	38 10 00 80 	.long     0x80001038 ->-2147479496  [!!!@2@:MOV       R3, #8	@@: LD.B      R0, [R0]

8000a900 <Clk_Hw_GetSpiClkFrequency>:
##@@@F_:Clk_Hw_GetSpiClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:1067
##@@@L1062_: *   
##@@@L1063_: * @param   
##@@@L1064_: * @retval   
##@@@L1065_: */   
##@@@L1066_:float Clk_Hw_GetSpiClkFrequency(void)   
##@@@L1067_:{   
8000a900:	83 5f       	PUSH      {R6-R7,LR}
8000a902:	e4 30       	SUB       SP, #4			;->0x04
8000a904:	11 46       	LD        R6, [PC + #17]        ;->0x8000a948  :=0xf000f448
##@@@P_:kf32a13k_hw_clk.c:1069
##@@@L1068_:    float ret = 0;   
##@@@L1069_:    if (CLK_PTR->CDU_CTL2.bits.SPICLKSEL)   
8000a906:	46 82       	LD.W      R4, [R6]
8000a908:	56 82       	LD.W      R5, [R6]
8000a90a:	7f 10       	MOV       R7, #15			;->0x000F
8000a90c:	57 69       	ANL       R5, R7
8000a90e:	30 11       	MOV       R3, #16			;->0x0010
8000a910:	43 69       	ANL       R4, R3
8000a912:	40 38       	CMP       R4, #0			;->0x00
8000a914:	06 f1       	JNZ       $+6                   ;->0x8000a920
##@@@P_:kf32a13k_hw_clk.c:1077
##@@@L1072_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.SPICLKDIV   
##@@@L1073_:                 : 0);   
##@@@L1074_:    }   
##@@@L1075_:    else   
##@@@L1076_:    {   
##@@@L1077_:        ret = (CLK_PTR->CDU_CTL2.bits.SPICLKDIV > 0   
8000a916:	50 38       	CMP       R5, #0			;->0x00
8000a918:	11 f0       	JZ        $+17                  ;->0x8000a93a
##@@@P_:kf32a13k_hw_clk.c:1078
##@@@L1078_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.SPICLKDIV   
8000a91a:	0d 45       	LD        R5, [PC + #13]        ;->0x8000a94c  :=0x8000a4c4
8000a91c:	05 5c       	LJMP      R5
8000a91e:	05 04       	SJMP      $+5                   ;->0x8000a928
##@@@P_:kf32a13k_hw_clk.c:1071
##@@@L1066_:float Clk_Hw_GetSpiClkFrequency(void)   
##@@@L1067_:{   
##@@@L1068_:    float ret = 0;   
##@@@L1069_:    if (CLK_PTR->CDU_CTL2.bits.SPICLKSEL)   
##@@@L1070_:    {   
##@@@L1071_:        ret = (CLK_PTR->CDU_CTL2.bits.SPICLKDIV > 0   
8000a920:	50 38       	CMP       R5, #0			;->0x00
8000a922:	0c f0       	JZ        $+12                  ;->0x8000a93a
##@@@P_:kf32a13k_hw_clk.c:1072
##@@@L1072_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.SPICLKDIV   
8000a924:	0b 45       	LD        R5, [PC + #11]        ;->0x8000a950  :=0x8000a2d4
8000a926:	05 5c       	LJMP      R5
8000a928:	56 82       	LD.W      R5, [R6]
8000a92a:	57 69       	ANL       R5, R7
8000a92c:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a930:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a934:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a938:	04 04       	SJMP      $+4                   ;->0x8000a940
8000a93a:	07 45       	LD        R5, [PC + #7]         ;->0x8000a954  :=0x80001090
8000a93c:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1081
##@@@L1076_:    {   
##@@@L1077_:        ret = (CLK_PTR->CDU_CTL2.bits.SPICLKDIV > 0   
##@@@L1078_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.SPICLKDIV   
##@@@L1079_:                 : 0);   
##@@@L1080_:    }   
##@@@L1081_:    return ret;   
8000a940:	e4 28       	ADD       SP, #4			;->0x04
8000a942:	03 5e       	POP       {R6-R7}
8000a944:	0d 5d       	POP       LR
8000a946:	1d 5c       	JMP       LR
8000a948:	48 f4 00 f0 	.long     0xf000f448 ->-268372920  [!!!@2@:JMI       $+72                  ;->0x8000a9d8	@@: JZ        $+0                   ;->0x8000a948
8000a94c:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000a950:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000a954:	90 10 00 80 	.long     0x80001090 ->-2147479408  [!!!@2@:MOV       R9, #0	@@: LD.B      R0, [R0]

8000a958 <Clk_Hw_GetAdcClkFrequency>:
##@@@F_:Clk_Hw_GetAdcClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:1092
##@@@L1087_: *   
##@@@L1088_: * @param   
##@@@L1089_: * @retval   
##@@@L1090_: */   
##@@@L1091_:float Clk_Hw_GetAdcClkFrequency(void)   
##@@@L1092_:{   
8000a958:	81 5f       	PUSH      {R6,LR}
8000a95a:	e4 30       	SUB       SP, #4			;->0x04
8000a95c:	12 46       	LD        R6, [PC + #18]        ;->0x8000a9a4  :=0xf000f448
##@@@P_:kf32a13k_hw_clk.c:1094
##@@@L1093_:    float ret = 0;   
##@@@L1094_:    if (CLK_PTR->CDU_CTL2.bits.ADCCLKSEL)   
8000a95e:	46 82       	LD.W      R4, [R6]
8000a960:	56 82       	LD.W      R5, [R6]
8000a962:	12 43       	LD        R3, [PC + #18]        ;->0x8000a9a8  :=0x1e0
8000a964:	12 42       	LD        R2, [PC + #18]        ;->0x8000a9ac  :=0x200
8000a966:	53 69       	ANL       R5, R3
8000a968:	42 69       	ANL       R4, R2
8000a96a:	40 38       	CMP       R4, #0			;->0x00
8000a96c:	06 f1       	JNZ       $+6                   ;->0x8000a978
##@@@P_:kf32a13k_hw_clk.c:1102
##@@@L1097_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.ADCCLKDIV   
##@@@L1098_:                 : 0);   
##@@@L1099_:    }   
##@@@L1100_:    else   
##@@@L1101_:    {   
##@@@L1102_:        ret = (CLK_PTR->CDU_CTL2.bits.ADCCLKDIV > 0   
8000a96e:	50 38       	CMP       R5, #0			;->0x00
8000a970:	13 f0       	JZ        $+19                  ;->0x8000a996
##@@@P_:kf32a13k_hw_clk.c:1103
##@@@L1103_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.ADCCLKDIV   
8000a972:	10 45       	LD        R5, [PC + #16]        ;->0x8000a9b0  :=0x8000a4c4
8000a974:	05 5c       	LJMP      R5
8000a976:	05 04       	SJMP      $+5                   ;->0x8000a980
##@@@P_:kf32a13k_hw_clk.c:1096
##@@@L1091_:float Clk_Hw_GetAdcClkFrequency(void)   
##@@@L1092_:{   
##@@@L1093_:    float ret = 0;   
##@@@L1094_:    if (CLK_PTR->CDU_CTL2.bits.ADCCLKSEL)   
##@@@L1095_:    {   
##@@@L1096_:        ret = (CLK_PTR->CDU_CTL2.bits.ADCCLKDIV > 0   
8000a978:	50 38       	CMP       R5, #0			;->0x00
8000a97a:	0e f0       	JZ        $+14                  ;->0x8000a996
##@@@P_:kf32a13k_hw_clk.c:1097
##@@@L1097_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.ADCCLKDIV   
8000a97c:	0e 45       	LD        R5, [PC + #14]        ;->0x8000a9b4  :=0x8000a2d4
8000a97e:	05 5c       	LJMP      R5
8000a980:	56 82       	LD.W      R5, [R6]
8000a982:	2d 7c       	LSR       R5, #5			;->0x05
8000a984:	4f 10       	MOV       R4, #15			;->0x000F
8000a986:	54 69       	ANL       R5, R4
8000a988:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a98c:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a990:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a994:	04 04       	SJMP      $+4                   ;->0x8000a99c
8000a996:	09 45       	LD        R5, [PC + #9]         ;->0x8000a9b8  :=0x80001094
8000a998:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1106
##@@@L1101_:    {   
##@@@L1102_:        ret = (CLK_PTR->CDU_CTL2.bits.ADCCLKDIV > 0   
##@@@L1103_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.ADCCLKDIV   
##@@@L1104_:                 : 0);   
##@@@L1105_:    }   
##@@@L1106_:    return ret;   
8000a99c:	e4 28       	ADD       SP, #4			;->0x04
8000a99e:	06 5d       	POP       R6
8000a9a0:	0d 5d       	POP       LR
8000a9a2:	1d 5c       	JMP       LR
8000a9a4:	48 f4 00 f0 	.long     0xf000f448 ->-268372920  [!!!@2@:JMI       $+72                  ;->0x8000aa34	@@: JZ        $+0                   ;->0x8000a9a4
8000a9a8:	e0 01 00 00 	.long     0x000001e0 ->000000480  [!!!@2@:CMN       SP, R0	@@: NOP      
8000a9ac:	00 02 00 00 	.long     0x00000200 ->000000512 
8000a9b0:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000a9b4:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000a9b8:	94 10 00 80 	.long     0x80001094 ->-2147479404  [!!!@2@:MOV       R9, #4	@@: LD.B      R0, [R0]

8000a9bc <Clk_Hw_GetI2CClkFrequency>:
##@@@F_:Clk_Hw_GetI2CClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:1117
##@@@L1112_: *   
##@@@L1113_: * @param   
##@@@L1114_: * @retval   
##@@@L1115_: */   
##@@@L1116_:float Clk_Hw_GetI2CClkFrequency(void)   
##@@@L1117_:{   
8000a9bc:	81 5f       	PUSH      {R6,LR}
8000a9be:	e4 30       	SUB       SP, #4			;->0x04
8000a9c0:	12 46       	LD        R6, [PC + #18]        ;->0x8000aa08  :=0xf000f448
##@@@P_:kf32a13k_hw_clk.c:1119
##@@@L1118_:    float ret = 0;   
##@@@L1119_:    if (CLK_PTR->CDU_CTL2.bits.ADCCLKSEL)   
8000a9c2:	46 82       	LD.W      R4, [R6]
8000a9c4:	56 82       	LD.W      R5, [R6]
8000a9c6:	12 43       	LD        R3, [PC + #18]        ;->0x8000aa0c  :=0x3c00
8000a9c8:	12 42       	LD        R2, [PC + #18]        ;->0x8000aa10  :=0x200
8000a9ca:	53 69       	ANL       R5, R3
8000a9cc:	42 69       	ANL       R4, R2
8000a9ce:	40 38       	CMP       R4, #0			;->0x00
8000a9d0:	06 f1       	JNZ       $+6                   ;->0x8000a9dc
##@@@P_:kf32a13k_hw_clk.c:1127
##@@@L1122_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.I2CCLKDIV   
##@@@L1123_:                 : 0);   
##@@@L1124_:    }   
##@@@L1125_:    else   
##@@@L1126_:    {   
##@@@L1127_:        ret = (CLK_PTR->CDU_CTL2.bits.I2CCLKDIV > 0   
8000a9d2:	50 38       	CMP       R5, #0			;->0x00
8000a9d4:	13 f0       	JZ        $+19                  ;->0x8000a9fa
##@@@P_:kf32a13k_hw_clk.c:1128
##@@@L1128_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.I2CCLKDIV   
8000a9d6:	10 45       	LD        R5, [PC + #16]        ;->0x8000aa14  :=0x8000a4c4
8000a9d8:	05 5c       	LJMP      R5
8000a9da:	05 04       	SJMP      $+5                   ;->0x8000a9e4
##@@@P_:kf32a13k_hw_clk.c:1121
##@@@L1116_:float Clk_Hw_GetI2CClkFrequency(void)   
##@@@L1117_:{   
##@@@L1118_:    float ret = 0;   
##@@@L1119_:    if (CLK_PTR->CDU_CTL2.bits.ADCCLKSEL)   
##@@@L1120_:    {   
##@@@L1121_:        ret = (CLK_PTR->CDU_CTL2.bits.I2CCLKDIV > 0   
8000a9dc:	50 38       	CMP       R5, #0			;->0x00
8000a9de:	0e f0       	JZ        $+14                  ;->0x8000a9fa
##@@@P_:kf32a13k_hw_clk.c:1122
##@@@L1122_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.I2CCLKDIV   
8000a9e0:	0e 45       	LD        R5, [PC + #14]        ;->0x8000aa18  :=0x8000a2d4
8000a9e2:	05 5c       	LJMP      R5
8000a9e4:	56 82       	LD.W      R5, [R6]
8000a9e6:	aa 7c       	LSR       R5, #10			;->0x0A
8000a9e8:	4f 10       	MOV       R4, #15			;->0x000F
8000a9ea:	54 69       	ANL       R5, R4
8000a9ec:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000a9f0:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000a9f4:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000a9f8:	04 04       	SJMP      $+4                   ;->0x8000aa00
8000a9fa:	09 45       	LD        R5, [PC + #9]         ;->0x8000aa1c  :=0x80001098
8000a9fc:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1131
##@@@L1126_:    {   
##@@@L1127_:        ret = (CLK_PTR->CDU_CTL2.bits.I2CCLKDIV > 0   
##@@@L1128_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.I2CCLKDIV   
##@@@L1129_:                 : 0);   
##@@@L1130_:    }   
##@@@L1131_:    return ret;   
8000aa00:	e4 28       	ADD       SP, #4			;->0x04
8000aa02:	06 5d       	POP       R6
8000aa04:	0d 5d       	POP       LR
8000aa06:	1d 5c       	JMP       LR
8000aa08:	48 f4 00 f0 	.long     0xf000f448 ->-268372920  [!!!@2@:JMI       $+72                  ;->0x8000aa98	@@: JZ        $+0                   ;->0x8000aa08
8000aa0c:	00 3c 00 00 	.long     0x00003c00 ->000015360  [!!!@2@:CMP       R0, #64	@@: NOP      
8000aa10:	00 02 00 00 	.long     0x00000200 ->000000512 
8000aa14:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000aa18:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000aa1c:	98 10 00 80 	.long     0x80001098 ->-2147479400  [!!!@2@:MOV       R9, #8	@@: LD.B      R0, [R0]

8000aa20 <Clk_Hw_GetCanClkFrequency>:
##@@@F_:Clk_Hw_GetCanClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:1142
##@@@L1137_: *   
##@@@L1138_: * @param   
##@@@L1139_: * @retval   
##@@@L1140_: */   
##@@@L1141_:float Clk_Hw_GetCanClkFrequency(void)   
##@@@L1142_:{   
8000aa20:	81 5f       	PUSH      {R6,LR}
8000aa22:	e4 30       	SUB       SP, #4			;->0x04
8000aa24:	12 46       	LD        R6, [PC + #18]        ;->0x8000aa6c  :=0xf000f448
##@@@P_:kf32a13k_hw_clk.c:1144
##@@@L1143_:    float ret = 0;   
##@@@L1144_:    if (CLK_PTR->CDU_CTL2.bits.CANCLKSEL)   
8000aa26:	46 82       	LD.W      R4, [R6]
8000aa28:	56 82       	LD.W      R5, [R6]
8000aa2a:	12 43       	LD        R3, [PC + #18]        ;->0x8000aa70  :=0x78000
8000aa2c:	12 42       	LD        R2, [PC + #18]        ;->0x8000aa74  :=0x80000
8000aa2e:	53 69       	ANL       R5, R3
8000aa30:	42 69       	ANL       R4, R2
8000aa32:	40 38       	CMP       R4, #0			;->0x00
8000aa34:	06 f1       	JNZ       $+6                   ;->0x8000aa40
##@@@P_:kf32a13k_hw_clk.c:1152
##@@@L1147_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.CANCLKDIV   
##@@@L1148_:                 : 0);   
##@@@L1149_:    }   
##@@@L1150_:    else   
##@@@L1151_:    {   
##@@@L1152_:        ret = (CLK_PTR->CDU_CTL2.bits.CANCLKDIV > 0   
8000aa36:	50 38       	CMP       R5, #0			;->0x00
8000aa38:	13 f0       	JZ        $+19                  ;->0x8000aa5e
##@@@P_:kf32a13k_hw_clk.c:1153
##@@@L1153_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.CANCLKDIV   
8000aa3a:	10 45       	LD        R5, [PC + #16]        ;->0x8000aa78  :=0x8000a4c4
8000aa3c:	05 5c       	LJMP      R5
8000aa3e:	05 04       	SJMP      $+5                   ;->0x8000aa48
##@@@P_:kf32a13k_hw_clk.c:1146
##@@@L1141_:float Clk_Hw_GetCanClkFrequency(void)   
##@@@L1142_:{   
##@@@L1143_:    float ret = 0;   
##@@@L1144_:    if (CLK_PTR->CDU_CTL2.bits.CANCLKSEL)   
##@@@L1145_:    {   
##@@@L1146_:        ret = (CLK_PTR->CDU_CTL2.bits.CANCLKDIV > 0   
8000aa40:	50 38       	CMP       R5, #0			;->0x00
8000aa42:	0e f0       	JZ        $+14                  ;->0x8000aa5e
##@@@P_:kf32a13k_hw_clk.c:1147
##@@@L1147_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.CANCLKDIV   
8000aa44:	0e 45       	LD        R5, [PC + #14]        ;->0x8000aa7c  :=0x8000a2d4
8000aa46:	05 5c       	LJMP      R5
8000aa48:	56 82       	LD.W      R5, [R6]
8000aa4a:	af 7c       	LSR       R5, #15			;->0x0F
8000aa4c:	4f 10       	MOV       R4, #15			;->0x000F
8000aa4e:	54 69       	ANL       R5, R4
8000aa50:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000aa54:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000aa58:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000aa5c:	04 04       	SJMP      $+4                   ;->0x8000aa64
8000aa5e:	09 45       	LD        R5, [PC + #9]         ;->0x8000aa80  :=0x8000109c
8000aa60:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1156
##@@@L1151_:    {   
##@@@L1152_:        ret = (CLK_PTR->CDU_CTL2.bits.CANCLKDIV > 0   
##@@@L1153_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.CANCLKDIV   
##@@@L1154_:                 : 0);   
##@@@L1155_:    }   
##@@@L1156_:    return ret;   
8000aa64:	e4 28       	ADD       SP, #4			;->0x04
8000aa66:	06 5d       	POP       R6
8000aa68:	0d 5d       	POP       LR
8000aa6a:	1d 5c       	JMP       LR
8000aa6c:	48 f4 00 f0 	.long     0xf000f448 ->-268372920  [!!!@2@:JMI       $+72                  ;->0x8000aafc	@@: JZ        $+0                   ;->0x8000aa6c
8000aa70:	00 80 07 00 	.long     0x00078000 ->000491520  [!!!@2@:LD.B      R0, [R0]	@@: BREAK    
8000aa74:	00 00 08 00 	.long     0x00080000 ->000524288  [!!!@2@:NOP      	@@: SYNC     
8000aa78:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000aa7c:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000aa80:	9c 10 00 80 	.long     0x8000109c ->-2147479396  [!!!@2@:MOV       R9, #12	@@: LD.B      R0, [R0]

8000aa84 <Clk_Hw_GetUTLINFFrequency>:
##@@@F_:Clk_Hw_GetUTLINFFrequency():
##@@@P_:kf32a13k_hw_clk.c:1167
##@@@L1162_: *   
##@@@L1163_: * @param   
##@@@L1164_: * @retval   
##@@@L1165_: */   
##@@@L1166_:float Clk_Hw_GetUTLINFFrequency(void)   
##@@@L1167_:{   
8000aa84:	81 5f       	PUSH      {R6,LR}
8000aa86:	e4 30       	SUB       SP, #4			;->0x04
8000aa88:	12 46       	LD        R6, [PC + #18]        ;->0x8000aad0  :=0xf000f448
##@@@P_:kf32a13k_hw_clk.c:1169
##@@@L1168_:    float ret = 0;   
##@@@L1169_:    if (CLK_PTR->CDU_CTL2.bits.UTLINFCLKSEL)   
8000aa8a:	46 82       	LD.W      R4, [R6]
8000aa8c:	56 82       	LD.W      R5, [R6]
8000aa8e:	12 43       	LD        R3, [PC + #18]        ;->0x8000aad4  :=0xf00000
8000aa90:	12 42       	LD        R2, [PC + #18]        ;->0x8000aad8  :=0x1000000
8000aa92:	53 69       	ANL       R5, R3
8000aa94:	42 69       	ANL       R4, R2
8000aa96:	40 38       	CMP       R4, #0			;->0x00
8000aa98:	06 f1       	JNZ       $+6                   ;->0x8000aaa4
##@@@P_:kf32a13k_hw_clk.c:1177
##@@@L1172_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINFCLKDIV   
##@@@L1173_:                 : 0);   
##@@@L1174_:    }   
##@@@L1175_:    else   
##@@@L1176_:    {   
##@@@L1177_:        ret = (CLK_PTR->CDU_CTL2.bits.UTLINFCLKDIV > 0   
8000aa9a:	50 38       	CMP       R5, #0			;->0x00
8000aa9c:	13 f0       	JZ        $+19                  ;->0x8000aac2
##@@@P_:kf32a13k_hw_clk.c:1178
##@@@L1178_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINFCLKDIV   
8000aa9e:	10 45       	LD        R5, [PC + #16]        ;->0x8000aadc  :=0x8000a4c4
8000aaa0:	05 5c       	LJMP      R5
8000aaa2:	05 04       	SJMP      $+5                   ;->0x8000aaac
##@@@P_:kf32a13k_hw_clk.c:1171
##@@@L1166_:float Clk_Hw_GetUTLINFFrequency(void)   
##@@@L1167_:{   
##@@@L1168_:    float ret = 0;   
##@@@L1169_:    if (CLK_PTR->CDU_CTL2.bits.UTLINFCLKSEL)   
##@@@L1170_:    {   
##@@@L1171_:        ret = (CLK_PTR->CDU_CTL2.bits.UTLINFCLKDIV > 0   
8000aaa4:	50 38       	CMP       R5, #0			;->0x00
8000aaa6:	0e f0       	JZ        $+14                  ;->0x8000aac2
##@@@P_:kf32a13k_hw_clk.c:1172
##@@@L1172_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINFCLKDIV   
8000aaa8:	0e 45       	LD        R5, [PC + #14]        ;->0x8000aae0  :=0x8000a2d4
8000aaaa:	05 5c       	LJMP      R5
8000aaac:	56 82       	LD.W      R5, [R6]
8000aaae:	2c 7d       	LSR       R5, #20			;->0x14
8000aab0:	4f 10       	MOV       R4, #15			;->0x000F
8000aab2:	54 69       	ANL       R5, R4
8000aab4:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000aab8:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000aabc:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000aac0:	04 04       	SJMP      $+4                   ;->0x8000aac8
8000aac2:	09 45       	LD        R5, [PC + #9]         ;->0x8000aae4  :=0x800010a0
8000aac4:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1181
##@@@L1176_:    {   
##@@@L1177_:        ret = (CLK_PTR->CDU_CTL2.bits.UTLINFCLKDIV > 0   
##@@@L1178_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINFCLKDIV   
##@@@L1179_:                 : 0);   
##@@@L1180_:    }   
##@@@L1181_:    return ret;   
8000aac8:	e4 28       	ADD       SP, #4			;->0x04
8000aaca:	06 5d       	POP       R6
8000aacc:	0d 5d       	POP       LR
8000aace:	1d 5c       	JMP       LR
8000aad0:	48 f4 00 f0 	.long     0xf000f448 ->-268372920  [!!!@2@:JMI       $+72                  ;->0x8000ab60	@@: JZ        $+0                   ;->0x8000aad0
8000aad4:	00 00 f0 00 	.long     0x00f00000 ->015728640  [!!!@2@:NOP      	@@: QAVRHL    R3, ACC6, ACC0, #0, #0, #0, #0
8000aad8:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
8000aadc:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000aae0:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000aae4:	a0 10 00 80 	.long     0x800010a0 ->-2147479392  [!!!@2@:MOV       R10, #0	@@: LD.B      R0, [R0]

8000aae8 <Clk_Hw_GetUTLINSFrequency>:
##@@@F_:Clk_Hw_GetUTLINSFrequency():
##@@@P_:kf32a13k_hw_clk.c:1192
##@@@L1187_: *   
##@@@L1188_: * @param   
##@@@L1189_: * @retval   
##@@@L1190_: */   
##@@@L1191_:float Clk_Hw_GetUTLINSFrequency(void)   
##@@@L1192_:{   
8000aae8:	81 5f       	PUSH      {R6,LR}
8000aaea:	e4 30       	SUB       SP, #4			;->0x04
8000aaec:	12 46       	LD        R6, [PC + #18]        ;->0x8000ab34  :=0xf000f448
##@@@P_:kf32a13k_hw_clk.c:1194
##@@@L1193_:    float ret = 0;   
##@@@L1194_:    if (CLK_PTR->CDU_CTL2.bits.UTLINSCLKSEL)   
8000aaee:	46 82       	LD.W      R4, [R6]
8000aaf0:	56 82       	LD.W      R5, [R6]
8000aaf2:	12 43       	LD        R3, [PC + #18]        ;->0x8000ab38  :=0x1e000000
8000aaf4:	12 42       	LD        R2, [PC + #18]        ;->0x8000ab3c  :=0x20000000
8000aaf6:	53 69       	ANL       R5, R3
8000aaf8:	42 69       	ANL       R4, R2
8000aafa:	40 38       	CMP       R4, #0			;->0x00
8000aafc:	06 f1       	JNZ       $+6                   ;->0x8000ab08
##@@@P_:kf32a13k_hw_clk.c:1202
##@@@L1197_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINSCLKDIV   
##@@@L1198_:                 : 0);   
##@@@L1199_:    }   
##@@@L1200_:    else   
##@@@L1201_:    {   
##@@@L1202_:        ret = (CLK_PTR->CDU_CTL2.bits.UTLINSCLKDIV > 0   
8000aafe:	50 38       	CMP       R5, #0			;->0x00
8000ab00:	13 f0       	JZ        $+19                  ;->0x8000ab26
##@@@P_:kf32a13k_hw_clk.c:1203
##@@@L1203_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINSCLKDIV   
8000ab02:	10 45       	LD        R5, [PC + #16]        ;->0x8000ab40  :=0x8000a4c4
8000ab04:	05 5c       	LJMP      R5
8000ab06:	05 04       	SJMP      $+5                   ;->0x8000ab10
##@@@P_:kf32a13k_hw_clk.c:1196
##@@@L1191_:float Clk_Hw_GetUTLINSFrequency(void)   
##@@@L1192_:{   
##@@@L1193_:    float ret = 0;   
##@@@L1194_:    if (CLK_PTR->CDU_CTL2.bits.UTLINSCLKSEL)   
##@@@L1195_:    {   
##@@@L1196_:        ret = (CLK_PTR->CDU_CTL2.bits.UTLINSCLKDIV > 0   
8000ab08:	50 38       	CMP       R5, #0			;->0x00
8000ab0a:	0e f0       	JZ        $+14                  ;->0x8000ab26
##@@@P_:kf32a13k_hw_clk.c:1197
##@@@L1197_:                 ? Clk_Hw_GetFsource1Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINSCLKDIV   
8000ab0c:	0e 45       	LD        R5, [PC + #14]        ;->0x8000ab44  :=0x8000a2d4
8000ab0e:	05 5c       	LJMP      R5
8000ab10:	56 82       	LD.W      R5, [R6]
8000ab12:	a9 7d       	LSR       R5, #25			;->0x19
8000ab14:	4f 10       	MOV       R4, #15			;->0x000F
8000ab16:	54 69       	ANL       R5, R4
8000ab18:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000ab1c:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000ab20:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000ab24:	04 04       	SJMP      $+4                   ;->0x8000ab2c
8000ab26:	09 45       	LD        R5, [PC + #9]         ;->0x8000ab48  :=0x800010a4
8000ab28:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
##@@@P_:kf32a13k_hw_clk.c:1206
##@@@L1201_:    {   
##@@@L1202_:        ret = (CLK_PTR->CDU_CTL2.bits.UTLINSCLKDIV > 0   
##@@@L1203_:                 ? Clk_Hw_GetFsource2Frequency() / (float)CLK_PTR->CDU_CTL2.bits.UTLINSCLKDIV   
##@@@L1204_:                 : 0);   
##@@@L1205_:    }   
##@@@L1206_:    return ret;   
8000ab2c:	e4 28       	ADD       SP, #4			;->0x04
8000ab2e:	06 5d       	POP       R6
8000ab30:	0d 5d       	POP       LR
8000ab32:	1d 5c       	JMP       LR
8000ab34:	48 f4 00 f0 	.long     0xf000f448 ->-268372920  [!!!@2@:JMI       $+72                  ;->0x8000abc4	@@: JZ        $+0                   ;->0x8000ab34
8000ab38:	00 00 00 1e 	.long     0x1e000000 ->503316480  [!!!@2@:NOP      	@@: MOV       R0, #224
8000ab3c:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000ab40:	c4 a4 00 80 	.long     0x8000a4c4 ->-2147441468  [!!!@2@:ST.W      [R0 + #19], R4	@@: LD.B      R0, [R0]
8000ab44:	d4 a2 00 80 	.long     0x8000a2d4 ->-2147441964  [!!!@2@:ST.W      [R2 + #11], R4	@@: LD.B      R0, [R0]
8000ab48:	a4 10 00 80 	.long     0x800010a4 ->-2147479388  [!!!@2@:MOV       R10, #4	@@: LD.B      R0, [R0]

8000ab4c <Clk_Hw_GetCPU0Frequency>:
##@@@F_:Clk_Hw_GetCPU0Frequency():
##@@@P_:kf32a13k_hw_clk.c:1217
##@@@L1212_: *   
##@@@L1213_: * @param   
##@@@L1214_: * @retval   
##@@@L1215_: */   
##@@@L1216_:float Clk_Hw_GetCPU0Frequency(void)   
##@@@L1217_:{   
8000ab4c:	81 5f       	PUSH      {R6,LR}
8000ab4e:	e4 30       	SUB       SP, #4			;->0x04
8000ab50:	17 46       	LD        R6, [PC + #23]        ;->0x8000abac  :=0xf000f440
##@@@F_:Clk_Hw_GetSysClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:924
##@@@L0919_: * @param   
##@@@L0920_: * @retval   
##@@@L0921_: */   
##@@@L0922_:float Clk_Hw_GetSysClkFrequency(void)   
##@@@L0923_:{   
##@@@L0924_:    return (CLK_PTR->CDU_CTL0.bits.SYSCLKDIV > 0   
8000ab52:	56 82       	LD.W      R5, [R6]
8000ab54:	40 1f       	MOV       R4, #240			;->0x00F0
8000ab56:	54 69       	ANL       R5, R4
8000ab58:	50 38       	CMP       R5, #0			;->0x00
8000ab5a:	0e f0       	JZ        $+14                  ;->0x8000ab76
##@@@P_:kf32a13k_hw_clk.c:925
##@@@L0925_:              ? Clk_Hw_GetFsource0Frequency() / (float)CLK_PTR->CDU_CTL0.bits.SYSCLKDIV   
8000ab5c:	15 45       	LD        R5, [PC + #21]        ;->0x8000abb0  :=0x8000a10c
8000ab5e:	05 5c       	LJMP      R5
8000ab60:	56 82       	LD.W      R5, [R6]
8000ab62:	2c 7c       	LSR       R5, #4			;->0x04
8000ab64:	4f 10       	MOV       R4, #15			;->0x000F
8000ab66:	54 69       	ANL       R5, R4
8000ab68:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000ab6c:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000ab70:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000ab74:	04 04       	SJMP      $+4                   ;->0x8000ab7c
##@@@F_:Clk_Hw_GetCPU0Frequency():
8000ab76:	10 45       	LD        R5, [PC + #16]        ;->0x8000abb4  :=0x800010a8
8000ab78:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
8000ab7c:	0f 45       	LD        R5, [PC + #15]        ;->0x8000abb8  :=0xf000f44c
##@@@P_:kf32a13k_hw_clk.c:1218
##@@@L1213_: * @param   
##@@@L1214_: * @retval   
##@@@L1215_: */   
##@@@L1216_:float Clk_Hw_GetCPU0Frequency(void)   
##@@@L1217_:{   
##@@@L1218_:    return (Clk_Hw_GetSysClkFrequency() * (64.F - (float)CLK_PTR->CDU_CTL3.bits.CPU0CLKDIV) / 64.F);   
8000ab7e:	55 82       	LD.W      R5, [R5]
8000ab80:	4f 13       	MOV       R4, #63			;->0x003F
8000ab82:	54 69       	ANL       R5, R4
8000ab84:	0e 44       	LD        R4, [PC + #14]        ;->0x8000abbc  :=0x800010ac
8000ab86:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000ab8a:	24 00 82 00 	FLD.W           S2, 	[R4 +#0  ]
8000ab8e:	0d 45       	LD        R5, [PC + #13]        ;->0x8000abc0  :=0x800010b0
8000ab90:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000ab94:	24 00 a3 00 	FLD.W           S3, 	[R5 +#0  ]
8000ab98:	2b 00 41 84 	FSUB.F32        S1 , 	S2 , 	S1 
8000ab9c:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000aba0:	29 00 00 0c 	FMUL.F32        S0 , 	S0 , 	S3 
8000aba4:	e4 28       	ADD       SP, #4			;->0x04
8000aba6:	06 5d       	POP       R6
8000aba8:	0d 5d       	POP       LR
8000abaa:	1d 5c       	JMP       LR
8000abac:	40 f4 00 f0 	.long     0xf000f440 ->-268372928  [!!!@2@:JMI       $+64                  ;->0x8000ac2c	@@: JZ        $+0                   ;->0x8000abac
8000abb0:	0c a1 00 80 	.long     0x8000a10c ->-2147442420  [!!!@2@:ST.W      [R1 + #4], R4	@@: LD.B      R0, [R0]
8000abb4:	a8 10 00 80 	.long     0x800010a8 ->-2147479384  [!!!@2@:MOV       R10, #8	@@: LD.B      R0, [R0]
8000abb8:	4c f4 00 f0 	.long     0xf000f44c ->-268372916  [!!!@2@:JMI       $+76                  ;->0x8000ac50	@@: JZ        $+0                   ;->0x8000abb8
8000abbc:	ac 10 00 80 	.long     0x800010ac ->-2147479380  [!!!@2@:MOV       R10, #12	@@: LD.B      R0, [R0]
8000abc0:	b0 10 00 80 	.long     0x800010b0 ->-2147479376  [!!!@2@:MOV       R11, #0	@@: LD.B      R0, [R0]

8000abc4 <Clk_Hw_GetCPU1Frequency>:
##@@@F_:Clk_Hw_GetCPU1Frequency():
##@@@P_:kf32a13k_hw_clk.c:1229
##@@@L1224_: *   
##@@@L1225_: * @param   
##@@@L1226_: * @retval   
##@@@L1227_: */   
##@@@L1228_:float Clk_Hw_GetCPU1Frequency(void)   
##@@@L1229_:{   
8000abc4:	81 5f       	PUSH      {R6,LR}
8000abc6:	e4 30       	SUB       SP, #4			;->0x04
8000abc8:	17 46       	LD        R6, [PC + #23]        ;->0x8000ac24  :=0xf000f440
##@@@F_:Clk_Hw_GetSysClkFrequency():
##@@@P_:kf32a13k_hw_clk.c:924
##@@@L0919_: * @param   
##@@@L0920_: * @retval   
##@@@L0921_: */   
##@@@L0922_:float Clk_Hw_GetSysClkFrequency(void)   
##@@@L0923_:{   
##@@@L0924_:    return (CLK_PTR->CDU_CTL0.bits.SYSCLKDIV > 0   
8000abca:	56 82       	LD.W      R5, [R6]
8000abcc:	40 1f       	MOV       R4, #240			;->0x00F0
8000abce:	54 69       	ANL       R5, R4
8000abd0:	50 38       	CMP       R5, #0			;->0x00
8000abd2:	0e f0       	JZ        $+14                  ;->0x8000abee
##@@@P_:kf32a13k_hw_clk.c:925
##@@@L0925_:              ? Clk_Hw_GetFsource0Frequency() / (float)CLK_PTR->CDU_CTL0.bits.SYSCLKDIV   
8000abd4:	15 45       	LD        R5, [PC + #21]        ;->0x8000ac28  :=0x8000a10c
8000abd6:	05 5c       	LJMP      R5
8000abd8:	56 82       	LD.W      R5, [R6]
8000abda:	2c 7c       	LSR       R5, #4			;->0x04
8000abdc:	4f 10       	MOV       R4, #15			;->0x000F
8000abde:	54 69       	ANL       R5, R4
8000abe0:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000abe4:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000abe8:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000abec:	04 04       	SJMP      $+4                   ;->0x8000abf4
##@@@F_:Clk_Hw_GetCPU1Frequency():
8000abee:	10 45       	LD        R5, [PC + #16]        ;->0x8000ac2c  :=0x800010b4
8000abf0:	24 00 a0 00 	FLD.W           S0, 	[R5 +#0  ]
8000abf4:	0f 45       	LD        R5, [PC + #15]        ;->0x8000ac30  :=0xf000f450
##@@@P_:kf32a13k_hw_clk.c:1230
##@@@L1225_: * @param   
##@@@L1226_: * @retval   
##@@@L1227_: */   
##@@@L1228_:float Clk_Hw_GetCPU1Frequency(void)   
##@@@L1229_:{   
##@@@L1230_:    return (Clk_Hw_GetSysClkFrequency() * (64.F - (float)CLK_PTR->CDU_CTL4.bits.CPU1CLKDIV) / 64.F);   
8000abf6:	55 82       	LD.W      R5, [R5]
8000abf8:	4f 13       	MOV       R4, #63			;->0x003F
8000abfa:	54 69       	ANL       R5, R4
8000abfc:	0e 44       	LD        R4, [PC + #14]        ;->0x8000ac34  :=0x800010b8
8000abfe:	1f 00 a1 1c 	FMOV            S1 ,	R5
8000ac02:	24 00 82 00 	FLD.W           S2, 	[R4 +#0  ]
8000ac06:	0d 45       	LD        R5, [PC + #13]        ;->0x8000ac38  :=0x800010bc
8000ac08:	1f 00 21 5c 	FCVTR.F32.U32  S1 ,	S1
8000ac0c:	24 00 a3 00 	FLD.W           S3, 	[R5 +#0  ]
8000ac10:	2b 00 41 84 	FSUB.F32        S1 , 	S2 , 	S1 
8000ac14:	29 00 00 04 	FMUL.F32        S0 , 	S0 , 	S1 
8000ac18:	29 00 00 0c 	FMUL.F32        S0 , 	S0 , 	S3 
8000ac1c:	e4 28       	ADD       SP, #4			;->0x04
8000ac1e:	06 5d       	POP       R6
8000ac20:	0d 5d       	POP       LR
8000ac22:	1d 5c       	JMP       LR
8000ac24:	40 f4 00 f0 	.long     0xf000f440 ->-268372928  [!!!@2@:JMI       $+64                  ;->0x8000aca4	@@: JZ        $+0                   ;->0x8000ac24
8000ac28:	0c a1 00 80 	.long     0x8000a10c ->-2147442420  [!!!@2@:ST.W      [R1 + #4], R4	@@: LD.B      R0, [R0]
8000ac2c:	b4 10 00 80 	.long     0x800010b4 ->-2147479372  [!!!@2@:MOV       R11, #4	@@: LD.B      R0, [R0]
8000ac30:	50 f4 00 f0 	.long     0xf000f450 ->-268372912  [!!!@2@:JMI       $+80                  ;->0x8000acd0	@@: JZ        $+0                   ;->0x8000ac30
8000ac34:	b8 10 00 80 	.long     0x800010b8 ->-2147479368  [!!!@2@:MOV       R11, #8	@@: LD.B      R0, [R0]
8000ac38:	bc 10 00 80 	.long     0x800010bc ->-2147479364  [!!!@2@:MOV       R11, #12	@@: LD.B      R0, [R0]

8000ac3c <Scu_Hw_SelectEruExternalInput>:
##@@@F_:Scu_Hw_SelectEruExternalInput():
##@@@P_:kf32a13k_hw_scu.c:75
##@@@L0070_: * @param Signal 通道触发单元   
##@@@L0071_: *   
##@@@L0072_: * @retval void   
##@@@L0073_: */   
##@@@L0074_:void Scu_Hw_SelectEruExternalInput(Scu_Hw_EruInputChannel_t InputChannel, Scu_Hw_EruInputSelect_t Signal)   
##@@@L0075_:{   
8000ac3c:	51 10       	MOV       R5, #1			;->0x0001
##@@@F_:Scu_LL_EruSelectExternalInput():
##@@@P_:kf32a13k_drv_scu.h:1964
##@@@L1959_: */   
##@@@L1960_:KF_INLINE void   
##@@@L1961_:Scu_LL_EruSelectExternalInput(Scu_EruInputChannelType_t InputChannel, Scu_EruExternalInputType_t InputSignal)   
##@@@L1962_:{   
##@@@L1963_:    uint32_t index = (InputChannel >> POS_1_SHIFT);   
##@@@L1964_:    if (InputChannel & POS_1_SHIFT)   
8000ac3e:	60 58       	MOV       R3, R0
8000ac40:	35 69       	ANL       R3, R5
8000ac42:	30 38       	CMP       R3, #0			;->0x00
8000ac44:	09 f0       	JZ        $+9                   ;->0x8000ac56
8000ac46:	0e 45       	LD        R5, [PC + #14]        ;->0x8000ac7c  :=0xff8fffff
8000ac48:	30 38       	CMP       R3, #0			;->0x00
8000ac4a:	09 f1       	JNZ       $+9                   ;->0x8000ac5c
8000ac4c:	40 17       	MOV       R4, #112			;->0x0070
8000ac4e:	30 38       	CMP       R3, #0			;->0x00
8000ac50:	09 f1       	JNZ       $+9                   ;->0x8000ac62
8000ac52:	34 10       	MOV       R3, #4			;->0x0004
8000ac54:	08 04       	SJMP      $+8                   ;->0x8000ac64
8000ac56:	0b 45       	LD        R5, [PC + #11]        ;->0x8000ac80  :=0xffffff8f
8000ac58:	30 38       	CMP       R3, #0			;->0x00
8000ac5a:	f9 f0       	JZ        $-7                   ;->0x8000ac4c
8000ac5c:	0a 44       	LD        R4, [PC + #10]        ;->0x8000ac84  :=0x700000
8000ac5e:	30 38       	CMP       R3, #0			;->0x00
8000ac60:	f9 f0       	JZ        $-7                   ;->0x8000ac52
8000ac62:	34 11       	MOV       R3, #20			;->0x0014
8000ac64:	13 6c       	LSL       R1, R3
8000ac66:	01 7a       	LSL       R0, #1			;->0x01
8000ac68:	08 43       	LD        R3, [PC + #8]         ;->0x8000ac88  :=0xfffffffc
8000ac6a:	09 42       	LD        R2, [PC + #9]         ;->0x8000ac8c  :=0xf000f110
##@@@P_:kf32a13k_drv_scu.h:1963
##@@@L1958_: * @retval void   
##@@@L1959_: */   
##@@@L1960_:KF_INLINE void   
##@@@L1961_:Scu_LL_EruSelectExternalInput(Scu_EruInputChannelType_t InputChannel, Scu_EruExternalInputType_t InputSignal)   
##@@@L1962_:{   
##@@@L1963_:    uint32_t index = (InputChannel >> POS_1_SHIFT);   
8000ac6c:	03 69       	ANL       R0, R3
8000ac6e:	98 e8       	LD.W      R3, [R0 + R2]
8000ac70:	14 69       	ANL       R1, R4
8000ac72:	35 69       	ANL       R3, R5
8000ac74:	31 6a       	ORL       R3, R1
8000ac76:	83 ee       	ST.W      [R0 + R2], R3
##@@@F_:Scu_Hw_SelectEruExternalInput():
##@@@P_:kf32a13k_hw_scu.c:77
##@@@L0076_:    Scu_LL_EruSelectExternalInput((Scu_EruInputChannelType_t)InputChannel, (Scu_EruExternalInputType_t)Signal);   
##@@@L0077_:}   
8000ac78:	1d 5c       	JMP       LR
8000ac7a:	00 00       	NOP      NOP      
8000ac7c:	ff ff 8f ff 	.long     0xff8fffff ->-07340033 
8000ac80:	8f ff ff ff 	.long     0xffffff8f ->-00000113 
8000ac84:	00 00 70 00 	.long     0x00700000 ->007340032  [!!!@2@:NOP      	@@: ST.H      [R3 + #0], R16
8000ac88:	fc ff ff ff 	.long     0xfffffffc ->-00000004 
8000ac8c:	10 f1 00 f0 	.long     0xf000f110 ->-268373744  [!!!@2@:JNZ       $+16                  ;->0x8000acac	@@: JZ        $+0                   ;->0x8000ac8c

8000ac90 <Scu_Hw_SetERUFilterPinEnabled>:
##@@@F_:Scu_Hw_SetERUFilterPinEnabled():
##@@@P_:kf32a13k_hw_scu.c:88
##@@@L0083_: * @param State 是否使能   
##@@@L0084_: *   
##@@@L0085_: * @retval void   
##@@@L0086_: */   
##@@@L0087_:void Scu_Hw_SetERUFilterPinEnabled(Scu_Hw_EruFilterPin_t Pin, bool State)   
##@@@L0088_:{   
8000ac90:	51 10       	MOV       R5, #1			;->0x0001
8000ac92:	05 44       	LD        R4, [PC + #5]         ;->0x8000aca4  :=0xf000f10c
##@@@F_:Scu_LL_SetERUFilterPinEnabled():
##@@@P_:kf32a13k_drv_scu.h:2494
##@@@L2489_: *   
##@@@L2490_: * @retval void   
##@@@L2491_: */   
##@@@L2492_:KF_INLINE void Scu_LL_SetERUFilterPinEnabled(Scu_EruFilterPin_t Pin, bool State)   
##@@@L2493_:{   
##@@@L2494_:    REG_BITS_WRITE(SCU_PTR->SCU_EIFCTL.reg, (1U << Pin), State);   
8000ac94:	50 6c       	LSL       R5, R0
8000ac96:	34 82       	LD.W      R3, [R4]
8000ac98:	55 68       	NOT       R5, R5
8000ac9a:	35 69       	ANL       R3, R5
8000ac9c:	31 6a       	ORL       R3, R1
8000ac9e:	43 85       	ST.W      [R4], R3
##@@@F_:Scu_Hw_SetERUFilterPinEnabled():
##@@@P_:kf32a13k_hw_scu.c:90
##@@@L0089_:    Scu_LL_SetERUFilterPinEnabled((Scu_EruFilterPin_t)Pin, State);   
##@@@L0090_:}   
8000aca0:	1d 5c       	JMP       LR
8000aca2:	00 00       	NOP      NOP      
8000aca4:	0c f1 00 f0 	.long     0xf000f10c ->-268373748  [!!!@2@:JNZ       $+12                  ;->0x8000acbc	@@: JZ        $+0                   ;->0x8000aca4

8000aca8 <Scu_Hw_GetERUFilterPinEnabled>:
##@@@F_:Scu_Hw_GetERUFilterPinEnabled():
##@@@P_:kf32a13k_hw_scu.c:100
##@@@L0095_: * @param Pin 获取滤波使能的引脚   
##@@@L0096_: *   
##@@@L0097_: * @retval bool 是否使能   
##@@@L0098_: */   
##@@@L0099_:bool Scu_Hw_GetERUFilterPinEnabled(Scu_Hw_EruFilterPin_t Pin)   
##@@@L0100_:{   
8000aca8:	a0 58       	MOV       R5, R0
8000acaa:	06 44       	LD        R4, [PC + #6]         ;->0x8000acc0  :=0xf000f10c
8000acac:	01 10       	MOV       R0, #1			;->0x0001
##@@@F_:Scu_LL_GetERUFilterPinEnabled():
##@@@P_:kf32a13k_drv_scu.h:2506
##@@@L2501_: *   
##@@@L2502_: * @retval bool 是否使能   
##@@@L2503_: */   
##@@@L2504_:KF_INLINE bool Scu_LL_GetERUFilterPinEnabled(Scu_EruFilterPin_t Pin)   
##@@@L2505_:{   
##@@@L2506_:    return (bool)(REG_BITS_READ(SCU_PTR->SCU_EIFCTL.reg, (1U << Pin), Pin));   
8000acae:	44 82       	LD.W      R4, [R4]
8000acb0:	60 58       	MOV       R3, R0
8000acb2:	35 6c       	LSL       R3, R5
8000acb4:	43 69       	ANL       R4, R3
8000acb6:	45 6d       	LSR       R4, R5
8000acb8:	40 38       	CMP       R4, #0			;->0x00
8000acba:	02 f1       	JNZ       $+2                   ;->0x8000acbe
##@@@F_:Scu_Hw_GetERUFilterPinEnabled():
8000acbc:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_hw_scu.c:101
##@@@L0101_:    return Scu_LL_GetERUFilterPinEnabled((Scu_EruFilterPin_t)Pin);   
8000acbe:	1d 5c       	JMP       LR
8000acc0:	0c f1 00 f0 	.long     0xf000f10c ->-268373748  [!!!@2@:JNZ       $+12                  ;->0x8000acd8	@@: JZ        $+0                   ;->0x8000acc0

8000acc4 <Scu_Hw_SetERUFilterClkDiv>:
##@@@F_:Scu_LL_SetERUFilterClkDiv():
##@@@P_:kf32a13k_drv_scu.h:2518
##@@@L2513_: *   
##@@@L2514_: * @retval void   
##@@@L2515_: */   
##@@@L2516_:KF_INLINE void Scu_LL_SetERUFilterClkDiv(Scu_EruFilterClkDiv_t Div)   
##@@@L2517_:{   
##@@@L2518_:    REG_WRITE(SCU_PTR->SCU_EIFCTL.bits.FILTDIV, Div);   
8000acc4:	80 7b       	LSL       R0, #24			;->0x18
8000acc6:	05 45       	LD        R5, [PC + #5]         ;->0x8000acd8  :=0xf000f10c
8000acc8:	05 44       	LD        R4, [PC + #5]         ;->0x8000acdc  :=0xf000000
8000acca:	35 82       	LD.W      R3, [R5]
8000accc:	05 42       	LD        R2, [PC + #5]         ;->0x8000ace0  :=0xf0ffffff
8000acce:	04 69       	ANL       R0, R4
8000acd0:	32 69       	ANL       R3, R2
8000acd2:	30 6a       	ORL       R3, R0
8000acd4:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_SetERUFilterClkDiv():
##@@@P_:kf32a13k_hw_scu.c:114
##@@@L0109_: * @retval void   
##@@@L0110_: */   
##@@@L0111_:void Scu_Hw_SetERUFilterClkDiv(Scu_Hw_EruFilterClkDiv_t Div)   
##@@@L0112_:{   
##@@@L0113_:    Scu_LL_SetERUFilterClkDiv((Scu_EruFilterClkDiv_t)Div);   
##@@@L0114_:}   
8000acd6:	1d 5c       	JMP       LR
8000acd8:	0c f1 00 f0 	.long     0xf000f10c ->-268373748  [!!!@2@:JNZ       $+12                  ;->0x8000acf0	@@: JZ        $+0                   ;->0x8000acd8
8000acdc:	00 00 00 0f 	.long     0x0f000000 ->251658240  [!!!@2@:NOP      	@@: LD.W      R7, [SP + #0]
8000ace0:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 

8000ace4 <Scu_Hw_SetERUFilterDepth>:
##@@@F_:Scu_Hw_SetERUFilterDepth():
##@@@P_:kf32a13k_hw_scu.c:124
##@@@L0119_: * @param Depth ERU数字滤波深度   
##@@@L0120_: *   
##@@@L0121_: * @retval void   
##@@@L0122_: */   
##@@@L0123_:void Scu_Hw_SetERUFilterDepth(Scu_Hw_EruFilterDepth_t Depth)   
##@@@L0124_:{   
8000ace4:	04 45       	LD        R5, [PC + #4]         ;->0x8000acf4  :=0xf000f10c
##@@@F_:Scu_LL_SetERUFilterDepth():
##@@@P_:kf32a13k_drv_scu.h:2530
##@@@L2525_: *   
##@@@L2526_: * @retval void   
##@@@L2527_: */   
##@@@L2528_:KF_INLINE void Scu_LL_SetERUFilterDepth(Scu_EruFilterDepth_t Depth)   
##@@@L2529_:{   
##@@@L2530_:    REG_WRITE(SCU_PTR->SCU_EIFCTL.bits.DEPTH, Depth);   
8000ace6:	45 82       	LD.W      R4, [R5]
8000ace8:	04 43       	LD        R3, [PC + #4]         ;->0x8000acf8  :=0xfffffff
8000acea:	43 69       	ANL       R4, R3
8000acec:	84 7b       	LSL       R0, #28			;->0x1C
8000acee:	40 6a       	ORL       R4, R0
8000acf0:	54 85       	ST.W      [R5], R4
##@@@F_:Scu_Hw_SetERUFilterDepth():
##@@@P_:kf32a13k_hw_scu.c:126
##@@@L0125_:    Scu_LL_SetERUFilterDepth((Scu_EruFilterDepth_t)Depth);   
##@@@L0126_:}   
8000acf2:	1d 5c       	JMP       LR
8000acf4:	0c f1 00 f0 	.long     0xf000f10c ->-268373748  [!!!@2@:JNZ       $+12                  ;->0x8000ad0c	@@: JZ        $+0                   ;->0x8000acf4
8000acf8:	ff ff ff 0f 	.long     0x0fffffff ->268435455 

8000acfc <Scu_Hw_SetEmergencyStopInputPolarity>:
##@@@F_:Scu_Hw_SetEmergencyStopInputPolarity():
##@@@P_:kf32a13k_hw_scu.c:138
##@@@L0133_: *          SCU_HW_EMERGENCY_STOP_POLARITY_LOW - 低电平有效   
##@@@L0134_: *   
##@@@L0135_: * @retval void   
##@@@L0136_: */   
##@@@L0137_:void Scu_Hw_SetEmergencyStopInputPolarity(Scu_Hw_EmergencyStopInputPolarity_t Polarity)   
##@@@L0138_:{   
8000acfc:	05 45       	LD        R5, [PC + #5]         ;->0x8000ad10  :=0xf000f140
8000acfe:	41 10       	MOV       R4, #1			;->0x0001
##@@@F_:Scu_LL_SetEmergencyStopInputPolarity():
##@@@P_:kf32a13k_drv_scu.h:2544
##@@@L2539_: *   
##@@@L2540_: * @retval void   
##@@@L2541_: */   
##@@@L2542_:KF_INLINE void Scu_LL_SetEmergencyStopInputPolarity(Scu_EmergencyStopInputPolarity_t Polarity)   
##@@@L2543_:{   
##@@@L2544_:    REG_WRITE(SCU_PTR->SCU_ESCTL.bits.POL, Polarity);   
8000ad00:	35 82       	LD.W      R3, [R5]
8000ad02:	05 42       	LD        R2, [PC + #5]         ;->0x8000ad14  :=0xfffffffe
8000ad04:	04 69       	ANL       R0, R4
8000ad06:	32 69       	ANL       R3, R2
8000ad08:	30 6a       	ORL       R3, R0
8000ad0a:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_SetEmergencyStopInputPolarity():
##@@@P_:kf32a13k_hw_scu.c:140
##@@@L0139_:    Scu_LL_SetEmergencyStopInputPolarity((Scu_EmergencyStopInputPolarity_t)Polarity);   
##@@@L0140_:}   
8000ad0c:	1d 5c       	JMP       LR
8000ad0e:	00 00       	NOP      NOP      
8000ad10:	40 f1 00 f0 	.long     0xf000f140 ->-268373696  [!!!@2@:JNZ       $+64                  ;->0x8000ad90	@@: JZ        $+0                   ;->0x8000ad10
8000ad14:	fe ff ff ff 	.long     0xfffffffe ->-00000002 

8000ad18 <Scu_Hw_SetEmergencyStopMode>:
##@@@F_:Scu_LL_SetEmergencyStopMode():
##@@@P_:kf32a13k_drv_scu.h:2558
##@@@L2553_: *   
##@@@L2554_: * @retval void   
##@@@L2555_: */   
##@@@L2556_:KF_INLINE void Scu_LL_SetEmergencyStopMode(Scu_EmergencyStopMode_t Mode)   
##@@@L2557_:{   
##@@@L2558_:    REG_WRITE(SCU_PTR->SCU_ESCTL.bits.MODE, Mode);   
8000ad18:	01 7a       	LSL       R0, #1			;->0x01
8000ad1a:	05 45       	LD        R5, [PC + #5]         ;->0x8000ad2c  :=0xf000f140
8000ad1c:	42 10       	MOV       R4, #2			;->0x0002
8000ad1e:	35 82       	LD.W      R3, [R5]
8000ad20:	04 42       	LD        R2, [PC + #4]         ;->0x8000ad30  :=0xfffffffd
8000ad22:	04 69       	ANL       R0, R4
8000ad24:	32 69       	ANL       R3, R2
8000ad26:	30 6a       	ORL       R3, R0
8000ad28:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_SetEmergencyStopMode():
##@@@P_:kf32a13k_hw_scu.c:154
##@@@L0149_: * @retval void   
##@@@L0150_: */   
##@@@L0151_:void Scu_Hw_SetEmergencyStopMode(Scu_Hw_EmergencyStopMode_t Mode)   
##@@@L0152_:{   
##@@@L0153_:    Scu_LL_SetEmergencyStopMode((Scu_EmergencyStopMode_t)Mode);   
##@@@L0154_:}   
8000ad2a:	1d 5c       	JMP       LR
8000ad2c:	40 f1 00 f0 	.long     0xf000f140 ->-268373696  [!!!@2@:JNZ       $+64                  ;->0x8000adac	@@: JZ        $+0                   ;->0x8000ad2c
8000ad30:	fd ff ff ff 	.long     0xfffffffd ->-00000003 

8000ad34 <Scu_Hw_SetEmergencyStopFlagEnabled>:
##@@@F_:Scu_LL_SetEmergencyStopFlagEnabled():
##@@@P_:kf32a13k_drv_scu.h:2572
##@@@L2567_: *   
##@@@L2568_: * @retval void   
##@@@L2569_: */   
##@@@L2570_:KF_INLINE void Scu_LL_SetEmergencyStopFlagEnabled(bool State)   
##@@@L2571_:{   
##@@@L2572_:    REG_WRITE(SCU_PTR->SCU_ESCTL.bits.ENON, State);   
8000ad34:	00 38       	CMP       R0, #0			;->0x00
8000ad36:	03 f1       	JNZ       $+3                   ;->0x8000ad3c
8000ad38:	50 10       	MOV       R5, #0			;->0x0000
8000ad3a:	02 04       	SJMP      $+2                   ;->0x8000ad3e
8000ad3c:	54 10       	MOV       R5, #4			;->0x0004
8000ad3e:	04 44       	LD        R4, [PC + #4]         ;->0x8000ad4c  :=0xf000f140
8000ad40:	34 82       	LD.W      R3, [R4]
8000ad42:	04 42       	LD        R2, [PC + #4]         ;->0x8000ad50  :=0xfffffffb
8000ad44:	32 69       	ANL       R3, R2
8000ad46:	35 6a       	ORL       R3, R5
8000ad48:	43 85       	ST.W      [R4], R3
##@@@F_:Scu_Hw_SetEmergencyStopFlagEnabled():
##@@@P_:kf32a13k_hw_scu.c:168
##@@@L0163_: * @retval void   
##@@@L0164_: */   
##@@@L0165_:void Scu_Hw_SetEmergencyStopFlagEnabled(bool State)   
##@@@L0166_:{   
##@@@L0167_:    Scu_LL_SetEmergencyStopFlagEnabled(State);   
##@@@L0168_:}   
8000ad4a:	1d 5c       	JMP       LR
8000ad4c:	40 f1 00 f0 	.long     0xf000f140 ->-268373696  [!!!@2@:JNZ       $+64                  ;->0x8000adcc	@@: JZ        $+0                   ;->0x8000ad4c
8000ad50:	fb ff ff ff 	.long     0xfffffffb ->-00000005 

8000ad54 <Scu_Hw_EmergencyStopPortSelect>:
##@@@F_:Scu_LL_EmergencyStopPortSelect():
##@@@P_:kf32a13k_drv_scu.h:2586
##@@@L2581_: *   
##@@@L2582_: * @retval void   
##@@@L2583_: */   
##@@@L2584_:KF_INLINE void Scu_LL_EmergencyStopPortSelect(Scu_EmergencyStopPort_t Select)   
##@@@L2585_:{   
##@@@L2586_:    REG_WRITE(SCU_PTR->SCU_ESCTL.bits.PSEL, Select);   
8000ad54:	03 7a       	LSL       R0, #3			;->0x03
8000ad56:	05 45       	LD        R5, [PC + #5]         ;->0x8000ad68  :=0xf000f140
8000ad58:	48 10       	MOV       R4, #8			;->0x0008
8000ad5a:	35 82       	LD.W      R3, [R5]
8000ad5c:	04 42       	LD        R2, [PC + #4]         ;->0x8000ad6c  :=0xfffffff7
8000ad5e:	04 69       	ANL       R0, R4
8000ad60:	32 69       	ANL       R3, R2
8000ad62:	30 6a       	ORL       R3, R0
8000ad64:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_EmergencyStopPortSelect():
##@@@P_:kf32a13k_hw_scu.c:182
##@@@L0177_: * @retval void   
##@@@L0178_: */   
##@@@L0179_:void Scu_Hw_EmergencyStopPortSelect(Scu_Hw_EmergencyStopPort_t Select)   
##@@@L0180_:{   
##@@@L0181_:    Scu_LL_EmergencyStopPortSelect((Scu_EmergencyStopPort_t)Select);   
##@@@L0182_:}   
8000ad66:	1d 5c       	JMP       LR
8000ad68:	40 f1 00 f0 	.long     0xf000f140 ->-268373696  [!!!@2@:JNZ       $+64                  ;->0x8000ade8	@@: JZ        $+0                   ;->0x8000ad68
8000ad6c:	f7 ff ff ff 	.long     0xfffffff7 ->-00000009 

8000ad70 <Scu_Hw_SafetyEmergencyStopFlagSelect>:
##@@@F_:Scu_Hw_SafetyEmergencyStopFlagSelect():
##@@@P_:kf32a13k_hw_scu.c:194
##@@@L0189_: *          SCU_HW_EMERGENCY_STOP_FLAG_CLEAR - 清零   
##@@@L0190_: *   
##@@@L0191_: * @retval void   
##@@@L0192_: */   
##@@@L0193_:void Scu_Hw_SafetyEmergencyStopFlagSelect(Scu_Hw_EmergencyStopFlag_t Select)   
##@@@L0194_:{   
8000ad70:	05 45       	LD        R5, [PC + #5]         ;->0x8000ad84  :=0xf000f144
8000ad72:	43 10       	MOV       R4, #3			;->0x0003
##@@@F_:Scu_LL_SafetyEmergencyStopFlagSelect():
##@@@P_:kf32a13k_drv_scu.h:2620
##@@@L2615_: *   
##@@@L2616_: * @retval void   
##@@@L2617_: */   
##@@@L2618_:KF_INLINE void Scu_LL_SafetyEmergencyStopFlagSelect(Scu_EmergencyStopFlag_t Select)   
##@@@L2619_:{   
##@@@L2620_:    REG_WRITE(SCU_PTR->SCU_ESSWCTL.bits.SEMSFM, Select);   
8000ad74:	35 82       	LD.W      R3, [R5]
8000ad76:	05 42       	LD        R2, [PC + #5]         ;->0x8000ad88  :=0xfffffffc
8000ad78:	04 69       	ANL       R0, R4
8000ad7a:	32 69       	ANL       R3, R2
8000ad7c:	30 6a       	ORL       R3, R0
8000ad7e:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_SafetyEmergencyStopFlagSelect():
##@@@P_:kf32a13k_hw_scu.c:196
##@@@L0195_:    Scu_LL_SafetyEmergencyStopFlagSelect((Scu_EmergencyStopFlag_t)Select);   
##@@@L0196_:}   
8000ad80:	1d 5c       	JMP       LR
8000ad82:	00 00       	NOP      NOP      
8000ad84:	44 f1 00 f0 	.long     0xf000f144 ->-268373692  [!!!@2@:JNZ       $+68                  ;->0x8000ae0c	@@: JZ        $+0                   ;->0x8000ad84
8000ad88:	fc ff ff ff 	.long     0xfffffffc ->-00000004 

8000ad8c <Scu_Hw_GetEmergencyStopFlag>:
##@@@F_:Scu_Hw_GetEmergencyStopFlag():
##@@@P_:kf32a13k_hw_scu.c:204
##@@@L0199_: * @brief 获取紧急停止标志位   
##@@@L0200_: *   
##@@@L0201_: * @retval bool   
##@@@L0202_: */   
##@@@L0203_:bool Scu_Hw_GetEmergencyStopFlag(void)   
##@@@L0204_:{   
8000ad8c:	02 45       	LD        R5, [PC + #2]         ;->0x8000ad94  :=0xf000f140
##@@@F_:Scu_LL_GetSafetyEmergencyStopFlag():
##@@@P_:kf32a13k_drv_scu.h:2606
##@@@L2601_: *   
##@@@L2602_: * @retval bool   
##@@@L2603_: */   
##@@@L2604_:KF_INLINE bool Scu_LL_GetSafetyEmergencyStopFlag(void)   
##@@@L2605_:{   
##@@@L2606_:    return (REG_BIT_BOOLED(SCU_PTR->SCU_ESCTL.bits.SEMSF, (1U << 17U)));   
8000ad8e:	55 82       	LD.W      R5, [R5]
8000ad90:	00 10       	MOV       R0, #0			;->0x0000
##@@@F_:Scu_Hw_GetEmergencyStopFlag():
##@@@P_:kf32a13k_hw_scu.c:205
##@@@L0205_:    return Scu_LL_GetSafetyEmergencyStopFlag();   
8000ad92:	1d 5c       	JMP       LR
8000ad94:	40 f1 00 f0 	.long     0xf000f140 ->-268373696  [!!!@2@:JNZ       $+64                  ;->0x8000ae14	@@: JZ        $+0                   ;->0x8000ad94

8000ad98 <Scu_Hw_GetSafetyEmergencyStopFlag>:
##@@@F_:Scu_Hw_GetSafetyEmergencyStopFlag():
##@@@P_:kf32a13k_hw_scu.c:214
##@@@L0209_: * @brief 获取SMU触发紧急停止标志位   
##@@@L0210_: *   
##@@@L0211_: * @retval bool   
##@@@L0212_: */   
##@@@L0213_:bool Scu_Hw_GetSafetyEmergencyStopFlag(void)   
##@@@L0214_:{   
8000ad98:	02 45       	LD        R5, [PC + #2]         ;->0x8000ada0  :=0xf000f140
##@@@F_:Scu_LL_GetSafetyEmergencyStopFlag():
##@@@P_:kf32a13k_drv_scu.h:2606
8000ad9a:	55 82       	LD.W      R5, [R5]
8000ad9c:	00 10       	MOV       R0, #0			;->0x0000
##@@@F_:Scu_Hw_GetSafetyEmergencyStopFlag():
##@@@P_:kf32a13k_hw_scu.c:215
##@@@L0215_:    return Scu_LL_GetSafetyEmergencyStopFlag();   
8000ad9e:	1d 5c       	JMP       LR
8000ada0:	40 f1 00 f0 	.long     0xf000f140 ->-268373696  [!!!@2@:JNZ       $+64                  ;->0x8000ae20	@@: JZ        $+0                   ;->0x8000ada0

8000ada4 <Scu_Hw_EmergencyStopFlagSelect>:
##@@@F_:Scu_LL_EmergencyStopFlagSelect():
##@@@P_:kf32a13k_drv_scu.h:2634
##@@@L2629_: *   
##@@@L2630_: * @retval void   
##@@@L2631_: */   
##@@@L2632_:KF_INLINE void Scu_LL_EmergencyStopFlagSelect(Scu_EmergencyStopFlag_t Select)   
##@@@L2633_:{   
##@@@L2634_:    REG_WRITE(SCU_PTR->SCU_ESSWCTL.bits.EMSFM, Select);   
8000ada4:	02 7a       	LSL       R0, #2			;->0x02
8000ada6:	05 45       	LD        R5, [PC + #5]         ;->0x8000adb8  :=0xf000f144
8000ada8:	4c 10       	MOV       R4, #12			;->0x000C
8000adaa:	35 82       	LD.W      R3, [R5]
8000adac:	04 42       	LD        R2, [PC + #4]         ;->0x8000adbc  :=0xfffffff3
8000adae:	04 69       	ANL       R0, R4
8000adb0:	32 69       	ANL       R3, R2
8000adb2:	30 6a       	ORL       R3, R0
8000adb4:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_EmergencyStopFlagSelect():
##@@@P_:kf32a13k_hw_scu.c:230
##@@@L0225_: * @retval void   
##@@@L0226_: */   
##@@@L0227_:void Scu_Hw_EmergencyStopFlagSelect(Scu_Hw_EmergencyStopFlag_t Select)   
##@@@L0228_:{   
##@@@L0229_:    Scu_LL_EmergencyStopFlagSelect((Scu_EmergencyStopFlag_t)Select);   
##@@@L0230_:}   
8000adb6:	1d 5c       	JMP       LR
8000adb8:	44 f1 00 f0 	.long     0xf000f144 ->-268373692  [!!!@2@:JNZ       $+68                  ;->0x8000ae40	@@: JZ        $+0                   ;->0x8000adb8
8000adbc:	f3 ff ff ff 	.long     0xfffffff3 ->-00000013 

8000adc0 <Scu_Hw_SetTrapEnabled>:
##@@@F_:Scu_LL_TrapEnable():
##@@@P_:kf32a13k_drv_scu.h:1783
##@@@L1778_: * @param bool   
##@@@L1779_: * @retval void   
##@@@L1780_: */   
##@@@L1781_:KF_INLINE void Scu_LL_TrapEnable(const Scu_CPUType_t CPU, Scu_TrapType_t Trap, const bool Status)   
##@@@L1782_:{   
##@@@L1783_:    REG_BITS_WRITE(   
8000adc0:	03 7a       	LSL       R0, #3			;->0x03
8000adc2:	68 c2       	ADD       R5, R0, R1
8000adc4:	25 6c       	LSL       R2, R5
8000adc6:	41 10       	MOV       R4, #1			;->0x0001
8000adc8:	04 43       	LD        R3, [PC + #4]         ;->0x8000add8  :=0xf000f0b8
8000adca:	45 6c       	LSL       R4, R5
8000adcc:	53 82       	LD.W      R5, [R3]
8000adce:	44 68       	NOT       R4, R4
8000add0:	54 69       	ANL       R5, R4
8000add2:	52 6a       	ORL       R5, R2
8000add4:	35 85       	ST.W      [R3], R5
##@@@F_:Scu_Hw_SetTrapEnabled():
##@@@P_:kf32a13k_hw_scu.c:244
##@@@L0239_: * @retval void   
##@@@L0240_: */   
##@@@L0241_:void Scu_Hw_SetTrapEnabled(const Scu_Hw_CPUType_t CPU, Scu_Hw_Trap_t Trap, const bool Status)   
##@@@L0242_:{   
##@@@L0243_:    Scu_LL_TrapEnable((Scu_CPUType_t)CPU, (Scu_TrapType_t)Trap, Status);   
##@@@L0244_:}   
8000add6:	1d 5c       	JMP       LR
8000add8:	b8 f0 00 f0 	.long     0xf000f0b8 ->-268373832  [!!!@2@:JZ        $-72                  ;->0x8000ad48	@@: JZ        $+0                   ;->0x8000add8

8000addc <Scu_Hw_GetTrapEnabledStatus>:
##@@@F_:Scu_LL_TrapGetEnable():
##@@@P_:kf32a13k_drv_scu.h:1798
##@@@L1793_: * @retval bool   
##@@@L1794_: */   
##@@@L1795_:KF_INLINE bool Scu_LL_TrapGetEnable(const Scu_CPUType_t CPU, Scu_TrapType_t Trap)   
##@@@L1796_:{   
##@@@L1797_:    return (   
##@@@L1798_:      REG_BITS_READ(SCU_PTR->SCU_TRAPEN.reg, MASK_1_BIT << (CPU * POS_8_SHIFT + Trap), (CPU * POS_8_SHIFT + Trap)));   
8000addc:	03 7a       	LSL       R0, #3			;->0x03
8000adde:	68 c2       	ADD       R5, R0, R1
8000ade0:	06 44       	LD        R4, [PC + #6]         ;->0x8000adf8  :=0xf000f0b8
8000ade2:	01 10       	MOV       R0, #1			;->0x0001
8000ade4:	44 82       	LD.W      R4, [R4]
8000ade6:	60 58       	MOV       R3, R0
8000ade8:	35 6c       	LSL       R3, R5
8000adea:	43 69       	ANL       R4, R3
8000adec:	45 6d       	LSR       R4, R5
##@@@P_:kf32a13k_drv_scu.h:1797
##@@@L1792_: * @param Scu_TrapType_t   
##@@@L1793_: * @retval bool   
##@@@L1794_: */   
##@@@L1795_:KF_INLINE bool Scu_LL_TrapGetEnable(const Scu_CPUType_t CPU, Scu_TrapType_t Trap)   
##@@@L1796_:{   
##@@@L1797_:    return (   
8000adee:	40 38       	CMP       R4, #0			;->0x00
8000adf0:	02 f1       	JNZ       $+2                   ;->0x8000adf4
##@@@F_:Scu_Hw_GetTrapEnabledStatus():
8000adf2:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_hw_scu.c:256
##@@@L0251_: *   
##@@@L0252_: * @retval bool   
##@@@L0253_: */   
##@@@L0254_:bool Scu_Hw_GetTrapEnabledStatus(const Scu_Hw_CPUType_t CPU, Scu_Hw_Trap_t Trap)   
##@@@L0255_:{   
##@@@L0256_:    return Scu_LL_TrapGetEnable((Scu_CPUType_t)CPU, (Scu_TrapType_t)Trap);   
8000adf4:	1d 5c       	JMP       LR
8000adf6:	00 00       	NOP      NOP      
8000adf8:	b8 f0 00 f0 	.long     0xf000f0b8 ->-268373832  [!!!@2@:JZ        $-72                  ;->0x8000ad68	@@: JZ        $+0                   ;->0x8000adf8

8000adfc <Scu_Hw_TriggerTrap>:
##@@@F_:Scu_Hw_TriggerTrap():
##@@@P_:kf32a13k_hw_scu.c:267
##@@@L0262_: * @param Trap 陷阱类型   
##@@@L0263_:
##@@@L0264_: * @retval void   
##@@@L0265_: */   
##@@@L0266_:void Scu_Hw_TriggerTrap(Scu_Hw_Trap_t Trap)   
##@@@L0267_:{   
8000adfc:	04 45       	LD        R5, [PC + #4]         ;->0x8000ae0c  :=0xf000f0b0
8000adfe:	41 10       	MOV       R4, #1			;->0x0001
##@@@F_:Scu_LL_TrapSetFlag():
##@@@P_:kf32a13k_drv_scu.h:1811
##@@@L1806_: * @param bool   
##@@@L1807_: * @retval void   
##@@@L1808_: */   
##@@@L1809_:KF_INLINE void Scu_LL_TrapSetFlag(Scu_TrapType_t Trap, const bool Status)   
##@@@L1810_:{   
##@@@L1811_:    REG_BITS_WRITE(SCU_PTR->SCU_TRAPSET.reg, MASK_1_BIT << Trap, Status << Trap);   
8000ae00:	35 82       	LD.W      R3, [R5]
8000ae02:	40 6c       	LSL       R4, R0
8000ae04:	34 6a       	ORL       R3, R4
8000ae06:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_TriggerTrap():
##@@@P_:kf32a13k_hw_scu.c:269
##@@@L0268_:    Scu_LL_TrapSetFlag((Scu_TrapType_t)Trap, true);   
##@@@L0269_:}   
8000ae08:	1d 5c       	JMP       LR
8000ae0a:	00 00       	NOP      NOP      
8000ae0c:	b0 f0 00 f0 	.long     0xf000f0b0 ->-268373840  [!!!@2@:JZ        $-80                  ;->0x8000ad6c	@@: JZ        $+0                   ;->0x8000ae0c

8000ae10 <Scu_Hw_ClearTrapFlag>:
##@@@F_:Scu_Hw_ClearTrapFlag():
##@@@P_:kf32a13k_hw_scu.c:279
##@@@L0274_: * @param Trap 陷阱类型   
##@@@L0275_: *   
##@@@L0276_: * @retval void   
##@@@L0277_: */   
##@@@L0278_:void Scu_Hw_ClearTrapFlag(Scu_Hw_Trap_t Trap)   
##@@@L0279_:{   
8000ae10:	04 45       	LD        R5, [PC + #4]         ;->0x8000ae20  :=0xf000f0b4
8000ae12:	41 10       	MOV       R4, #1			;->0x0001
##@@@F_:Scu_LL_TrapClearFlag():
##@@@P_:kf32a13k_drv_scu.h:1824
##@@@L1819_: * @param bool   
##@@@L1820_: * @retval void   
##@@@L1821_: */   
##@@@L1822_:KF_INLINE void Scu_LL_TrapClearFlag(Scu_TrapType_t Trap, const bool Status)   
##@@@L1823_:{   
##@@@L1824_:    REG_BITS_WRITE(SCU_PTR->SCU_TRAPCLR.reg, MASK_1_BIT << Trap, Status << Trap);   
8000ae14:	35 82       	LD.W      R3, [R5]
8000ae16:	40 6c       	LSL       R4, R0
8000ae18:	34 6a       	ORL       R3, R4
8000ae1a:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_ClearTrapFlag():
##@@@P_:kf32a13k_hw_scu.c:281
##@@@L0280_:    Scu_LL_TrapClearFlag((Scu_TrapType_t)Trap, true);   
##@@@L0281_:}   
8000ae1c:	1d 5c       	JMP       LR
8000ae1e:	00 00       	NOP      NOP      
8000ae20:	b4 f0 00 f0 	.long     0xf000f0b4 ->-268373836  [!!!@2@:JZ        $-76                  ;->0x8000ad88	@@: JZ        $+0                   ;->0x8000ae20

8000ae24 <Scu_Hw_GetTrapTriggerFlag>:
##@@@F_:Scu_Hw_GetTrapTriggerFlag():
##@@@P_:kf32a13k_hw_scu.c:291
##@@@L0286_: * @param Trap 陷阱类型   
##@@@L0287_: *   
##@@@L0288_: * @retval bool   
##@@@L0289_: */   
##@@@L0290_:bool Scu_Hw_GetTrapTriggerFlag(Scu_Hw_Trap_t Trap)   
##@@@L0291_:{   
8000ae24:	a0 58       	MOV       R5, R0
8000ae26:	06 44       	LD        R4, [PC + #6]         ;->0x8000ae3c  :=0xf000f0ac
8000ae28:	01 10       	MOV       R0, #1			;->0x0001
##@@@F_:Scu_LL_TrapGetFlag():
##@@@P_:kf32a13k_drv_scu.h:1836
##@@@L1831_: * @param Scu_TrapType_t   
##@@@L1832_: * @retval bool   
##@@@L1833_: */   
##@@@L1834_:KF_INLINE bool Scu_LL_TrapGetFlag(Scu_TrapType_t Trap)   
##@@@L1835_:{   
##@@@L1836_:    return (REG_BITS_READ(SCU_PTR->SCU_TRAPSTA.reg, MASK_1_BIT << Trap, Trap));   
8000ae2a:	44 82       	LD.W      R4, [R4]
8000ae2c:	60 58       	MOV       R3, R0
8000ae2e:	35 6c       	LSL       R3, R5
8000ae30:	43 69       	ANL       R4, R3
8000ae32:	45 6d       	LSR       R4, R5
8000ae34:	40 38       	CMP       R4, #0			;->0x00
8000ae36:	02 f1       	JNZ       $+2                   ;->0x8000ae3a
##@@@F_:Scu_Hw_GetTrapTriggerFlag():
8000ae38:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_hw_scu.c:292
##@@@L0292_:    return (Scu_LL_TrapGetFlag((Scu_TrapType_t)Trap));   
8000ae3a:	1d 5c       	JMP       LR
8000ae3c:	ac f0 00 f0 	.long     0xf000f0ac ->-268373844  [!!!@2@:JZ        $-84                  ;->0x8000ad94	@@: JZ        $+0                   ;->0x8000ae3c

8000ae40 <Scu_Hw_GetCpuWdtCheckTolerance>:
##@@@F_:Scu_LL_GetCpuWdtCheckTolerance():
##@@@P_:kf32a13k_drv_scu.h:2463
##@@@L2458_: */   
##@@@L2459_:KF_INLINE uint8_t Scu_LL_GetCpuWdtCheckTolerance(Scu_CPUType_t CPU)   
##@@@L2460_:{   
##@@@L2461_:    uint8_t retVal = 0U;   
##@@@L2462_:
##@@@L2463_:    retVal = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTSTA.bits.TCT);   
8000ae40:	04 45       	LD        R5, [PC + #4]         ;->0x8000ae50  :=0xf000f0d8
8000ae42:	04 7a       	LSL       R0, #4			;->0x04
8000ae44:	40 e9       	LD.W      R0, [R0 + R5]
8000ae46:	81 7c       	LSR       R0, #9			;->0x09
8000ae48:	5f 17       	MOV       R5, #127			;->0x007F
##@@@F_:Scu_Hw_GetCpuWdtCheckTolerance():
##@@@P_:kf32a13k_hw_scu.c:304
##@@@L0299_: *   
##@@@L0300_: * @retval bool   
##@@@L0301_: */   
##@@@L0302_:uint8_t Scu_Hw_GetCpuWdtCheckTolerance(Scu_Hw_CPUType_t CPU)   
##@@@L0303_:{   
##@@@L0304_:    return Scu_LL_GetCpuWdtCheckTolerance((Scu_CPUType_t)CPU);   
8000ae4a:	05 69       	ANL       R0, R5
8000ae4c:	1d 5c       	JMP       LR
8000ae4e:	00 00       	NOP      NOP      
8000ae50:	d8 f0 00 f0 	.long     0xf000f0d8 ->-268373800  [!!!@2@:JZ        $-40                  ;->0x8000ae00	@@: JZ        $+0                   ;->0x8000ae50

8000ae54 <Scu_Hw_GetCpuWdtTimerValue>:
##@@@F_:Scu_LL_GetCpuWdtTimerValue():
##@@@P_:kf32a13k_drv_scu.h:2479
##@@@L2474_: */   
##@@@L2475_:KF_INLINE uint16_t Scu_LL_GetCpuWdtTimerValue(Scu_CPUType_t CPU)   
##@@@L2476_:{   
##@@@L2477_:    uint16_t retVal = 0U;   
##@@@L2478_:
##@@@L2479_:    retVal = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTSTA.bits.TIM);   
8000ae54:	03 45       	LD        R5, [PC + #3]         ;->0x8000ae60  :=0xf000f0d8
8000ae56:	04 7a       	LSL       R0, #4			;->0x04
8000ae58:	40 e9       	LD.W      R0, [R0 + R5]
8000ae5a:	00 7d       	LSR       R0, #16			;->0x10
##@@@F_:Scu_Hw_GetCpuWdtTimerValue():
##@@@P_:kf32a13k_hw_scu.c:316
##@@@L0311_: *   
##@@@L0312_: * @retval bool   
##@@@L0313_: */   
##@@@L0314_:uint16_t Scu_Hw_GetCpuWdtTimerValue(Scu_Hw_CPUType_t CPU)   
##@@@L0315_:{   
##@@@L0316_:    return Scu_LL_GetCpuWdtTimerValue((Scu_CPUType_t)CPU);   
8000ae5c:	1d 5c       	JMP       LR
8000ae5e:	00 00       	NOP      NOP      
8000ae60:	d8 f0 00 f0 	.long     0xf000f0d8 ->-268373800  [!!!@2@:JZ        $-40                  ;->0x8000ae10	@@: JZ        $+0                   ;->0x8000ae60

8000ae64 <Scu_Hw_GetCpuWdtStatus>:
##@@@F_:Scu_LL_GetCpuWdtStatus():
##@@@P_:kf32a13k_drv_scu.h:2447
##@@@L2442_: */   
##@@@L2443_:KF_INLINE bool Scu_LL_GetCpuWdtStatus(Scu_CPUType_t CPU, Scu_WdtStatusFlag_t Flag)   
##@@@L2444_:{   
##@@@L2445_:    bool retVal = true;   
##@@@L2446_:
##@@@L2447_:    retVal = REG_BIT_BOOLED(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTSTA.reg, (1U << Flag));   
8000ae64:	04 45       	LD        R5, [PC + #4]         ;->0x8000ae74  :=0xf000f0d8
8000ae66:	04 7a       	LSL       R0, #4			;->0x04
8000ae68:	40 e9       	LD.W      R0, [R0 + R5]
8000ae6a:	01 6d       	LSR       R0, R1
8000ae6c:	51 10       	MOV       R5, #1			;->0x0001
8000ae6e:	05 69       	ANL       R0, R5
##@@@F_:Scu_Hw_GetCpuWdtStatus():
##@@@P_:kf32a13k_hw_scu.c:329
##@@@L0324_: *   
##@@@L0325_: * @retval bool   
##@@@L0326_: */   
##@@@L0327_:bool Scu_Hw_GetCpuWdtStatus(Scu_Hw_CPUType_t CPU, Scu_Hw_WdtStatusFlag_t Flag)   
##@@@L0328_:{   
##@@@L0329_:    return Scu_LL_GetCpuWdtStatus((Scu_CPUType_t)CPU, (Scu_WdtStatusFlag_t)Flag);   
8000ae70:	1d 5c       	JMP       LR
8000ae72:	00 00       	NOP      NOP      
8000ae74:	d8 f0 00 f0 	.long     0xf000f0d8 ->-268373800  [!!!@2@:JZ        $-40                  ;->0x8000ae24	@@: JZ        $+0                   ;->0x8000ae74

8000ae78 <Scu_Hw_WdtGetCpuWdgReload>:
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000ae78:	03 45       	LD        R5, [PC + #3]         ;->0x8000ae84  :=0xf000f0d0
8000ae7a:	04 7a       	LSL       R0, #4			;->0x04
8000ae7c:	40 e9       	LD.W      R0, [R0 + R5]
8000ae7e:	03 45       	LD        R5, [PC + #3]         ;->0x8000ae88  :=0x1ffff
8000ae80:	05 69       	ANL       R0, R5
##@@@F_:Scu_Hw_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_hw_scu.c:340
##@@@L0335_: * @param CPU   
##@@@L0336_: * @retval uint32_t   
##@@@L0337_: */   
##@@@L0338_:uint32_t Scu_Hw_WdtGetCpuWdgReload(Scu_Hw_CPUType_t CPU)   
##@@@L0339_:{   
##@@@L0340_:    return Scu_LL_WdtGetCpuWdgReload((Scu_CPUType_t)CPU);   
8000ae82:	1d 5c       	JMP       LR
8000ae84:	d0 f0 00 f0 	.long     0xf000f0d0 ->-268373808  [!!!@2@:JZ        $-48                  ;->0x8000ae24	@@: JZ        $+0                   ;->0x8000ae84
8000ae88:	ff ff 01 00 	.long     0x0001ffff ->000131071 

8000ae8c <Scu_Hw_WdtGetCpuRegLockState>:
##@@@F_:Scu_Hw_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_hw_scu.c:352
##@@@L0347_: * @retval bool   
##@@@L0348_: *         true:寄存器被锁定   
##@@@L0349_: *         false:寄存器被解锁   
##@@@L0350_: */   
##@@@L0351_:bool Scu_Hw_WdtGetCpuRegLockState(Scu_Hw_CPUType_t CPU)   
##@@@L0352_:{   
8000ae8c:	04 45       	LD        R5, [PC + #4]         ;->0x8000ae9c  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000ae8e:	04 7a       	LSL       R0, #4			;->0x04
8000ae90:	40 e7       	LD.H      R0, [R0 + R5]
8000ae92:	52 10       	MOV       R5, #2			;->0x0002
8000ae94:	05 69       	ANL       R0, R5
8000ae96:	01 7c       	LSR       R0, #1			;->0x01
##@@@F_:Scu_Hw_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_hw_scu.c:353
##@@@L0353_:    return Scu_LL_WdtGetCpuRegLockState((Scu_CPUType_t)CPU);   
8000ae98:	1d 5c       	JMP       LR
8000ae9a:	00 00       	NOP      NOP      
8000ae9c:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000ae34	@@: JZ        $+0                   ;->0x8000ae9c

8000aea0 <Scu_Hw_WdtClearCpuEndinit>:
##@@@F_:Scu_Hw_WdtClearCpuEndinit():
##@@@P_:kf32a13k_hw_scu.c:365
##@@@L0360_: * @param uint32_t   
##@@@L0361_: * @param uint32_t   
##@@@L0362_: * @retval void   
##@@@L0363_: */   
##@@@L0364_:void Scu_Hw_WdtClearCpuEndinit(Scu_Hw_CPUType_t CPU, uint32_t Password)   
##@@@L0365_:{   
8000aea0:	0a 45       	LD        R5, [PC + #10]        ;->0x8000aec8  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000aea2:	04 7a       	LSL       R0, #4			;->0x04
8000aea4:	60 c3       	ADD       R4, R0, R5
8000aea6:	64 98       	LD.W      R4, [R4 + #1]
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
8000aea8:	20 7b       	LSL       R4, #16			;->0x10
8000aeaa:	0a 7a       	LSL       R1, #2			;->0x02
8000aeac:	41 6a       	ORL       R4, R1
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000aeae:	50 e7       	LD.H      R2, [R0 + R5]
8000aeb0:	32 10       	MOV       R3, #2			;->0x0002
8000aeb2:	23 69       	ANL       R2, R3
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2246
##@@@L2241_: * @retval void   
##@@@L2242_: */   
##@@@L2243_:KF_INLINE void Scu_LL_WdtClearCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2244_:{   
##@@@L2245_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2246_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000aeb4:	20 38       	CMP       R2, #0			;->0x00
8000aeb6:	05 f0       	JZ        $+5                   ;->0x8000aec0
8000aeb8:	21 10       	MOV       R2, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2248
##@@@L2247_:    {   
##@@@L2248_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000aeba:	24 58       	MOV       R1, R4
8000aebc:	12 6a       	ORL       R1, R2
8000aebe:	41 ef       	ST.W      [R0 + R5], R1
##@@@P_:kf32a13k_drv_scu.h:2251
##@@@L2249_:    }   
##@@@L2250_:
##@@@L2251_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000aec0:	43 6a       	ORL       R4, R3
8000aec2:	44 ef       	ST.W      [R0 + R5], R4
##@@@F_:Scu_Hw_WdtClearCpuEndinit():
##@@@P_:kf32a13k_hw_scu.c:367
##@@@L0366_:    Scu_LL_WdtClearCpuEndinitInline(CPU, Password);   
##@@@L0367_:}   
8000aec4:	1d 5c       	JMP       LR
8000aec6:	00 00       	NOP      NOP      
8000aec8:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000ae60	@@: JZ        $+0                   ;->0x8000aec8

8000aecc <Scu_Hw_WdtSetCpuEndinit>:
##@@@F_:Scu_Hw_WdtSetCpuEndinit():
##@@@P_:kf32a13k_hw_scu.c:377
##@@@L0372_: *   
##@@@L0373_: * @param uint32_t   
##@@@L0374_: * @retval void   
##@@@L0375_: */   
##@@@L0376_:void Scu_Hw_WdtSetCpuEndinit(Scu_Hw_CPUType_t CPU, uint32_t Password)   
##@@@L0377_:{   
8000aecc:	0a 45       	LD        R5, [PC + #10]        ;->0x8000aef4  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000aece:	04 7a       	LSL       R0, #4			;->0x04
8000aed0:	60 c3       	ADD       R4, R0, R5
8000aed2:	64 98       	LD.W      R4, [R4 + #1]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000aed4:	20 7b       	LSL       R4, #16			;->0x10
8000aed6:	0a 7a       	LSL       R1, #2			;->0x02
8000aed8:	41 6a       	ORL       R4, R1
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000aeda:	58 e7       	LD.H      R3, [R0 + R5]
8000aedc:	22 10       	MOV       R2, #2			;->0x0002
8000aede:	32 69       	ANL       R3, R2
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2271
##@@@L2266_: * @retval void   
##@@@L2267_: */   
##@@@L2268_:KF_INLINE void Scu_LL_WdtSetCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2269_:{   
##@@@L2270_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2271_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000aee0:	30 38       	CMP       R3, #0			;->0x00
8000aee2:	05 f0       	JZ        $+5                   ;->0x8000aeec
8000aee4:	31 10       	MOV       R3, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2273
##@@@L2272_:    {   
##@@@L2273_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000aee6:	44 58       	MOV       R2, R4
8000aee8:	23 6a       	ORL       R2, R3
8000aeea:	42 ef       	ST.W      [R0 + R5], R2
8000aeec:	33 10       	MOV       R3, #3			;->0x0003
##@@@P_:kf32a13k_drv_scu.h:2276
##@@@L2274_:    }   
##@@@L2275_:
##@@@L2276_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000aeee:	43 6a       	ORL       R4, R3
8000aef0:	44 ef       	ST.W      [R0 + R5], R4
##@@@F_:Scu_Hw_WdtSetCpuEndinit():
##@@@P_:kf32a13k_hw_scu.c:379
##@@@L0378_:    Scu_LL_WdtSetCpuEndinitInline(CPU, Password);   
##@@@L0379_:}   
8000aef2:	1d 5c       	JMP       LR
8000aef4:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000ae8c	@@: JZ        $+0                   ;->0x8000aef4

8000aef8 <Scu_Hw_WdtChangeCpuWdgPassword>:
##@@@F_:Scu_Hw_WdtChangeCpuWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:391
##@@@L0386_: * @param uint32_t   
##@@@L0387_: * @param uint32_t   
##@@@L0388_: * @retval void   
##@@@L0389_: */   
##@@@L0390_:void Scu_Hw_WdtChangeCpuWdgPassword(Scu_Hw_CPUType_t CPU, uint32_t Password, uint32_t NewPassword)   
##@@@L0391_:{   
8000aef8:	26 5d       	PUSH      R6
8000aefa:	e4 30       	SUB       SP, #4			;->0x04
8000aefc:	0b 45       	LD        R5, [PC + #11]        ;->0x8000af28  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000aefe:	04 7a       	LSL       R0, #4			;->0x04
8000af00:	60 c3       	ADD       R4, R0, R5
8000af02:	5c 98       	LD.W      R3, [R4 + #1]
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000af04:	70 e7       	LD.H      R6, [R0 + R5]
8000af06:	42 10       	MOV       R4, #2			;->0x0002
8000af08:	64 69       	ANL       R6, R4
##@@@F_:Scu_LL_WdtChangeCpuWdgPasswordInline():
##@@@P_:kf32a13k_drv_scu.h:2347
##@@@L2342_:KF_INLINE void Scu_LL_WdtChangeCpuWdgPasswordInline(Scu_CPUType_t CPU, uint32_t Password, uint32_t NewPassword)   
##@@@L2343_:{   
##@@@L2344_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2345_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
##@@@L2346_:    {   
##@@@L2347_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000af0a:	18 7b       	LSL       R3, #16			;->0x10
##@@@P_:kf32a13k_drv_scu.h:2345
##@@@L2340_: * @retval void   
##@@@L2341_: */   
##@@@L2342_:KF_INLINE void Scu_LL_WdtChangeCpuWdgPasswordInline(Scu_CPUType_t CPU, uint32_t Password, uint32_t NewPassword)   
##@@@L2343_:{   
##@@@L2344_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2345_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000af0c:	60 38       	CMP       R6, #0			;->0x00
8000af0e:	06 f0       	JZ        $+6                   ;->0x8000af1a
##@@@P_:kf32a13k_drv_scu.h:2347
##@@@L2346_:    {   
##@@@L2347_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000af10:	0a 7a       	LSL       R1, #2			;->0x02
8000af12:	13 6a       	ORL       R1, R3
8000af14:	61 10       	MOV       R6, #1			;->0x0001
8000af16:	16 6a       	ORL       R1, R6
8000af18:	41 ef       	ST.W      [R0 + R5], R1
##@@@P_:kf32a13k_drv_scu.h:2350
##@@@L2348_:    }   
##@@@L2349_:
##@@@L2350_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (NewPassword << 2U) | (Rel << 16U);   
8000af1a:	12 7a       	LSL       R2, #2			;->0x02
8000af1c:	23 6a       	ORL       R2, R3
8000af1e:	24 6a       	ORL       R2, R4
8000af20:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Scu_Hw_WdtChangeCpuWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:393
##@@@L0392_:    Scu_LL_WdtChangeCpuWdgPasswordInline(CPU, Password, NewPassword);   
##@@@L0393_:}   
8000af22:	e4 28       	ADD       SP, #4			;->0x04
8000af24:	06 5d       	POP       R6
8000af26:	1d 5c       	JMP       LR
8000af28:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000aec0	@@: JZ        $+0                   ;->0x8000af28

8000af2c <Scu_Hw_WdtChangeCpuWdgReload>:
##@@@F_:Scu_Hw_WdtChangeCpuWdgReload():
##@@@P_:kf32a13k_hw_scu.c:405
##@@@L0400_: * @param uint32_t   
##@@@L0401_: * @param uint32_t   
##@@@L0402_: * @retval void   
##@@@L0403_: */   
##@@@L0404_:void Scu_Hw_WdtChangeCpuWdgReload(Scu_Hw_CPUType_t CPU, uint32_t Password, uint32_t Reload)   
##@@@L0405_:{   
8000af2c:	26 5d       	PUSH      R6
8000af2e:	e4 30       	SUB       SP, #4			;->0x04
8000af30:	0c 45       	LD        R5, [PC + #12]        ;->0x8000af60  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000af32:	04 7a       	LSL       R0, #4			;->0x04
8000af34:	60 c3       	ADD       R4, R0, R5
8000af36:	5c 98       	LD.W      R3, [R4 + #1]
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000af38:	70 e7       	LD.H      R6, [R0 + R5]
8000af3a:	42 10       	MOV       R4, #2			;->0x0002
8000af3c:	64 69       	ANL       R6, R4
##@@@F_:Scu_LL_WdtChangeCpuWdgReloadInline():
8000af3e:	0a 7a       	LSL       R1, #2			;->0x02
##@@@P_:kf32a13k_drv_scu.h:2371
##@@@L2366_: * @retval void   
##@@@L2367_: */   
##@@@L2368_:KF_INLINE void Scu_LL_WdtChangeCpuWdgReloadInline(Scu_CPUType_t CPU, uint32_t Password, uint32_t Reload)   
##@@@L2369_:{   
##@@@L2370_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2371_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000af40:	60 38       	CMP       R6, #0			;->0x00
8000af42:	07 f0       	JZ        $+7                   ;->0x8000af50
##@@@P_:kf32a13k_drv_scu.h:2373
##@@@L2372_:    {   
##@@@L2373_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000af44:	18 7b       	LSL       R3, #16			;->0x10
8000af46:	c1 58       	MOV       R6, R1
8000af48:	63 6a       	ORL       R6, R3
8000af4a:	31 10       	MOV       R3, #1			;->0x0001
8000af4c:	63 6a       	ORL       R6, R3
8000af4e:	46 ef       	ST.W      [R0 + R5], R6
##@@@P_:kf32a13k_drv_scu.h:2376
##@@@L2374_:    }   
##@@@L2375_:
##@@@L2376_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Reload << 16U);   
8000af50:	10 7b       	LSL       R2, #16			;->0x10
8000af52:	12 6a       	ORL       R1, R2
8000af54:	14 6a       	ORL       R1, R4
8000af56:	41 ef       	ST.W      [R0 + R5], R1
##@@@F_:Scu_Hw_WdtChangeCpuWdgReload():
##@@@P_:kf32a13k_hw_scu.c:407
##@@@L0406_:    Scu_LL_WdtChangeCpuWdgReloadInline(CPU, Password, Reload);   
##@@@L0407_:}   
8000af58:	e4 28       	ADD       SP, #4			;->0x04
8000af5a:	06 5d       	POP       R6
8000af5c:	1d 5c       	JMP       LR
8000af5e:	00 00       	NOP      NOP      
8000af60:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000aef8	@@: JZ        $+0                   ;->0x8000af60

8000af64 <Scu_Hw_WdtClearSafetyEndinit>:
##@@@F_:Scu_Hw_WdtClearSafetyEndinit():
##@@@P_:kf32a13k_hw_scu.c:417
##@@@L0412_: *   
##@@@L0413_: * @param uint32_t   
##@@@L0414_: * @retval void   
##@@@L0415_: */   
##@@@L0416_:void Scu_Hw_WdtClearSafetyEndinit(uint32_t Password)   
##@@@L0417_:{   
8000af64:	09 45       	LD        R5, [PC + #9]         ;->0x8000af88  :=0xf000f0c0
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000af66:	55 82       	LD.W      R5, [R5]
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
8000af68:	02 7a       	LSL       R0, #2			;->0x02
8000af6a:	28 7b       	LSL       R5, #16			;->0x10
8000af6c:	08 44       	LD        R4, [PC + #8]         ;->0x8000af8c  :=0xf000f0bc
8000af6e:	50 6a       	ORL       R5, R0
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000af70:	24 81       	LD.H      R2, [R4]
8000af72:	32 10       	MOV       R3, #2			;->0x0002
8000af74:	23 69       	ANL       R2, R3
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2295
##@@@L2290_: * @retval void   
##@@@L2291_: */   
##@@@L2292_:KF_INLINE void Scu_LL_WdtClearSafetyEndinitInline(uint32_t Password)   
##@@@L2293_:{   
##@@@L2294_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2295_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000af76:	20 38       	CMP       R2, #0			;->0x00
8000af78:	05 f0       	JZ        $+5                   ;->0x8000af82
8000af7a:	21 10       	MOV       R2, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2297
##@@@L2296_:    {   
##@@@L2297_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000af7c:	25 58       	MOV       R1, R5
8000af7e:	12 6a       	ORL       R1, R2
8000af80:	41 85       	ST.W      [R4], R1
##@@@P_:kf32a13k_drv_scu.h:2300
##@@@L2298_:    }   
##@@@L2299_:
##@@@L2300_:    SCU_PTR->SCU_SWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000af82:	53 6a       	ORL       R5, R3
8000af84:	45 85       	ST.W      [R4], R5
##@@@F_:Scu_Hw_WdtClearSafetyEndinit():
##@@@P_:kf32a13k_hw_scu.c:419
##@@@L0418_:    Scu_LL_WdtClearSafetyEndinitInline(Password);   
##@@@L0419_:}   
8000af86:	1d 5c       	JMP       LR
8000af88:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000af08	@@: JZ        $+0                   ;->0x8000af88
8000af8c:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000af04	@@: JZ        $+0                   ;->0x8000af8c

8000af90 <Scu_Hw_WdtSetSafetyEndinit>:
##@@@F_:Scu_Hw_WdtSetSafetyEndinit():
##@@@P_:kf32a13k_hw_scu.c:429
##@@@L0424_: *   
##@@@L0425_: * @param uint32_t   
##@@@L0426_: * @retval void   
##@@@L0427_: */   
##@@@L0428_:void Scu_Hw_WdtSetSafetyEndinit(uint32_t Password)   
##@@@L0429_:{   
8000af90:	0a 45       	LD        R5, [PC + #10]        ;->0x8000afb8  :=0xf000f0c0
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000af92:	55 82       	LD.W      R5, [R5]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000af94:	02 7a       	LSL       R0, #2			;->0x02
8000af96:	28 7b       	LSL       R5, #16			;->0x10
8000af98:	09 44       	LD        R4, [PC + #9]         ;->0x8000afbc  :=0xf000f0bc
8000af9a:	50 6a       	ORL       R5, R0
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000af9c:	34 81       	LD.H      R3, [R4]
8000af9e:	22 10       	MOV       R2, #2			;->0x0002
8000afa0:	32 69       	ANL       R3, R2
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2319
##@@@L2314_: * @retval void   
##@@@L2315_: */   
##@@@L2316_:KF_INLINE void Scu_LL_WdtSetSafetyEndinitInline(uint32_t Password)   
##@@@L2317_:{   
##@@@L2318_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2319_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000afa2:	30 38       	CMP       R3, #0			;->0x00
8000afa4:	05 f0       	JZ        $+5                   ;->0x8000afae
8000afa6:	31 10       	MOV       R3, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2321
##@@@L2320_:    {   
##@@@L2321_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000afa8:	45 58       	MOV       R2, R5
8000afaa:	23 6a       	ORL       R2, R3
8000afac:	42 85       	ST.W      [R4], R2
8000afae:	33 10       	MOV       R3, #3			;->0x0003
##@@@P_:kf32a13k_drv_scu.h:2324
##@@@L2322_:    }   
##@@@L2323_:
##@@@L2324_:    SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000afb0:	53 6a       	ORL       R5, R3
8000afb2:	45 85       	ST.W      [R4], R5
##@@@F_:Scu_Hw_WdtSetSafetyEndinit():
##@@@P_:kf32a13k_hw_scu.c:431
##@@@L0430_:    Scu_LL_WdtSetSafetyEndinitInline(Password);   
##@@@L0431_:}   
8000afb4:	1d 5c       	JMP       LR
8000afb6:	00 00       	NOP      NOP      
8000afb8:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000af38	@@: JZ        $+0                   ;->0x8000afb8
8000afbc:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000af34	@@: JZ        $+0                   ;->0x8000afbc

8000afc0 <Scu_Hw_WdtChangeSafetyWdgPassword>:
##@@@F_:Scu_Hw_WdtChangeSafetyWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:442
##@@@L0437_: * @param uint32_t   
##@@@L0438_: * @param uint32_t   
##@@@L0439_: * @retval void   
##@@@L0440_: */   
##@@@L0441_:void Scu_Hw_WdtChangeSafetyWdgPassword(uint32_t Password, uint32_t NewPassword)   
##@@@L0442_:{   
8000afc0:	0a 44       	LD        R4, [PC + #10]        ;->0x8000afe8  :=0xf000f0c0
8000afc2:	0b 45       	LD        R5, [PC + #11]        ;->0x8000afec  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000afc4:	34 82       	LD.W      R3, [R4]
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000afc6:	25 81       	LD.H      R2, [R5]
8000afc8:	42 10       	MOV       R4, #2			;->0x0002
8000afca:	24 69       	ANL       R2, R4
##@@@F_:Scu_LL_WdtChangeSafetyWdgPasswordInline():
##@@@P_:kf32a13k_drv_scu.h:2398
##@@@L2393_:KF_INLINE void Scu_LL_WdtChangeSafetyWdgPasswordInline(uint32_t Password, uint32_t NewPassword)   
##@@@L2394_:{   
##@@@L2395_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2396_:    if (Scu_LL_WdtGetSafetyRegLockState())   
##@@@L2397_:    {   
##@@@L2398_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000afcc:	18 7b       	LSL       R3, #16			;->0x10
##@@@P_:kf32a13k_drv_scu.h:2396
##@@@L2391_: * @retval void   
##@@@L2392_: */   
##@@@L2393_:KF_INLINE void Scu_LL_WdtChangeSafetyWdgPasswordInline(uint32_t Password, uint32_t NewPassword)   
##@@@L2394_:{   
##@@@L2395_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2396_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000afce:	20 38       	CMP       R2, #0			;->0x00
8000afd0:	06 f0       	JZ        $+6                   ;->0x8000afdc
##@@@P_:kf32a13k_drv_scu.h:2398
##@@@L2397_:    {   
##@@@L2398_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000afd2:	02 7a       	LSL       R0, #2			;->0x02
8000afd4:	03 6a       	ORL       R0, R3
8000afd6:	21 10       	MOV       R2, #1			;->0x0001
8000afd8:	02 6a       	ORL       R0, R2
8000afda:	50 85       	ST.W      [R5], R0
##@@@P_:kf32a13k_drv_scu.h:2401
##@@@L2399_:    }   
##@@@L2400_:
##@@@L2401_:    SCU_PTR->SCU_SWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (NewPassword << 2U) | (Rel << 16U);   
8000afdc:	0a 7a       	LSL       R1, #2			;->0x02
8000afde:	13 6a       	ORL       R1, R3
8000afe0:	14 6a       	ORL       R1, R4
8000afe2:	51 85       	ST.W      [R5], R1
##@@@F_:Scu_Hw_WdtChangeSafetyWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:444
##@@@L0443_:    Scu_LL_WdtChangeSafetyWdgPasswordInline(Password, NewPassword);   
##@@@L0444_:}   
8000afe4:	1d 5c       	JMP       LR
8000afe6:	00 00       	NOP      NOP      
8000afe8:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000af68	@@: JZ        $+0                   ;->0x8000afe8
8000afec:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000af64	@@: JZ        $+0                   ;->0x8000afec

8000aff0 <Scu_Hw_WdtChangeSafetyWdgReload>:
##@@@F_:Scu_Hw_WdtChangeSafetyWdgReload():
##@@@P_:kf32a13k_hw_scu.c:455
##@@@L0450_: * @param uint32_t   
##@@@L0451_: * @param uint32_t   
##@@@L0452_: * @retval void   
##@@@L0453_: */   
##@@@L0454_:void Scu_Hw_WdtChangeSafetyWdgReload(uint32_t Password, uint32_t Reload)   
##@@@L0455_:{   
8000aff0:	0b 44       	LD        R4, [PC + #11]        ;->0x8000b01c  :=0xf000f0c0
8000aff2:	0c 45       	LD        R5, [PC + #12]        ;->0x8000b020  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000aff4:	34 82       	LD.W      R3, [R4]
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000aff6:	25 81       	LD.H      R2, [R5]
8000aff8:	42 10       	MOV       R4, #2			;->0x0002
8000affa:	24 69       	ANL       R2, R4
##@@@F_:Scu_LL_WdtChangeSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:2421
##@@@L2416_: * @retval void   
##@@@L2417_: */   
##@@@L2418_:KF_INLINE void Scu_LL_WdtChangeSafetyWdgReload(uint32_t Password, uint32_t Reload)   
##@@@L2419_:{   
##@@@L2420_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2421_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000affc:	20 38       	CMP       R2, #0			;->0x00
8000affe:	07 f0       	JZ        $+7                   ;->0x8000b00c
##@@@P_:kf32a13k_drv_scu.h:2423
##@@@L2422_:    {   
##@@@L2423_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b000:	18 7b       	LSL       R3, #16			;->0x10
8000b002:	02 7a       	LSL       R0, #2			;->0x02
8000b004:	03 6a       	ORL       R0, R3
8000b006:	31 10       	MOV       R3, #1			;->0x0001
8000b008:	03 6a       	ORL       R0, R3
8000b00a:	50 85       	ST.W      [R5], R0
##@@@P_:kf32a13k_drv_scu.h:2426
##@@@L2424_:    }   
##@@@L2425_:
##@@@L2426_:    SCU_PTR->SCU_SWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Reload << 2U) | (Reload << 16U);   
8000b00c:	61 58       	MOV       R3, R1
8000b00e:	18 7b       	LSL       R3, #16			;->0x10
8000b010:	0a 7a       	LSL       R1, #2			;->0x02
8000b012:	13 6a       	ORL       R1, R3
8000b014:	14 6a       	ORL       R1, R4
8000b016:	51 85       	ST.W      [R5], R1
##@@@F_:Scu_Hw_WdtChangeSafetyWdgReload():
##@@@P_:kf32a13k_hw_scu.c:457
##@@@L0456_:    Scu_LL_WdtChangeSafetyWdgReload(Password, Reload);   
##@@@L0457_:}   
8000b018:	1d 5c       	JMP       LR
8000b01a:	00 00       	NOP      NOP      
8000b01c:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000af9c	@@: JZ        $+0                   ;->0x8000b01c
8000b020:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000af98	@@: JZ        $+0                   ;->0x8000b020

8000b024 <Scu_Hw_WdtClearGlobalEndinit>:
##@@@F_:Scu_Hw_WdtClearGlobalEndinit():
##@@@P_:kf32a13k_hw_scu.c:467
##@@@L0462_: *   
##@@@L0463_: * @param uint32_t   
##@@@L0464_: * @retval void   
##@@@L0465_: */   
##@@@L0466_:void Scu_Hw_WdtClearGlobalEndinit(uint32_t Password)   
##@@@L0467_:{   
8000b024:	0a 45       	LD        R5, [PC + #10]        ;->0x8000b04c  :=0xf000f0ec
##@@@F_:Scu_LL_WdtGetGlobalEndInit():
##@@@P_:kf32a13k_drv_scu.h:1188
##@@@L1183_: * @param void   
##@@@L1184_: * @retval bool   
##@@@L1185_: */   
##@@@L1186_:KF_INLINE bool Scu_LL_WdtGetGlobalEndInit(void)   
##@@@L1187_:{   
##@@@L1188_:    return (REG_READ(SCU_PTR->SCU_GECTL0.bits.ENDINIT));   
8000b026:	45 82       	LD.W      R4, [R5]
8000b028:	32 10       	MOV       R3, #2			;->0x0002
8000b02a:	43 69       	ANL       R4, R3
##@@@F_:Scu_Hw_WdtClearGlobalEndinit():
##@@@P_:kf32a13k_hw_scu.c:469
##@@@L0468_:    // TODO:需要确定使用方式   
##@@@L0469_:    if (true == Scu_LL_WdtGetGlobalEndInit())   
8000b02c:	40 38       	CMP       R4, #0			;->0x00
8000b02e:	0d f0       	JZ        $+13                  ;->0x8000b048
##@@@F_:Scu_LL_WdtSetGlobalWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:1200
##@@@L1195_: * @param Password   
##@@@L1196_: * @retval void   
##@@@L1197_: */   
##@@@L1198_:KF_INLINE void Scu_LL_WdtSetGlobalWdgPassword(uint32_t Password)   
##@@@L1199_:{   
##@@@L1200_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.EPW, Password);   
8000b030:	02 7a       	LSL       R0, #2			;->0x02
8000b032:	08 44       	LD        R4, [PC + #8]         ;->0x8000b050  :=0xfffc
8000b034:	35 82       	LD.W      R3, [R5]
8000b036:	08 42       	LD        R2, [PC + #8]         ;->0x8000b054  :=0xffff0003
8000b038:	04 69       	ANL       R0, R4
8000b03a:	32 69       	ANL       R3, R2
8000b03c:	30 6a       	ORL       R3, R0
8000b03e:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_LL_WdtUnlockGlobalReg():
##@@@P_:kf32a13k_drv_scu.h:1172
##@@@L1167_: * @param void   
##@@@L1168_: * @retval void   
##@@@L1169_: */   
##@@@L1170_:KF_INLINE void Scu_LL_WdtUnlockGlobalReg(void)   
##@@@L1171_:{   
##@@@L1172_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.ENDINIT, false);   
8000b040:	45 82       	LD.W      R4, [R5]
8000b042:	06 43       	LD        R3, [PC + #6]         ;->0x8000b058  :=0xfffffffd
8000b044:	43 69       	ANL       R4, R3
8000b046:	54 85       	ST.W      [R5], R4
##@@@F_:Scu_Hw_WdtClearGlobalEndinit():
##@@@P_:kf32a13k_hw_scu.c:474
##@@@L0470_:    {   
##@@@L0471_:        Scu_LL_WdtSetGlobalWdgPassword(Password);   
##@@@L0472_:        Scu_LL_WdtUnlockGlobalReg();   
##@@@L0473_:    }   
##@@@L0474_:}   
8000b048:	1d 5c       	JMP       LR
8000b04a:	00 00       	NOP      NOP      
8000b04c:	ec f0 00 f0 	.long     0xf000f0ec ->-268373780  [!!!@2@:JZ        $-20                  ;->0x8000b024	@@: JZ        $+0                   ;->0x8000b04c
8000b050:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b054:	03 00 ff ff 	.long     0xffff0003 ->-00065533 
8000b058:	fd ff ff ff 	.long     0xfffffffd ->-00000003 

8000b05c <Scu_Hw_WdtSetGlobalEndinit>:
##@@@F_:Scu_Hw_WdtSetGlobalEndinit():
##@@@P_:kf32a13k_hw_scu.c:484
##@@@L0479_: *   
##@@@L0480_: * @param uint32_t   
##@@@L0481_: * @retval void   
##@@@L0482_: */   
##@@@L0483_:void Scu_Hw_WdtSetGlobalEndinit(uint32_t Password)   
##@@@L0484_:{   
8000b05c:	0a 45       	LD        R5, [PC + #10]        ;->0x8000b084  :=0xf000f0ec
##@@@F_:Scu_LL_WdtGetGlobalEndInit():
##@@@P_:kf32a13k_drv_scu.h:1188
##@@@L1183_: * @param void   
##@@@L1184_: * @retval bool   
##@@@L1185_: */   
##@@@L1186_:KF_INLINE bool Scu_LL_WdtGetGlobalEndInit(void)   
##@@@L1187_:{   
##@@@L1188_:    return (REG_READ(SCU_PTR->SCU_GECTL0.bits.ENDINIT));   
8000b05e:	45 82       	LD.W      R4, [R5]
8000b060:	32 10       	MOV       R3, #2			;->0x0002
8000b062:	43 69       	ANL       R4, R3
##@@@F_:Scu_Hw_WdtSetGlobalEndinit():
##@@@P_:kf32a13k_hw_scu.c:486
##@@@L0485_:    // TODO:需要确定使用方式   
##@@@L0486_:    if (false == Scu_LL_WdtGetGlobalEndInit())   
8000b064:	40 38       	CMP       R4, #0			;->0x00
8000b066:	0d f1       	JNZ       $+13                  ;->0x8000b080
##@@@F_:Scu_LL_WdtSetGlobalWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:1200
##@@@L1195_: * @param Password   
##@@@L1196_: * @retval void   
##@@@L1197_: */   
##@@@L1198_:KF_INLINE void Scu_LL_WdtSetGlobalWdgPassword(uint32_t Password)   
##@@@L1199_:{   
##@@@L1200_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.EPW, Password);   
8000b068:	02 7a       	LSL       R0, #2			;->0x02
8000b06a:	08 44       	LD        R4, [PC + #8]         ;->0x8000b088  :=0xfffc
8000b06c:	35 82       	LD.W      R3, [R5]
8000b06e:	08 42       	LD        R2, [PC + #8]         ;->0x8000b08c  :=0xffff0003
8000b070:	04 69       	ANL       R0, R4
8000b072:	32 69       	ANL       R3, R2
8000b074:	30 6a       	ORL       R3, R0
8000b076:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_LL_WdtUnlockGlobalReg():
##@@@P_:kf32a13k_drv_scu.h:1172
##@@@L1167_: * @param void   
##@@@L1168_: * @retval void   
##@@@L1169_: */   
##@@@L1170_:KF_INLINE void Scu_LL_WdtUnlockGlobalReg(void)   
##@@@L1171_:{   
##@@@L1172_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.ENDINIT, false);   
8000b078:	45 82       	LD.W      R4, [R5]
8000b07a:	06 43       	LD        R3, [PC + #6]         ;->0x8000b090  :=0xfffffffd
8000b07c:	43 69       	ANL       R4, R3
8000b07e:	54 85       	ST.W      [R5], R4
##@@@F_:Scu_Hw_WdtSetGlobalEndinit():
##@@@P_:kf32a13k_hw_scu.c:491
##@@@L0487_:    {   
##@@@L0488_:        Scu_LL_WdtSetGlobalWdgPassword(Password);   
##@@@L0489_:        Scu_LL_WdtUnlockGlobalReg();   
##@@@L0490_:    }   
##@@@L0491_:}   
8000b080:	1d 5c       	JMP       LR
8000b082:	00 00       	NOP      NOP      
8000b084:	ec f0 00 f0 	.long     0xf000f0ec ->-268373780  [!!!@2@:JZ        $-20                  ;->0x8000b05c	@@: JZ        $+0                   ;->0x8000b084
8000b088:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b08c:	03 00 ff ff 	.long     0xffff0003 ->-00065533 
8000b090:	fd ff ff ff 	.long     0xfffffffd ->-00000003 

8000b094 <Scu_Hw_WdtChangeGlobalWdgPassword>:
##@@@F_:Scu_Hw_WdtChangeGlobalWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:502
##@@@L0497_: * @param uint32_t   
##@@@L0498_: * @param uint32_t   
##@@@L0499_: * @retval void   
##@@@L0500_: */   
##@@@L0501_:void Scu_Hw_WdtChangeGlobalWdgPassword(uint32_t Password, uint32_t NewPassword)   
##@@@L0502_:{   
8000b094:	26 5d       	PUSH      R6
8000b096:	e4 30       	SUB       SP, #4			;->0x04
8000b098:	10 45       	LD        R5, [PC + #16]        ;->0x8000b0d8  :=0xf000f0ec
##@@@F_:Scu_LL_WdtGetGlobalEndInit():
##@@@P_:kf32a13k_drv_scu.h:1188
##@@@L1183_: * @param void   
##@@@L1184_: * @retval bool   
##@@@L1185_: */   
##@@@L1186_:KF_INLINE bool Scu_LL_WdtGetGlobalEndInit(void)   
##@@@L1187_:{   
##@@@L1188_:    return (REG_READ(SCU_PTR->SCU_GECTL0.bits.ENDINIT));   
8000b09a:	35 82       	LD.W      R3, [R5]
8000b09c:	42 10       	MOV       R4, #2			;->0x0002
8000b09e:	34 69       	ANL       R3, R4
##@@@F_:Scu_Hw_WdtChangeGlobalWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:504
##@@@L0503_:    // TODO:需要确定使用方式   
##@@@L0504_:    if (true == Scu_LL_WdtGetGlobalEndInit())   
8000b0a0:	30 38       	CMP       R3, #0			;->0x00
8000b0a2:	0d f0       	JZ        $+13                  ;->0x8000b0bc
##@@@F_:Scu_LL_WdtSetGlobalWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:1200
##@@@L1195_: * @param Password   
##@@@L1196_: * @retval void   
##@@@L1197_: */   
##@@@L1198_:KF_INLINE void Scu_LL_WdtSetGlobalWdgPassword(uint32_t Password)   
##@@@L1199_:{   
##@@@L1200_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.EPW, Password);   
8000b0a4:	02 7a       	LSL       R0, #2			;->0x02
8000b0a6:	0e 43       	LD        R3, [PC + #14]        ;->0x8000b0dc  :=0xfffc
8000b0a8:	25 82       	LD.W      R2, [R5]
8000b0aa:	0e 46       	LD        R6, [PC + #14]        ;->0x8000b0e0  :=0xffff0003
8000b0ac:	03 69       	ANL       R0, R3
8000b0ae:	26 69       	ANL       R2, R6
8000b0b0:	20 6a       	ORL       R2, R0
8000b0b2:	52 85       	ST.W      [R5], R2
##@@@F_:Scu_LL_WdtUnlockGlobalReg():
##@@@P_:kf32a13k_drv_scu.h:1172
##@@@L1167_: * @param void   
##@@@L1168_: * @retval void   
##@@@L1169_: */   
##@@@L1170_:KF_INLINE void Scu_LL_WdtUnlockGlobalReg(void)   
##@@@L1171_:{   
##@@@L1172_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.ENDINIT, false);   
8000b0b4:	35 82       	LD.W      R3, [R5]
8000b0b6:	0c 42       	LD        R2, [PC + #12]        ;->0x8000b0e4  :=0xfffffffd
8000b0b8:	32 69       	ANL       R3, R2
8000b0ba:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_LL_WdtSetGlobalWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:1200
##@@@L1195_: * @param Password   
##@@@L1196_: * @retval void   
##@@@L1197_: */   
##@@@L1198_:KF_INLINE void Scu_LL_WdtSetGlobalWdgPassword(uint32_t Password)   
##@@@L1199_:{   
##@@@L1200_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.EPW, Password);   
8000b0bc:	0a 7a       	LSL       R1, #2			;->0x02
8000b0be:	08 43       	LD        R3, [PC + #8]         ;->0x8000b0dc  :=0xfffc
8000b0c0:	25 82       	LD.W      R2, [R5]
8000b0c2:	08 40       	LD        R0, [PC + #8]         ;->0x8000b0e0  :=0xffff0003
8000b0c4:	13 69       	ANL       R1, R3
8000b0c6:	20 69       	ANL       R2, R0
8000b0c8:	21 6a       	ORL       R2, R1
8000b0ca:	52 85       	ST.W      [R5], R2
##@@@F_:Scu_LL_WdtlockGlobalReg():
##@@@P_:kf32a13k_drv_scu.h:1156
##@@@L1151_: * @param void   
##@@@L1152_: * @retval void   
##@@@L1153_: */   
##@@@L1154_:KF_INLINE void Scu_LL_WdtlockGlobalReg(void)   
##@@@L1155_:{   
##@@@L1156_:    REG_WRITE(SCU_PTR->SCU_GECTL0.bits.ENDINIT, true);   
8000b0cc:	35 82       	LD.W      R3, [R5]
8000b0ce:	34 6a       	ORL       R3, R4
8000b0d0:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_WdtChangeGlobalWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:511
##@@@L0506_:        Scu_LL_WdtSetGlobalWdgPassword(Password);   
##@@@L0507_:        Scu_LL_WdtUnlockGlobalReg();   
##@@@L0508_:    }   
##@@@L0509_:    Scu_LL_WdtSetGlobalWdgPassword(NewPassword);   
##@@@L0510_:    Scu_LL_WdtlockGlobalReg();   
##@@@L0511_:}   
8000b0d2:	e4 28       	ADD       SP, #4			;->0x04
8000b0d4:	06 5d       	POP       R6
8000b0d6:	1d 5c       	JMP       LR
8000b0d8:	ec f0 00 f0 	.long     0xf000f0ec ->-268373780  [!!!@2@:JZ        $-20                  ;->0x8000b0b0	@@: JZ        $+0                   ;->0x8000b0d8
8000b0dc:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b0e0:	03 00 ff ff 	.long     0xffff0003 ->-00065533 
8000b0e4:	fd ff ff ff 	.long     0xfffffffd ->-00000003 

8000b0e8 <Scu_Hw_WdtDisableCpuWdg>:
##@@@F_:Scu_Hw_WdtDisableCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:523
##@@@L0518_: * @param uint32_t   
##@@@L0519_:
##@@@L0520_: * @retval void   
##@@@L0521_: */   
##@@@L0522_:void Scu_Hw_WdtDisableCpuWdg(Scu_Hw_CPUType_t CPU, uint32_t Password)   
##@@@L0523_:{   
8000b0e8:	03 5f       	PUSH      {R6-R7}
8000b0ea:	e8 30       	SUB       SP, #8			;->0x08
8000b0ec:	15 43       	LD        R3, [PC + #21]        ;->0x8000b140  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b0ee:	04 7a       	LSL       R0, #4			;->0x04
8000b0f0:	e8 c2       	ADD       R5, R0, R3
8000b0f2:	75 98       	LD.W      R6, [R5 + #1]
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b0f4:	f8 e6       	LD.H      R7, [R0 + R3]
8000b0f6:	42 10       	MOV       R4, #2			;->0x0002
8000b0f8:	74 69       	ANL       R7, R4
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
8000b0fa:	30 7b       	LSL       R6, #16			;->0x10
8000b0fc:	0a 7a       	LSL       R1, #2			;->0x02
8000b0fe:	61 6a       	ORL       R6, R1
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b100:	15 c1       	ADD       R2, R5, #4
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2246
##@@@L2241_: * @retval void   
##@@@L2242_: */   
##@@@L2243_:KF_INLINE void Scu_LL_WdtClearCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2244_:{   
##@@@L2245_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2246_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b102:	01 22       	ST.W      [SP + #1], R2
8000b104:	70 38       	CMP       R7, #0			;->0x00
8000b106:	05 f0       	JZ        $+5                   ;->0x8000b110
8000b108:	71 10       	MOV       R7, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2248
##@@@L2247_:    {   
##@@@L2248_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b10a:	46 58       	MOV       R2, R6
8000b10c:	27 6a       	ORL       R2, R7
8000b10e:	c2 ee       	ST.W      [R0 + R3], R2
##@@@P_:kf32a13k_drv_scu.h:2251
##@@@L2249_:    }   
##@@@L2250_:
##@@@L2251_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b110:	64 6a       	ORL       R6, R4
8000b112:	c6 ee       	ST.W      [R0 + R3], R6
##@@@F_:Scu_LL_WdtRequestCpuWdgDisable():
##@@@P_:kf32a13k_drv_scu.h:1427
##@@@L1422_: * @param bool   
##@@@L1423_: * @retval void   
##@@@L1424_: */   
##@@@L1425_:KF_INLINE void Scu_LL_WdtRequestCpuWdgDisable(Scu_CPUType_t CPU, const bool Status)   
##@@@L1426_:{   
##@@@L1427_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.DR, Status);   
8000b114:	9d 98       	LD.W      R3, [R5 + #2]
8000b116:	28 10       	MOV       R2, #8			;->0x0008
8000b118:	32 6a       	ORL       R3, R2
8000b11a:	ab a0       	ST.W      [R5 + #2], R3
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b11c:	01 0b       	LD.W      R3, [SP + #1]
8000b11e:	33 82       	LD.W      R3, [R3]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b120:	18 7b       	LSL       R3, #16			;->0x10
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b122:	25 81       	LD.H      R2, [R5]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b124:	31 6a       	ORL       R3, R1
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
8000b126:	24 69       	ANL       R2, R4
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2271
##@@@L2266_: * @retval void   
##@@@L2267_: */   
##@@@L2268_:KF_INLINE void Scu_LL_WdtSetCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2269_:{   
##@@@L2270_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2271_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b128:	20 38       	CMP       R2, #0			;->0x00
8000b12a:	05 f0       	JZ        $+5                   ;->0x8000b134
8000b12c:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2273
##@@@L2272_:    {   
##@@@L2273_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b12e:	43 58       	MOV       R2, R3
8000b130:	24 6a       	ORL       R2, R4
8000b132:	52 85       	ST.W      [R5], R2
8000b134:	43 10       	MOV       R4, #3			;->0x0003
##@@@P_:kf32a13k_drv_scu.h:2276
##@@@L2274_:    }   
##@@@L2275_:
##@@@L2276_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b136:	34 6a       	ORL       R3, R4
8000b138:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_WdtDisableCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:528
##@@@L0524_:    /* Select CPU Watchdog based on Core Id */   
##@@@L0525_:    Scu_Hw_WdtClearCpuEndinit(CPU, Password);   
##@@@L0526_:    Scu_LL_WdtRequestCpuWdgDisable((Scu_CPUType_t)CPU, true);   
##@@@L0527_:    Scu_Hw_WdtSetCpuEndinit(CPU, Password);   
##@@@L0528_:}   
8000b13a:	e8 28       	ADD       SP, #8			;->0x08
8000b13c:	03 5e       	POP       {R6-R7}
8000b13e:	1d 5c       	JMP       LR
8000b140:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000b0d8	@@: JZ        $+0                   ;->0x8000b140

8000b144 <Scu_Hw_WdtEnableCpuWdg>:
##@@@F_:Scu_Hw_WdtEnableCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:539
##@@@L0534_: * @param uint32_t   
##@@@L0535_: * @param uint32_t   
##@@@L0536_: * @retval void   
##@@@L0537_: */   
##@@@L0538_:void Scu_Hw_WdtEnableCpuWdg(Scu_Hw_CPUType_t CPU, uint32_t Password)   
##@@@L0539_:{   
8000b144:	03 5f       	PUSH      {R6-R7}
8000b146:	e8 30       	SUB       SP, #8			;->0x08
8000b148:	15 43       	LD        R3, [PC + #21]        ;->0x8000b19c  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b14a:	04 7a       	LSL       R0, #4			;->0x04
8000b14c:	e8 c2       	ADD       R5, R0, R3
8000b14e:	75 98       	LD.W      R6, [R5 + #1]
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b150:	f8 e6       	LD.H      R7, [R0 + R3]
8000b152:	42 10       	MOV       R4, #2			;->0x0002
8000b154:	74 69       	ANL       R7, R4
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
8000b156:	30 7b       	LSL       R6, #16			;->0x10
8000b158:	0a 7a       	LSL       R1, #2			;->0x02
8000b15a:	61 6a       	ORL       R6, R1
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b15c:	15 c1       	ADD       R2, R5, #4
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2246
##@@@L2241_: * @retval void   
##@@@L2242_: */   
##@@@L2243_:KF_INLINE void Scu_LL_WdtClearCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2244_:{   
##@@@L2245_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2246_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b15e:	01 22       	ST.W      [SP + #1], R2
8000b160:	70 38       	CMP       R7, #0			;->0x00
8000b162:	05 f0       	JZ        $+5                   ;->0x8000b16c
8000b164:	71 10       	MOV       R7, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2248
##@@@L2247_:    {   
##@@@L2248_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b166:	46 58       	MOV       R2, R6
8000b168:	27 6a       	ORL       R2, R7
8000b16a:	c2 ee       	ST.W      [R0 + R3], R2
##@@@P_:kf32a13k_drv_scu.h:2251
##@@@L2249_:    }   
##@@@L2250_:
##@@@L2251_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b16c:	64 6a       	ORL       R6, R4
8000b16e:	c6 ee       	ST.W      [R0 + R3], R6
##@@@F_:Scu_LL_WdtRequestCpuWdgDisable():
##@@@P_:kf32a13k_drv_scu.h:1427
##@@@L1422_: * @param bool   
##@@@L1423_: * @retval void   
##@@@L1424_: */   
##@@@L1425_:KF_INLINE void Scu_LL_WdtRequestCpuWdgDisable(Scu_CPUType_t CPU, const bool Status)   
##@@@L1426_:{   
##@@@L1427_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.DR, Status);   
8000b170:	9d 98       	LD.W      R3, [R5 + #2]
8000b172:	0c 42       	LD        R2, [PC + #12]        ;->0x8000b1a0  :=0xfffffff7
8000b174:	32 69       	ANL       R3, R2
8000b176:	ab a0       	ST.W      [R5 + #2], R3
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b178:	01 0b       	LD.W      R3, [SP + #1]
8000b17a:	33 82       	LD.W      R3, [R3]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b17c:	18 7b       	LSL       R3, #16			;->0x10
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b17e:	25 81       	LD.H      R2, [R5]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b180:	31 6a       	ORL       R3, R1
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
8000b182:	24 69       	ANL       R2, R4
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2271
##@@@L2266_: * @retval void   
##@@@L2267_: */   
##@@@L2268_:KF_INLINE void Scu_LL_WdtSetCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2269_:{   
##@@@L2270_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2271_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b184:	20 38       	CMP       R2, #0			;->0x00
8000b186:	05 f0       	JZ        $+5                   ;->0x8000b190
8000b188:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2273
##@@@L2272_:    {   
##@@@L2273_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b18a:	43 58       	MOV       R2, R3
8000b18c:	24 6a       	ORL       R2, R4
8000b18e:	52 85       	ST.W      [R5], R2
8000b190:	43 10       	MOV       R4, #3			;->0x0003
##@@@P_:kf32a13k_drv_scu.h:2276
##@@@L2274_:    }   
##@@@L2275_:
##@@@L2276_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b192:	34 6a       	ORL       R3, R4
8000b194:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_WdtEnableCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:544
##@@@L0540_:    /* Select CPU Watchdog based on Core Id */   
##@@@L0541_:    Scu_Hw_WdtClearCpuEndinit(CPU, Password);   
##@@@L0542_:    Scu_LL_WdtRequestCpuWdgDisable((Scu_CPUType_t)CPU, false);   
##@@@L0543_:    Scu_Hw_WdtSetCpuEndinit(CPU, Password);   
##@@@L0544_:}   
8000b196:	e8 28       	ADD       SP, #8			;->0x08
8000b198:	03 5e       	POP       {R6-R7}
8000b19a:	1d 5c       	JMP       LR
8000b19c:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000b134	@@: JZ        $+0                   ;->0x8000b19c
8000b1a0:	f7 ff ff ff 	.long     0xfffffff7 ->-00000009 

8000b1a4 <Scu_Hw_WdtDisableSafetyWdg>:
##@@@F_:Scu_Hw_WdtDisableSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:554
##@@@L0549_: *   
##@@@L0550_: * @param uint32_t   
##@@@L0551_: * @retval void   
##@@@L0552_: */   
##@@@L0553_:void Scu_Hw_WdtDisableSafetyWdg(uint32_t Password)   
##@@@L0554_:{   
8000b1a4:	26 5d       	PUSH      R6
8000b1a6:	e4 30       	SUB       SP, #4			;->0x04
8000b1a8:	14 43       	LD        R3, [PC + #20]        ;->0x8000b1f8  :=0xf000f0c0
8000b1aa:	15 45       	LD        R5, [PC + #21]        ;->0x8000b1fc  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b1ac:	23 82       	LD.W      R2, [R3]
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b1ae:	15 81       	LD.H      R1, [R5]
8000b1b0:	42 10       	MOV       R4, #2			;->0x0002
8000b1b2:	14 69       	ANL       R1, R4
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
8000b1b4:	02 7a       	LSL       R0, #2			;->0x02
8000b1b6:	10 7b       	LSL       R2, #16			;->0x10
8000b1b8:	20 6a       	ORL       R2, R0
##@@@P_:kf32a13k_drv_scu.h:2295
##@@@L2290_: * @retval void   
##@@@L2291_: */   
##@@@L2292_:KF_INLINE void Scu_LL_WdtClearSafetyEndinitInline(uint32_t Password)   
##@@@L2293_:{   
##@@@L2294_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2295_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b1ba:	10 38       	CMP       R1, #0			;->0x00
8000b1bc:	05 f0       	JZ        $+5                   ;->0x8000b1c6
8000b1be:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2297
##@@@L2296_:    {   
##@@@L2297_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b1c0:	c2 58       	MOV       R6, R2
8000b1c2:	61 6a       	ORL       R6, R1
8000b1c4:	56 85       	ST.W      [R5], R6
##@@@P_:kf32a13k_drv_scu.h:2300
##@@@L2298_:    }   
##@@@L2299_:
##@@@L2300_:    SCU_PTR->SCU_SWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b1c6:	24 6a       	ORL       R2, R4
8000b1c8:	0e 41       	LD        R1, [PC + #14]        ;->0x8000b200  :=0xf000f0c4
8000b1ca:	52 85       	ST.W      [R5], R2
##@@@F_:Scu_LL_WdtRequestSafetyWdgDisable():
##@@@P_:kf32a13k_drv_scu.h:1605
##@@@L1600_: * @param bool   
##@@@L1601_: * @retval void   
##@@@L1602_: */   
##@@@L1603_:KF_INLINE void Scu_LL_WdtRequestSafetyWdgDisable(const bool Status)   
##@@@L1604_:{   
##@@@L1605_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.DR, Status);   
8000b1cc:	21 82       	LD.W      R2, [R1]
8000b1ce:	68 10       	MOV       R6, #8			;->0x0008
8000b1d0:	26 6a       	ORL       R2, R6
8000b1d2:	12 85       	ST.W      [R1], R2
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b1d4:	33 82       	LD.W      R3, [R3]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b1d6:	18 7b       	LSL       R3, #16			;->0x10
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b1d8:	25 81       	LD.H      R2, [R5]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b1da:	30 6a       	ORL       R3, R0
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
8000b1dc:	24 69       	ANL       R2, R4
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2319
##@@@L2314_: * @retval void   
##@@@L2315_: */   
##@@@L2316_:KF_INLINE void Scu_LL_WdtSetSafetyEndinitInline(uint32_t Password)   
##@@@L2317_:{   
##@@@L2318_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2319_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b1de:	20 38       	CMP       R2, #0			;->0x00
8000b1e0:	05 f0       	JZ        $+5                   ;->0x8000b1ea
8000b1e2:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2321
##@@@L2320_:    {   
##@@@L2321_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b1e4:	43 58       	MOV       R2, R3
8000b1e6:	24 6a       	ORL       R2, R4
8000b1e8:	52 85       	ST.W      [R5], R2
8000b1ea:	43 10       	MOV       R4, #3			;->0x0003
##@@@P_:kf32a13k_drv_scu.h:2324
##@@@L2322_:    }   
##@@@L2323_:
##@@@L2324_:    SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b1ec:	34 6a       	ORL       R3, R4
8000b1ee:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_WdtDisableSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:558
##@@@L0555_:    Scu_Hw_WdtClearSafetyEndinit(Password);   
##@@@L0556_:    Scu_LL_WdtRequestSafetyWdgDisable(true);   
##@@@L0557_:    Scu_Hw_WdtSetSafetyEndinit(Password);   
##@@@L0558_:}   
8000b1f0:	e4 28       	ADD       SP, #4			;->0x04
8000b1f2:	06 5d       	POP       R6
8000b1f4:	1d 5c       	JMP       LR
8000b1f6:	00 00       	NOP      NOP      
8000b1f8:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000b178	@@: JZ        $+0                   ;->0x8000b1f8
8000b1fc:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000b174	@@: JZ        $+0                   ;->0x8000b1fc
8000b200:	c4 f0 00 f0 	.long     0xf000f0c4 ->-268373820  [!!!@2@:JZ        $-60                  ;->0x8000b188	@@: JZ        $+0                   ;->0x8000b200

8000b204 <Scu_Hw_WdtEnableSafetyWdg>:
##@@@F_:Scu_Hw_WdtEnableSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:568
##@@@L0563_: *   
##@@@L0564_: * @param uint32_t   
##@@@L0565_: * @retval void   
##@@@L0566_: */   
##@@@L0567_:void Scu_Hw_WdtEnableSafetyWdg(uint32_t Password)   
##@@@L0568_:{   
8000b204:	26 5d       	PUSH      R6
8000b206:	e4 30       	SUB       SP, #4			;->0x04
8000b208:	14 43       	LD        R3, [PC + #20]        ;->0x8000b258  :=0xf000f0c0
8000b20a:	15 45       	LD        R5, [PC + #21]        ;->0x8000b25c  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b20c:	23 82       	LD.W      R2, [R3]
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b20e:	15 81       	LD.H      R1, [R5]
8000b210:	42 10       	MOV       R4, #2			;->0x0002
8000b212:	14 69       	ANL       R1, R4
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
8000b214:	02 7a       	LSL       R0, #2			;->0x02
8000b216:	10 7b       	LSL       R2, #16			;->0x10
8000b218:	20 6a       	ORL       R2, R0
##@@@P_:kf32a13k_drv_scu.h:2295
##@@@L2290_: * @retval void   
##@@@L2291_: */   
##@@@L2292_:KF_INLINE void Scu_LL_WdtClearSafetyEndinitInline(uint32_t Password)   
##@@@L2293_:{   
##@@@L2294_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2295_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b21a:	10 38       	CMP       R1, #0			;->0x00
8000b21c:	05 f0       	JZ        $+5                   ;->0x8000b226
8000b21e:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2297
##@@@L2296_:    {   
##@@@L2297_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b220:	c2 58       	MOV       R6, R2
8000b222:	61 6a       	ORL       R6, R1
8000b224:	56 85       	ST.W      [R5], R6
##@@@P_:kf32a13k_drv_scu.h:2300
##@@@L2298_:    }   
##@@@L2299_:
##@@@L2300_:    SCU_PTR->SCU_SWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b226:	24 6a       	ORL       R2, R4
8000b228:	0e 41       	LD        R1, [PC + #14]        ;->0x8000b260  :=0xf000f0c4
8000b22a:	52 85       	ST.W      [R5], R2
##@@@F_:Scu_LL_WdtRequestSafetyWdgDisable():
##@@@P_:kf32a13k_drv_scu.h:1605
##@@@L1600_: * @param bool   
##@@@L1601_: * @retval void   
##@@@L1602_: */   
##@@@L1603_:KF_INLINE void Scu_LL_WdtRequestSafetyWdgDisable(const bool Status)   
##@@@L1604_:{   
##@@@L1605_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.DR, Status);   
8000b22c:	21 82       	LD.W      R2, [R1]
8000b22e:	0e 46       	LD        R6, [PC + #14]        ;->0x8000b264  :=0xfffffff7
8000b230:	26 69       	ANL       R2, R6
8000b232:	12 85       	ST.W      [R1], R2
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b234:	33 82       	LD.W      R3, [R3]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b236:	18 7b       	LSL       R3, #16			;->0x10
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b238:	25 81       	LD.H      R2, [R5]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b23a:	30 6a       	ORL       R3, R0
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
8000b23c:	24 69       	ANL       R2, R4
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2319
##@@@L2314_: * @retval void   
##@@@L2315_: */   
##@@@L2316_:KF_INLINE void Scu_LL_WdtSetSafetyEndinitInline(uint32_t Password)   
##@@@L2317_:{   
##@@@L2318_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2319_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b23e:	20 38       	CMP       R2, #0			;->0x00
8000b240:	05 f0       	JZ        $+5                   ;->0x8000b24a
8000b242:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2321
##@@@L2320_:    {   
##@@@L2321_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b244:	43 58       	MOV       R2, R3
8000b246:	24 6a       	ORL       R2, R4
8000b248:	52 85       	ST.W      [R5], R2
8000b24a:	43 10       	MOV       R4, #3			;->0x0003
##@@@P_:kf32a13k_drv_scu.h:2324
##@@@L2322_:    }   
##@@@L2323_:
##@@@L2324_:    SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b24c:	34 6a       	ORL       R3, R4
8000b24e:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_WdtEnableSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:572
##@@@L0569_:    Scu_Hw_WdtClearSafetyEndinit(Password);   
##@@@L0570_:    Scu_LL_WdtRequestSafetyWdgDisable(false);   
##@@@L0571_:    Scu_Hw_WdtSetSafetyEndinit(Password);   
##@@@L0572_:}   
8000b250:	e4 28       	ADD       SP, #4			;->0x04
8000b252:	06 5d       	POP       R6
8000b254:	1d 5c       	JMP       LR
8000b256:	00 00       	NOP      NOP      
8000b258:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000b1d8	@@: JZ        $+0                   ;->0x8000b258
8000b25c:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000b1d4	@@: JZ        $+0                   ;->0x8000b25c
8000b260:	c4 f0 00 f0 	.long     0xf000f0c4 ->-268373820  [!!!@2@:JZ        $-60                  ;->0x8000b1e8	@@: JZ        $+0                   ;->0x8000b260
8000b264:	f7 ff ff ff 	.long     0xfffffff7 ->-00000009 

8000b268 <Scu_Hw_WdtInitCpuWdg>:
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:583
##@@@L0578_: * @param uint32_t   
##@@@L0579_: * @param Scu_WdtConfigType_t   
##@@@L0580_: * @retval void   
##@@@L0581_: */   
##@@@L0582_:void Scu_Hw_WdtInitCpuWdg(Scu_Hw_CPUType_t CPU, Scu_WdtConfigType_t *ConfigPtr)   
##@@@L0583_:{   
8000b268:	0f 5f       	PUSH      {R6-R9}
8000b26a:	ec 30       	SUB       SP, #12			;->0x0C
8000b26c:	56 45       	LD        R5, [PC + #86]        ;->0x8000b3c4  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b26e:	04 7a       	LSL       R0, #4			;->0x04
8000b270:	60 c3       	ADD       R4, R0, R5
8000b272:	02 25       	ST.W      [SP + #2], R5
8000b274:	50 e7       	LD.H      R2, [R0 + R5]
8000b276:	92 10       	MOV       R9, #2			;->0x0002
8000b278:	29 69       	ANL       R2, R9
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:585
##@@@L0584_:    uint32_t password = 0U;   
##@@@L0585_:    if (true == Scu_LL_WdtGetCpuRegLockState((Scu_CPUType_t)CPU))   
8000b27a:	20 38       	CMP       R2, #0			;->0x00
8000b27c:	0f f0       	JZ        $+15                  ;->0x8000b29a
##@@@F_:Scu_LL_WdtlockCpuReg():
##@@@P_:kf32a13k_drv_scu.h:799
##@@@L0794_: * @param CPU   
##@@@L0795_: * @retval void   
##@@@L0796_: */   
##@@@L0797_:KF_INLINE void Scu_LL_WdtlockCpuReg(Scu_CPUType_t CPU)   
##@@@L0798_:{   
##@@@L0799_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.ENDINIT, true);   
8000b27e:	24 81       	LD.H      R2, [R4]
8000b280:	61 10       	MOV       R6, #1			;->0x0001
8000b282:	26 6a       	ORL       R2, R6
8000b284:	42 84       	ST.H      [R4], R2
##@@@F_:Scu_LL_WdtGetCpuWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:858
##@@@L0853_: * @retval uint32_t   
##@@@L0854_: */   
##@@@L0855_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgPassword(Scu_CPUType_t CPU)   
##@@@L0856_:{   
##@@@L0857_:    uint32_t password;   
##@@@L0858_:    password = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW);   
8000b286:	24 81       	LD.H      R2, [R4]
8000b288:	50 46       	LD        R6, [PC + #80]        ;->0x8000b3c8  :=0xfffc
##@@@F_:Scu_LL_WdtSetCpuWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:845
##@@@L0840_: * @retval void   
##@@@L0841_: */   
##@@@L0842_:KF_INLINE void Scu_LL_WdtSetCpuWdgPassword(Scu_CPUType_t CPU, uint32_t PassWord)   
##@@@L0843_:{   
##@@@L0844_:    // TODO:passWord写时是否需要异或操作   
##@@@L0845_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW, PassWord);   
8000b28a:	26 69       	ANL       R2, R6
8000b28c:	64 81       	LD.H      R6, [R4]
8000b28e:	73 10       	MOV       R7, #3			;->0x0003
8000b290:	67 69       	ANL       R6, R7
8000b292:	62 6a       	ORL       R6, R2
8000b294:	2c 1f       	MOV       R2, #252			;->0x00FC
8000b296:	62 6b       	XRL       R6, R2
8000b298:	46 84       	ST.H      [R4], R6
##@@@F_:Scu_LL_WdtUnlockCpuReg():
##@@@P_:kf32a13k_drv_scu.h:815
##@@@L0810_: * @param CPU   
##@@@L0811_: * @retval void   
##@@@L0812_: */   
##@@@L0813_:KF_INLINE void Scu_LL_WdtUnlockCpuReg(Scu_CPUType_t CPU)   
##@@@L0814_:{   
##@@@L0815_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.ENDINIT, false);   
8000b29a:	24 81       	LD.H      R2, [R4]
8000b29c:	4c 46       	LD        R6, [PC + #76]        ;->0x8000b3cc  :=0xfffe
8000b29e:	26 69       	ANL       R2, R6
8000b2a0:	42 84       	ST.H      [R4], R2
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:592
##@@@L0587_:        Scu_LL_WdtlockCpuReg((Scu_CPUType_t)CPU);   
##@@@L0588_:        password = Scu_LL_WdtGetCpuWdgPassword((Scu_CPUType_t)CPU);   
##@@@L0589_:        Scu_LL_WdtSetCpuWdgPassword((Scu_CPUType_t)CPU, password);   
##@@@L0590_:    }   
##@@@L0591_:    Scu_LL_WdtUnlockCpuReg((Scu_CPUType_t)CPU);   
##@@@L0592_:    Scu_LL_WdtSetCpuWdgPassword((Scu_CPUType_t)CPU, ConfigPtr->Password);   
8000b2a2:	61 81       	LD.H      R6, [R1]
##@@@F_:Scu_LL_WdtSetCpuWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:845
##@@@L0840_: * @retval void   
##@@@L0841_: */   
##@@@L0842_:KF_INLINE void Scu_LL_WdtSetCpuWdgPassword(Scu_CPUType_t CPU, uint32_t PassWord)   
##@@@L0843_:{   
##@@@L0844_:    // TODO:passWord写时是否需要异或操作   
##@@@L0845_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW, PassWord);   
8000b2a4:	74 81       	LD.H      R7, [R4]
8000b2a6:	83 10       	MOV       R8, #3			;->0x0003
8000b2a8:	78 69       	ANL       R7, R8
8000b2aa:	32 7a       	LSL       R6, #2			;->0x02
8000b2ac:	76 6a       	ORL       R7, R6
8000b2ae:	47 84       	ST.H      [R4], R7
8000b2b0:	48 46       	LD        R6, [PC + #72]        ;->0x8000b3d0  :=0x1ffff
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:593
##@@@L0593_:    Scu_LL_WdtSetCpuWdgReload((Scu_CPUType_t)CPU, ConfigPtr->Reload);   
8000b2b2:	79 98       	LD.W      R7, [R1 + #1]
##@@@F_:Scu_LL_WdtSetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:875
##@@@L0870_: * @retval void   
##@@@L0871_: */   
##@@@L0872_:KF_INLINE void Scu_LL_WdtSetCpuWdgReload(Scu_CPUType_t CPU, uint32_t Reload)   
##@@@L0873_:{   
##@@@L0874_:    // TODO:passWord写时是否需要异或操作   
##@@@L0875_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL, Reload);   
8000b2b4:	48 42       	LD        R2, [PC + #72]        ;->0x8000b3d4  :=0xf000f0d0
8000b2b6:	49 43       	LD        R3, [PC + #73]        ;->0x8000b3d8  :=0xfffe0000
8000b2b8:	a8 e8       	LD.W      R5, [R0 + R2]
8000b2ba:	76 69       	ANL       R7, R6
8000b2bc:	53 69       	ANL       R5, R3
8000b2be:	57 6a       	ORL       R5, R7
8000b2c0:	85 ee       	ST.W      [R0 + R2], R5
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:594
##@@@L0594_:    Scu_LL_WdtSetCpuWdgClockDivide((Scu_CPUType_t)CPU, (Scu_WdtDivType_t)ConfigPtr->InputFrequency);   
8000b2c2:	f9 98       	LD.W      R7, [R1 + #3]
##@@@F_:Scu_LL_WdtSetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:875
8000b2c4:	a8 c2       	ADD       R5, R0, R2
##@@@F_:Scu_LL_WdtSetCpuWdgClockDivide():
##@@@P_:kf32a13k_drv_scu.h:1541
##@@@L1536_: * @param Scu_WdtDivType_t   
##@@@L1537_: * @retval void   
##@@@L1538_: */   
##@@@L1539_:KF_INLINE void Scu_LL_WdtSetCpuWdgClockDivide(Scu_CPUType_t CPU, const Scu_WdtDivType_t ScuDiv)   
##@@@L1540_:{   
##@@@L1541_:    switch (ScuDiv)   
8000b2c6:	01 25       	ST.W      [SP + #1], R5
8000b2c8:	77 38       	CMP       R7, #7			;->0x07
8000b2ca:	02 f9       	JLS       $+2                   ;->0x8000b2ce
8000b2cc:	42 04       	SJMP      $+66                  ;->0x8000b350
8000b2ce:	44 45       	LD        R5, [PC + #68]        ;->0x8000b3dc  :=0x800011a8
8000b2d0:	3a 7a       	LSL       R7, #2			;->0x02
8000b2d2:	ed e9       	LD.W      R5, [R5 + R7]
8000b2d4:	15 5c       	JMP       R5
##@@@P_:kf32a13k_drv_scu.h:1544
##@@@L1542_:    {   
##@@@L1543_:    case SCUWDT_DIVBY_16384: {   
##@@@L1544_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 0U);   
8000b2d6:	43 45       	LD        R5, [PC + #67]        ;->0x8000b3e0  :=0xf000f0d4
8000b2d8:	58 e9       	LD.W      R3, [R0 + R5]
8000b2da:	43 42       	LD        R2, [PC + #67]        ;->0x8000b3e4  :=0xfffffffd
8000b2dc:	32 69       	ANL       R3, R2
8000b2de:	04 04       	SJMP      $+4                   ;->0x8000b2e6
##@@@P_:kf32a13k_drv_scu.h:1550
##@@@L1545_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR1, 0U);   
##@@@L1546_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR2, 0U);   
##@@@L1547_:    }   
##@@@L1548_:    break;   
##@@@L1549_:    case SCUWDT_DIVBY_64: {   
##@@@L1550_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 1U);   
8000b2e0:	40 45       	LD        R5, [PC + #64]        ;->0x8000b3e0  :=0xf000f0d4
8000b2e2:	58 e9       	LD.W      R3, [R0 + R5]
8000b2e4:	39 6a       	ORL       R3, R9
8000b2e6:	43 ef       	ST.W      [R0 + R5], R3
8000b2e8:	58 e9       	LD.W      R3, [R0 + R5]
8000b2ea:	40 42       	LD        R2, [PC + #64]        ;->0x8000b3e8  :=0xfffffffb
8000b2ec:	32 69       	ANL       R3, R2
8000b2ee:	0d 04       	SJMP      $+13                  ;->0x8000b308
##@@@P_:kf32a13k_drv_scu.h:1556
##@@@L1551_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR1, 0U);   
##@@@L1552_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR2, 0U);   
##@@@L1553_:    }   
##@@@L1554_:    break;   
##@@@L1555_:    case SCUWDT_DIVBY_256: {   
##@@@L1556_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 0U);   
8000b2f0:	3c 45       	LD        R5, [PC + #60]        ;->0x8000b3e0  :=0xf000f0d4
8000b2f2:	58 e9       	LD.W      R3, [R0 + R5]
8000b2f4:	3c 42       	LD        R2, [PC + #60]        ;->0x8000b3e4  :=0xfffffffd
8000b2f6:	32 69       	ANL       R3, R2
8000b2f8:	04 04       	SJMP      $+4                   ;->0x8000b300
##@@@P_:kf32a13k_drv_scu.h:1562
##@@@L1557_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR1, 1U);   
##@@@L1558_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR2, 0U);   
##@@@L1559_:    }   
##@@@L1560_:    break;   
##@@@L1561_:    case SCUWDT_DIVBY_512: {   
##@@@L1562_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 1U);   
8000b2fa:	3a 45       	LD        R5, [PC + #58]        ;->0x8000b3e0  :=0xf000f0d4
8000b2fc:	58 e9       	LD.W      R3, [R0 + R5]
8000b2fe:	39 6a       	ORL       R3, R9
8000b300:	43 ef       	ST.W      [R0 + R5], R3
8000b302:	58 e9       	LD.W      R3, [R0 + R5]
8000b304:	24 10       	MOV       R2, #4			;->0x0004
8000b306:	32 6a       	ORL       R3, R2
8000b308:	43 ef       	ST.W      [R0 + R5], R3
8000b30a:	39 43       	LD        R3, [PC + #57]        ;->0x8000b3ec  :=0xffffffdf
8000b30c:	50 e9       	LD.W      R2, [R0 + R5]
8000b30e:	23 69       	ANL       R2, R3
8000b310:	42 ef       	ST.W      [R0 + R5], R2
8000b312:	1f 04       	SJMP      $+31                  ;->0x8000b350
##@@@P_:kf32a13k_drv_scu.h:1568
##@@@L1563_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR1, 1U);   
##@@@L1564_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR2, 0U);   
##@@@L1565_:    }   
##@@@L1566_:    break;   
##@@@L1567_:    case SCUWDT_DIVBY_1024: {   
##@@@L1568_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 0U);   
8000b314:	33 45       	LD        R5, [PC + #51]        ;->0x8000b3e0  :=0xf000f0d4
8000b316:	58 e9       	LD.W      R3, [R0 + R5]
8000b318:	33 42       	LD        R2, [PC + #51]        ;->0x8000b3e4  :=0xfffffffd
8000b31a:	32 69       	ANL       R3, R2
8000b31c:	04 04       	SJMP      $+4                   ;->0x8000b324
##@@@P_:kf32a13k_drv_scu.h:1574
##@@@L1569_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR1, 0U);   
##@@@L1570_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR2, 1U);   
##@@@L1571_:    }   
##@@@L1572_:    break;   
##@@@L1573_:    case SCUWDT_DIVBY_2048: {   
##@@@L1574_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 1U);   
8000b31e:	31 45       	LD        R5, [PC + #49]        ;->0x8000b3e0  :=0xf000f0d4
8000b320:	58 e9       	LD.W      R3, [R0 + R5]
8000b322:	39 6a       	ORL       R3, R9
8000b324:	43 ef       	ST.W      [R0 + R5], R3
8000b326:	58 e9       	LD.W      R3, [R0 + R5]
8000b328:	30 42       	LD        R2, [PC + #48]        ;->0x8000b3e8  :=0xfffffffb
8000b32a:	32 69       	ANL       R3, R2
8000b32c:	0d 04       	SJMP      $+13                  ;->0x8000b346
##@@@P_:kf32a13k_drv_scu.h:1580
##@@@L1575_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR1, 0U);   
##@@@L1576_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR2, 1U);   
##@@@L1577_:    }   
##@@@L1578_:    break;   
##@@@L1579_:    case SCUWDT_DIVBY_4096: {   
##@@@L1580_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 0U);   
8000b32e:	2d 45       	LD        R5, [PC + #45]        ;->0x8000b3e0  :=0xf000f0d4
8000b330:	58 e9       	LD.W      R3, [R0 + R5]
8000b332:	2d 42       	LD        R2, [PC + #45]        ;->0x8000b3e4  :=0xfffffffd
8000b334:	32 69       	ANL       R3, R2
8000b336:	04 04       	SJMP      $+4                   ;->0x8000b33e
##@@@P_:kf32a13k_drv_scu.h:1586
##@@@L1581_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR1, 1U);   
##@@@L1582_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR2, 1U);   
##@@@L1583_:    }   
##@@@L1584_:    break;   
##@@@L1585_:    case SCUWDT_DIVBY_8192: {   
##@@@L1586_:        REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.IR0, 1U);   
8000b338:	2a 45       	LD        R5, [PC + #42]        ;->0x8000b3e0  :=0xf000f0d4
8000b33a:	58 e9       	LD.W      R3, [R0 + R5]
8000b33c:	39 6a       	ORL       R3, R9
8000b33e:	43 ef       	ST.W      [R0 + R5], R3
8000b340:	58 e9       	LD.W      R3, [R0 + R5]
8000b342:	24 10       	MOV       R2, #4			;->0x0004
8000b344:	32 6a       	ORL       R3, R2
8000b346:	43 ef       	ST.W      [R0 + R5], R3
8000b348:	58 e9       	LD.W      R3, [R0 + R5]
8000b34a:	20 12       	MOV       R2, #32			;->0x0020
8000b34c:	32 6a       	ORL       R3, R2
8000b34e:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:595
##@@@L0595_:    Scu_LL_WdtRequestCpuWdgDisable((Scu_CPUType_t)CPU, ConfigPtr->DisableWatchdog);   
8000b350:	a1 58       	MOV       R5, R1
8000b352:	50 29       	ADD       R5, #16			;->0x10
##@@@F_:Scu_LL_WdtRequestCpuWdgDisable():
##@@@P_:kf32a13k_drv_scu.h:1427
##@@@L1422_: * @param bool   
##@@@L1423_: * @retval void   
##@@@L1424_: */   
##@@@L1425_:KF_INLINE void Scu_LL_WdtRequestCpuWdgDisable(Scu_CPUType_t CPU, const bool Status)   
##@@@L1426_:{   
##@@@L1427_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.DR, Status);   
8000b354:	23 47       	LD        R7, [PC + #35]        ;->0x8000b3e0  :=0xf000f0d4
8000b356:	ed b8       	LDP.B     R5, [R5] << #3
8000b358:	d8 e9       	LD.W      R3, [R0 + R7]
8000b35a:	26 42       	LD        R2, [PC + #38]        ;->0x8000b3f0  :=0xfffffff7
8000b35c:	32 69       	ANL       R3, R2
8000b35e:	35 6a       	ORL       R3, R5
8000b360:	c3 ef       	ST.W      [R0 + R7], R3
8000b362:	25 45       	LD        R5, [PC + #37]        ;->0x8000b3f4  :=0xffffffbf
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:596
##@@@L0596_:    Scu_LL_WdtRequestCpuWdgUnlockRestriction((Scu_CPUType_t)CPU, ConfigPtr->EnableSmuRestriction);   
8000b364:	99 8c       	LD.B      R3, [R1 + #18]
##@@@F_:Scu_LL_WdtRequestCpuWdgUnlockRestriction():
##@@@P_:kf32a13k_drv_scu.h:1440
##@@@L1435_: * @param bool   
##@@@L1436_: * @retval void   
##@@@L1437_: */   
##@@@L1438_:KF_INLINE void Scu_LL_WdtRequestCpuWdgUnlockRestriction(Scu_CPUType_t CPU, const bool Status)   
##@@@L1439_:{   
##@@@L1440_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.UR, Status);   
8000b366:	d0 e9       	LD.W      R2, [R0 + R7]
8000b368:	25 69       	ANL       R2, R5
8000b36a:	1e 7a       	LSL       R3, #6			;->0x06
8000b36c:	23 6a       	ORL       R2, R3
8000b36e:	c2 ef       	ST.W      [R0 + R7], R2
8000b370:	22 45       	LD        R5, [PC + #34]        ;->0x8000b3f8  :=0xffffff7f
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:597
##@@@L0597_:    Scu_LL_WdtRequestCpuWdgAutomaticPassword((Scu_CPUType_t)CPU, ConfigPtr->EnableAutomaticPasswordChange);   
8000b372:	d9 8c       	LD.B      R3, [R1 + #19]
##@@@F_:Scu_LL_WdtRequestCpuWdgAutomaticPassword():
##@@@P_:kf32a13k_drv_scu.h:1465
##@@@L1460_: * @param bool   
##@@@L1461_: * @retval void   
##@@@L1462_: */   
##@@@L1463_:KF_INLINE void Scu_LL_WdtRequestCpuWdgAutomaticPassword(Scu_CPUType_t CPU, const bool Status)   
##@@@L1464_:{   
##@@@L1465_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.PAR, Status);   
8000b374:	d0 e9       	LD.W      R2, [R0 + R7]
8000b376:	25 69       	ANL       R2, R5
8000b378:	1f 7a       	LSL       R3, #7			;->0x07
8000b37a:	23 6a       	ORL       R2, R3
8000b37c:	c2 ef       	ST.W      [R0 + R7], R2
8000b37e:	20 45       	LD        R5, [PC + #32]        ;->0x8000b3fc  :=0xfffffeff
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:598
##@@@L0598_:    Scu_LL_WdtRequestCpuWdgTimeCheck((Scu_CPUType_t)CPU, ConfigPtr->EnableTimerCheck);   
8000b380:	59 8c       	LD.B      R3, [R1 + #17]
##@@@F_:Scu_LL_WdtRequestCpuWdgTimeCheck():
##@@@P_:kf32a13k_drv_scu.h:1491
##@@@L1486_: * @param bool   
##@@@L1487_: * @retval void   
##@@@L1488_: */   
##@@@L1489_:KF_INLINE void Scu_LL_WdtRequestCpuWdgTimeCheck(Scu_CPUType_t CPU, const bool Status)   
##@@@L1490_:{   
##@@@L1491_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.TCR, Status);   
8000b382:	d0 e9       	LD.W      R2, [R0 + R7]
8000b384:	25 69       	ANL       R2, R5
8000b386:	98 7a       	LSL       R3, #8			;->0x08
8000b388:	23 6a       	ORL       R2, R3
8000b38a:	c2 ef       	ST.W      [R0 + R7], R2
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:599
##@@@L0599_:    Scu_LL_WdtSetCpuWdgCheckTolerance((Scu_CPUType_t)CPU, ConfigPtr->TimerCheckTolerance);   
8000b38c:	a9 98       	LD.W      R5, [R1 + #2]
##@@@F_:Scu_LL_WdtSetCpuWdgCheckTolerance():
##@@@P_:kf32a13k_drv_scu.h:1516
##@@@L1511_: * @param uint32_t   
##@@@L1512_: * @retval void   
##@@@L1513_: */   
##@@@L1514_:KF_INLINE void Scu_LL_WdtSetCpuWdgCheckTolerance(Scu_CPUType_t CPU, const uint32_t Tolerance)   
##@@@L1515_:{   
##@@@L1516_:    REG_WRITE(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL1.bits.TCTR, Tolerance);   
8000b38e:	a9 7a       	LSL       R5, #9			;->0x09
8000b390:	1c 43       	LD        R3, [PC + #28]        ;->0x8000b400  :=0xfe00
8000b392:	1d 42       	LD        R2, [PC + #29]        ;->0x8000b404  :=0xffff01ff
8000b394:	f0 e9       	LD.W      R6, [R0 + R7]
8000b396:	53 69       	ANL       R5, R3
8000b398:	62 69       	ANL       R6, R2
8000b39a:	65 6a       	ORL       R6, R5
8000b39c:	c6 ef       	ST.W      [R0 + R7], R6
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b39e:	a9 ba       	LDP.W     R5, [R1] << #2
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b3a0:	01 0b       	LD.W      R3, [SP + #1]
8000b3a2:	13 82       	LD.W      R1, [R3]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b3a4:	08 7b       	LSL       R1, #16			;->0x10
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b3a6:	44 81       	LD.H      R4, [R4]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b3a8:	15 6a       	ORL       R1, R5
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
8000b3aa:	49 69       	ANL       R4, R9
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2271
##@@@L2266_: * @retval void   
##@@@L2267_: */   
##@@@L2268_:KF_INLINE void Scu_LL_WdtSetCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2269_:{   
##@@@L2270_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2271_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b3ac:	40 38       	CMP       R4, #0			;->0x00
8000b3ae:	02 0b       	LD.W      R3, [SP + #2]
8000b3b0:	05 f0       	JZ        $+5                   ;->0x8000b3ba
8000b3b2:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2273
##@@@L2272_:    {   
##@@@L2273_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b3b4:	81 58       	MOV       R4, R1
8000b3b6:	45 6a       	ORL       R4, R5
8000b3b8:	c4 ee       	ST.W      [R0 + R3], R4
##@@@P_:kf32a13k_drv_scu.h:2276
##@@@L2274_:    }   
##@@@L2275_:
##@@@L2276_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b3ba:	18 6a       	ORL       R1, R8
8000b3bc:	c1 ee       	ST.W      [R0 + R3], R1
##@@@F_:Scu_Hw_WdtInitCpuWdg():
##@@@P_:kf32a13k_hw_scu.c:601
##@@@L0600_:    Scu_Hw_WdtSetCpuEndinit(CPU, ConfigPtr->Password);   
##@@@L0601_:}   
8000b3be:	ec 28       	ADD       SP, #12			;->0x0C
8000b3c0:	0f 5e       	POP       {R6-R9}
8000b3c2:	1d 5c       	JMP       LR
8000b3c4:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000b35c	@@: JZ        $+0                   ;->0x8000b3c4
8000b3c8:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b3cc:	fe ff 00 00 	.long     0x0000fffe ->000065534 
8000b3d0:	ff ff 01 00 	.long     0x0001ffff ->000131071 
8000b3d4:	d0 f0 00 f0 	.long     0xf000f0d0 ->-268373808  [!!!@2@:JZ        $-48                  ;->0x8000b374	@@: JZ        $+0                   ;->0x8000b3d4
8000b3d8:	00 00 fe ff 	.long     0xfffe0000 ->-00131072 
8000b3dc:	a8 11 00 80 	.long     0x800011a8 ->-2147479128  [!!!@2@:MOV       R10, #24	@@: LD.B      R0, [R0]
8000b3e0:	d4 f0 00 f0 	.long     0xf000f0d4 ->-268373804  [!!!@2@:JZ        $-44                  ;->0x8000b388	@@: JZ        $+0                   ;->0x8000b3e0
8000b3e4:	fd ff ff ff 	.long     0xfffffffd ->-00000003 
8000b3e8:	fb ff ff ff 	.long     0xfffffffb ->-00000005 
8000b3ec:	df ff ff ff 	.long     0xffffffdf ->-00000033 
8000b3f0:	f7 ff ff ff 	.long     0xfffffff7 ->-00000009 
8000b3f4:	bf ff ff ff 	.long     0xffffffbf ->-00000065 
8000b3f8:	7f ff ff ff 	.long     0xffffff7f ->-00000129 
8000b3fc:	ff fe ff ff 	.long     0xfffffeff ->-00000257 
8000b400:	00 fe 00 00 	.long     0x0000fe00 ->000065024  [!!!@2@:LJMP      $+0                   ;->0x8000b400	@@: NOP      
8000b404:	ff 01 ff ff 	.long     0xffff01ff ->-00065025 

8000b408 <Scu_Hw_WdtInitSafetyWdg>:
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:612
##@@@L0607_: * @param uint32_t   
##@@@L0608_: * @param Scu_WdtConfigType_t   
##@@@L0609_: * @retval void   
##@@@L0610_: */   
##@@@L0611_:void Scu_Hw_WdtInitSafetyWdg(Scu_WdtConfigType_t *ConfigPtr)   
##@@@L0612_:{   
8000b408:	0f 5f       	PUSH      {R6-R9}
8000b40a:	e4 30       	SUB       SP, #4			;->0x04
8000b40c:	53 45       	LD        R5, [PC + #83]        ;->0x8000b558  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b40e:	35 81       	LD.H      R3, [R5]
8000b410:	42 10       	MOV       R4, #2			;->0x0002
8000b412:	34 69       	ANL       R3, R4
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:614
##@@@L0613_:    uint32_t password = 0U;   
##@@@L0614_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b414:	30 38       	CMP       R3, #0			;->0x00
8000b416:	0f f0       	JZ        $+15                  ;->0x8000b434
##@@@F_:Scu_LL_WdtlockSafetyReg():
##@@@P_:kf32a13k_drv_scu.h:914
##@@@L0909_: * @param CPU   
##@@@L0910_: * @retval void   
##@@@L0911_: */   
##@@@L0912_:KF_INLINE void Scu_LL_WdtlockSafetyReg(void)   
##@@@L0913_:{   
##@@@L0914_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL0.bits.ENDINIT, true);   
8000b418:	35 81       	LD.H      R3, [R5]
8000b41a:	21 10       	MOV       R2, #1			;->0x0001
8000b41c:	32 6a       	ORL       R3, R2
8000b41e:	53 84       	ST.H      [R5], R3
##@@@F_:Scu_LL_WdtGetSafetyWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:983
##@@@L0978_: * @retval uint32_t   
##@@@L0979_: */   
##@@@L0980_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgPassword(void)   
##@@@L0981_:{   
##@@@L0982_:    uint32_t password;   
##@@@L0983_:    password = REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.PW);   
8000b420:	35 81       	LD.H      R3, [R5]
8000b422:	4f 42       	LD        R2, [PC + #79]        ;->0x8000b55c  :=0xfffc
##@@@F_:Scu_LL_WdtSetSafetyWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:958
##@@@L0953_: * @param Password   
##@@@L0954_: * @retval void   
##@@@L0955_: */   
##@@@L0956_:KF_INLINE void Scu_LL_WdtSetSafetyWdgPassword(uint32_t Password)   
##@@@L0957_:{   
##@@@L0958_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL0.bits.PW, Password);   
8000b424:	32 69       	ANL       R3, R2
8000b426:	25 81       	LD.H      R2, [R5]
8000b428:	13 10       	MOV       R1, #3			;->0x0003
8000b42a:	21 69       	ANL       R2, R1
8000b42c:	23 6a       	ORL       R2, R3
8000b42e:	3c 1f       	MOV       R3, #252			;->0x00FC
8000b430:	23 6b       	XRL       R2, R3
8000b432:	52 84       	ST.H      [R5], R2
##@@@F_:Scu_LL_WdtUnlockSafetyReg():
##@@@P_:kf32a13k_drv_scu.h:930
##@@@L0925_: * @param CPU   
##@@@L0926_: * @retval void   
##@@@L0927_: */   
##@@@L0928_:KF_INLINE void Scu_LL_WdtUnlockSafetyReg(void)   
##@@@L0929_:{   
##@@@L0930_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL0.bits.ENDINIT, false);   
8000b434:	35 81       	LD.H      R3, [R5]
8000b436:	4b 42       	LD        R2, [PC + #75]        ;->0x8000b560  :=0xfffe
8000b438:	32 69       	ANL       R3, R2
8000b43a:	53 84       	ST.H      [R5], R3
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:621
##@@@L0616_:        Scu_LL_WdtlockSafetyReg();   
##@@@L0617_:        password = Scu_LL_WdtGetSafetyWdgPassword();   
##@@@L0618_:        Scu_LL_WdtSetSafetyWdgPassword(password);   
##@@@L0619_:    }   
##@@@L0620_:    Scu_LL_WdtUnlockSafetyReg();   
##@@@L0621_:    Scu_LL_WdtSetSafetyWdgPassword(ConfigPtr->Password);   
8000b43c:	20 81       	LD.H      R2, [R0]
##@@@F_:Scu_LL_WdtSetSafetyWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:958
##@@@L0953_: * @param Password   
##@@@L0954_: * @retval void   
##@@@L0955_: */   
##@@@L0956_:KF_INLINE void Scu_LL_WdtSetSafetyWdgPassword(uint32_t Password)   
##@@@L0957_:{   
##@@@L0958_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL0.bits.PW, Password);   
8000b43e:	15 81       	LD.H      R1, [R5]
8000b440:	93 10       	MOV       R9, #3			;->0x0003
8000b442:	19 69       	ANL       R1, R9
8000b444:	12 7a       	LSL       R2, #2			;->0x02
8000b446:	12 6a       	ORL       R1, R2
8000b448:	51 84       	ST.H      [R5], R1
8000b44a:	47 41       	LD        R1, [PC + #71]        ;->0x8000b564  :=0x1ffff
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:622
##@@@L0622_:    Scu_LL_WdtSetSafetyWdgReload(ConfigPtr->Reload);   
8000b44c:	70 98       	LD.W      R6, [R0 + #1]
8000b44e:	47 42       	LD        R2, [PC + #71]        ;->0x8000b568  :=0xf000f0c0
8000b450:	47 47       	LD        R7, [PC + #71]        ;->0x8000b56c  :=0xfffe0000
##@@@F_:Scu_LL_WdtSetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:970
##@@@L0965_: * @param Reload   
##@@@L0966_: * @retval void   
##@@@L0967_: */   
##@@@L0968_:KF_INLINE void Scu_LL_WdtSetSafetyWdgReload(uint32_t Reload)   
##@@@L0969_:{   
##@@@L0970_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL0.bits.REL, Reload);   
8000b452:	82 82       	LD.W      R8, [R2]
8000b454:	61 69       	ANL       R6, R1
8000b456:	87 69       	ANL       R8, R7
8000b458:	86 6a       	ORL       R8, R6
8000b45a:	28 85       	ST.W      [R2], R8
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:623
##@@@L0623_:    Scu_LL_WdtSetSafetyWdgClockDivide((Scu_WdtDivType_t)ConfigPtr->InputFrequency);   
8000b45c:	c8 98       	LD.W      R1, [R0 + #3]
##@@@F_:Scu_LL_WdtSetSafetyWdgClockDivide():
##@@@P_:kf32a13k_drv_scu.h:1713
##@@@L1708_: * @param Scu_WdtDivType_t   
##@@@L1709_: * @retval void   
##@@@L1710_: */   
##@@@L1711_:KF_INLINE void Scu_LL_WdtSetSafetyWdgClockDivide(const Scu_WdtDivType_t ScuDiv)   
##@@@L1712_:{   
##@@@L1713_:    switch (ScuDiv)   
8000b45e:	17 38       	CMP       R1, #7			;->0x07
8000b460:	02 f9       	JLS       $+2                   ;->0x8000b464
8000b462:	42 04       	SJMP      $+66                  ;->0x8000b4e6
8000b464:	43 46       	LD        R6, [PC + #67]        ;->0x8000b570  :=0x800011c8
8000b466:	0a 7a       	LSL       R1, #2			;->0x02
8000b468:	4e e8       	LD.W      R1, [R6 + R1]
8000b46a:	11 5c       	JMP       R1
8000b46c:	42 41       	LD        R1, [PC + #66]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1716
##@@@L1714_:    {   
##@@@L1715_:    case SCUWDT_DIVBY_16384: {   
##@@@L1716_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 0U);   
8000b46e:	61 82       	LD.W      R6, [R1]
8000b470:	42 47       	LD        R7, [PC + #66]        ;->0x8000b578  :=0xfffffffd
8000b472:	67 69       	ANL       R6, R7
8000b474:	04 04       	SJMP      $+4                   ;->0x8000b47c
8000b476:	40 41       	LD        R1, [PC + #64]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1722
##@@@L1717_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR1, 0U);   
##@@@L1718_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR2, 0U);   
##@@@L1719_:    }   
##@@@L1720_:    break;   
##@@@L1721_:    case SCUWDT_DIVBY_64: {   
##@@@L1722_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 1U);   
8000b478:	61 82       	LD.W      R6, [R1]
8000b47a:	64 6a       	ORL       R6, R4
8000b47c:	16 85       	ST.W      [R1], R6
8000b47e:	61 82       	LD.W      R6, [R1]
8000b480:	3f 47       	LD        R7, [PC + #63]        ;->0x8000b57c  :=0xfffffffb
8000b482:	67 69       	ANL       R6, R7
8000b484:	0d 04       	SJMP      $+13                  ;->0x8000b49e
8000b486:	3c 41       	LD        R1, [PC + #60]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1728
##@@@L1723_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR1, 0U);   
##@@@L1724_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR2, 0U);   
##@@@L1725_:    }   
##@@@L1726_:    break;   
##@@@L1727_:    case SCUWDT_DIVBY_256: {   
##@@@L1728_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 0U);   
8000b488:	61 82       	LD.W      R6, [R1]
8000b48a:	3c 47       	LD        R7, [PC + #60]        ;->0x8000b578  :=0xfffffffd
8000b48c:	67 69       	ANL       R6, R7
8000b48e:	04 04       	SJMP      $+4                   ;->0x8000b496
8000b490:	39 41       	LD        R1, [PC + #57]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1734
##@@@L1729_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR1, 1U);   
##@@@L1730_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR2, 0U);   
##@@@L1731_:    }   
##@@@L1732_:    break;   
##@@@L1733_:    case SCUWDT_DIVBY_512: {   
##@@@L1734_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 1U);   
8000b492:	61 82       	LD.W      R6, [R1]
8000b494:	64 6a       	ORL       R6, R4
8000b496:	16 85       	ST.W      [R1], R6
8000b498:	61 82       	LD.W      R6, [R1]
8000b49a:	74 10       	MOV       R7, #4			;->0x0004
8000b49c:	67 6a       	ORL       R6, R7
8000b49e:	16 85       	ST.W      [R1], R6
8000b4a0:	11 82       	LD.W      R1, [R1]
8000b4a2:	38 46       	LD        R6, [PC + #56]        ;->0x8000b580  :=0xffffffdf
8000b4a4:	16 69       	ANL       R1, R6
8000b4a6:	1e 04       	SJMP      $+30                  ;->0x8000b4e2
8000b4a8:	33 41       	LD        R1, [PC + #51]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1740
##@@@L1735_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR1, 1U);   
##@@@L1736_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR2, 0U);   
##@@@L1737_:    }   
##@@@L1738_:    break;   
##@@@L1739_:    case SCUWDT_DIVBY_1024: {   
##@@@L1740_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 0U);   
8000b4aa:	61 82       	LD.W      R6, [R1]
8000b4ac:	33 47       	LD        R7, [PC + #51]        ;->0x8000b578  :=0xfffffffd
8000b4ae:	67 69       	ANL       R6, R7
8000b4b0:	04 04       	SJMP      $+4                   ;->0x8000b4b8
8000b4b2:	31 41       	LD        R1, [PC + #49]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1746
##@@@L1741_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR1, 0U);   
##@@@L1742_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR2, 1U);   
##@@@L1743_:    }   
##@@@L1744_:    break;   
##@@@L1745_:    case SCUWDT_DIVBY_2048: {   
##@@@L1746_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 1U);   
8000b4b4:	61 82       	LD.W      R6, [R1]
8000b4b6:	64 6a       	ORL       R6, R4
8000b4b8:	16 85       	ST.W      [R1], R6
8000b4ba:	61 82       	LD.W      R6, [R1]
8000b4bc:	30 47       	LD        R7, [PC + #48]        ;->0x8000b57c  :=0xfffffffb
8000b4be:	67 69       	ANL       R6, R7
8000b4c0:	0d 04       	SJMP      $+13                  ;->0x8000b4da
8000b4c2:	2d 41       	LD        R1, [PC + #45]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1752
##@@@L1747_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR1, 0U);   
##@@@L1748_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR2, 1U);   
##@@@L1749_:    }   
##@@@L1750_:    break;   
##@@@L1751_:    case SCUWDT_DIVBY_4096: {   
##@@@L1752_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 0U);   
8000b4c4:	61 82       	LD.W      R6, [R1]
8000b4c6:	2d 47       	LD        R7, [PC + #45]        ;->0x8000b578  :=0xfffffffd
8000b4c8:	67 69       	ANL       R6, R7
8000b4ca:	04 04       	SJMP      $+4                   ;->0x8000b4d2
8000b4cc:	2a 41       	LD        R1, [PC + #42]        ;->0x8000b574  :=0xf000f0c4
##@@@P_:kf32a13k_drv_scu.h:1758
##@@@L1753_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR1, 1U);   
##@@@L1754_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR2, 1U);   
##@@@L1755_:    }   
##@@@L1756_:    break;   
##@@@L1757_:    case SCUWDT_DIVBY_8192: {   
##@@@L1758_:        REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.IR0, 1U);   
8000b4ce:	61 82       	LD.W      R6, [R1]
8000b4d0:	64 6a       	ORL       R6, R4
8000b4d2:	16 85       	ST.W      [R1], R6
8000b4d4:	61 82       	LD.W      R6, [R1]
8000b4d6:	74 10       	MOV       R7, #4			;->0x0004
8000b4d8:	67 6a       	ORL       R6, R7
8000b4da:	16 85       	ST.W      [R1], R6
8000b4dc:	11 82       	LD.W      R1, [R1]
8000b4de:	60 12       	MOV       R6, #32			;->0x0020
8000b4e0:	16 6a       	ORL       R1, R6
8000b4e2:	25 46       	LD        R6, [PC + #37]        ;->0x8000b574  :=0xf000f0c4
8000b4e4:	61 85       	ST.W      [R6], R1
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:624
##@@@L0624_:    Scu_LL_WdtRequestSafetyWdgDisable(ConfigPtr->DisableWatchdog);   
8000b4e6:	c0 58       	MOV       R6, R0
8000b4e8:	60 29       	ADD       R6, #16			;->0x10
8000b4ea:	23 41       	LD        R1, [PC + #35]        ;->0x8000b574  :=0xf000f0c4
##@@@F_:Scu_LL_WdtRequestSafetyWdgDisable():
##@@@P_:kf32a13k_drv_scu.h:1605
##@@@L1600_: * @param bool   
##@@@L1601_: * @retval void   
##@@@L1602_: */   
##@@@L1603_:KF_INLINE void Scu_LL_WdtRequestSafetyWdgDisable(const bool Status)   
##@@@L1604_:{   
##@@@L1605_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.DR, Status);   
8000b4ec:	f6 b8       	LDP.B     R6, [R6] << #3
8000b4ee:	71 82       	LD.W      R7, [R1]
8000b4f0:	25 43       	LD        R3, [PC + #37]        ;->0x8000b584  :=0xfffffff7
8000b4f2:	73 69       	ANL       R7, R3
8000b4f4:	76 6a       	ORL       R7, R6
8000b4f6:	17 85       	ST.W      [R1], R7
8000b4f8:	24 43       	LD        R3, [PC + #36]        ;->0x8000b588  :=0xffffffbf
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:625
##@@@L0625_:    Scu_LL_WdtRequestSafetyWdgUnlockRestriction(ConfigPtr->EnableSmuRestriction);   
8000b4fa:	b0 8c       	LD.B      R6, [R0 + #18]
##@@@F_:Scu_LL_WdtRequestSafetyWdgUnlockRestriction():
##@@@P_:kf32a13k_drv_scu.h:1617
##@@@L1612_: * @param bool   
##@@@L1613_: * @retval void   
##@@@L1614_: */   
##@@@L1615_:KF_INLINE void Scu_LL_WdtRequestSafetyWdgUnlockRestriction(const bool Status)   
##@@@L1616_:{   
##@@@L1617_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.UR, Status);   
8000b4fc:	71 82       	LD.W      R7, [R1]
8000b4fe:	73 69       	ANL       R7, R3
8000b500:	36 7a       	LSL       R6, #6			;->0x06
8000b502:	76 6a       	ORL       R7, R6
8000b504:	17 85       	ST.W      [R1], R7
8000b506:	22 43       	LD        R3, [PC + #34]        ;->0x8000b58c  :=0xffffff7f
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:626
##@@@L0626_:    Scu_LL_WdtRequestSafetyWdgAutomaticPassword(ConfigPtr->EnableAutomaticPasswordChange);   
8000b508:	f0 8c       	LD.B      R6, [R0 + #19]
##@@@F_:Scu_LL_WdtRequestSafetyWdgAutomaticPassword():
##@@@P_:kf32a13k_drv_scu.h:1641
##@@@L1636_: * @param bool   
##@@@L1637_: * @retval void   
##@@@L1638_: */   
##@@@L1639_:KF_INLINE void Scu_LL_WdtRequestSafetyWdgAutomaticPassword(const bool Status)   
##@@@L1640_:{   
##@@@L1641_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.PAR, Status);   
8000b50a:	71 82       	LD.W      R7, [R1]
8000b50c:	73 69       	ANL       R7, R3
8000b50e:	37 7a       	LSL       R6, #7			;->0x07
8000b510:	76 6a       	ORL       R7, R6
8000b512:	17 85       	ST.W      [R1], R7
8000b514:	1f 43       	LD        R3, [PC + #31]        ;->0x8000b590  :=0xfffffeff
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:627
##@@@L0627_:    Scu_LL_WdtRequestSafetyWdgTimeCheck(ConfigPtr->EnableTimerCheck);   
8000b516:	70 8c       	LD.B      R6, [R0 + #17]
##@@@F_:Scu_LL_WdtRequestSafetyWdgTimeCheck():
##@@@P_:kf32a13k_drv_scu.h:1665
##@@@L1660_: * @param bool   
##@@@L1661_: * @retval void   
##@@@L1662_: */   
##@@@L1663_:KF_INLINE void Scu_LL_WdtRequestSafetyWdgTimeCheck(const bool Status)   
##@@@L1664_:{   
##@@@L1665_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.TCR, Status);   
8000b518:	71 82       	LD.W      R7, [R1]
8000b51a:	73 69       	ANL       R7, R3
8000b51c:	b0 7a       	LSL       R6, #8			;->0x08
8000b51e:	76 6a       	ORL       R7, R6
8000b520:	17 85       	ST.W      [R1], R7
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:628
##@@@L0628_:    Scu_LL_WdtSetSafetyWdgCheckTolerance(ConfigPtr->TimerCheckTolerance);   
8000b522:	98 98       	LD.W      R3, [R0 + #2]
##@@@F_:Scu_LL_WdtSetSafetyWdgCheckTolerance():
##@@@P_:kf32a13k_drv_scu.h:1689
##@@@L1684_: * @param uint32_t   
##@@@L1685_: * @retval void   
##@@@L1686_: */   
##@@@L1687_:KF_INLINE void Scu_LL_WdtSetSafetyWdgCheckTolerance(const uint32_t Tolerance)   
##@@@L1688_:{   
##@@@L1689_:    REG_WRITE(SCU_PTR->SCU_SWDTCTL1.bits.TCTR, Tolerance);   
8000b524:	99 7a       	LSL       R3, #9			;->0x09
8000b526:	1c 46       	LD        R6, [PC + #28]        ;->0x8000b594  :=0xfe00
8000b528:	1c 47       	LD        R7, [PC + #28]        ;->0x8000b598  :=0xffff01ff
8000b52a:	81 82       	LD.W      R8, [R1]
8000b52c:	36 69       	ANL       R3, R6
8000b52e:	87 69       	ANL       R8, R7
8000b530:	83 6a       	ORL       R8, R3
8000b532:	18 85       	ST.W      [R1], R8
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b534:	98 ba       	LDP.W     R3, [R0] << #2
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b536:	22 82       	LD.W      R2, [R2]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b538:	10 7b       	LSL       R2, #16			;->0x10
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b53a:	15 81       	LD.H      R1, [R5]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b53c:	23 6a       	ORL       R2, R3
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
8000b53e:	14 69       	ANL       R1, R4
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2319
##@@@L2314_: * @retval void   
##@@@L2315_: */   
##@@@L2316_:KF_INLINE void Scu_LL_WdtSetSafetyEndinitInline(uint32_t Password)   
##@@@L2317_:{   
##@@@L2318_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2319_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b540:	10 38       	CMP       R1, #0			;->0x00
8000b542:	05 f0       	JZ        $+5                   ;->0x8000b54c
8000b544:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2321
##@@@L2320_:    {   
##@@@L2321_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b546:	62 58       	MOV       R3, R2
8000b548:	34 6a       	ORL       R3, R4
8000b54a:	53 85       	ST.W      [R5], R3
##@@@P_:kf32a13k_drv_scu.h:2324
##@@@L2322_:    }   
##@@@L2323_:
##@@@L2324_:    SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b54c:	29 6a       	ORL       R2, R9
8000b54e:	52 85       	ST.W      [R5], R2
##@@@F_:Scu_Hw_WdtInitSafetyWdg():
##@@@P_:kf32a13k_hw_scu.c:630
##@@@L0629_:    Scu_Hw_WdtSetSafetyEndinit(ConfigPtr->Password);   
##@@@L0630_:}   
8000b550:	e4 28       	ADD       SP, #4			;->0x04
8000b552:	0f 5e       	POP       {R6-R9}
8000b554:	1d 5c       	JMP       LR
8000b556:	00 00       	NOP      NOP      
8000b558:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000b4d0	@@: JZ        $+0                   ;->0x8000b558
8000b55c:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b560:	fe ff 00 00 	.long     0x0000fffe ->000065534 
8000b564:	ff ff 01 00 	.long     0x0001ffff ->000131071 
8000b568:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000b4e8	@@: JZ        $+0                   ;->0x8000b568
8000b56c:	00 00 fe ff 	.long     0xfffe0000 ->-00131072 
8000b570:	c8 11 00 80 	.long     0x800011c8 ->-2147479096  [!!!@2@:MOV       R12, #24	@@: LD.B      R0, [R0]
8000b574:	c4 f0 00 f0 	.long     0xf000f0c4 ->-268373820  [!!!@2@:JZ        $-60                  ;->0x8000b4fc	@@: JZ        $+0                   ;->0x8000b574
8000b578:	fd ff ff ff 	.long     0xfffffffd ->-00000003 
8000b57c:	fb ff ff ff 	.long     0xfffffffb ->-00000005 
8000b580:	df ff ff ff 	.long     0xffffffdf ->-00000033 
8000b584:	f7 ff ff ff 	.long     0xfffffff7 ->-00000009 
8000b588:	bf ff ff ff 	.long     0xffffffbf ->-00000065 
8000b58c:	7f ff ff ff 	.long     0xffffff7f ->-00000129 
8000b590:	ff fe ff ff 	.long     0xfffffeff ->-00000257 
8000b594:	00 fe 00 00 	.long     0x0000fe00 ->000065024  [!!!@2@:LJMP      $+0                   ;->0x8000b594	@@: NOP      
8000b598:	ff 01 ff ff 	.long     0xffff01ff ->-00065025 

8000b59c <Scu_Hw_RcuEvaluateReset>:
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:640
##@@@L0635_: *   
##@@@L0636_: * @param void   
##@@@L0637_: * @retval Scu_RcuResetCodeType_t   
##@@@L0638_: */   
##@@@L0639_:Scu_RcuResetCodeType_t Scu_Hw_RcuEvaluateReset(void)   
##@@@L0640_:{   
8000b59c:	26 5d       	PUSH      R6
8000b59e:	e4 30       	SUB       SP, #4			;->0x04
8000b5a0:	40 10       	MOV       R4, #0			;->0x0000
##@@@P_:kf32a13k_hw_scu.c:644
##@@@L0641_:    Scu_RcuResetCodeType_t resetCode;   
##@@@L0642_:    resetCode.ResetType    = SCURCU_HW_RESET_UNDEFINED;   
##@@@L0643_:    resetCode.ResetTrigger = SCURCU_HW_TRIGGER_UNDEFINED;   
##@@@L0644_:    resetCode.ResetReason  = 0U;   
8000b5a2:	04 b1       	ST.H      [R0 + #4], R4
8000b5a4:	5d 11       	MOV       R5, #29			;->0x001D
##@@@P_:kf32a13k_hw_scu.c:643
##@@@L0638_: */   
##@@@L0639_:Scu_RcuResetCodeType_t Scu_Hw_RcuEvaluateReset(void)   
##@@@L0640_:{   
##@@@L0641_:    Scu_RcuResetCodeType_t resetCode;   
##@@@L0642_:    resetCode.ResetType    = SCURCU_HW_RESET_UNDEFINED;   
##@@@L0643_:    resetCode.ResetTrigger = SCURCU_HW_TRIGGER_UNDEFINED;   
8000b5a6:	45 a0       	ST.W      [R0 + #1], R5
8000b5a8:	35 10       	MOV       R3, #5			;->0x0005
8000b5aa:	30 45       	LD        R5, [PC + #48]        ;->0x8000b668  :=0xf000f088
##@@@P_:kf32a13k_hw_scu.c:642
##@@@L0637_: * @retval Scu_RcuResetCodeType_t   
##@@@L0638_: */   
##@@@L0639_:Scu_RcuResetCodeType_t Scu_Hw_RcuEvaluateReset(void)   
##@@@L0640_:{   
##@@@L0641_:    Scu_RcuResetCodeType_t resetCode;   
##@@@L0642_:    resetCode.ResetType    = SCURCU_HW_RESET_UNDEFINED;   
8000b5ac:	03 85       	ST.W      [R0], R3
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
##@@@L0686_: *         true:产生相应触发类型的请求   
##@@@L0687_: *         false:没有产生相应触发类型的请求   
##@@@L0688_: */   
##@@@L0689_:KF_INLINE bool Scu_LL_RcuGetResetTriggerState(Scu_RcuTriggerType_t RcuTrigger)   
##@@@L0690_:{   
##@@@L0691_:    return (REG_BITS_READ(SCU_PTR->RCU_STA.reg, MASK_1_BIT << RcuTrigger, RcuTrigger));   
8000b5ae:	15 82       	LD.W      R1, [R5]
8000b5b0:	21 10       	MOV       R2, #1			;->0x0001
8000b5b2:	12 69       	ANL       R1, R2
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:645
##@@@L0643_:    resetCode.ResetTrigger = SCURCU_HW_TRIGGER_UNDEFINED;   
##@@@L0644_:    resetCode.ResetReason  = 0U;   
##@@@L0645_:    if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_ESR0))   
8000b5b4:	10 38       	CMP       R1, #0			;->0x00
8000b5b6:	3e f1       	JNZ       $+62                  ;->0x8000b632
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b5b8:	65 82       	LD.W      R6, [R5]
8000b5ba:	12 10       	MOV       R1, #2			;->0x0002
8000b5bc:	61 69       	ANL       R6, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:650
##@@@L0646_:    {   
##@@@L0647_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_ESR0;   
##@@@L0648_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_ESR0);   
##@@@L0649_:    }   
##@@@L0650_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_ESR1))   
8000b5be:	60 38       	CMP       R6, #0			;->0x00
8000b5c0:	3d f1       	JNZ       $+61                  ;->0x8000b63a
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b5c2:	65 82       	LD.W      R6, [R5]
8000b5c4:	24 10       	MOV       R2, #4			;->0x0004
8000b5c6:	62 69       	ANL       R6, R2
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:655
##@@@L0651_:    {   
##@@@L0652_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_ESR1;   
##@@@L0653_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_ESR1);   
##@@@L0654_:    }   
##@@@L0655_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_SMUALL))   
8000b5c8:	60 38       	CMP       R6, #0			;->0x00
8000b5ca:	02 f0       	JZ        $+2                   ;->0x8000b5ce
8000b5cc:	5c 04       	SJMP      $+92                  ;->0x8000b684
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b5ce:	15 82       	LD.W      R1, [R5]
8000b5d0:	68 10       	MOV       R6, #8			;->0x0008
8000b5d2:	16 69       	ANL       R1, R6
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:660
##@@@L0656_:    {   
##@@@L0657_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_SMUALL;   
##@@@L0658_:        resetCode.ResetType    = SCURCU_HW_RESET_UNDEFINED;   
##@@@L0659_:    }   
##@@@L0660_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_SMU))   
8000b5d4:	10 38       	CMP       R1, #0			;->0x00
8000b5d6:	02 f0       	JZ        $+2                   ;->0x8000b5da
8000b5d8:	5a 04       	SJMP      $+90                  ;->0x8000b68c
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b5da:	15 82       	LD.W      R1, [R5]
8000b5dc:	60 11       	MOV       R6, #16			;->0x0010
8000b5de:	16 69       	ANL       R1, R6
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:665
##@@@L0661_:    {   
##@@@L0662_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_SMU;   
##@@@L0663_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_SMU);   
##@@@L0664_:    }   
##@@@L0665_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_SW))   
8000b5e0:	10 38       	CMP       R1, #0			;->0x00
8000b5e2:	02 f0       	JZ        $+2                   ;->0x8000b5e6
8000b5e4:	5a 04       	SJMP      $+90                  ;->0x8000b698
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b5e6:	25 82       	LD.W      R2, [R5]
8000b5e8:	10 12       	MOV       R1, #32			;->0x0020
8000b5ea:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:670
##@@@L0666_:    {   
##@@@L0667_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_SW;   
##@@@L0668_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_SW);   
##@@@L0669_:    }   
##@@@L0670_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_STM0))   
8000b5ec:	20 38       	CMP       R2, #0			;->0x00
8000b5ee:	02 f0       	JZ        $+2                   ;->0x8000b5f2
8000b5f0:	59 04       	SJMP      $+89                  ;->0x8000b6a2
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b5f2:	35 82       	LD.W      R3, [R5]
8000b5f4:	20 14       	MOV       R2, #64			;->0x0040
8000b5f6:	32 69       	ANL       R3, R2
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:675
##@@@L0671_:    {   
##@@@L0672_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_STM0;   
##@@@L0673_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_STM0);   
##@@@L0674_:    }   
##@@@L0675_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_STM1))   
8000b5f8:	30 38       	CMP       R3, #0			;->0x00
8000b5fa:	02 f0       	JZ        $+2                   ;->0x8000b5fe
8000b5fc:	58 04       	SJMP      $+88                  ;->0x8000b6ac
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b5fe:	35 82       	LD.W      R3, [R5]
8000b600:	1b 42       	LD        R2, [PC + #27]        ;->0x8000b66c  :=0x40000
8000b602:	32 69       	ANL       R3, R2
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:680
##@@@L0676_:    {   
##@@@L0677_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_STM1;   
##@@@L0678_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_STM1);   
##@@@L0679_:    }   
##@@@L0680_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_CB0))   
8000b604:	30 38       	CMP       R3, #0			;->0x00
8000b606:	02 f0       	JZ        $+2                   ;->0x8000b60a
8000b608:	58 04       	SJMP      $+88                  ;->0x8000b6b8
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b60a:	35 82       	LD.W      R3, [R5]
8000b60c:	19 42       	LD        R2, [PC + #25]        ;->0x8000b670  :=0x80000
8000b60e:	32 69       	ANL       R3, R2
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:685
##@@@L0681_:    {   
##@@@L0682_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_CB0;   
##@@@L0683_:        resetCode.ResetType    = SCURCU_HW_RESET_SYSTEM;   
##@@@L0684_:    }   
##@@@L0685_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_CB1))   
8000b610:	30 38       	CMP       R3, #0			;->0x00
8000b612:	02 f0       	JZ        $+2                   ;->0x8000b616
8000b614:	56 04       	SJMP      $+86                  ;->0x8000b6c0
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b616:	35 82       	LD.W      R3, [R5]
8000b618:	17 42       	LD        R2, [PC + #23]        ;->0x8000b674  :=0x100000
8000b61a:	32 69       	ANL       R3, R2
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:690
##@@@L0686_:    {   
##@@@L0687_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_CB1;   
##@@@L0688_:        resetCode.ResetType    = SCURCU_HW_RESET_DEBUG;   
##@@@L0689_:    }   
##@@@L0690_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_CB3))   
8000b61c:	30 38       	CMP       R3, #0			;->0x00
8000b61e:	02 f0       	JZ        $+2                   ;->0x8000b622
8000b620:	55 04       	SJMP      $+85                  ;->0x8000b6ca
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b622:	35 82       	LD.W      R3, [R5]
8000b624:	15 42       	LD        R2, [PC + #21]        ;->0x8000b678  :=0x200000
8000b626:	32 69       	ANL       R3, R2
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:697
##@@@L0692_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_CB3;   
##@@@L0693_:        resetCode.ResetType    = SCURCU_HW_RESET_APPLICATION;   
##@@@L0694_:    }   
##@@@L0695_:    else   
##@@@L0696_:    {   
##@@@L0697_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_DCDC11))   
8000b628:	30 38       	CMP       R3, #0			;->0x00
8000b62a:	02 f0       	JZ        $+2                   ;->0x8000b62e
8000b62c:	54 04       	SJMP      $+84                  ;->0x8000b6d4
8000b62e:	35 10       	MOV       R3, #5			;->0x0005
8000b630:	56 04       	SJMP      $+86                  ;->0x8000b6dc
8000b632:	13 43       	LD        R3, [PC + #19]        ;->0x8000b67c  :=0xf000f090
##@@@P_:kf32a13k_hw_scu.c:647
##@@@L0642_:    resetCode.ResetType    = SCURCU_HW_RESET_UNDEFINED;   
##@@@L0643_:    resetCode.ResetTrigger = SCURCU_HW_TRIGGER_UNDEFINED;   
##@@@L0644_:    resetCode.ResetReason  = 0U;   
##@@@L0645_:    if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_ESR0))   
##@@@L0646_:    {   
##@@@L0647_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_ESR0;   
8000b634:	44 a0       	ST.W      [R0 + #1], R4
##@@@F_:Scu_LL_RcuGetResetType():
##@@@P_:kf32a13k_drv_scu.h:719
##@@@L0714_: * @retval Scu_RcuResetType_t   
##@@@L0715_: */   
##@@@L0716_:KF_INLINE Scu_RcuResetType_t Scu_LL_RcuGetResetType(Scu_RcuTriggerType_t RcuTrigger)   
##@@@L0717_:{   
##@@@L0718_:    // TODO:需要确定RCU_CTL0 BIT6~BIT7是 SMUMOD 还是 SACURMOD   
##@@@L0719_:    return ((Scu_RcuResetType_t)REG_BITS_READ(   
8000b636:	43 82       	LD.W      R4, [R3]
8000b638:	05 04       	SJMP      $+5                   ;->0x8000b642
##@@@F_:Scu_Hw_RcuEvaluateReset():
8000b63a:	11 44       	LD        R4, [PC + #17]        ;->0x8000b67c  :=0xf000f090
##@@@P_:kf32a13k_hw_scu.c:652
##@@@L0648_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_ESR0);   
##@@@L0649_:    }   
##@@@L0650_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_ESR1))   
##@@@L0651_:    {   
##@@@L0652_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_ESR1;   
8000b63c:	42 a0       	ST.W      [R0 + #1], R2
##@@@F_:Scu_LL_RcuGetResetType():
##@@@P_:kf32a13k_drv_scu.h:719
8000b63e:	44 82       	LD.W      R4, [R4]
8000b640:	22 7c       	LSR       R4, #2			;->0x02
##@@@F_:Scu_Hw_RcuEvaluateReset():
8000b642:	33 10       	MOV       R3, #3			;->0x0003
8000b644:	43 69       	ANL       R4, R3
8000b646:	64 58       	MOV       R3, R4
8000b648:	04 85       	ST.W      [R0], R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
##@@@L0686_: *         true:产生相应触发类型的请求   
##@@@L0687_: *         false:没有产生相应触发类型的请求   
##@@@L0688_: */   
##@@@L0689_:KF_INLINE bool Scu_LL_RcuGetResetTriggerState(Scu_RcuTriggerType_t RcuTrigger)   
##@@@L0690_:{   
##@@@L0691_:    return (REG_BITS_READ(SCU_PTR->RCU_STA.reg, MASK_1_BIT << RcuTrigger, RcuTrigger));   
8000b64a:	55 82       	LD.W      R5, [R5]
8000b64c:	0d 44       	LD        R4, [PC + #13]        ;->0x8000b680  :=0x10000
8000b64e:	54 69       	ANL       R5, R4
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:738
##@@@L0733_:        {   
##@@@L0734_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_LBTERM;   
##@@@L0735_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
##@@@L0736_:        }   
##@@@L0737_:    }   
##@@@L0738_:    if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_PORST))   
8000b650:	50 38       	CMP       R5, #0			;->0x00
8000b652:	07 f0       	JZ        $+7                   ;->0x8000b660
8000b654:	30 38       	CMP       R3, #0			;->0x00
8000b656:	05 f0       	JZ        $+5                   ;->0x8000b660
8000b658:	53 10       	MOV       R5, #3			;->0x0003
##@@@P_:kf32a13k_hw_scu.c:743
##@@@L0739_:    {   
##@@@L0740_:        if (SCURCU_RESET_COLDPOWERON != (Scu_RcuResetType_t)resetCode.ResetType)   
##@@@L0741_:        {   
##@@@L0742_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_PORST;   
##@@@L0743_:            resetCode.ResetType    = SCURCU_HW_RESET_WARMPOWERON;   
8000b65a:	05 85       	ST.W      [R0], R5
8000b65c:	50 11       	MOV       R5, #16			;->0x0010
##@@@P_:kf32a13k_hw_scu.c:742
##@@@L0737_:    }   
##@@@L0738_:    if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_PORST))   
##@@@L0739_:    {   
##@@@L0740_:        if (SCURCU_RESET_COLDPOWERON != (Scu_RcuResetType_t)resetCode.ResetType)   
##@@@L0741_:        {   
##@@@L0742_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_PORST;   
8000b65e:	45 a0       	ST.W      [R0 + #1], R5
##@@@P_:kf32a13k_hw_scu.c:746
##@@@L0743_:            resetCode.ResetType    = SCURCU_HW_RESET_WARMPOWERON;   
##@@@L0744_:        }   
##@@@L0745_:    }   
##@@@L0746_:    return resetCode;   
8000b660:	e4 28       	ADD       SP, #4			;->0x04
8000b662:	06 5d       	POP       R6
8000b664:	1d 5c       	JMP       LR
8000b666:	00 00       	NOP      NOP      
8000b668:	88 f0 00 f0 	.long     0xf000f088 ->-268373880  [!!!@2@:JZ        $-120                 ;->0x8000b578	@@: JZ        $+0                   ;->0x8000b668
8000b66c:	00 00 04 00 	.long     0x00040000 ->000262144 
8000b670:	00 00 08 00 	.long     0x00080000 ->000524288  [!!!@2@:NOP      	@@: SYNC     
8000b674:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16
8000b678:	00 00 20 00 	.long     0x00200000 ->002097152  [!!!@2@:NOP      	@@: FST.W            [R0+#0],	S1
8000b67c:	90 f0 00 f0 	.long     0xf000f090 ->-268373872  [!!!@2@:JZ        $-112                 ;->0x8000b59c	@@: JZ        $+0                   ;->0x8000b67c
8000b680:	00 00 01 00 	.long     0x00010000 ->000065536  [!!!@2@:NOP      	@@: .short    0x0001
##@@@P_:kf32a13k_hw_scu.c:657
##@@@L0652_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_ESR1;   
##@@@L0653_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_ESR1);   
##@@@L0654_:    }   
##@@@L0655_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_SMUALL))   
##@@@L0656_:    {   
##@@@L0657_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_SMUALL;   
8000b684:	41 a0       	ST.W      [R0 + #1], R1
8000b686:	31 10       	MOV       R3, #1			;->0x0001
8000b688:	45 10       	MOV       R4, #5			;->0x0005
8000b68a:	df 07       	SJMP      $-33                  ;->0x8000b648
8000b68c:	33 10       	MOV       R3, #3			;->0x0003
8000b68e:	35 44       	LD        R4, [PC + #53]        ;->0x8000b760  :=0xf000f090
##@@@P_:kf32a13k_hw_scu.c:662
##@@@L0658_:        resetCode.ResetType    = SCURCU_HW_RESET_UNDEFINED;   
##@@@L0659_:    }   
##@@@L0660_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_SMU))   
##@@@L0661_:    {   
##@@@L0662_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_SMU;   
8000b690:	43 a0       	ST.W      [R0 + #1], R3
##@@@F_:Scu_LL_RcuGetResetType():
##@@@P_:kf32a13k_drv_scu.h:719
##@@@L0714_: * @retval Scu_RcuResetType_t   
##@@@L0715_: */   
##@@@L0716_:KF_INLINE Scu_RcuResetType_t Scu_LL_RcuGetResetType(Scu_RcuTriggerType_t RcuTrigger)   
##@@@L0717_:{   
##@@@L0718_:    // TODO:需要确定RCU_CTL0 BIT6~BIT7是 SMUMOD 还是 SACURMOD   
##@@@L0719_:    return ((Scu_RcuResetType_t)REG_BITS_READ(   
8000b692:	44 82       	LD.W      R4, [R4]
8000b694:	26 7c       	LSR       R4, #6			;->0x06
8000b696:	d7 07       	SJMP      $-41                  ;->0x8000b644
##@@@F_:Scu_Hw_RcuEvaluateReset():
8000b698:	32 44       	LD        R4, [PC + #50]        ;->0x8000b760  :=0xf000f090
##@@@P_:kf32a13k_hw_scu.c:667
##@@@L0663_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_SMU);   
##@@@L0664_:    }   
##@@@L0665_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_SW))   
##@@@L0666_:    {   
##@@@L0667_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_SW;   
8000b69a:	42 a0       	ST.W      [R0 + #1], R2
##@@@F_:Scu_LL_RcuGetResetType():
##@@@P_:kf32a13k_drv_scu.h:719
8000b69c:	44 82       	LD.W      R4, [R4]
8000b69e:	a0 7c       	LSR       R4, #8			;->0x08
8000b6a0:	d1 07       	SJMP      $-47                  ;->0x8000b642
##@@@F_:Scu_Hw_RcuEvaluateReset():
8000b6a2:	30 44       	LD        R4, [PC + #48]        ;->0x8000b760  :=0xf000f090
##@@@P_:kf32a13k_hw_scu.c:672
##@@@L0668_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_SW);   
##@@@L0669_:    }   
##@@@L0670_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_STM0))   
##@@@L0671_:    {   
##@@@L0672_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_STM0;   
8000b6a4:	43 a0       	ST.W      [R0 + #1], R3
##@@@F_:Scu_LL_RcuGetResetType():
##@@@P_:kf32a13k_drv_scu.h:719
8000b6a6:	44 82       	LD.W      R4, [R4]
8000b6a8:	a2 7c       	LSR       R4, #10			;->0x0A
8000b6aa:	cc 07       	SJMP      $-52                  ;->0x8000b642
##@@@F_:Scu_Hw_RcuEvaluateReset():
8000b6ac:	46 10       	MOV       R4, #6			;->0x0006
8000b6ae:	2d 43       	LD        R3, [PC + #45]        ;->0x8000b760  :=0xf000f090
##@@@P_:kf32a13k_hw_scu.c:677
##@@@L0673_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_STM0);   
##@@@L0674_:    }   
##@@@L0675_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_STM1))   
##@@@L0676_:    {   
##@@@L0677_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_STM1;   
8000b6b0:	44 a0       	ST.W      [R0 + #1], R4
##@@@F_:Scu_LL_RcuGetResetType():
##@@@P_:kf32a13k_drv_scu.h:719
8000b6b2:	43 82       	LD.W      R4, [R3]
8000b6b4:	a4 7c       	LSR       R4, #12			;->0x0C
8000b6b6:	c6 07       	SJMP      $-58                  ;->0x8000b642
##@@@F_:Scu_Hw_RcuEvaluateReset():
8000b6b8:	32 11       	MOV       R3, #18			;->0x0012
8000b6ba:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_hw_scu.c:682
##@@@L0678_:        resetCode.ResetType    = (Scu_Hw_RcuResetType_t)Scu_LL_RcuGetResetType(SCURCU_TRIGGER_STM1);   
##@@@L0679_:    }   
##@@@L0680_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_CB0))   
##@@@L0681_:    {   
##@@@L0682_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_CB0;   
8000b6bc:	43 a0       	ST.W      [R0 + #1], R3
8000b6be:	c4 07       	SJMP      $-60                  ;->0x8000b646
8000b6c0:	43 11       	MOV       R4, #19			;->0x0013
##@@@P_:kf32a13k_hw_scu.c:687
##@@@L0683_:        resetCode.ResetType    = SCURCU_HW_RESET_SYSTEM;   
##@@@L0684_:    }   
##@@@L0685_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_CB1))   
##@@@L0686_:    {   
##@@@L0687_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_CB1;   
8000b6c2:	44 a0       	ST.W      [R0 + #1], R4
8000b6c4:	31 10       	MOV       R3, #1			;->0x0001
8000b6c6:	44 10       	MOV       R4, #4			;->0x0004
8000b6c8:	c0 07       	SJMP      $-64                  ;->0x8000b648
8000b6ca:	44 11       	MOV       R4, #20			;->0x0014
##@@@P_:kf32a13k_hw_scu.c:692
##@@@L0688_:        resetCode.ResetType    = SCURCU_HW_RESET_DEBUG;   
##@@@L0689_:    }   
##@@@L0690_:    else if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_CB3))   
##@@@L0691_:    {   
##@@@L0692_:        resetCode.ResetTrigger = SCURCU_HW_TRIGGER_CB3;   
8000b6cc:	44 a0       	ST.W      [R0 + #1], R4
8000b6ce:	31 10       	MOV       R3, #1			;->0x0001
8000b6d0:	42 10       	MOV       R4, #2			;->0x0002
8000b6d2:	bb 07       	SJMP      $-69                  ;->0x8000b648
8000b6d4:	35 11       	MOV       R3, #21			;->0x0015
##@@@P_:kf32a13k_hw_scu.c:699
##@@@L0694_:    }   
##@@@L0695_:    else   
##@@@L0696_:    {   
##@@@L0697_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_DCDC11))   
##@@@L0698_:        {   
##@@@L0699_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_DCDC11;   
8000b6d6:	43 a0       	ST.W      [R0 + #1], R3
##@@@P_:kf32a13k_hw_scu.c:700
##@@@L0700_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b6d8:	04 85       	ST.W      [R0], R4
8000b6da:	64 58       	MOV       R3, R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
##@@@L0686_: *         true:产生相应触发类型的请求   
##@@@L0687_: *         false:没有产生相应触发类型的请求   
##@@@L0688_: */   
##@@@L0689_:KF_INLINE bool Scu_LL_RcuGetResetTriggerState(Scu_RcuTriggerType_t RcuTrigger)   
##@@@L0690_:{   
##@@@L0691_:    return (REG_BITS_READ(SCU_PTR->RCU_STA.reg, MASK_1_BIT << RcuTrigger, RcuTrigger));   
8000b6dc:	25 82       	LD.W      R2, [R5]
8000b6de:	22 41       	LD        R1, [PC + #34]        ;->0x8000b764  :=0x400000
8000b6e0:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:702
##@@@L0701_:        }   
##@@@L0702_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_LDO33))   
8000b6e2:	20 38       	CMP       R2, #0			;->0x00
8000b6e4:	05 f0       	JZ        $+5                   ;->0x8000b6ee
8000b6e6:	36 11       	MOV       R3, #22			;->0x0016
##@@@P_:kf32a13k_hw_scu.c:704
##@@@L0703_:        {   
##@@@L0704_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_LDO33;   
8000b6e8:	43 a0       	ST.W      [R0 + #1], R3
##@@@P_:kf32a13k_hw_scu.c:705
##@@@L0705_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b6ea:	04 85       	ST.W      [R0], R4
8000b6ec:	64 58       	MOV       R3, R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b6ee:	25 82       	LD.W      R2, [R5]
8000b6f0:	1e 41       	LD        R1, [PC + #30]        ;->0x8000b768  :=0x800000
8000b6f2:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:707
##@@@L0706_:        }   
##@@@L0707_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_SWD))   
8000b6f4:	20 38       	CMP       R2, #0			;->0x00
8000b6f6:	05 f0       	JZ        $+5                   ;->0x8000b700
8000b6f8:	37 11       	MOV       R3, #23			;->0x0017
##@@@P_:kf32a13k_hw_scu.c:709
##@@@L0708_:        {   
##@@@L0709_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_SWD;   
8000b6fa:	43 a0       	ST.W      [R0 + #1], R3
##@@@P_:kf32a13k_hw_scu.c:710
##@@@L0710_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b6fc:	04 85       	ST.W      [R0], R4
8000b6fe:	64 58       	MOV       R3, R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b700:	25 82       	LD.W      R2, [R5]
8000b702:	1b 41       	LD        R1, [PC + #27]        ;->0x8000b76c  :=0x1000000
8000b704:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:712
##@@@L0711_:        }   
##@@@L0712_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_HSMS))   
8000b706:	20 38       	CMP       R2, #0			;->0x00
8000b708:	05 f0       	JZ        $+5                   ;->0x8000b712
8000b70a:	38 11       	MOV       R3, #24			;->0x0018
##@@@P_:kf32a13k_hw_scu.c:714
##@@@L0713_:        {   
##@@@L0714_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_HSMS;   
8000b70c:	43 a0       	ST.W      [R0 + #1], R3
##@@@P_:kf32a13k_hw_scu.c:715
##@@@L0715_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b70e:	04 85       	ST.W      [R0], R4
8000b710:	64 58       	MOV       R3, R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b712:	25 82       	LD.W      R2, [R5]
8000b714:	17 41       	LD        R1, [PC + #23]        ;->0x8000b770  :=0x2000000
8000b716:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:717
##@@@L0716_:        }   
##@@@L0717_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_HSMA))   
8000b718:	20 38       	CMP       R2, #0			;->0x00
8000b71a:	05 f0       	JZ        $+5                   ;->0x8000b724
8000b71c:	39 11       	MOV       R3, #25			;->0x0019
##@@@P_:kf32a13k_hw_scu.c:719
##@@@L0718_:        {   
##@@@L0719_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_HSMA;   
8000b71e:	43 a0       	ST.W      [R0 + #1], R3
##@@@P_:kf32a13k_hw_scu.c:720
##@@@L0720_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b720:	04 85       	ST.W      [R0], R4
8000b722:	64 58       	MOV       R3, R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b724:	25 82       	LD.W      R2, [R5]
8000b726:	14 41       	LD        R1, [PC + #20]        ;->0x8000b774  :=0x4000000
8000b728:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:722
##@@@L0721_:        }   
##@@@L0722_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_STBYR))   
8000b72a:	20 38       	CMP       R2, #0			;->0x00
8000b72c:	05 f0       	JZ        $+5                   ;->0x8000b736
8000b72e:	3a 11       	MOV       R3, #26			;->0x001A
##@@@P_:kf32a13k_hw_scu.c:724
##@@@L0723_:        {   
##@@@L0724_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_STBYR;   
8000b730:	43 a0       	ST.W      [R0 + #1], R3
##@@@P_:kf32a13k_hw_scu.c:725
##@@@L0725_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b732:	04 85       	ST.W      [R0], R4
8000b734:	64 58       	MOV       R3, R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b736:	25 82       	LD.W      R2, [R5]
8000b738:	10 41       	LD        R1, [PC + #16]        ;->0x8000b778  :=0x8000000
8000b73a:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:727
##@@@L0726_:        }   
##@@@L0727_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_LBPORST))   
8000b73c:	20 38       	CMP       R2, #0			;->0x00
8000b73e:	05 f0       	JZ        $+5                   ;->0x8000b748
8000b740:	3b 11       	MOV       R3, #27			;->0x001B
##@@@P_:kf32a13k_hw_scu.c:729
##@@@L0728_:        {   
##@@@L0729_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_LBPORST;   
8000b742:	43 a0       	ST.W      [R0 + #1], R3
##@@@P_:kf32a13k_hw_scu.c:730
##@@@L0730_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b744:	04 85       	ST.W      [R0], R4
8000b746:	64 58       	MOV       R3, R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b748:	25 82       	LD.W      R2, [R5]
8000b74a:	0d 41       	LD        R1, [PC + #13]        ;->0x8000b77c  :=0x10000000
8000b74c:	21 69       	ANL       R2, R1
##@@@F_:Scu_Hw_RcuEvaluateReset():
##@@@P_:kf32a13k_hw_scu.c:732
##@@@L0731_:        }   
##@@@L0732_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_LBTERM))   
8000b74e:	20 38       	CMP       R2, #0			;->0x00
8000b750:	02 f1       	JNZ       $+2                   ;->0x8000b754
8000b752:	7c 07       	SJMP      $-132                 ;->0x8000b64a
##@@@P_:kf32a13k_hw_scu.c:735
##@@@L0733_:        {   
##@@@L0734_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_LBTERM;   
##@@@L0735_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
8000b754:	04 85       	ST.W      [R0], R4
8000b756:	4c 11       	MOV       R4, #28			;->0x001C
##@@@P_:kf32a13k_hw_scu.c:734
##@@@L0729_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_LBPORST;   
##@@@L0730_:            resetCode.ResetType    = SCURCU_HW_RESET_COLDPOWERON;   
##@@@L0731_:        }   
##@@@L0732_:        if (Scu_LL_RcuGetResetTriggerState(SCURCU_TRIGGER_LBTERM))   
##@@@L0733_:        {   
##@@@L0734_:            resetCode.ResetTrigger = SCURCU_HW_TRIGGER_LBTERM;   
8000b758:	44 a0       	ST.W      [R0 + #1], R4
##@@@F_:Scu_LL_RcuGetResetTriggerState():
##@@@P_:kf32a13k_drv_scu.h:691
8000b75a:	55 82       	LD.W      R5, [R5]
8000b75c:	82 07       	SJMP      $-126                 ;->0x8000b660
##@@@F_:Scu_Hw_RcuEvaluateReset():
8000b75e:	00 00       	NOP      NOP      
8000b760:	90 f0 00 f0 	.long     0xf000f090 ->-268373872  [!!!@2@:JZ        $-112                 ;->0x8000b680	@@: JZ        $+0                   ;->0x8000b760
8000b764:	00 00 40 00 	.long     0x00400000 ->004194304  [!!!@2@:NOP      	@@: LD.W      R0, [R2 + #0]
8000b768:	00 00 80 00 	.long     0x00800000 ->008388608  [!!!@2@:NOP      	@@: LJMP      $+128                 ;->0x8000b868
8000b76c:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
8000b770:	00 00 00 02 	.long     0x02000000 ->033554432 
8000b774:	00 00 00 04 	.long     0x04000000 ->067108864  [!!!@2@:NOP      	@@: SJMP      $+0                   ;->0x8000b774
8000b778:	00 00 00 08 	.long     0x08000000 ->134217728  [!!!@2@:NOP      	@@: LD.W      R0, [SP + #0]
8000b77c:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0

8000b780 <Scu_Hw_RcuPerformReset>:
##@@@F_:Scu_Hw_RcuPerformReset():
##@@@P_:kf32a13k_hw_scu.c:759
##@@@L0754_: * @param Scu_RcuResetType_t   
##@@@L0755_: * @param UserResetInfo   
##@@@L0756_: * @retval void   
##@@@L0757_: */   
##@@@L0758_:void Scu_Hw_RcuPerformReset(Scu_Hw_CPUType_t CPU, Scu_Hw_RcuResetType_t ResetType, uint32_t UserResetInfo)   
##@@@L0759_:{   
8000b780:	0f 5f       	PUSH      {R6-R9}
8000b782:	e8 30       	SUB       SP, #8			;->0x08
8000b784:	22 46       	LD        R6, [PC + #34]        ;->0x8000b80c  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:983
##@@@L0978_: * @retval uint32_t   
##@@@L0979_: */   
##@@@L0980_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgPassword(void)   
##@@@L0981_:{   
##@@@L0982_:    uint32_t password;   
##@@@L0983_:    password = REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.PW);   
8000b786:	56 81       	LD.H      R5, [R6]
8000b788:	22 44       	LD        R4, [PC + #34]        ;->0x8000b810  :=0xf000f0c0
8000b78a:	3c 1f       	MOV       R3, #252			;->0x00FC
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b78c:	74 82       	LD.W      R7, [R4]
8000b78e:	22 44       	LD        R4, [PC + #34]        ;->0x8000b814  :=0xfffc
##@@@F_:Scu_LL_WdtGetSafetyWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:985
##@@@L0980_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgPassword(void)   
##@@@L0981_:{   
##@@@L0982_:    uint32_t password;   
##@@@L0983_:    password = REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.PW);   
##@@@L0984_:    // TODO:不确定是否需要异或操作   
##@@@L0985_:    password ^= 0x003F;   
8000b790:	53 6b       	XRL       R5, R3
8000b792:	01 24       	ST.W      [SP + #1], R4
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
8000b794:	54 69       	ANL       R5, R4
8000b796:	38 7b       	LSL       R7, #16			;->0x10
8000b798:	75 6a       	ORL       R7, R5
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b79a:	86 81       	LD.H      R8, [R6]
8000b79c:	52 10       	MOV       R5, #2			;->0x0002
8000b79e:	85 69       	ANL       R8, R5
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2295
##@@@L2290_: * @retval void   
##@@@L2291_: */   
##@@@L2292_:KF_INLINE void Scu_LL_WdtClearSafetyEndinitInline(uint32_t Password)   
##@@@L2293_:{   
##@@@L2294_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2295_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b7a0:	80 38       	CMP       R8, #0			;->0x00
8000b7a2:	05 f0       	JZ        $+5                   ;->0x8000b7ac
8000b7a4:	81 10       	MOV       R8, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2297
##@@@L2296_:    {   
##@@@L2297_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b7a6:	27 59       	MOV       R9, R7
8000b7a8:	98 6a       	ORL       R9, R8
8000b7aa:	69 85       	ST.W      [R6], R9
##@@@P_:kf32a13k_drv_scu.h:2300
##@@@L2298_:    }   
##@@@L2299_:
##@@@L2300_:    SCU_PTR->SCU_SWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b7ac:	75 6a       	ORL       R7, R5
8000b7ae:	67 85       	ST.W      [R6], R7
8000b7b0:	11 38       	CMP       R1, #1			;->0x01
8000b7b2:	03 f0       	JZ        $+3                   ;->0x8000b7b8
##@@@F_:Scu_Hw_RcuPerformReset():
8000b7b4:	19 41       	LD        R1, [PC + #25]        ;->0x8000b818  :=0x200
8000b7b6:	02 04       	SJMP      $+2                   ;->0x8000b7ba
8000b7b8:	19 41       	LD        R1, [PC + #25]        ;->0x8000b81c  :=0x100
8000b7ba:	1a 46       	LD        R6, [PC + #26]        ;->0x8000b820  :=0xf000f090
8000b7bc:	76 82       	LD.W      R7, [R6]
8000b7be:	1a 44       	LD        R4, [PC + #26]        ;->0x8000b824  :=0xfffffcff
8000b7c0:	74 69       	ANL       R7, R4
8000b7c2:	71 6a       	ORL       R7, R1
8000b7c4:	67 85       	ST.W      [R6], R7
8000b7c6:	19 41       	LD        R1, [PC + #25]        ;->0x8000b828  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:858
##@@@L0853_: * @retval uint32_t   
##@@@L0854_: */   
##@@@L0855_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgPassword(Scu_CPUType_t CPU)   
##@@@L0856_:{   
##@@@L0857_:    uint32_t password;   
##@@@L0858_:    password = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW);   
8000b7c8:	04 7a       	LSL       R0, #4			;->0x04
8000b7ca:	60 e6       	LD.H      R4, [R0 + R1]
##@@@P_:kf32a13k_drv_scu.h:861
##@@@L0859_:
##@@@L0860_:    // TODO:不确定是否需要异或操作   
##@@@L0861_:    password ^= 0x003F;   
8000b7cc:	43 6b       	XRL       R4, R3
##@@@P_:kf32a13k_drv_scu.h:858
##@@@L0853_: * @retval uint32_t   
##@@@L0854_: */   
##@@@L0855_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgPassword(Scu_CPUType_t CPU)   
##@@@L0856_:{   
##@@@L0857_:    uint32_t password;   
##@@@L0858_:    password = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW);   
8000b7ce:	58 c2       	ADD       R3, R0, R1
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b7d0:	5b 98       	LD.W      R3, [R3 + #1]
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
8000b7d2:	01 0e       	LD.W      R6, [SP + #1]
8000b7d4:	46 69       	ANL       R4, R6
8000b7d6:	18 7b       	LSL       R3, #16			;->0x10
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b7d8:	70 e6       	LD.H      R6, [R0 + R1]
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
8000b7da:	34 6a       	ORL       R3, R4
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
8000b7dc:	65 69       	ANL       R6, R5
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2246
##@@@L2241_: * @retval void   
##@@@L2242_: */   
##@@@L2243_:KF_INLINE void Scu_LL_WdtClearCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2244_:{   
##@@@L2245_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2246_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b7de:	60 38       	CMP       R6, #0			;->0x00
8000b7e0:	05 f0       	JZ        $+5                   ;->0x8000b7ea
8000b7e2:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2248
##@@@L2247_:    {   
##@@@L2248_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b7e4:	c3 58       	MOV       R6, R3
8000b7e6:	64 6a       	ORL       R6, R4
8000b7e8:	46 ee       	ST.W      [R0 + R1], R6
##@@@P_:kf32a13k_drv_scu.h:2251
##@@@L2249_:    }   
##@@@L2250_:
##@@@L2251_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b7ea:	35 6a       	ORL       R3, R5
8000b7ec:	10 44       	LD        R4, [PC + #16]        ;->0x8000b82c  :=0xf000f098
8000b7ee:	43 ee       	ST.W      [R0 + R1], R3
##@@@F_:Scu_LL_RcuSetResetInfo():
##@@@P_:kf32a13k_drv_scu.h:732
##@@@L0727_: * @param uint32_t   
##@@@L0728_: * @retval void   
##@@@L0729_: */   
##@@@L0730_:KF_INLINE void Scu_LL_RcuSetResetInfo(uint32_t ResetInfo)   
##@@@L0731_:{   
##@@@L0732_:    REG_WRITE(SCU_PTR->RCU_CTL1.bits.USINFOR, ResetInfo);   
8000b7f0:	34 82       	LD.W      R3, [R4]
8000b7f2:	10 41       	LD        R1, [PC + #16]        ;->0x8000b830  :=0xffff
8000b7f4:	31 69       	ANL       R3, R1
8000b7f6:	10 7b       	LSL       R2, #16			;->0x10
8000b7f8:	32 6a       	ORL       R3, R2
8000b7fa:	0f 42       	LD        R2, [PC + #15]        ;->0x8000b834  :=0xf000f094
8000b7fc:	43 85       	ST.W      [R4], R3
##@@@F_:Scu_LL_RcuEnableSoftReset():
##@@@P_:kf32a13k_drv_scu.h:756
##@@@L0751_: * @param void   
##@@@L0752_: * @retval void   
##@@@L0753_: */   
##@@@L0754_:KF_INLINE void Scu_LL_RcuEnableSoftReset(void)   
##@@@L0755_:{   
##@@@L0756_:    REG_WRITE(SCU_PTR->RCU_SW.bits.SWRQ, true);   
8000b7fe:	42 82       	LD.W      R4, [R2]
8000b800:	45 6a       	ORL       R4, R5
8000b802:	24 85       	ST.W      [R2], R4
##@@@F_:Scu_Hw_RcuPerformReset():
##@@@P_:kf32a13k_hw_scu.c:779
##@@@L0774_:    Scu_LL_RcuSetResetInfo(UserResetInfo);   
##@@@L0775_:    Scu_LL_RcuEnableSoftReset();   
##@@@L0776_:    /* Add some delay for HW to reset */   
##@@@L0777_:    while (index--)   
##@@@L0778_:        ;   
##@@@L0779_:}   
8000b804:	e8 28       	ADD       SP, #8			;->0x08
8000b806:	0f 5e       	POP       {R6-R9}
8000b808:	1d 5c       	JMP       LR
8000b80a:	00 00       	NOP      NOP      
8000b80c:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000b784	@@: JZ        $+0                   ;->0x8000b80c
8000b810:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000b790	@@: JZ        $+0                   ;->0x8000b810
8000b814:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b818:	00 02 00 00 	.long     0x00000200 ->000000512 
8000b81c:	00 01 00 00 	.long     0x00000100 ->000000256  [!!!@2@:CMN       R0, R0	@@: NOP      
8000b820:	90 f0 00 f0 	.long     0xf000f090 ->-268373872  [!!!@2@:JZ        $-112                 ;->0x8000b740	@@: JZ        $+0                   ;->0x8000b820
8000b824:	ff fc ff ff 	.long     0xfffffcff ->-00000769 
8000b828:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000b7c0	@@: JZ        $+0                   ;->0x8000b828
8000b82c:	98 f0 00 f0 	.long     0xf000f098 ->-268373864  [!!!@2@:JZ        $-104                 ;->0x8000b75c	@@: JZ        $+0                   ;->0x8000b82c
8000b830:	ff ff 00 00 	.long     0x0000ffff ->000065535 
8000b834:	94 f0 00 f0 	.long     0xf000f094 ->-268373868  [!!!@2@:JZ        $-108                 ;->0x8000b75c	@@: JZ        $+0                   ;->0x8000b834

8000b838 <Scu_Hw_RcuClearColdResetStatus>:
##@@@F_:Scu_Hw_RcuClearColdResetStatus():
##@@@P_:kf32a13k_hw_scu.c:791
##@@@L0786_: * @param Scu_RcuResetType_t   
##@@@L0787_: * @param UserResetInfo   
##@@@L0788_: * @retval void   
##@@@L0789_: */   
##@@@L0790_:void Scu_Hw_RcuClearColdResetStatus(Scu_Hw_CPUType_t CPU)   
##@@@L0791_:{   
8000b838:	03 5f       	PUSH      {R6-R7}
8000b83a:	e8 30       	SUB       SP, #8			;->0x08
8000b83c:	17 42       	LD        R2, [PC + #23]        ;->0x8000b898  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:858
##@@@L0853_: * @retval uint32_t   
##@@@L0854_: */   
##@@@L0855_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgPassword(Scu_CPUType_t CPU)   
##@@@L0856_:{   
##@@@L0857_:    uint32_t password;   
##@@@L0858_:    password = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW);   
8000b83e:	04 7a       	LSL       R0, #4			;->0x04
8000b840:	a0 e6       	LD.H      R4, [R0 + R2]
8000b842:	5c 1f       	MOV       R5, #252			;->0x00FC
##@@@P_:kf32a13k_drv_scu.h:861
##@@@L0859_:
##@@@L0860_:    // TODO:不确定是否需要异或操作   
##@@@L0861_:    password ^= 0x003F;   
8000b844:	45 6b       	XRL       R4, R5
##@@@P_:kf32a13k_drv_scu.h:858
##@@@L0853_: * @retval uint32_t   
##@@@L0854_: */   
##@@@L0855_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgPassword(Scu_CPUType_t CPU)   
##@@@L0856_:{   
##@@@L0857_:    uint32_t password;   
##@@@L0858_:    password = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW);   
8000b846:	88 c2       	ADD       R1, R0, R2
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b848:	69 98       	LD.W      R5, [R1 + #1]
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b84a:	b8 e6       	LD.H      R7, [R0 + R2]
8000b84c:	32 10       	MOV       R3, #2			;->0x0002
8000b84e:	14 46       	LD        R6, [PC + #20]        ;->0x8000b89c  :=0xfffc
8000b850:	73 69       	ANL       R7, R3
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
8000b852:	46 69       	ANL       R4, R6
8000b854:	01 21       	ST.W      [SP + #1], R1
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b856:	31 c1       	ADD       R6, R1, #4
##@@@F_:Scu_LL_WdtClearCpuEndinitInline():
8000b858:	28 7b       	LSL       R5, #16			;->0x10
8000b85a:	54 6a       	ORL       R5, R4
##@@@P_:kf32a13k_drv_scu.h:2246
##@@@L2241_: * @retval void   
##@@@L2242_: */   
##@@@L2243_:KF_INLINE void Scu_LL_WdtClearCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2244_:{   
##@@@L2245_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2246_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b85c:	70 38       	CMP       R7, #0			;->0x00
8000b85e:	05 f0       	JZ        $+5                   ;->0x8000b868
8000b860:	71 10       	MOV       R7, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2248
##@@@L2247_:    {   
##@@@L2248_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b862:	25 58       	MOV       R1, R5
8000b864:	17 6a       	ORL       R1, R7
8000b866:	81 ee       	ST.W      [R0 + R2], R1
##@@@P_:kf32a13k_drv_scu.h:2251
##@@@L2249_:    }   
##@@@L2250_:
##@@@L2251_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b868:	53 6a       	ORL       R5, R3
8000b86a:	0e 41       	LD        R1, [PC + #14]        ;->0x8000b8a0  :=0xf000f098
8000b86c:	85 ee       	ST.W      [R0 + R2], R5
##@@@F_:Scu_LL_RcuClearColdResetStatus():
##@@@P_:kf32a13k_drv_scu.h:768
##@@@L0763_: * @param void   
##@@@L0764_: * @retval void   
##@@@L0765_: */   
##@@@L0766_:KF_INLINE void Scu_LL_RcuClearColdResetStatus(void)   
##@@@L0767_:{   
##@@@L0768_:    REG_WRITE(SCU_PTR->RCU_CTL1.bits.COLDCLR, true);   
8000b86e:	51 82       	LD.W      R5, [R1]
8000b870:	53 6a       	ORL       R5, R3
8000b872:	15 85       	ST.W      [R1], R5
##@@@F_:Scu_LL_WdtGetCpuWdgReload():
##@@@P_:kf32a13k_drv_scu.h:887
##@@@L0882_: * @param void   
##@@@L0883_: * @retval void   
##@@@L0884_: */   
##@@@L0885_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgReload(Scu_CPUType_t CPU)   
##@@@L0886_:{   
##@@@L0887_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.REL));   
8000b874:	26 82       	LD.W      R2, [R6]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b876:	10 7b       	LSL       R2, #16			;->0x10
8000b878:	01 09       	LD.W      R1, [SP + #1]
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
##@@@P_:kf32a13k_drv_scu.h:787
##@@@L0782_: *         false:寄存器被解锁   
##@@@L0783_: */   
##@@@L0784_:KF_INLINE bool Scu_LL_WdtGetCpuRegLockState(Scu_CPUType_t CPU)   
##@@@L0785_:{   
##@@@L0786_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0787_:    return (REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.LCK));   
8000b87a:	51 81       	LD.H      R5, [R1]
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
8000b87c:	24 6a       	ORL       R2, R4
##@@@F_:Scu_LL_WdtGetCpuRegLockState():
8000b87e:	53 69       	ANL       R5, R3
##@@@F_:Scu_LL_WdtSetCpuEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2271
##@@@L2266_: * @retval void   
##@@@L2267_: */   
##@@@L2268_:KF_INLINE void Scu_LL_WdtSetCpuEndinitInline(Scu_CPUType_t CPU, uint32_t Password)   
##@@@L2269_:{   
##@@@L2270_:    uint32_t Rel = Scu_LL_WdtGetCpuWdgReload(CPU);   
##@@@L2271_:    if (Scu_LL_WdtGetCpuRegLockState(CPU))   
8000b880:	50 38       	CMP       R5, #0			;->0x00
8000b882:	05 f0       	JZ        $+5                   ;->0x8000b88c
8000b884:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2273
##@@@L2272_:    {   
##@@@L2273_:        SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b886:	82 58       	MOV       R4, R2
8000b888:	45 6a       	ORL       R4, R5
8000b88a:	14 85       	ST.W      [R1], R4
8000b88c:	53 10       	MOV       R5, #3			;->0x0003
##@@@P_:kf32a13k_drv_scu.h:2276
##@@@L2274_:    }   
##@@@L2275_:
##@@@L2276_:    SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b88e:	25 6a       	ORL       R2, R5
8000b890:	12 85       	ST.W      [R1], R2
##@@@F_:Scu_Hw_RcuClearColdResetStatus():
##@@@P_:kf32a13k_hw_scu.c:797
##@@@L0792_:    uint32_t password;   
##@@@L0793_:    password = Scu_LL_WdtGetCpuWdgPassword((Scu_CPUType_t)CPU);   
##@@@L0794_:    Scu_Hw_WdtClearCpuEndinit(CPU, password);   
##@@@L0795_:    Scu_LL_RcuClearColdResetStatus();   
##@@@L0796_:    Scu_Hw_WdtSetCpuEndinit(CPU, password);   
##@@@L0797_:}   
8000b892:	e8 28       	ADD       SP, #8			;->0x08
8000b894:	03 5e       	POP       {R6-R7}
8000b896:	1d 5c       	JMP       LR
8000b898:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000b830	@@: JZ        $+0                   ;->0x8000b898
8000b89c:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b8a0:	98 f0 00 f0 	.long     0xf000f098 ->-268373864  [!!!@2@:JZ        $-104                 ;->0x8000b7d0	@@: JZ        $+0                   ;->0x8000b8a0

8000b8a4 <Scu_Hw_ConfigResetRequestTrigger>:
##@@@F_:Scu_Hw_ConfigResetRequestTrigger():
##@@@P_:kf32a13k_hw_scu.c:808
##@@@L0803_: * @param Scu_Hw_CPUType_t   
##@@@L0804_: * @param Scu_RcuResetType_t   
##@@@L0805_: * @retval void   
##@@@L0806_: */   
##@@@L0807_:void Scu_Hw_ConfigResetRequestTrigger(Scu_Hw_RcuTriggerType_t Trigger, Scu_Hw_RcuResetType_t ResetType)   
##@@@L0808_:{   
8000b8a4:	07 5f       	PUSH      {R6-R8}
8000b8a6:	e8 30       	SUB       SP, #8			;->0x08
8000b8a8:	19 45       	LD        R5, [PC + #25]        ;->0x8000b90c  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:983
##@@@L0978_: * @retval uint32_t   
##@@@L0979_: */   
##@@@L0980_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgPassword(void)   
##@@@L0981_:{   
##@@@L0982_:    uint32_t password;   
##@@@L0983_:    password = REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.PW);   
8000b8aa:	45 81       	LD.H      R4, [R5]
8000b8ac:	19 43       	LD        R3, [PC + #25]        ;->0x8000b910  :=0xf000f0c0
8000b8ae:	2c 1f       	MOV       R2, #252			;->0x00FC
8000b8b0:	19 46       	LD        R6, [PC + #25]        ;->0x8000b914  :=0xfffc
##@@@P_:kf32a13k_drv_scu.h:985
##@@@L0984_:    // TODO:不确定是否需要异或操作   
##@@@L0985_:    password ^= 0x003F;   
8000b8b2:	42 6b       	XRL       R4, R2
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
8000b8b4:	46 69       	ANL       R4, R6
8000b8b6:	01 23       	ST.W      [SP + #1], R3
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b8b8:	63 82       	LD.W      R6, [R3]
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b8ba:	75 81       	LD.H      R7, [R5]
8000b8bc:	22 10       	MOV       R2, #2			;->0x0002
8000b8be:	72 69       	ANL       R7, R2
##@@@F_:Scu_LL_WdtClearSafetyEndinitInline():
8000b8c0:	30 7b       	LSL       R6, #16			;->0x10
8000b8c2:	64 6a       	ORL       R6, R4
##@@@P_:kf32a13k_drv_scu.h:2295
##@@@L2290_: * @retval void   
##@@@L2291_: */   
##@@@L2292_:KF_INLINE void Scu_LL_WdtClearSafetyEndinitInline(uint32_t Password)   
##@@@L2293_:{   
##@@@L2294_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2295_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b8c4:	70 38       	CMP       R7, #0			;->0x00
8000b8c6:	05 f0       	JZ        $+5                   ;->0x8000b8d0
8000b8c8:	71 10       	MOV       R7, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2297
##@@@L2296_:    {   
##@@@L2297_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b8ca:	06 59       	MOV       R8, R6
8000b8cc:	87 6a       	ORL       R8, R7
8000b8ce:	58 85       	ST.W      [R5], R8
##@@@P_:kf32a13k_drv_scu.h:2300
##@@@L2298_:    }   
##@@@L2299_:
##@@@L2300_:    SCU_PTR->SCU_SWDTCTL0.reg = (0U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b8d0:	62 6a       	ORL       R6, R2
8000b8d2:	56 85       	ST.W      [R5], R6
##@@@F_:Scu_LL_RcuSetResetType():
##@@@P_:kf32a13k_drv_scu.h:705
##@@@L0700_: * @retval void   
##@@@L0701_: */   
##@@@L0702_:KF_INLINE void Scu_LL_RcuSetResetType(Scu_RcuTriggerType_t RcuTrigger, Scu_RcuResetType_t ResetType)   
##@@@L0703_:{   
##@@@L0704_:    // TODO:需要确定RCU_CTL0 BIT6~BIT7是 SMUMOD 还是 SACURMOD   
##@@@L0705_:    REG_BITS_WRITE(   
8000b8d4:	01 7a       	LSL       R0, #1			;->0x01
8000b8d6:	63 10       	MOV       R6, #3			;->0x0003
8000b8d8:	10 6c       	LSL       R1, R0
8000b8da:	e6 58       	MOV       R7, R6
8000b8dc:	0f 43       	LD        R3, [PC + #15]        ;->0x8000b918  :=0xf000f090
8000b8de:	70 6c       	LSL       R7, R0
8000b8e0:	03 82       	LD.W      R0, [R3]
8000b8e2:	77 68       	NOT       R7, R7
8000b8e4:	07 69       	ANL       R0, R7
8000b8e6:	01 6a       	ORL       R0, R1
8000b8e8:	30 85       	ST.W      [R3], R0
##@@@F_:Scu_LL_WdtGetSafetyWdgReload():
##@@@P_:kf32a13k_drv_scu.h:998
##@@@L0993_: * @param void   
##@@@L0994_: * @retval uint32_t   
##@@@L0995_: */   
##@@@L0996_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgReload(void)   
##@@@L0997_:{   
##@@@L0998_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.REL));   
8000b8ea:	01 0b       	LD.W      R3, [SP + #1]
8000b8ec:	33 82       	LD.W      R3, [R3]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b8ee:	18 7b       	LSL       R3, #16			;->0x10
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
##@@@P_:kf32a13k_drv_scu.h:902
##@@@L0897_: *         false:寄存器被解锁   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE bool Scu_LL_WdtGetSafetyRegLockState(void)   
##@@@L0900_:{   
##@@@L0901_:    // TODO:LCK位是否可以使用软件操作，是否可以全部使用硬件操作   
##@@@L0902_:    return (REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.LCK));   
8000b8f0:	15 81       	LD.H      R1, [R5]
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
8000b8f2:	34 6a       	ORL       R3, R4
##@@@F_:Scu_LL_WdtGetSafetyRegLockState():
8000b8f4:	12 69       	ANL       R1, R2
##@@@F_:Scu_LL_WdtSetSafetyEndinitInline():
##@@@P_:kf32a13k_drv_scu.h:2319
##@@@L2314_: * @retval void   
##@@@L2315_: */   
##@@@L2316_:KF_INLINE void Scu_LL_WdtSetSafetyEndinitInline(uint32_t Password)   
##@@@L2317_:{   
##@@@L2318_:    uint32_t Rel = Scu_LL_WdtGetSafetyWdgReload();   
##@@@L2319_:    if (Scu_LL_WdtGetSafetyRegLockState())   
8000b8f6:	10 38       	CMP       R1, #0			;->0x00
8000b8f8:	05 f0       	JZ        $+5                   ;->0x8000b902
8000b8fa:	41 10       	MOV       R4, #1			;->0x0001
##@@@P_:kf32a13k_drv_scu.h:2321
##@@@L2320_:    {   
##@@@L2321_:        SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (0U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b8fc:	43 58       	MOV       R2, R3
8000b8fe:	24 6a       	ORL       R2, R4
8000b900:	52 85       	ST.W      [R5], R2
##@@@P_:kf32a13k_drv_scu.h:2324
##@@@L2322_:    }   
##@@@L2323_:
##@@@L2324_:    SCU_PTR->SCU_SWDTCTL0.reg = (1U << 0U) | (1U << 1U) | (Password << 2U) | (Rel << 16U);   
8000b902:	36 6a       	ORL       R3, R6
8000b904:	53 85       	ST.W      [R5], R3
##@@@F_:Scu_Hw_ConfigResetRequestTrigger():
##@@@P_:kf32a13k_hw_scu.c:814
##@@@L0809_:    uint32_t password;   
##@@@L0810_:    password = Scu_LL_WdtGetSafetyWdgPassword();   
##@@@L0811_:    Scu_Hw_WdtClearSafetyEndinit(password);   
##@@@L0812_:    Scu_LL_RcuSetResetType((Scu_RcuTriggerType_t)Trigger, (Scu_RcuResetType_t)ResetType);   
##@@@L0813_:    Scu_Hw_WdtSetSafetyEndinit(password);   
##@@@L0814_:}   
8000b906:	e8 28       	ADD       SP, #8			;->0x08
8000b908:	07 5e       	POP       {R6-R8}
8000b90a:	1d 5c       	JMP       LR
8000b90c:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000b884	@@: JZ        $+0                   ;->0x8000b90c
8000b910:	c0 f0 00 f0 	.long     0xf000f0c0 ->-268373824  [!!!@2@:JZ        $-64                  ;->0x8000b890	@@: JZ        $+0                   ;->0x8000b910
8000b914:	fc ff 00 00 	.long     0x0000fffc ->000065532 
8000b918:	90 f0 00 f0 	.long     0xf000f090 ->-268373872  [!!!@2@:JZ        $-112                 ;->0x8000b838	@@: JZ        $+0                   ;->0x8000b918

8000b91c <Scu_Hw_WdtGetCpuWdgPassword>:
##@@@F_:Scu_Hw_WdtGetCpuWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:824
##@@@L0819_: *   
##@@@L0820_: * @param CPU   
##@@@L0821_: * @retval uint32_t   
##@@@L0822_: */   
##@@@L0823_:uint32_t Scu_Hw_WdtGetCpuWdgPassword(Scu_Hw_CPUType_t CPU)   
##@@@L0824_:{   
8000b91c:	04 45       	LD        R5, [PC + #4]         ;->0x8000b92c  :=0xf000f0cc
##@@@F_:Scu_LL_WdtGetCpuWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:858
##@@@L0853_: * @retval uint32_t   
##@@@L0854_: */   
##@@@L0855_:KF_INLINE uint32_t Scu_LL_WdtGetCpuWdgPassword(Scu_CPUType_t CPU)   
##@@@L0856_:{   
##@@@L0857_:    uint32_t password;   
##@@@L0858_:    password = REG_READ(SCU_PTR->SCU_CPUWDT[CPU].SCU_CPUWDTCTL0.bits.PW);   
8000b91e:	04 7a       	LSL       R0, #4			;->0x04
8000b920:	40 e7       	LD.H      R0, [R0 + R5]
8000b922:	02 7c       	LSR       R0, #2			;->0x02
8000b924:	5f 13       	MOV       R5, #63			;->0x003F
##@@@P_:kf32a13k_drv_scu.h:861
##@@@L0859_:
##@@@L0860_:    // TODO:不确定是否需要异或操作   
##@@@L0861_:    password ^= 0x003F;   
8000b926:	05 6b       	XRL       R0, R5
##@@@F_:Scu_Hw_WdtGetCpuWdgPassword():
##@@@P_:kf32a13k_hw_scu.c:825
##@@@L0825_:    return (Scu_LL_WdtGetCpuWdgPassword((Scu_CPUType_t)CPU));   
8000b928:	1d 5c       	JMP       LR
8000b92a:	00 00       	NOP      NOP      
8000b92c:	cc f0 00 f0 	.long     0xf000f0cc ->-268373812  [!!!@2@:JZ        $-52                  ;->0x8000b8c4	@@: JZ        $+0                   ;->0x8000b92c

8000b930 <Scu_Hw_WdtGetSafetyPassword>:
##@@@F_:Scu_Hw_WdtGetSafetyPassword():
##@@@P_:kf32a13k_hw_scu.c:835
##@@@L0830_: *   
##@@@L0831_: *   
##@@@L0832_: * @retval uint32_t   
##@@@L0833_: */   
##@@@L0834_:uint32_t Scu_Hw_WdtGetSafetyPassword()   
##@@@L0835_:{   
8000b930:	03 45       	LD        R5, [PC + #3]         ;->0x8000b93c  :=0xf000f0bc
##@@@F_:Scu_LL_WdtGetSafetyWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:983
##@@@L0978_: * @retval uint32_t   
##@@@L0979_: */   
##@@@L0980_:KF_INLINE uint32_t Scu_LL_WdtGetSafetyWdgPassword(void)   
##@@@L0981_:{   
##@@@L0982_:    uint32_t password;   
##@@@L0983_:    password = REG_READ(SCU_PTR->SCU_SWDTCTL0.bits.PW);   
8000b932:	05 81       	LD.H      R0, [R5]
8000b934:	02 7c       	LSR       R0, #2			;->0x02
8000b936:	5f 13       	MOV       R5, #63			;->0x003F
##@@@P_:kf32a13k_drv_scu.h:985
##@@@L0984_:    // TODO:不确定是否需要异或操作   
##@@@L0985_:    password ^= 0x003F;   
8000b938:	05 6b       	XRL       R0, R5
##@@@F_:Scu_Hw_WdtGetSafetyPassword():
##@@@P_:kf32a13k_hw_scu.c:836
##@@@L0836_:    return (Scu_LL_WdtGetSafetyWdgPassword());   
8000b93a:	1d 5c       	JMP       LR
8000b93c:	bc f0 00 f0 	.long     0xf000f0bc ->-268373828  [!!!@2@:JZ        $-68                  ;->0x8000b8b4	@@: JZ        $+0                   ;->0x8000b93c

8000b940 <Scu_Hw_WdtGetGlobalPassword>:
##@@@F_:Scu_Hw_WdtGetGlobalPassword():
##@@@P_:kf32a13k_hw_scu.c:846
##@@@L0841_: *   
##@@@L0842_: *   
##@@@L0843_: * @retval uint32_t   
##@@@L0844_: */   
##@@@L0845_:uint32_t Scu_Hw_WdtGetGlobalPassword()   
##@@@L0846_:{   
8000b940:	04 45       	LD        R5, [PC + #4]         ;->0x8000b950  :=0xf000f0ec
##@@@F_:Scu_LL_WdtGetGlobalWdgPassword():
##@@@P_:kf32a13k_drv_scu.h:1213
##@@@L1208_: * @retval uint32_t   
##@@@L1209_: */   
##@@@L1210_:KF_INLINE uint32_t Scu_LL_WdtGetGlobalWdgPassword(void)   
##@@@L1211_:{   
##@@@L1212_:    uint32_t password;   
##@@@L1213_:    password = REG_READ(SCU_PTR->SCU_GECTL0.bits.EPW);   
8000b942:	05 82       	LD.W      R0, [R5]
8000b944:	04 45       	LD        R5, [PC + #4]         ;->0x8000b954  :=0x3fff
8000b946:	02 7c       	LSR       R0, #2			;->0x02
8000b948:	05 69       	ANL       R0, R5
8000b94a:	5f 13       	MOV       R5, #63			;->0x003F
##@@@P_:kf32a13k_drv_scu.h:1215
##@@@L1214_:    // TODO:不确定是否需要异或操作   
##@@@L1215_:    password ^= 0x003F;   
8000b94c:	05 6b       	XRL       R0, R5
##@@@F_:Scu_Hw_WdtGetGlobalPassword():
##@@@P_:kf32a13k_hw_scu.c:847
##@@@L0847_:    return (Scu_LL_WdtGetGlobalWdgPassword());   
8000b94e:	1d 5c       	JMP       LR
8000b950:	ec f0 00 f0 	.long     0xf000f0ec ->-268373780  [!!!@2@:JZ        $-20                  ;->0x8000b928	@@: JZ        $+0                   ;->0x8000b950
8000b954:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      

8000b958 <Systick_Hw_DisableModule>:
##@@@F_:Systick_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_systick.h:224
##@@@L0219_: * @retval void   
##@@@L0220_: */   
##@@@L0221_:KF_INLINE void Systick_LL_SetModuleDisabled(Systick_RegisterMap_t *const Module, const bool Status)   
##@@@L0222_:{   
##@@@L0223_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0224_:    REG_WRITE(Module->SYSTICK_CLKC.bits.DISR, Status);   
8000b958:	50 82       	LD.W      R5, [R0]
8000b95a:	41 10       	MOV       R4, #1			;->0x0001
8000b95c:	54 6a       	ORL       R5, R4
8000b95e:	05 85       	ST.W      [R0], R5
##@@@F_:Systick_Hw_DisableModule():
##@@@P_:kf32a13k_hw_systick.c:86
##@@@L0081_:#endif   
##@@@L0082_:    Systick_LL_SetModuleDisabled(Module, true);   
##@@@L0083_:#if 0   
##@@@L0084_:    SCU_LL_SetCpuEndinit(coreID, password);   
##@@@L0085_:#endif   
##@@@L0086_:}   
8000b960:	1d 5c       	JMP       LR
	...

8000b964 <Systick_Hw_EnableModule>:
##@@@F_:Systick_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_systick.h:224
8000b964:	50 82       	LD.W      R5, [R0]
8000b966:	03 44       	LD        R4, [PC + #3]         ;->0x8000b970  :=0xfffffffe
8000b968:	54 69       	ANL       R5, R4
8000b96a:	05 85       	ST.W      [R0], R5
##@@@F_:Systick_Hw_EnableModule():
##@@@P_:kf32a13k_hw_systick.c:106
##@@@L0101_:#endif   
##@@@L0102_:    Systick_LL_SetModuleDisabled(Module, false);   
##@@@L0103_:#if 0   
##@@@L0104_:    SCU_LL_SetCpuEndinit(coreID, password);   
##@@@L0105_:#endif   
##@@@L0106_:}   
8000b96c:	1d 5c       	JMP       LR
8000b96e:	00 00       	NOP      NOP      
8000b970:	fe ff ff ff 	.long     0xfffffffe ->-00000002 

8000b974 <Systick_Hw_EnableSuspend>:
##@@@F_:Systick_Hw_EnableSuspend():
##@@@P_:kf32a13k_hw_systick.c:118
##@@@L0113_: * @retval 挂起状态   
##@@@L0114_: *              false: 未挂起   
##@@@L0115_: *              true: 挂起   
##@@@L0116_: */   
##@@@L0117_:bool Systick_Hw_EnableSuspend(Systick_RegisterMap_t *const Module)   
##@@@L0118_:{   
8000b974:	e8 30       	SUB       SP, #8			;->0x08
8000b976:	50 10       	MOV       R5, #0			;->0x0000
##@@@F_:Systick_LL_SetSuspendMode():
##@@@P_:kf32a13k_drv_systick.h:322
##@@@L0317_:KF_INLINE void Systick_LL_SetSuspendMode(Systick_RegisterMap_t *const Module, const Systick_SuspendMode_t SuspendMode)   
##@@@L0318_:{   
##@@@L0319_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0320_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICKSUSPEND_MODE(SuspendMode));   
##@@@L0321_:
##@@@L0322_:    SYSTICK_DBG_T regValue = {0U};   
8000b978:	01 25       	ST.W      [SP + #1], R5
##@@@P_:kf32a13k_drv_systick.h:324
##@@@L0323_:
##@@@L0324_:    regValue.reg           = REG_READ(Module->SYSTICK_DBG.reg);   
8000b97a:	a8 98       	LD.W      R5, [R0 + #2]
8000b97c:	01 25       	ST.W      [SP + #1], R5
8000b97e:	0a 45       	LD        R5, [PC + #10]        ;->0x8000b9a4  :=0x10000000
##@@@P_:kf32a13k_drv_systick.h:325
##@@@L0325_:    regValue.bits.SUSP     = true;   
8000b980:	01 0c       	LD.W      R4, [SP + #1]
8000b982:	45 6a       	ORL       R4, R5
8000b984:	01 24       	ST.W      [SP + #1], R4
8000b986:	09 45       	LD        R5, [PC + #9]         ;->0x8000b9a8  :=0xf0ffffff
##@@@P_:kf32a13k_drv_systick.h:326
##@@@L0326_:    regValue.bits.SUS      = SuspendMode;   
8000b988:	01 0c       	LD.W      R4, [SP + #1]
8000b98a:	09 43       	LD        R3, [PC + #9]         ;->0x8000b9ac  :=0x2000000
8000b98c:	45 69       	ANL       R4, R5
8000b98e:	43 6a       	ORL       R4, R3
8000b990:	01 24       	ST.W      [SP + #1], R4
##@@@P_:kf32a13k_drv_systick.h:327
##@@@L0327_:    REG_WRITE(Module->SYSTICK_DBG.reg, regValue.reg);   
8000b992:	01 0d       	LD.W      R5, [SP + #1]
8000b994:	85 a0       	ST.W      [R0 + #2], R5
##@@@F_:Systick_LL_IsModuleSuspended():
##@@@P_:kf32a13k_drv_systick.h:305
##@@@L0300_: *        false Systick模块挂起   
##@@@L0301_: */   
##@@@L0302_:KF_INLINE bool Systick_LL_IsModuleSuspended(Systick_RegisterMap_t *const Module)   
##@@@L0303_:{   
##@@@L0304_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0305_:    return (REG_READ(Module->SYSTICK_DBG.bits.SUSSTA));   
8000b996:	80 98       	LD.W      R0, [R0 + #2]
8000b998:	06 45       	LD        R5, [PC + #6]         ;->0x8000b9b0  :=0x20000000
8000b99a:	05 69       	ANL       R0, R5
8000b99c:	85 7d       	LSR       R0, #29			;->0x1D
##@@@F_:Systick_Hw_EnableSuspend():
##@@@P_:kf32a13k_hw_systick.c:121
##@@@L0119_:    /*TODO: 检查OCDS是否使能*/   
##@@@L0120_:    Systick_LL_SetSuspendMode(Module, SYSTICK_SUSPEND_MODE_STOP);   
##@@@L0121_:    return (bool)(Systick_LL_IsModuleSuspended(Module));   
8000b99e:	e8 28       	ADD       SP, #8			;->0x08
8000b9a0:	1d 5c       	JMP       LR
8000b9a2:	00 00       	NOP      NOP      
8000b9a4:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
8000b9a8:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
8000b9ac:	00 00 00 02 	.long     0x02000000 ->033554432 
8000b9b0:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0

8000b9b4 <Systick_Hw_DisableSuspend>:
##@@@F_:Systick_Hw_DisableSuspend():
##@@@P_:kf32a13k_hw_systick.c:134
##@@@L0129_: * @retval 挂起状态   
##@@@L0130_: *              false: 未挂起   
##@@@L0131_: *              true: 挂起   
##@@@L0132_: */   
##@@@L0133_:bool Systick_Hw_DisableSuspend(Systick_RegisterMap_t *const Module)   
##@@@L0134_:{   
8000b9b4:	e8 30       	SUB       SP, #8			;->0x08
8000b9b6:	50 10       	MOV       R5, #0			;->0x0000
##@@@F_:Systick_LL_SetSuspendMode():
##@@@P_:kf32a13k_drv_systick.h:322
##@@@L0317_:KF_INLINE void Systick_LL_SetSuspendMode(Systick_RegisterMap_t *const Module, const Systick_SuspendMode_t SuspendMode)   
##@@@L0318_:{   
##@@@L0319_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0320_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICKSUSPEND_MODE(SuspendMode));   
##@@@L0321_:
##@@@L0322_:    SYSTICK_DBG_T regValue = {0U};   
8000b9b8:	01 25       	ST.W      [SP + #1], R5
##@@@P_:kf32a13k_drv_systick.h:324
##@@@L0323_:
##@@@L0324_:    regValue.reg           = REG_READ(Module->SYSTICK_DBG.reg);   
8000b9ba:	a8 98       	LD.W      R5, [R0 + #2]
8000b9bc:	01 25       	ST.W      [SP + #1], R5
8000b9be:	09 45       	LD        R5, [PC + #9]         ;->0x8000b9e0  :=0x10000000
##@@@P_:kf32a13k_drv_systick.h:325
##@@@L0325_:    regValue.bits.SUSP     = true;   
8000b9c0:	01 0c       	LD.W      R4, [SP + #1]
8000b9c2:	45 6a       	ORL       R4, R5
8000b9c4:	01 24       	ST.W      [SP + #1], R4
8000b9c6:	08 45       	LD        R5, [PC + #8]         ;->0x8000b9e4  :=0xf0ffffff
##@@@P_:kf32a13k_drv_systick.h:326
##@@@L0326_:    regValue.bits.SUS      = SuspendMode;   
8000b9c8:	01 0c       	LD.W      R4, [SP + #1]
8000b9ca:	45 69       	ANL       R4, R5
8000b9cc:	01 24       	ST.W      [SP + #1], R4
##@@@P_:kf32a13k_drv_systick.h:327
##@@@L0327_:    REG_WRITE(Module->SYSTICK_DBG.reg, regValue.reg);   
8000b9ce:	01 0d       	LD.W      R5, [SP + #1]
8000b9d0:	85 a0       	ST.W      [R0 + #2], R5
##@@@F_:Systick_LL_IsModuleSuspended():
##@@@P_:kf32a13k_drv_systick.h:305
##@@@L0300_: *        false Systick模块挂起   
##@@@L0301_: */   
##@@@L0302_:KF_INLINE bool Systick_LL_IsModuleSuspended(Systick_RegisterMap_t *const Module)   
##@@@L0303_:{   
##@@@L0304_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0305_:    return (REG_READ(Module->SYSTICK_DBG.bits.SUSSTA));   
8000b9d2:	80 98       	LD.W      R0, [R0 + #2]
8000b9d4:	05 45       	LD        R5, [PC + #5]         ;->0x8000b9e8  :=0x20000000
8000b9d6:	05 69       	ANL       R0, R5
8000b9d8:	85 7d       	LSR       R0, #29			;->0x1D
##@@@F_:Systick_Hw_DisableSuspend():
##@@@P_:kf32a13k_hw_systick.c:137
##@@@L0135_:    /*TODO: 检查OCDS是否使能*/   
##@@@L0136_:    Systick_LL_SetSuspendMode(Module, SYSTICK_SUSPEND_MODE_NONE);   
##@@@L0137_:    return (bool)(Systick_LL_IsModuleSuspended(Module));   
8000b9da:	e8 28       	ADD       SP, #8			;->0x08
8000b9dc:	1d 5c       	JMP       LR
8000b9de:	00 00       	NOP      NOP      
8000b9e0:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
8000b9e4:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
8000b9e8:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0

8000b9ec <Systick_Hw_DisableSleepMode>:
##@@@F_:Systick_LL_SetSleepModeEnabled():
##@@@P_:kf32a13k_drv_systick.h:251
##@@@L0246_: * @retval void   
##@@@L0247_: */   
##@@@L0248_:KF_INLINE void Systick_LL_SetSleepModeEnabled(Systick_RegisterMap_t *const Module, const bool Status)   
##@@@L0249_:{   
##@@@L0250_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0251_:    REG_WRITE(Module->SYSTICK_CLKC.bits.EDIS, Status);   
8000b9ec:	50 82       	LD.W      R5, [R0]
8000b9ee:	03 44       	LD        R4, [PC + #3]         ;->0x8000b9f8  :=0xfffffffb
8000b9f0:	54 69       	ANL       R5, R4
8000b9f2:	05 85       	ST.W      [R0], R5
##@@@F_:Systick_Hw_DisableSleepMode():
##@@@P_:kf32a13k_hw_systick.c:157
##@@@L0152_:#endif   
##@@@L0153_:    Systick_LL_SetSleepModeEnabled(Module, false);   
##@@@L0154_:#if 0   
##@@@L0155_:        SCU_LL_SetCpuEndinit(coreID, password);   
##@@@L0156_:#endif   
##@@@L0157_:}   
8000b9f4:	1d 5c       	JMP       LR
8000b9f6:	00 00       	NOP      NOP      
8000b9f8:	fb ff ff ff 	.long     0xfffffffb ->-00000005 

8000b9fc <Systick_Hw_EnableSleepMode>:
##@@@F_:Systick_LL_SetSleepModeEnabled():
##@@@P_:kf32a13k_drv_systick.h:251
8000b9fc:	50 82       	LD.W      R5, [R0]
8000b9fe:	44 10       	MOV       R4, #4			;->0x0004
8000ba00:	54 6a       	ORL       R5, R4
8000ba02:	05 85       	ST.W      [R0], R5
##@@@F_:Systick_Hw_EnableSleepMode():
##@@@P_:kf32a13k_hw_systick.c:177
##@@@L0172_:#endif   
##@@@L0173_:    Systick_LL_SetSleepModeEnabled(Module, true);   
##@@@L0174_:#if 0   
##@@@L0175_:        SCU_LL_SetCpuEndinit(coreID, password);   
##@@@L0176_:#endif   
##@@@L0177_:}   
8000ba04:	1d 5c       	JMP       LR
	...

8000ba08 <Systick_Hw_InitCompare>:
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:188
##@@@L0183_: * @param Module   
##@@@L0184_: * @param Config   
##@@@L0185_: * @return   
##@@@L0186_: */   
##@@@L0187_:bool Systick_Hw_InitCompare(Systick_RegisterMap_t *const Module, const Systick_CompareConfig_t *Config)   
##@@@L0188_:{   
8000ba08:	bf 5f       	PUSH      {R6-R11,LR}
8000ba0a:	e0 31       	SUB       SP, #16			;->0x10
##@@@P_:kf32a13k_hw_systick.c:190
##@@@L0189_:    bool ret = true;   
##@@@L0190_:    if ((Config->Comparator == SYSTICK_COMPARATOR_0) || (Config->Comparator == SYSTICK_COMPARATOR_1))   
8000ba0c:	81 82       	LD.W      R8, [R1]
8000ba0e:	81 38       	CMP       R8, #1			;->0x01
8000ba10:	05 f9       	JLS       $+5                   ;->0x8000ba1a
8000ba12:	82 38       	CMP       R8, #2			;->0x02
8000ba14:	52 f3       	JNC       $+82                  ;->0x8000bab8
8000ba16:	00 10       	MOV       R0, #0			;->0x0000
8000ba18:	51 04       	SJMP      $+81                  ;->0x8000baba
8000ba1a:	e1 58       	MOV       R7, R1
8000ba1c:	c0 58       	MOV       R6, R0
##@@@P_:kf32a13k_hw_systick.c:195
##@@@L0191_:    {   
##@@@L0192_:        uint32_t offsetTimer = 0;   
##@@@L0193_:        Systick_LL_SetCompareControl(   
##@@@L0194_:          Module, (Systick_Comparator_t)Config->Comparator, (Systick_ComparatorOffset_t)Config->ComparatorOffset,   
##@@@L0195_:          (Systick_ComparatorSize_t)Config->ComparatorSize, (Systick_ComparatorInterrupt_t)Config->ComparatorInterrupt);   
8000ba1e:	69 98       	LD.W      R5, [R1 + #1]
8000ba20:	d1 98       	LD.W      R2, [R1 + #3]
##@@@P_:kf32a13k_hw_systick.c:194
##@@@L0189_:    bool ret = true;   
##@@@L0190_:    if ((Config->Comparator == SYSTICK_COMPARATOR_0) || (Config->Comparator == SYSTICK_COMPARATOR_1))   
##@@@L0191_:    {   
##@@@L0192_:        uint32_t offsetTimer = 0;   
##@@@L0193_:        Systick_LL_SetCompareControl(   
##@@@L0194_:          Module, (Systick_Comparator_t)Config->Comparator, (Systick_ComparatorOffset_t)Config->ComparatorOffset,   
8000ba22:	a1 98       	LD.W      R4, [R1 + #2]
##@@@F_:Systick_LL_SetCompareControl():
8000ba24:	98 9c       	LD.W      R3, [R0 + #18]
##@@@P_:kf32a13k_drv_systick.h:629
##@@@L0624_:{   
##@@@L0625_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0626_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0627_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR_OFFSET(Offset));   
##@@@L0628_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR_SIZE(Size));   
##@@@L0629_:    if (Comparator == SYSTICK_COMPARATOR_0)   
8000ba26:	02 23       	ST.W      [SP + #2], R3
8000ba28:	80 38       	CMP       R8, #0			;->0x00
8000ba2a:	0e f0       	JZ        $+14                  ;->0x8000ba46
8000ba2c:	26 43       	LD        R3, [PC + #38]        ;->0x8000bac4  :=0x1f0000
##@@@P_:kf32a13k_drv_systick.h:637
##@@@L0632_:        REG_WRITE(Module->SYSTICK_CMPCTL.bits.MSTART0, Offset);   
##@@@L0633_:        REG_WRITE(Module->SYSTICK_ICR.bits.CMP0IFSEL, Interrupt);   
##@@@L0634_:    }   
##@@@L0635_:    else   
##@@@L0636_:    {   
##@@@L0637_:        REG_WRITE(Module->SYSTICK_CMPCTL.bits.MSIZE1, Size);   
8000ba2e:	10 7b       	LSL       R2, #16			;->0x10
8000ba30:	23 69       	ANL       R2, R3
8000ba32:	26 43       	LD        R3, [PC + #38]        ;->0x8000bac8  :=0xffffffbf
8000ba34:	03 23       	ST.W      [SP + #3], R3
8000ba36:	a0 14       	MOV       R10, #64			;->0x0040
8000ba38:	96 10       	MOV       R9, #6			;->0x0006
8000ba3a:	25 43       	LD        R3, [PC + #37]        ;->0x8000bacc  :=0xe0ffffff
8000ba3c:	01 23       	ST.W      [SP + #1], R3
8000ba3e:	25 41       	LD        R1, [PC + #37]        ;->0x8000bad0  :=0x1f000000
8000ba40:	25 40       	LD        R0, [PC + #37]        ;->0x8000bad4  :=0xffe0ffff
8000ba42:	b8 11       	MOV       R11, #24			;->0x0018
8000ba44:	0c 04       	SJMP      $+12                  ;->0x8000ba5c
8000ba46:	3f 11       	MOV       R3, #31			;->0x001F
##@@@P_:kf32a13k_drv_systick.h:631
##@@@L0626_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0627_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR_OFFSET(Offset));   
##@@@L0628_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR_SIZE(Size));   
##@@@L0629_:    if (Comparator == SYSTICK_COMPARATOR_0)   
##@@@L0630_:    {   
##@@@L0631_:        REG_WRITE(Module->SYSTICK_CMPCTL.bits.MSIZE0, Size);   
8000ba48:	23 69       	ANL       R2, R3
8000ba4a:	24 43       	LD        R3, [PC + #36]        ;->0x8000bad8  :=0xfffffffb
8000ba4c:	03 23       	ST.W      [SP + #3], R3
8000ba4e:	a4 10       	MOV       R10, #4			;->0x0004
8000ba50:	92 10       	MOV       R9, #2			;->0x0002
8000ba52:	23 43       	LD        R3, [PC + #35]        ;->0x8000badc  :=0xffffe0ff
8000ba54:	01 23       	ST.W      [SP + #1], R3
8000ba56:	23 41       	LD        R1, [PC + #35]        ;->0x8000bae0  :=0x1f00
8000ba58:	23 40       	LD        R0, [PC + #35]        ;->0x8000bae4  :=0xffffffe0
8000ba5a:	b8 10       	MOV       R11, #8			;->0x0008
8000ba5c:	02 0b       	LD.W      R3, [SP + #2]
8000ba5e:	03 69       	ANL       R0, R3
8000ba60:	02 6a       	ORL       R0, R2
8000ba62:	b0 a4       	ST.W      [R6 + #18], R0
8000ba64:	4b 6c       	LSL       R4, R11
8000ba66:	96 9c       	LD.W      R2, [R6 + #18]
8000ba68:	41 69       	ANL       R4, R1
8000ba6a:	01 0b       	LD.W      R3, [SP + #1]
8000ba6c:	23 69       	ANL       R2, R3
8000ba6e:	24 6a       	ORL       R2, R4
8000ba70:	b2 a4       	ST.W      [R6 + #18], R2
8000ba72:	59 6c       	LSL       R5, R9
8000ba74:	e6 9c       	LD.W      R4, [R6 + #19]
8000ba76:	5a 69       	ANL       R5, R10
8000ba78:	03 0b       	LD.W      R3, [SP + #3]
8000ba7a:	43 69       	ANL       R4, R3
8000ba7c:	45 6a       	ORL       R4, R5
8000ba7e:	f4 a4       	ST.W      [R6 + #19], R4
##@@@F_:Systick_LL_GetTimer():
##@@@P_:kf32a13k_drv_systick.h:505
##@@@L0500_:KF_INLINE uint64_t Systick_LL_GetTimer(Systick_RegisterMap_t *const Module)   
##@@@L0501_:{   
##@@@L0502_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0503_:    uint64_t result;   
##@@@L0504_:    uint32_t Reg_Cap;   
##@@@L0505_:    result  = REG_READ(Module->SYSTICK_TIM0.reg);   
8000ba80:	06 9a       	LD.W      R0, [R6 + #8]
##@@@P_:kf32a13k_drv_systick.h:507
##@@@L0506_:    Reg_Cap = REG_READ(Module->SYSTICK_CAP.reg);   
##@@@L0507_:    result |= ((uint64_t)Reg_Cap) << 32U;   
8000ba82:	ce 9b       	LD.W      R1, [R6 + #15]
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:197
##@@@L0195_:          (Systick_ComparatorSize_t)Config->ComparatorSize, (Systick_ComparatorInterrupt_t)Config->ComparatorInterrupt);   
##@@@L0196_:        /* 配置比较器Ticks */   
##@@@L0197_:        offsetTimer = (uint32_t)(Systick_LL_GetTimer(Module) >> Config->ComparatorOffset);   
8000ba84:	97 98       	LD.W      R2, [R7 + #2]
8000ba86:	19 45       	LD        R5, [PC + #25]        ;->0x8000bae8  :=0x8000d960
8000ba88:	05 5c       	LJMP      R5
##@@@P_:kf32a13k_hw_systick.c:198
##@@@L0198_:        Systick_LL_UpdateCompare(Module, (Systick_Comparator_t)Config->Comparator, offsetTimer + Config->Ticks);   
8000ba8a:	2f 99       	LD.W      R5, [R7 + #4]
##@@@F_:Systick_LL_UpdateCompare():
##@@@P_:kf32a13k_drv_systick.h:576
##@@@L0571_:KF_INLINE void Systick_LL_UpdateCompare(   
##@@@L0572_:  Systick_RegisterMap_t *const Module, const Systick_Comparator_t Comparator, const uint32_t Ticks)   
##@@@L0573_:{   
##@@@L0574_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0575_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0576_:    REG_WRITE((Module->SYSTICK_CMP)[Comparator].bits.CMPVAL, Ticks);   
8000ba8c:	a7 ba       	LDP.W     R4, [R7] << #2
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:198
8000ba8e:	2d c2       	ADD       R5, R5, R0
##@@@F_:Systick_LL_UpdateCompare():
##@@@P_:kf32a13k_drv_systick.h:576
8000ba90:	26 c3       	ADD       R4, R6, R4
8000ba92:	25 a4       	ST.W      [R4 + #16], R5
8000ba94:	51 10       	MOV       R5, #1			;->0x0001
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:723
##@@@L0718_:KF_INLINE void Systick_LL_ClearIntrFlag(Systick_RegisterMap_t *const Module, const Systick_IntrMask_t IntrMask)   
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
8000ba96:	67 ba       	LDP.W     R4, [R7] << #1
8000ba98:	65 58       	MOV       R3, R5
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000ba9a:	16 9d       	LD.W      R2, [R6 + #20]
##@@@P_:kf32a13k_drv_systick.h:723
##@@@L0718_:KF_INLINE void Systick_LL_ClearIntrFlag(Systick_RegisterMap_t *const Module, const Systick_IntrMask_t IntrMask)   
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
8000ba9c:	34 6c       	LSL       R3, R4
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000ba9e:	32 6a       	ORL       R3, R2
8000baa0:	33 a5       	ST.W      [R6 + #20], R3
##@@@F_:Systick_LL_SetIntrEnabled():
##@@@P_:kf32a13k_drv_systick.h:700
##@@@L0695_:KF_INLINE void Systick_LL_SetIntrEnabled(   
##@@@L0696_:  Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask, const bool Status)   
##@@@L0697_:{   
##@@@L0698_:
##@@@L0699_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0700_:    REG_BITS_WRITE(   
8000baa2:	a7 ba       	LDP.W     R4, [R7] << #2
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:202
##@@@L0199_:        /* 使能中断前清除中断标志，以避免寄存器的复位值引起比较匹配中断 */   
##@@@L0200_:        /** @attention 修改比较值以后再清标志 */   
##@@@L0201_:        Systick_LL_ClearIntrFlag(Module, (Systick_IntrMask_t)Config->Comparator);   
##@@@L0202_:        Systick_LL_SetIntrEnabled(Module, (Systick_IntrEnableFlagMask_t)Config->Comparator, Config->EnableInterrupt);   
8000baa4:	1f 8d       	LD.B      R3, [R7 + #20]
##@@@F_:Systick_LL_SetIntrEnabled():
##@@@P_:kf32a13k_drv_systick.h:700
8000baa6:	34 6c       	LSL       R3, R4
8000baa8:	54 6c       	LSL       R5, R4
8000baaa:	e6 9c       	LD.W      R4, [R6 + #19]
8000baac:	55 68       	NOT       R5, R5
8000baae:	45 69       	ANL       R4, R5
8000bab0:	43 6a       	ORL       R4, R3
8000bab2:	f4 a4       	ST.W      [R6 + #19], R4
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:190
##@@@L0185_: * @return   
##@@@L0186_: */   
##@@@L0187_:bool Systick_Hw_InitCompare(Systick_RegisterMap_t *const Module, const Systick_CompareConfig_t *Config)   
##@@@L0188_:{   
##@@@L0189_:    bool ret = true;   
##@@@L0190_:    if ((Config->Comparator == SYSTICK_COMPARATOR_0) || (Config->Comparator == SYSTICK_COMPARATOR_1))   
8000bab4:	82 38       	CMP       R8, #2			;->0x02
8000bab6:	b0 f2       	JC        $-80                  ;->0x8000ba16
8000bab8:	01 10       	MOV       R0, #1			;->0x0001
##@@@P_:kf32a13k_hw_systick.c:208
##@@@L0203_:    }   
##@@@L0204_:    else   
##@@@L0205_:    {   
##@@@L0206_:        ret = false;   
##@@@L0207_:    }   
##@@@L0208_:    return ret;   
8000baba:	e0 29       	ADD       SP, #16			;->0x10
8000babc:	3f 5e       	POP       {R6-R11}
8000babe:	0d 5d       	POP       LR
8000bac0:	1d 5c       	JMP       LR
8000bac2:	00 00       	NOP      NOP      
8000bac4:	00 00 1f 00 	.long     0x001f0000 ->002031616  [!!!@2@:NOP      	@@: FST.W           [R31++], S0
8000bac8:	bf ff ff ff 	.long     0xffffffbf ->-00000065 
8000bacc:	ff ff ff e0 	.long     0xe0ffffff ->-520093697 
8000bad0:	00 00 00 1f 	.long     0x1f000000 ->520093696  [!!!@2@:NOP      	@@: MOV       R0, #240
8000bad4:	ff ff e0 ff 	.long     0xffe0ffff ->-02031617 
8000bad8:	fb ff ff ff 	.long     0xfffffffb ->-00000005 
8000badc:	ff e0 ff ff 	.long     0xffffe0ff ->-00007937 
8000bae0:	00 1f 00 00 	.long     0x00001f00 ->000007936  [!!!@2@:MOV       R0, #240	@@: NOP      
8000bae4:	e0 ff ff ff 	.long     0xffffffe0 ->-00000032 
8000bae8:	60 d9 00 80 	.long     0x8000d960 ->-2147428000  [!!!@2@:XRL       R4, R0, R5	@@: LD.B      R0, [R0]

8000baec <Systick_Hw_ResetModule>:
##@@@F_:Systick_Hw_ResetModule():
##@@@P_:kf32a13k_hw_systick.c:212
##@@@L0209_:}   
##@@@L0210_:
##@@@L0211_:void Systick_Hw_ResetModule(Systick_RegisterMap_t *const Module)   
##@@@L0212_:{   
8000baec:	87 5f       	PUSH      {R6-R8,LR}
8000baee:	e4 30       	SUB       SP, #4			;->0x04
8000baf0:	c0 58       	MOV       R6, R0
8000baf2:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:kf32a13k_hw_systick.c:213
##@@@L0213_:    uint16_t password = Scu_Hw_WdtGetCpuWdgPassword(SCU_HW_CPU0);   
8000baf4:	07 58       	MOV       R0, R7
8000baf6:	12 45       	LD        R5, [PC + #18]        ;->0x8000bb3c  :=0x8000b91c
8000baf8:	05 5c       	LJMP      R5
8000bafa:	12 45       	LD        R5, [PC + #18]        ;->0x8000bb40  :=0xffff
8000bafc:	00 59       	MOV       R8, R0
##@@@P_:kf32a13k_hw_systick.c:214
##@@@L0214_:    Scu_Hw_WdtClearCpuEndinit(SCU_HW_CPU0, password);   
8000bafe:	85 69       	ANL       R8, R5
8000bb00:	07 58       	MOV       R0, R7
8000bb02:	28 58       	MOV       R1, R8
8000bb04:	10 45       	LD        R5, [PC + #16]        ;->0x8000bb44  :=0x8000aea0
8000bb06:	05 5c       	LJMP      R5
##@@@F_:Systick_LL_ResetModule():
##@@@P_:kf32a13k_drv_systick.h:342
##@@@L0337_: * @retval void   
##@@@L0338_: */   
##@@@L0339_:KF_INLINE void Systick_LL_ResetModule(Systick_RegisterMap_t *const Module)   
##@@@L0340_:{   
##@@@L0341_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0342_:    REG_WRITE(Module->SYSTICK_RST0.bits.RST, 1U);   
8000bb08:	ee 98       	LD.W      R5, [R6 + #3]
8000bb0a:	41 10       	MOV       R4, #1			;->0x0001
8000bb0c:	54 6a       	ORL       R5, R4
8000bb0e:	f5 a0       	ST.W      [R6 + #3], R5
##@@@P_:kf32a13k_drv_systick.h:343
##@@@L0343_:    REG_WRITE(Module->SYSTICK_RST1.bits.RST, 1U);   
8000bb10:	2e 99       	LD.W      R5, [R6 + #4]
8000bb12:	54 6a       	ORL       R5, R4
8000bb14:	35 a1       	ST.W      [R6 + #4], R5
##@@@F_:Systick_LL_ClearResetStatus():
##@@@P_:kf32a13k_drv_systick.h:357
##@@@L0352_: * @retval void   
##@@@L0353_: */   
##@@@L0354_:KF_INLINE void Systick_LL_ClearResetStatus(Systick_RegisterMap_t *const Module)   
##@@@L0355_:{   
##@@@L0356_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0357_:    REG_WRITE(Module->SYSTICK_RSTCLR.bits.CLR, 1U);   
8000bb16:	6e 99       	LD.W      R5, [R6 + #5]
8000bb18:	54 6a       	ORL       R5, R4
8000bb1a:	75 a1       	ST.W      [R6 + #5], R5
8000bb1c:	0b 45       	LD        R5, [PC + #11]        ;->0x8000bb48  :=0xfffffffb
##@@@F_:Systick_LL_SetSleepModeEnabled():
##@@@P_:kf32a13k_drv_systick.h:251
##@@@L0246_: * @retval void   
##@@@L0247_: */   
##@@@L0248_:KF_INLINE void Systick_LL_SetSleepModeEnabled(Systick_RegisterMap_t *const Module, const bool Status)   
##@@@L0249_:{   
##@@@L0250_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0251_:    REG_WRITE(Module->SYSTICK_CLKC.bits.EDIS, Status);   
8000bb1e:	46 82       	LD.W      R4, [R6]
8000bb20:	45 69       	ANL       R4, R5
8000bb22:	64 85       	ST.W      [R6], R4
8000bb24:	0a 45       	LD        R5, [PC + #10]        ;->0x8000bb4c  :=0xfffffffe
##@@@F_:Systick_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_systick.h:224
##@@@L0219_: * @retval void   
##@@@L0220_: */   
##@@@L0221_:KF_INLINE void Systick_LL_SetModuleDisabled(Systick_RegisterMap_t *const Module, const bool Status)   
##@@@L0222_:{   
##@@@L0223_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0224_:    REG_WRITE(Module->SYSTICK_CLKC.bits.DISR, Status);   
8000bb26:	46 82       	LD.W      R4, [R6]
8000bb28:	45 69       	ANL       R4, R5
8000bb2a:	64 85       	ST.W      [R6], R4
##@@@F_:Systick_Hw_ResetModule():
##@@@P_:kf32a13k_hw_systick.c:222
##@@@L0217_:    // while (!Systick_LL_GetResetStatus(Module));   
##@@@L0218_:
##@@@L0219_:    Systick_LL_ClearResetStatus(Module);   
##@@@L0220_:    Systick_LL_SetSleepModeEnabled(Module, false);   
##@@@L0221_:    Systick_LL_SetModuleDisabled(Module, false);   
##@@@L0222_:    Scu_Hw_WdtSetCpuEndinit(SCU_HW_CPU0, password);   
8000bb2c:	07 58       	MOV       R0, R7
8000bb2e:	28 58       	MOV       R1, R8
8000bb30:	08 45       	LD        R5, [PC + #8]         ;->0x8000bb50  :=0x8000aecc
8000bb32:	05 5c       	LJMP      R5
##@@@P_:kf32a13k_hw_systick.c:223
##@@@L0223_:}   
8000bb34:	e4 28       	ADD       SP, #4			;->0x04
8000bb36:	07 5e       	POP       {R6-R8}
8000bb38:	0d 5d       	POP       LR
8000bb3a:	1d 5c       	JMP       LR
8000bb3c:	1c b9 00 80 	.long     0x8000b91c ->-2147436260  [!!!@2@:STP.B     [R4], R3 << #0	@@: LD.B      R0, [R0]
8000bb40:	ff ff 00 00 	.long     0x0000ffff ->000065535 
8000bb44:	a0 ae 00 80 	.long     0x8000aea0 ->-2147438944  [!!!@2@:LD.H      R4, [R0 + #26]	@@: LD.B      R0, [R0]
8000bb48:	fb ff ff ff 	.long     0xfffffffb ->-00000005 
8000bb4c:	fe ff ff ff 	.long     0xfffffffe ->-00000002 
8000bb50:	cc ae 00 80 	.long     0x8000aecc ->-2147438900  [!!!@2@:LD.H      R1, [R4 + #27]	@@: LD.B      R0, [R0]

8000bb54 <Systick_Hw_Cmp0DelayUs>:
##@@@F_:Systick_Hw_Cmp0DelayUs():
##@@@P_:kf32a13k_hw_systick.c:232
##@@@L0227_: * @attention 该程序不可重入，调用时建议使用临界区保护   
##@@@L0228_: *   
##@@@L0229_: * @param UsTime   
##@@@L0230_: */   
##@@@L0231_:void Systick_Hw_Cmp0DelayUs(uint32_t UsTime)   
##@@@L0232_:{   
8000bb54:	2d 5d       	PUSH      LR
8000bb56:	ea 00 70 40 	FPUSH.W         S16, 	{S16-S17}
8000bb5a:	e8 30       	SUB       SP, #8			;->0x08
8000bb5c:	1f 00 00 1c 	FMOV            S0 ,	R0
##@@@P_:kf32a13k_hw_systick.c:238
##@@@L0233_:#ifdef SIMULATION   
##@@@L0234_:    float freq = 20000000.;   
##@@@L0235_:#else   
##@@@L0236_:    float freq = Clk_Hw_GetSysClkFrequency();   
##@@@L0237_:#endif   
##@@@L0238_:    uint32_t ticks = (uint32_t)((float)UsTime * freq / 1000000.F);   
8000bb60:	1f 00 10 5c 	FCVTR.F32.U32  S16,	S0
##@@@P_:kf32a13k_hw_systick.c:236
##@@@L0231_:void Systick_Hw_Cmp0DelayUs(uint32_t UsTime)   
##@@@L0232_:{   
##@@@L0233_:#ifdef SIMULATION   
##@@@L0234_:    float freq = 20000000.;   
##@@@L0235_:#else   
##@@@L0236_:    float freq = Clk_Hw_GetSysClkFrequency();   
8000bb64:	1d 45       	LD        R5, [PC + #29]        ;->0x8000bbd8  :=0x8000a68c
8000bb66:	05 5c       	LJMP      R5
8000bb68:	1d 45       	LD        R5, [PC + #29]        ;->0x8000bbdc  :=0x800011e8
8000bb6a:	24 00 a1 00 	FLD.W           S1, 	[R5 +#0  ]
8000bb6e:	29 00 00 40 	FMUL.F32        S0 , 	S0 , 	S16
##@@@P_:kf32a13k_hw_systick.c:238
##@@@L0237_:#endif   
##@@@L0238_:    uint32_t ticks = (uint32_t)((float)UsTime * freq / 1000000.F);   
8000bb72:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000bb76:	1f 00 00 54 	FCVTR.U32.F32  S0 ,	S0
8000bb7a:	1f 00 04 20 	FMOV            R4 ,	S0
##@@@P_:kf32a13k_hw_systick.c:239
##@@@L0239_:    if (ticks > 0)   
8000bb7e:	40 38       	CMP       R4, #0			;->0x00
8000bb80:	27 f0       	JZ        $+39                  ;->0x8000bbce
8000bb82:	18 45       	LD        R5, [PC + #24]        ;->0x8000bbe0  :=0xf0000148
##@@@F_:Systick_LL_SetCompareControl():
8000bb84:	35 82       	LD.W      R3, [R5]
8000bb86:	2f 11       	MOV       R2, #31			;->0x001F
8000bb88:	32 6a       	ORL       R3, R2
8000bb8a:	53 85       	ST.W      [R5], R3
8000bb8c:	35 82       	LD.W      R3, [R5]
8000bb8e:	16 42       	LD        R2, [PC + #22]        ;->0x8000bbe4  :=0xffffe0ff
8000bb90:	32 69       	ANL       R3, R2
8000bb92:	53 85       	ST.W      [R5], R3
8000bb94:	15 45       	LD        R5, [PC + #21]        ;->0x8000bbe8  :=0xf000014c
8000bb96:	16 43       	LD        R3, [PC + #22]        ;->0x8000bbec  :=0xfffffffb
8000bb98:	25 82       	LD.W      R2, [R5]
8000bb9a:	23 69       	ANL       R2, R3
8000bb9c:	52 85       	ST.W      [R5], R2
8000bb9e:	15 43       	LD        R3, [PC + #21]        ;->0x8000bbf0  :=0xf0000120
8000bba0:	15 42       	LD        R2, [PC + #21]        ;->0x8000bbf4  :=0xf000013c
##@@@F_:Systick_LL_GetTimer():
##@@@P_:kf32a13k_drv_systick.h:505
##@@@L0500_:KF_INLINE uint64_t Systick_LL_GetTimer(Systick_RegisterMap_t *const Module)   
##@@@L0501_:{   
##@@@L0502_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0503_:    uint64_t result;   
##@@@L0504_:    uint32_t Reg_Cap;   
##@@@L0505_:    result  = REG_READ(Module->SYSTICK_TIM0.reg);   
8000bba2:	33 82       	LD.W      R3, [R3]
##@@@P_:kf32a13k_drv_systick.h:506
##@@@L0506_:    Reg_Cap = REG_READ(Module->SYSTICK_CAP.reg);   
8000bba4:	22 82       	LD.W      R2, [R2]
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:198
##@@@L0193_:        Systick_LL_SetCompareControl(   
##@@@L0194_:          Module, (Systick_Comparator_t)Config->Comparator, (Systick_ComparatorOffset_t)Config->ComparatorOffset,   
##@@@L0195_:          (Systick_ComparatorSize_t)Config->ComparatorSize, (Systick_ComparatorInterrupt_t)Config->ComparatorInterrupt);   
##@@@L0196_:        /* 配置比较器Ticks */   
##@@@L0197_:        offsetTimer = (uint32_t)(Systick_LL_GetTimer(Module) >> Config->ComparatorOffset);   
##@@@L0198_:        Systick_LL_UpdateCompare(Module, (Systick_Comparator_t)Config->Comparator, offsetTimer + Config->Ticks);   
8000bba6:	1b c3       	ADD       R3, R3, R4
8000bba8:	14 42       	LD        R2, [PC + #20]        ;->0x8000bbf8  :=0xf0000140
8000bbaa:	15 44       	LD        R4, [PC + #21]        ;->0x8000bbfc  :=0xf0000150
##@@@F_:Systick_LL_UpdateCompare():
##@@@P_:kf32a13k_drv_systick.h:576
##@@@L0571_:KF_INLINE void Systick_LL_UpdateCompare(   
##@@@L0572_:  Systick_RegisterMap_t *const Module, const Systick_Comparator_t Comparator, const uint32_t Ticks)   
##@@@L0573_:{   
##@@@L0574_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0575_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0576_:    REG_WRITE((Module->SYSTICK_CMP)[Comparator].bits.CMPVAL, Ticks);   
8000bbac:	23 85       	ST.W      [R2], R3
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bbae:	24 82       	LD.W      R2, [R4]
8000bbb0:	31 10       	MOV       R3, #1			;->0x0001
8000bbb2:	23 6a       	ORL       R2, R3
8000bbb4:	42 85       	ST.W      [R4], R2
8000bbb6:	13 42       	LD        R2, [PC + #19]        ;->0x8000bc00  :=0xfffffffe
##@@@F_:Systick_LL_SetIntrEnabled():
##@@@P_:kf32a13k_drv_systick.h:700
##@@@L0695_:KF_INLINE void Systick_LL_SetIntrEnabled(   
##@@@L0696_:  Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask, const bool Status)   
##@@@L0697_:{   
##@@@L0698_:
##@@@L0699_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0700_:    REG_BITS_WRITE(   
8000bbb8:	15 82       	LD.W      R1, [R5]
8000bbba:	12 69       	ANL       R1, R2
8000bbbc:	51 85       	ST.W      [R5], R1
8000bbbe:	22 10       	MOV       R2, #2			;->0x0002
##@@@F_:Systick_LL_GetIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:678
##@@@L0673_: * @attention 这个标志位不会产生中断，在CMPxIE使能的情况下，即使该标志位没有清零，中断也只能由比较匹配事件产生   
##@@@L0674_: */   
##@@@L0675_:KF_INLINE bool Systick_LL_GetIntrFlag(Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask)   
##@@@L0676_:{   
##@@@L0677_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0678_:    return (bool)(REG_BITS_READ(   
8000bbc0:	15 82       	LD.W      R1, [R5]
8000bbc2:	12 69       	ANL       R1, R2
##@@@F_:Systick_Hw_Cmp0DelayUs():
##@@@P_:kf32a13k_hw_systick.c:250
##@@@L0245_:          .ComparatorSize      = SYSTICK_HW_COMPARATOR_SIZE_32BITS,   
##@@@L0246_:          .Ticks               = ticks,   
##@@@L0247_:          .EnableInterrupt     = false,   
##@@@L0248_:        };   
##@@@L0249_:        Systick_Hw_InitCompare(SYSTICK0_PTR, &Config);   
##@@@L0250_:        while (!Systick_LL_GetIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_CMP0))   
8000bbc4:	10 38       	CMP       R1, #0			;->0x00
8000bbc6:	fd f0       	JZ        $-3                   ;->0x8000bbc0
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bbc8:	54 82       	LD.W      R5, [R4]
8000bbca:	53 6a       	ORL       R5, R3
8000bbcc:	45 85       	ST.W      [R4], R5
##@@@F_:Systick_Hw_Cmp0DelayUs():
##@@@P_:kf32a13k_hw_systick.c:258
##@@@L0253_:        Systick_LL_ClearIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_INDEX_CMP0);   
##@@@L0254_:    }   
##@@@L0255_:    else   
##@@@L0256_:    {   
##@@@L0257_:    }   
##@@@L0258_:}   
8000bbce:	e8 28       	ADD       SP, #8			;->0x08
8000bbd0:	ea 00 70 60 	FPOP.W          S16, 	{S16-S17}
8000bbd4:	0d 5d       	POP       LR
8000bbd6:	1d 5c       	JMP       LR
8000bbd8:	8c a6 00 80 	.long     0x8000a68c ->-2147441012  [!!!@2@:ST.W      [R1 + #26], R4	@@: LD.B      R0, [R0]
8000bbdc:	e8 11 00 80 	.long     0x800011e8 ->-2147479064  [!!!@2@:MOV       SP, #24	@@: LD.B      R0, [R0]
8000bbe0:	48 01 00 f0 	.long     0xf0000148 ->-268435128  [!!!@2@:CMN       R4, R8	@@: JZ        $+0                   ;->0x8000bbe0
8000bbe4:	ff e0 ff ff 	.long     0xffffe0ff ->-00007937 
8000bbe8:	4c 01 00 f0 	.long     0xf000014c ->-268435124  [!!!@2@:CMN       R4, R12	@@: JZ        $+0                   ;->0x8000bbe8
8000bbec:	fb ff ff ff 	.long     0xfffffffb ->-00000005 
8000bbf0:	20 01 00 f0 	.long     0xf0000120 ->-268435168  [!!!@2@:CMN       R2, R0	@@: JZ        $+0                   ;->0x8000bbf0
8000bbf4:	3c 01 00 f0 	.long     0xf000013c ->-268435140  [!!!@2@:CMN       R3, R12	@@: JZ        $+0                   ;->0x8000bbf4
8000bbf8:	40 01 00 f0 	.long     0xf0000140 ->-268435136  [!!!@2@:CMN       R4, R0	@@: JZ        $+0                   ;->0x8000bbf8
8000bbfc:	50 01 00 f0 	.long     0xf0000150 ->-268435120  [!!!@2@:CMN       R5, R0	@@: JZ        $+0                   ;->0x8000bbfc
8000bc00:	fe ff ff ff 	.long     0xfffffffe ->-00000002 

8000bc04 <Systick_Hw_Cmp0DelayMs>:
##@@@F_:Systick_Hw_Cmp0DelayMs():
##@@@P_:kf32a13k_hw_systick.c:267
##@@@L0262_: * @attention 该程序不可重入，调用时建议使用临界区保护   
##@@@L0263_: *   
##@@@L0264_: * @param UsTime   
##@@@L0265_: */   
##@@@L0266_:void Systick_Hw_Cmp0DelayMs(uint32_t MsTime)   
##@@@L0267_:{   
8000bc04:	2d 5d       	PUSH      LR
8000bc06:	ea 00 70 40 	FPUSH.W         S16, 	{S16-S17}
8000bc0a:	e8 30       	SUB       SP, #8			;->0x08
8000bc0c:	1f 00 00 1c 	FMOV            S0 ,	R0
##@@@P_:kf32a13k_hw_systick.c:273
##@@@L0268_:#ifdef SIMULATION   
##@@@L0269_:    float freq = 20000000.;   
##@@@L0270_:#else   
##@@@L0271_:    float freq = Clk_Hw_GetSysClkFrequency();   
##@@@L0272_:#endif   
##@@@L0273_:    uint32_t ticks = (uint32_t)((float)MsTime * freq / 1000.F);   
8000bc10:	1f 00 10 5c 	FCVTR.F32.U32  S16,	S0
##@@@P_:kf32a13k_hw_systick.c:271
##@@@L0266_:void Systick_Hw_Cmp0DelayMs(uint32_t MsTime)   
##@@@L0267_:{   
##@@@L0268_:#ifdef SIMULATION   
##@@@L0269_:    float freq = 20000000.;   
##@@@L0270_:#else   
##@@@L0271_:    float freq = Clk_Hw_GetSysClkFrequency();   
8000bc14:	1d 45       	LD        R5, [PC + #29]        ;->0x8000bc88  :=0x8000a68c
8000bc16:	05 5c       	LJMP      R5
8000bc18:	1d 45       	LD        R5, [PC + #29]        ;->0x8000bc8c  :=0x800011ec
8000bc1a:	24 00 a1 00 	FLD.W           S1, 	[R5 +#0  ]
8000bc1e:	29 00 00 40 	FMUL.F32        S0 , 	S0 , 	S16
##@@@P_:kf32a13k_hw_systick.c:273
##@@@L0272_:#endif   
##@@@L0273_:    uint32_t ticks = (uint32_t)((float)MsTime * freq / 1000.F);   
8000bc22:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000bc26:	1f 00 00 54 	FCVTR.U32.F32  S0 ,	S0
8000bc2a:	1f 00 04 20 	FMOV            R4 ,	S0
##@@@P_:kf32a13k_hw_systick.c:274
##@@@L0274_:    if (ticks > 0)   
8000bc2e:	40 38       	CMP       R4, #0			;->0x00
8000bc30:	27 f0       	JZ        $+39                  ;->0x8000bc7e
8000bc32:	18 45       	LD        R5, [PC + #24]        ;->0x8000bc90  :=0xf0000148
##@@@F_:Systick_LL_SetCompareControl():
8000bc34:	35 82       	LD.W      R3, [R5]
8000bc36:	2f 11       	MOV       R2, #31			;->0x001F
8000bc38:	32 6a       	ORL       R3, R2
8000bc3a:	53 85       	ST.W      [R5], R3
8000bc3c:	35 82       	LD.W      R3, [R5]
8000bc3e:	16 42       	LD        R2, [PC + #22]        ;->0x8000bc94  :=0xffffe0ff
8000bc40:	32 69       	ANL       R3, R2
8000bc42:	53 85       	ST.W      [R5], R3
8000bc44:	15 45       	LD        R5, [PC + #21]        ;->0x8000bc98  :=0xf000014c
8000bc46:	16 43       	LD        R3, [PC + #22]        ;->0x8000bc9c  :=0xfffffffb
8000bc48:	25 82       	LD.W      R2, [R5]
8000bc4a:	23 69       	ANL       R2, R3
8000bc4c:	52 85       	ST.W      [R5], R2
8000bc4e:	15 43       	LD        R3, [PC + #21]        ;->0x8000bca0  :=0xf0000120
8000bc50:	15 42       	LD        R2, [PC + #21]        ;->0x8000bca4  :=0xf000013c
##@@@F_:Systick_LL_GetTimer():
##@@@P_:kf32a13k_drv_systick.h:505
##@@@L0500_:KF_INLINE uint64_t Systick_LL_GetTimer(Systick_RegisterMap_t *const Module)   
##@@@L0501_:{   
##@@@L0502_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0503_:    uint64_t result;   
##@@@L0504_:    uint32_t Reg_Cap;   
##@@@L0505_:    result  = REG_READ(Module->SYSTICK_TIM0.reg);   
8000bc52:	33 82       	LD.W      R3, [R3]
##@@@P_:kf32a13k_drv_systick.h:506
##@@@L0506_:    Reg_Cap = REG_READ(Module->SYSTICK_CAP.reg);   
8000bc54:	22 82       	LD.W      R2, [R2]
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:198
##@@@L0193_:        Systick_LL_SetCompareControl(   
##@@@L0194_:          Module, (Systick_Comparator_t)Config->Comparator, (Systick_ComparatorOffset_t)Config->ComparatorOffset,   
##@@@L0195_:          (Systick_ComparatorSize_t)Config->ComparatorSize, (Systick_ComparatorInterrupt_t)Config->ComparatorInterrupt);   
##@@@L0196_:        /* 配置比较器Ticks */   
##@@@L0197_:        offsetTimer = (uint32_t)(Systick_LL_GetTimer(Module) >> Config->ComparatorOffset);   
##@@@L0198_:        Systick_LL_UpdateCompare(Module, (Systick_Comparator_t)Config->Comparator, offsetTimer + Config->Ticks);   
8000bc56:	1b c3       	ADD       R3, R3, R4
8000bc58:	14 42       	LD        R2, [PC + #20]        ;->0x8000bca8  :=0xf0000140
8000bc5a:	15 44       	LD        R4, [PC + #21]        ;->0x8000bcac  :=0xf0000150
##@@@F_:Systick_LL_UpdateCompare():
##@@@P_:kf32a13k_drv_systick.h:576
##@@@L0571_:KF_INLINE void Systick_LL_UpdateCompare(   
##@@@L0572_:  Systick_RegisterMap_t *const Module, const Systick_Comparator_t Comparator, const uint32_t Ticks)   
##@@@L0573_:{   
##@@@L0574_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0575_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0576_:    REG_WRITE((Module->SYSTICK_CMP)[Comparator].bits.CMPVAL, Ticks);   
8000bc5c:	23 85       	ST.W      [R2], R3
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bc5e:	24 82       	LD.W      R2, [R4]
8000bc60:	31 10       	MOV       R3, #1			;->0x0001
8000bc62:	23 6a       	ORL       R2, R3
8000bc64:	42 85       	ST.W      [R4], R2
8000bc66:	13 42       	LD        R2, [PC + #19]        ;->0x8000bcb0  :=0xfffffffe
##@@@F_:Systick_LL_SetIntrEnabled():
##@@@P_:kf32a13k_drv_systick.h:700
##@@@L0695_:KF_INLINE void Systick_LL_SetIntrEnabled(   
##@@@L0696_:  Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask, const bool Status)   
##@@@L0697_:{   
##@@@L0698_:
##@@@L0699_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0700_:    REG_BITS_WRITE(   
8000bc68:	15 82       	LD.W      R1, [R5]
8000bc6a:	12 69       	ANL       R1, R2
8000bc6c:	51 85       	ST.W      [R5], R1
8000bc6e:	22 10       	MOV       R2, #2			;->0x0002
##@@@F_:Systick_LL_GetIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:678
##@@@L0673_: * @attention 这个标志位不会产生中断，在CMPxIE使能的情况下，即使该标志位没有清零，中断也只能由比较匹配事件产生   
##@@@L0674_: */   
##@@@L0675_:KF_INLINE bool Systick_LL_GetIntrFlag(Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask)   
##@@@L0676_:{   
##@@@L0677_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0678_:    return (bool)(REG_BITS_READ(   
8000bc70:	15 82       	LD.W      R1, [R5]
8000bc72:	12 69       	ANL       R1, R2
##@@@F_:Systick_Hw_Cmp0DelayMs():
##@@@P_:kf32a13k_hw_systick.c:285
##@@@L0280_:          .ComparatorSize      = SYSTICK_HW_COMPARATOR_SIZE_32BITS,   
##@@@L0281_:          .Ticks               = ticks,   
##@@@L0282_:          .EnableInterrupt     = false,   
##@@@L0283_:        };   
##@@@L0284_:        Systick_Hw_InitCompare(SYSTICK0_PTR, &Config);   
##@@@L0285_:        while (!Systick_LL_GetIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_CMP0))   
8000bc74:	10 38       	CMP       R1, #0			;->0x00
8000bc76:	fd f0       	JZ        $-3                   ;->0x8000bc70
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bc78:	54 82       	LD.W      R5, [R4]
8000bc7a:	53 6a       	ORL       R5, R3
8000bc7c:	45 85       	ST.W      [R4], R5
##@@@F_:Systick_Hw_Cmp0DelayMs():
##@@@P_:kf32a13k_hw_systick.c:293
##@@@L0288_:        Systick_LL_ClearIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_INDEX_CMP0);   
##@@@L0289_:    }   
##@@@L0290_:    else   
##@@@L0291_:    {   
##@@@L0292_:    }   
##@@@L0293_:}   
8000bc7e:	e8 28       	ADD       SP, #8			;->0x08
8000bc80:	ea 00 70 60 	FPOP.W          S16, 	{S16-S17}
8000bc84:	0d 5d       	POP       LR
8000bc86:	1d 5c       	JMP       LR
8000bc88:	8c a6 00 80 	.long     0x8000a68c ->-2147441012  [!!!@2@:ST.W      [R1 + #26], R4	@@: LD.B      R0, [R0]
8000bc8c:	ec 11 00 80 	.long     0x800011ec ->-2147479060  [!!!@2@:MOV       SP, #28	@@: LD.B      R0, [R0]
8000bc90:	48 01 00 f0 	.long     0xf0000148 ->-268435128  [!!!@2@:CMN       R4, R8	@@: JZ        $+0                   ;->0x8000bc90
8000bc94:	ff e0 ff ff 	.long     0xffffe0ff ->-00007937 
8000bc98:	4c 01 00 f0 	.long     0xf000014c ->-268435124  [!!!@2@:CMN       R4, R12	@@: JZ        $+0                   ;->0x8000bc98
8000bc9c:	fb ff ff ff 	.long     0xfffffffb ->-00000005 
8000bca0:	20 01 00 f0 	.long     0xf0000120 ->-268435168  [!!!@2@:CMN       R2, R0	@@: JZ        $+0                   ;->0x8000bca0
8000bca4:	3c 01 00 f0 	.long     0xf000013c ->-268435140  [!!!@2@:CMN       R3, R12	@@: JZ        $+0                   ;->0x8000bca4
8000bca8:	40 01 00 f0 	.long     0xf0000140 ->-268435136  [!!!@2@:CMN       R4, R0	@@: JZ        $+0                   ;->0x8000bca8
8000bcac:	50 01 00 f0 	.long     0xf0000150 ->-268435120  [!!!@2@:CMN       R5, R0	@@: JZ        $+0                   ;->0x8000bcac
8000bcb0:	fe ff ff ff 	.long     0xfffffffe ->-00000002 

8000bcb4 <Systick_Hw_Cmp1DelayUs>:
##@@@F_:Systick_Hw_Cmp1DelayUs():
##@@@P_:kf32a13k_hw_systick.c:302
##@@@L0297_: * @attention 该程序不可重入，调用时建议使用临界区保护   
##@@@L0298_: *   
##@@@L0299_: * @param UsTime   
##@@@L0300_: */   
##@@@L0301_:void Systick_Hw_Cmp1DelayUs(uint32_t UsTime)   
##@@@L0302_:{   
8000bcb4:	2d 5d       	PUSH      LR
8000bcb6:	ea 00 70 40 	FPUSH.W         S16, 	{S16-S17}
8000bcba:	e8 30       	SUB       SP, #8			;->0x08
8000bcbc:	1f 00 00 1c 	FMOV            S0 ,	R0
##@@@P_:kf32a13k_hw_systick.c:308
##@@@L0303_:#ifdef SIMULATION   
##@@@L0304_:    float freq = 20000000.;   
##@@@L0305_:#else   
##@@@L0306_:    float freq = Clk_Hw_GetSysClkFrequency();   
##@@@L0307_:#endif   
##@@@L0308_:    uint32_t ticks = (uint32_t)((float)UsTime * freq / 1000000.F);   
8000bcc0:	1f 00 10 5c 	FCVTR.F32.U32  S16,	S0
##@@@P_:kf32a13k_hw_systick.c:306
##@@@L0301_:void Systick_Hw_Cmp1DelayUs(uint32_t UsTime)   
##@@@L0302_:{   
##@@@L0303_:#ifdef SIMULATION   
##@@@L0304_:    float freq = 20000000.;   
##@@@L0305_:#else   
##@@@L0306_:    float freq = Clk_Hw_GetSysClkFrequency();   
8000bcc4:	1d 45       	LD        R5, [PC + #29]        ;->0x8000bd38  :=0x8000a68c
8000bcc6:	05 5c       	LJMP      R5
8000bcc8:	1d 45       	LD        R5, [PC + #29]        ;->0x8000bd3c  :=0x800011f0
8000bcca:	24 00 a1 00 	FLD.W           S1, 	[R5 +#0  ]
8000bcce:	29 00 00 40 	FMUL.F32        S0 , 	S0 , 	S16
##@@@P_:kf32a13k_hw_systick.c:308
##@@@L0307_:#endif   
##@@@L0308_:    uint32_t ticks = (uint32_t)((float)UsTime * freq / 1000000.F);   
8000bcd2:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000bcd6:	1f 00 00 54 	FCVTR.U32.F32  S0 ,	S0
8000bcda:	1f 00 04 20 	FMOV            R4 ,	S0
##@@@P_:kf32a13k_hw_systick.c:309
##@@@L0309_:    if (ticks > 0)   
8000bcde:	40 38       	CMP       R4, #0			;->0x00
8000bce0:	27 f0       	JZ        $+39                  ;->0x8000bd2e
8000bce2:	18 43       	LD        R3, [PC + #24]        ;->0x8000bd40  :=0xf0000148
##@@@F_:Systick_LL_SetCompareControl():
8000bce4:	53 82       	LD.W      R5, [R3]
8000bce6:	18 42       	LD        R2, [PC + #24]        ;->0x8000bd44  :=0x1f0000
8000bce8:	52 6a       	ORL       R5, R2
8000bcea:	35 85       	ST.W      [R3], R5
8000bcec:	23 82       	LD.W      R2, [R3]
8000bcee:	17 45       	LD        R5, [PC + #23]        ;->0x8000bd48  :=0xe0ffffff
8000bcf0:	25 69       	ANL       R2, R5
8000bcf2:	17 45       	LD        R5, [PC + #23]        ;->0x8000bd4c  :=0xf000014c
8000bcf4:	32 85       	ST.W      [R3], R2
8000bcf6:	35 82       	LD.W      R3, [R5]
8000bcf8:	20 14       	MOV       R2, #64			;->0x0040
8000bcfa:	32 6a       	ORL       R3, R2
8000bcfc:	53 85       	ST.W      [R5], R3
8000bcfe:	15 43       	LD        R3, [PC + #21]        ;->0x8000bd50  :=0xf0000120
8000bd00:	15 42       	LD        R2, [PC + #21]        ;->0x8000bd54  :=0xf000013c
##@@@F_:Systick_LL_GetTimer():
##@@@P_:kf32a13k_drv_systick.h:505
##@@@L0500_:KF_INLINE uint64_t Systick_LL_GetTimer(Systick_RegisterMap_t *const Module)   
##@@@L0501_:{   
##@@@L0502_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0503_:    uint64_t result;   
##@@@L0504_:    uint32_t Reg_Cap;   
##@@@L0505_:    result  = REG_READ(Module->SYSTICK_TIM0.reg);   
8000bd02:	33 82       	LD.W      R3, [R3]
##@@@P_:kf32a13k_drv_systick.h:506
##@@@L0506_:    Reg_Cap = REG_READ(Module->SYSTICK_CAP.reg);   
8000bd04:	22 82       	LD.W      R2, [R2]
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:198
##@@@L0193_:        Systick_LL_SetCompareControl(   
##@@@L0194_:          Module, (Systick_Comparator_t)Config->Comparator, (Systick_ComparatorOffset_t)Config->ComparatorOffset,   
##@@@L0195_:          (Systick_ComparatorSize_t)Config->ComparatorSize, (Systick_ComparatorInterrupt_t)Config->ComparatorInterrupt);   
##@@@L0196_:        /* 配置比较器Ticks */   
##@@@L0197_:        offsetTimer = (uint32_t)(Systick_LL_GetTimer(Module) >> Config->ComparatorOffset);   
##@@@L0198_:        Systick_LL_UpdateCompare(Module, (Systick_Comparator_t)Config->Comparator, offsetTimer + Config->Ticks);   
8000bd06:	1b c3       	ADD       R3, R3, R4
8000bd08:	14 42       	LD        R2, [PC + #20]        ;->0x8000bd58  :=0xf0000144
8000bd0a:	15 44       	LD        R4, [PC + #21]        ;->0x8000bd5c  :=0xf0000150
##@@@F_:Systick_LL_UpdateCompare():
##@@@P_:kf32a13k_drv_systick.h:576
##@@@L0571_:KF_INLINE void Systick_LL_UpdateCompare(   
##@@@L0572_:  Systick_RegisterMap_t *const Module, const Systick_Comparator_t Comparator, const uint32_t Ticks)   
##@@@L0573_:{   
##@@@L0574_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0575_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0576_:    REG_WRITE((Module->SYSTICK_CMP)[Comparator].bits.CMPVAL, Ticks);   
8000bd0c:	23 85       	ST.W      [R2], R3
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bd0e:	24 82       	LD.W      R2, [R4]
8000bd10:	34 10       	MOV       R3, #4			;->0x0004
8000bd12:	23 6a       	ORL       R2, R3
8000bd14:	42 85       	ST.W      [R4], R2
8000bd16:	13 42       	LD        R2, [PC + #19]        ;->0x8000bd60  :=0xffffffef
##@@@F_:Systick_LL_SetIntrEnabled():
##@@@P_:kf32a13k_drv_systick.h:700
##@@@L0695_:KF_INLINE void Systick_LL_SetIntrEnabled(   
##@@@L0696_:  Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask, const bool Status)   
##@@@L0697_:{   
##@@@L0698_:
##@@@L0699_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0700_:    REG_BITS_WRITE(   
8000bd18:	15 82       	LD.W      R1, [R5]
8000bd1a:	12 69       	ANL       R1, R2
8000bd1c:	51 85       	ST.W      [R5], R1
8000bd1e:	20 12       	MOV       R2, #32			;->0x0020
##@@@F_:Systick_LL_GetIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:678
##@@@L0673_: * @attention 这个标志位不会产生中断，在CMPxIE使能的情况下，即使该标志位没有清零，中断也只能由比较匹配事件产生   
##@@@L0674_: */   
##@@@L0675_:KF_INLINE bool Systick_LL_GetIntrFlag(Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask)   
##@@@L0676_:{   
##@@@L0677_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0678_:    return (bool)(REG_BITS_READ(   
8000bd20:	15 82       	LD.W      R1, [R5]
8000bd22:	12 69       	ANL       R1, R2
##@@@F_:Systick_Hw_Cmp1DelayUs():
##@@@P_:kf32a13k_hw_systick.c:320
##@@@L0315_:          .ComparatorSize      = SYSTICK_HW_COMPARATOR_SIZE_32BITS,   
##@@@L0316_:          .Ticks               = ticks,   
##@@@L0317_:          .EnableInterrupt     = false,   
##@@@L0318_:        };   
##@@@L0319_:        Systick_Hw_InitCompare(SYSTICK0_PTR, &Config);   
##@@@L0320_:        while (!Systick_LL_GetIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_CMP1))   
8000bd24:	10 38       	CMP       R1, #0			;->0x00
8000bd26:	fd f0       	JZ        $-3                   ;->0x8000bd20
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bd28:	54 82       	LD.W      R5, [R4]
8000bd2a:	53 6a       	ORL       R5, R3
8000bd2c:	45 85       	ST.W      [R4], R5
##@@@F_:Systick_Hw_Cmp1DelayUs():
##@@@P_:kf32a13k_hw_systick.c:328
##@@@L0323_:        Systick_LL_ClearIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_INDEX_CMP1);   
##@@@L0324_:    }   
##@@@L0325_:    else   
##@@@L0326_:    {   
##@@@L0327_:    }   
##@@@L0328_:}   
8000bd2e:	e8 28       	ADD       SP, #8			;->0x08
8000bd30:	ea 00 70 60 	FPOP.W          S16, 	{S16-S17}
8000bd34:	0d 5d       	POP       LR
8000bd36:	1d 5c       	JMP       LR
8000bd38:	8c a6 00 80 	.long     0x8000a68c ->-2147441012  [!!!@2@:ST.W      [R1 + #26], R4	@@: LD.B      R0, [R0]
8000bd3c:	f0 11 00 80 	.long     0x800011f0 ->-2147479056  [!!!@2@:MOV       PC, #16	@@: LD.B      R0, [R0]
8000bd40:	48 01 00 f0 	.long     0xf0000148 ->-268435128  [!!!@2@:CMN       R4, R8	@@: JZ        $+0                   ;->0x8000bd40
8000bd44:	00 00 1f 00 	.long     0x001f0000 ->002031616  [!!!@2@:NOP      	@@: FST.W           [R31++], S0
8000bd48:	ff ff ff e0 	.long     0xe0ffffff ->-520093697 
8000bd4c:	4c 01 00 f0 	.long     0xf000014c ->-268435124  [!!!@2@:CMN       R4, R12	@@: JZ        $+0                   ;->0x8000bd4c
8000bd50:	20 01 00 f0 	.long     0xf0000120 ->-268435168  [!!!@2@:CMN       R2, R0	@@: JZ        $+0                   ;->0x8000bd50
8000bd54:	3c 01 00 f0 	.long     0xf000013c ->-268435140  [!!!@2@:CMN       R3, R12	@@: JZ        $+0                   ;->0x8000bd54
8000bd58:	44 01 00 f0 	.long     0xf0000144 ->-268435132  [!!!@2@:CMN       R4, R4	@@: JZ        $+0                   ;->0x8000bd58
8000bd5c:	50 01 00 f0 	.long     0xf0000150 ->-268435120  [!!!@2@:CMN       R5, R0	@@: JZ        $+0                   ;->0x8000bd5c
8000bd60:	ef ff ff ff 	.long     0xffffffef ->-00000017 

8000bd64 <Systick_Hw_Cmp1DelayMs>:
##@@@F_:Systick_Hw_Cmp1DelayMs():
##@@@P_:kf32a13k_hw_systick.c:337
##@@@L0332_: * @attention 该程序不可重入，调用时建议使用临界区保护   
##@@@L0333_: *   
##@@@L0334_: * @param UsTime   
##@@@L0335_: */   
##@@@L0336_:void Systick_Hw_Cmp1DelayMs(uint32_t MsTime)   
##@@@L0337_:{   
8000bd64:	2d 5d       	PUSH      LR
8000bd66:	ea 00 70 40 	FPUSH.W         S16, 	{S16-S17}
8000bd6a:	e8 30       	SUB       SP, #8			;->0x08
8000bd6c:	1f 00 00 1c 	FMOV            S0 ,	R0
##@@@P_:kf32a13k_hw_systick.c:343
##@@@L0338_:#ifdef SIMULATION   
##@@@L0339_:    float freq = 20000000.;   
##@@@L0340_:#else   
##@@@L0341_:    float freq = Clk_Hw_GetSysClkFrequency();   
##@@@L0342_:#endif   
##@@@L0343_:    uint32_t ticks = (uint32_t)((float)MsTime * freq / 1000.F);   
8000bd70:	1f 00 10 5c 	FCVTR.F32.U32  S16,	S0
##@@@P_:kf32a13k_hw_systick.c:341
##@@@L0336_:void Systick_Hw_Cmp1DelayMs(uint32_t MsTime)   
##@@@L0337_:{   
##@@@L0338_:#ifdef SIMULATION   
##@@@L0339_:    float freq = 20000000.;   
##@@@L0340_:#else   
##@@@L0341_:    float freq = Clk_Hw_GetSysClkFrequency();   
8000bd74:	20 45       	LD        R5, [PC + #32]        ;->0x8000bdf4  :=0x8000a68c
8000bd76:	05 5c       	LJMP      R5
8000bd78:	20 45       	LD        R5, [PC + #32]        ;->0x8000bdf8  :=0x800011f4
8000bd7a:	24 00 a1 00 	FLD.W           S1, 	[R5 +#0  ]
8000bd7e:	29 00 00 40 	FMUL.F32        S0 , 	S0 , 	S16
##@@@P_:kf32a13k_hw_systick.c:343
##@@@L0342_:#endif   
##@@@L0343_:    uint32_t ticks = (uint32_t)((float)MsTime * freq / 1000.F);   
8000bd82:	ea 00 00 84 	FDIV.F32        S0 , 	S0 , 	S1 
8000bd86:	1f 00 00 54 	FCVTR.U32.F32  S0 ,	S0
8000bd8a:	1f 00 04 20 	FMOV            R4 ,	S0
##@@@P_:kf32a13k_hw_systick.c:344
##@@@L0344_:    if (ticks > 0)   
8000bd8e:	40 38       	CMP       R4, #0			;->0x00
8000bd90:	2c f0       	JZ        $+44                  ;->0x8000bde8
8000bd92:	1b 43       	LD        R3, [PC + #27]        ;->0x8000bdfc  :=0xf0000148
##@@@F_:Systick_LL_SetCompareControl():
8000bd94:	53 82       	LD.W      R5, [R3]
8000bd96:	1b 42       	LD        R2, [PC + #27]        ;->0x8000be00  :=0x1f0000
8000bd98:	52 6a       	ORL       R5, R2
8000bd9a:	35 85       	ST.W      [R3], R5
8000bd9c:	23 82       	LD.W      R2, [R3]
8000bd9e:	1a 45       	LD        R5, [PC + #26]        ;->0x8000be04  :=0xe0ffffff
8000bda0:	1a 41       	LD        R1, [PC + #26]        ;->0x8000be08  :=0x1000000
8000bda2:	25 69       	ANL       R2, R5
8000bda4:	21 6a       	ORL       R2, R1
8000bda6:	1a 45       	LD        R5, [PC + #26]        ;->0x8000be0c  :=0xf000014c
8000bda8:	32 85       	ST.W      [R3], R2
8000bdaa:	35 82       	LD.W      R3, [R5]
8000bdac:	20 14       	MOV       R2, #64			;->0x0040
8000bdae:	32 6a       	ORL       R3, R2
8000bdb0:	53 85       	ST.W      [R5], R3
8000bdb2:	18 43       	LD        R3, [PC + #24]        ;->0x8000be10  :=0xf0000120
8000bdb4:	18 42       	LD        R2, [PC + #24]        ;->0x8000be14  :=0xf000013c
##@@@F_:Systick_LL_GetTimer():
##@@@P_:kf32a13k_drv_systick.h:505
##@@@L0500_:KF_INLINE uint64_t Systick_LL_GetTimer(Systick_RegisterMap_t *const Module)   
##@@@L0501_:{   
##@@@L0502_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0503_:    uint64_t result;   
##@@@L0504_:    uint32_t Reg_Cap;   
##@@@L0505_:    result  = REG_READ(Module->SYSTICK_TIM0.reg);   
8000bdb6:	33 82       	LD.W      R3, [R3]
##@@@P_:kf32a13k_drv_systick.h:507
##@@@L0506_:    Reg_Cap = REG_READ(Module->SYSTICK_CAP.reg);   
##@@@L0507_:    result |= ((uint64_t)Reg_Cap) << 32U;   
8000bdb8:	22 82       	LD.W      R2, [R2]
##@@@F_:Systick_Hw_InitCompare():
##@@@P_:kf32a13k_hw_systick.c:197
##@@@L0192_:        uint32_t offsetTimer = 0;   
##@@@L0193_:        Systick_LL_SetCompareControl(   
##@@@L0194_:          Module, (Systick_Comparator_t)Config->Comparator, (Systick_ComparatorOffset_t)Config->ComparatorOffset,   
##@@@L0195_:          (Systick_ComparatorSize_t)Config->ComparatorSize, (Systick_ComparatorInterrupt_t)Config->ComparatorInterrupt);   
##@@@L0196_:        /* 配置比较器Ticks */   
##@@@L0197_:        offsetTimer = (uint32_t)(Systick_LL_GetTimer(Module) >> Config->ComparatorOffset);   
8000bdba:	19 7c       	LSR       R3, #1			;->0x01
8000bdbc:	97 7b       	LSL       R2, #31			;->0x1F
8000bdbe:	32 6a       	ORL       R3, R2
##@@@P_:kf32a13k_hw_systick.c:198
##@@@L0198_:        Systick_LL_UpdateCompare(Module, (Systick_Comparator_t)Config->Comparator, offsetTimer + Config->Ticks);   
8000bdc0:	1b c3       	ADD       R3, R3, R4
8000bdc2:	16 42       	LD        R2, [PC + #22]        ;->0x8000be18  :=0xf0000144
8000bdc4:	16 44       	LD        R4, [PC + #22]        ;->0x8000be1c  :=0xf0000150
##@@@F_:Systick_LL_UpdateCompare():
##@@@P_:kf32a13k_drv_systick.h:576
##@@@L0571_:KF_INLINE void Systick_LL_UpdateCompare(   
##@@@L0572_:  Systick_RegisterMap_t *const Module, const Systick_Comparator_t Comparator, const uint32_t Ticks)   
##@@@L0573_:{   
##@@@L0574_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0575_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0576_:    REG_WRITE((Module->SYSTICK_CMP)[Comparator].bits.CMPVAL, Ticks);   
8000bdc6:	23 85       	ST.W      [R2], R3
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bdc8:	24 82       	LD.W      R2, [R4]
8000bdca:	34 10       	MOV       R3, #4			;->0x0004
8000bdcc:	23 6a       	ORL       R2, R3
8000bdce:	42 85       	ST.W      [R4], R2
8000bdd0:	14 42       	LD        R2, [PC + #20]        ;->0x8000be20  :=0xffffffef
##@@@F_:Systick_LL_SetIntrEnabled():
##@@@P_:kf32a13k_drv_systick.h:700
##@@@L0695_:KF_INLINE void Systick_LL_SetIntrEnabled(   
##@@@L0696_:  Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask, const bool Status)   
##@@@L0697_:{   
##@@@L0698_:
##@@@L0699_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0700_:    REG_BITS_WRITE(   
8000bdd2:	15 82       	LD.W      R1, [R5]
8000bdd4:	12 69       	ANL       R1, R2
8000bdd6:	51 85       	ST.W      [R5], R1
8000bdd8:	20 12       	MOV       R2, #32			;->0x0020
##@@@F_:Systick_LL_GetIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:678
##@@@L0673_: * @attention 这个标志位不会产生中断，在CMPxIE使能的情况下，即使该标志位没有清零，中断也只能由比较匹配事件产生   
##@@@L0674_: */   
##@@@L0675_:KF_INLINE bool Systick_LL_GetIntrFlag(Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask)   
##@@@L0676_:{   
##@@@L0677_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0678_:    return (bool)(REG_BITS_READ(   
8000bdda:	15 82       	LD.W      R1, [R5]
8000bddc:	12 69       	ANL       R1, R2
##@@@F_:Systick_Hw_Cmp1DelayMs():
##@@@P_:kf32a13k_hw_systick.c:355
##@@@L0350_:          .ComparatorSize      = SYSTICK_HW_COMPARATOR_SIZE_32BITS,   
##@@@L0351_:          .Ticks               = ticks,   
##@@@L0352_:          .EnableInterrupt     = false,   
##@@@L0353_:        };   
##@@@L0354_:        Systick_Hw_InitCompare(SYSTICK0_PTR, &Config);   
##@@@L0355_:        while (!Systick_LL_GetIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_CMP1))   
8000bdde:	10 38       	CMP       R1, #0			;->0x00
8000bde0:	fd f0       	JZ        $-3                   ;->0x8000bdda
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000bde2:	54 82       	LD.W      R5, [R4]
8000bde4:	53 6a       	ORL       R5, R3
8000bde6:	45 85       	ST.W      [R4], R5
##@@@F_:Systick_Hw_Cmp1DelayMs():
##@@@P_:kf32a13k_hw_systick.c:363
##@@@L0358_:        Systick_LL_ClearIntrFlag(SYSTICK0_PTR, SYSTICK_INTR_INDEX_CMP1);   
##@@@L0359_:    }   
##@@@L0360_:    else   
##@@@L0361_:    {   
##@@@L0362_:    }   
##@@@L0363_:}   
8000bde8:	e8 28       	ADD       SP, #8			;->0x08
8000bdea:	ea 00 70 60 	FPOP.W          S16, 	{S16-S17}
8000bdee:	0d 5d       	POP       LR
8000bdf0:	1d 5c       	JMP       LR
8000bdf2:	00 00       	NOP      NOP      
8000bdf4:	8c a6 00 80 	.long     0x8000a68c ->-2147441012  [!!!@2@:ST.W      [R1 + #26], R4	@@: LD.B      R0, [R0]
8000bdf8:	f4 11 00 80 	.long     0x800011f4 ->-2147479052  [!!!@2@:MOV       PC, #20	@@: LD.B      R0, [R0]
8000bdfc:	48 01 00 f0 	.long     0xf0000148 ->-268435128  [!!!@2@:CMN       R4, R8	@@: JZ        $+0                   ;->0x8000bdfc
8000be00:	00 00 1f 00 	.long     0x001f0000 ->002031616  [!!!@2@:NOP      	@@: FST.W           [R31++], S0
8000be04:	ff ff ff e0 	.long     0xe0ffffff ->-520093697 
8000be08:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
8000be0c:	4c 01 00 f0 	.long     0xf000014c ->-268435124  [!!!@2@:CMN       R4, R12	@@: JZ        $+0                   ;->0x8000be0c
8000be10:	20 01 00 f0 	.long     0xf0000120 ->-268435168  [!!!@2@:CMN       R2, R0	@@: JZ        $+0                   ;->0x8000be10
8000be14:	3c 01 00 f0 	.long     0xf000013c ->-268435140  [!!!@2@:CMN       R3, R12	@@: JZ        $+0                   ;->0x8000be14
8000be18:	44 01 00 f0 	.long     0xf0000144 ->-268435132  [!!!@2@:CMN       R4, R4	@@: JZ        $+0                   ;->0x8000be18
8000be1c:	50 01 00 f0 	.long     0xf0000150 ->-268435120  [!!!@2@:CMN       R5, R0	@@: JZ        $+0                   ;->0x8000be1c
8000be20:	ef ff ff ff 	.long     0xffffffef ->-00000017 

8000be24 <Systick_Hw_InitOverflow>:
##@@@F_:Systick_Hw_InitOverflow():
##@@@P_:kf32a13k_hw_systick.c:372
##@@@L0367_: *   
##@@@L0368_: * @param Config   
##@@@L0369_: */   
##@@@L0370_:void Systick_Hw_InitOverflow(Systick_RegisterMap_t *const Module, const Systick_OverflowConfig_t *Config)   
##@@@L0371_:{   
##@@@L0372_:    Systick_LL_SetTimerHighOverflowValue(Module, Config->OVH);   
8000be24:	69 98       	LD.W      R5, [R1 + #1]
##@@@F_:Systick_LL_SetTimerHighOverflowValue():
##@@@P_:kf32a13k_drv_systick.h:820
##@@@L0815_: * @retval void   
##@@@L0816_: */   
##@@@L0817_:KF_INLINE void Systick_LL_SetTimerHighOverflowValue(Systick_RegisterMap_t *const Module, const uint32_t Value)   
##@@@L0818_:{   
##@@@L0819_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0820_:    REG_WRITE(Module->SYSTICK_OVH.bits.OVERFLOWVAL_H, Value);   
8000be26:	c5 a5       	ST.W      [R0 + #23], R5
##@@@F_:Systick_Hw_InitOverflow():
##@@@P_:kf32a13k_hw_systick.c:373
##@@@L0373_:    Systick_LL_SetTimerLowOverflowValue(Module, Config->OVL);   
8000be28:	a9 98       	LD.W      R5, [R1 + #2]
##@@@F_:Systick_LL_SetTimerLowOverflowValue():
##@@@P_:kf32a13k_drv_systick.h:834
##@@@L0829_: * @retval void   
##@@@L0830_: */   
##@@@L0831_:KF_INLINE void Systick_LL_SetTimerLowOverflowValue(Systick_RegisterMap_t *const Module, const uint32_t Value)   
##@@@L0832_:{   
##@@@L0833_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0834_:    REG_WRITE(Module->SYSTICK_OVL.bits.OVERFLOWVAL_L, Value);   
8000be2a:	05 a6       	ST.W      [R0 + #24], R5
##@@@F_:Systick_LL_ClearIntrFlag():
##@@@P_:kf32a13k_drv_systick.h:724
##@@@L0719_:{   
##@@@L0720_:    uint32_t Mask;   
##@@@L0721_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0722_:
##@@@L0723_:    Mask = (uint32_t)0x1U << ((uint32_t)IntrMask << 1U);   
##@@@L0724_:    REG_BIT_SET(Module->SYSTICK_ISCR.reg, Mask);   
8000be2c:	28 9d       	LD.W      R5, [R0 + #20]
8000be2e:	40 11       	MOV       R4, #16			;->0x0010
8000be30:	54 6a       	ORL       R5, R4
8000be32:	05 a5       	ST.W      [R0 + #20], R5
8000be34:	0b 45       	LD        R5, [PC + #11]        ;->0x8000be60  :=0xfffffeff
##@@@F_:Systick_Hw_InitOverflow():
##@@@P_:kf32a13k_hw_systick.c:375
##@@@L0374_:    Systick_LL_ClearIntrFlag(Module, SYSTICK_INTR_INDEX_OVERFLOW);   
##@@@L0375_:    Systick_LL_SetIntrEnabled(Module, SYSTICK_INTR_OVERFLOW, Config->OverflowIntrEnable);   
8000be36:	61 88       	LD.B      R4, [R1 + #1]
##@@@F_:Systick_LL_SetIntrEnabled():
##@@@P_:kf32a13k_drv_systick.h:700
##@@@L0695_:KF_INLINE void Systick_LL_SetIntrEnabled(   
##@@@L0696_:  Systick_RegisterMap_t *const Module, const Systick_IntrEnableFlagMask_t IntrMask, const bool Status)   
##@@@L0697_:{   
##@@@L0698_:
##@@@L0699_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0700_:    REG_BITS_WRITE(   
8000be38:	d8 9c       	LD.W      R3, [R0 + #19]
8000be3a:	35 69       	ANL       R3, R5
8000be3c:	a0 7a       	LSL       R4, #8			;->0x08
8000be3e:	34 6a       	ORL       R3, R4
8000be40:	c3 a4       	ST.W      [R0 + #19], R3
##@@@F_:Systick_Hw_InitOverflow():
##@@@P_:kf32a13k_hw_systick.c:376
##@@@L0376_:    Systick_LL_EnableTimerOverload(Module, Config->OverflowEnable);   
8000be42:	31 80       	LD.B      R3, [R1]
8000be44:	08 44       	LD        R4, [PC + #8]         ;->0x8000be64  :=0x80000000
##@@@F_:Systick_LL_EnableTimerOverload():
##@@@P_:kf32a13k_drv_systick.h:659
##@@@L0654_:KF_INLINE void Systick_LL_EnableTimerOverload(Systick_RegisterMap_t *const Module, const bool Status)   
##@@@L0655_:{   
##@@@L0656_:
##@@@L0657_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0658_:
##@@@L0659_:    REG_BIT_SET(Module->SYSTICK_ICR.bits.OVERFLOWMOD, Status);   
8000be46:	e8 9c       	LD.W      R5, [R0 + #19]
8000be48:	30 38       	CMP       R3, #0			;->0x00
8000be4a:	03 f0       	JZ        $+3                   ;->0x8000be50
8000be4c:	a4 58       	MOV       R5, R4
8000be4e:	02 04       	SJMP      $+2                   ;->0x8000be52
8000be50:	54 69       	ANL       R5, R4
8000be52:	06 44       	LD        R4, [PC + #6]         ;->0x8000be68  :=0x7fffffff
8000be54:	d8 9c       	LD.W      R3, [R0 + #19]
8000be56:	34 69       	ANL       R3, R4
8000be58:	35 6a       	ORL       R3, R5
8000be5a:	c3 a4       	ST.W      [R0 + #19], R3
##@@@F_:Systick_Hw_InitOverflow():
##@@@P_:kf32a13k_hw_systick.c:377
##@@@L0377_:}   
8000be5c:	1d 5c       	JMP       LR
8000be5e:	00 00       	NOP      NOP      
8000be60:	ff fe ff ff 	.long     0xfffffeff ->-00000257 
8000be64:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
8000be68:	ff ff ff 7f 	.long     0x7fffffff ->2147483647 

8000be6c <Systick_Hw_IntrRequestNodeInit>:
##@@@F_:Systick_Hw_IntrRequestNodeInit():
##@@@P_:kf32a13k_hw_systick.c:393
##@@@L0388_: * @return   
##@@@L0389_: */   
##@@@L0390_:bool Systick_Hw_IntrRequestNodeInit(   
##@@@L0391_:  Systick_RegisterMap_t *const Module, const uint32_t Priority, const Int_SourceType_t TypeOfService,   
##@@@L0392_:  const Systick_Hw_ServiceInterruptLineType Line, const bool EnableState)   
##@@@L0393_:{   
8000be6c:	26 5d       	PUSH      R6
8000be6e:	e8 30       	SUB       SP, #8			;->0x08
##@@@P_:kf32a13k_hw_systick.c:399
##@@@L0394_:    bool                      ret = true;   
##@@@L0395_:    volatile Intr_IrqEnumType ServiceRequestNodeIndex;   
##@@@L0396_:#ifdef SIMULATION   
##@@@L0397_:    switch ((uint64_t)Module)   
##@@@L0398_:#else   
##@@@L0399_:    switch ((uint32_t)Module)   
8000be70:	2c 45       	LD        R5, [PC + #44]        ;->0x8000bf20  :=0xf0000200
8000be72:	05 70       	CMP       R0, R5
8000be74:	06 f0       	JZ        $+6                   ;->0x8000be80
8000be76:	2c 45       	LD        R5, [PC + #44]        ;->0x8000bf24  :=0xf0000100
8000be78:	05 70       	CMP       R0, R5
8000be7a:	4f f1       	JNZ       $+79                  ;->0x8000bf18
8000be7c:	51 1b       	MOV       R5, #177			;->0x00B1
8000be7e:	02 04       	SJMP      $+2                   ;->0x8000be82
8000be80:	54 1b       	MOV       R5, #180			;->0x00B4
8000be82:	6b c3       	ADD       R5, R3, R5
8000be84:	01 25       	ST.W      [SP + #1], R5
8000be86:	29 45       	LD        R5, [PC + #41]        ;->0x8000bf28  :=0xf0030000
8000be88:	29 44       	LD        R4, [PC + #41]        ;->0x8000bf2c  :=0x400
##@@@P_:kf32a13k_hw_systick.c:418
##@@@L0413_:    {   
##@@@L0414_:        /*TODO: 超时判断 */   
##@@@L0415_:        do   
##@@@L0416_:        {   
##@@@L0417_:            // Int_LL_EnableServiceRequest(ServiceRequestNodeIndex, false);   
##@@@L0418_:            __asm__ volatile("PUSH R0");   
8000be8a:	20 5d       	PUSH      R0
8000be8c:	20 5c c4 02 	MOVL      R0, #708			;->0x02C4
8000be90:	40 5c 03 f0 	MOVH      R0, #61443			;->0xF003
##@@@P_:kf32a13k_hw_systick.c:420
##@@@L0419_:            __asm__ volatile("MOV R0,#0xF00302C4");   
##@@@L0420_:            __asm__ volatile("CLR [R0], #10");   
8000be94:	82 4e       	CLR       [R0], #10			;->0x0A
##@@@P_:kf32a13k_hw_systick.c:421
##@@@L0421_:            __asm__ volatile("POP R0");   
8000be96:	00 5d       	POP       R0
8000be98:	26 43       	LD        R3, [PC + #38]        ;->0x8000bf30  :=0x4
8000be9a:	3e 64       	ADD       R3, SP
##@@@F_:Int_LL_GetServiceRequest():
##@@@P_:kf32a13k_drv_int.h:741
##@@@L0736_: */   
##@@@L0737_:KF_INLINE bool Int_LL_GetServiceRequest(const Intr_IrqEnumType IntIndex)   
##@@@L0738_:{   
##@@@L0739_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0740_:    KF_DRV_INT_ASSERT(CHECK_INT_BOOL(Status));   
##@@@L0741_:    return (REG_READ(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIE));   
8000be9c:	9b ba       	LDP.W     R3, [R3] << #2
8000be9e:	5b e9       	LD.W      R3, [R3 + R5]
8000bea0:	34 69       	ANL       R3, R4
##@@@F_:Systick_Hw_IntrRequestNodeInit():
##@@@P_:kf32a13k_hw_systick.c:422
##@@@L0422_:        } while (Int_LL_GetServiceRequest(ServiceRequestNodeIndex));   
8000bea2:	30 38       	CMP       R3, #0			;->0x00
8000bea4:	f3 f1       	JNZ       $-13                  ;->0x8000be8a
8000bea6:	24 44       	LD        R4, [PC + #36]        ;->0x8000bf34  :=0x2000000
8000bea8:	24 43       	LD        R3, [PC + #36]        ;->0x8000bf38  :=0x1000000
8000beaa:	22 41       	LD        R1, [PC + #34]        ;->0x8000bf30  :=0x4
8000beac:	1e 64       	ADD       R1, SP
##@@@F_:Int_LL_ClearIntRequestState():
##@@@P_:kf32a13k_drv_int.h:632
##@@@L0627_: */   
##@@@L0628_:KF_INLINE void Int_LL_ClearIntRequestState(const Intr_IrqEnumType IntIndex, const bool Status)   
##@@@L0629_:{   
##@@@L0630_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0631_:    KF_DRV_INT_ASSERT(CHECK_INT_BOOL(Status));   
##@@@L0632_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIC, Status);   
8000beae:	81 ba       	LDP.W     R0, [R1] << #2
8000beb0:	70 e9       	LD.W      R6, [R0 + R5]
8000beb2:	64 6a       	ORL       R6, R4
8000beb4:	46 ef       	ST.W      [R0 + R5], R6
##@@@F_:Int_LL_GetIntRequestState():
##@@@P_:kf32a13k_drv_int.h:647
##@@@L0642_: *          false:无服务请求等待处理   
##@@@L0643_: */   
##@@@L0644_:KF_INLINE bool Int_LL_GetIntRequestState(const Intr_IrqEnumType IntIndex)   
##@@@L0645_:{   
##@@@L0646_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0647_:    return (REG_READ(INT_PTR->INT_SRC.SRC[IntIndex].bits.SRIF));   
8000beb6:	89 ba       	LDP.W     R1, [R1] << #2
8000beb8:	49 e9       	LD.W      R1, [R1 + R5]
8000beba:	13 69       	ANL       R1, R3
##@@@F_:Systick_Hw_IntrRequestNodeInit():
##@@@P_:kf32a13k_hw_systick.c:427
##@@@L0423_:        /*TODO: 超时判断 */   
##@@@L0424_:        do   
##@@@L0425_:        {   
##@@@L0426_:            Int_LL_ClearIntRequestState(ServiceRequestNodeIndex, true);   
##@@@L0427_:        } while (Int_LL_GetIntRequestState(ServiceRequestNodeIndex));   
8000bebc:	10 38       	CMP       R1, #0			;->0x00
8000bebe:	f6 f1       	JNZ       $-10                  ;->0x8000beaa
8000bec0:	1c 44       	LD        R4, [PC + #28]        ;->0x8000bf30  :=0x4
8000bec2:	4e 64       	ADD       R4, SP
##@@@F_:Int_LL_SetServiceType():
##@@@P_:kf32a13k_drv_int.h:693
##@@@L0688_: */   
##@@@L0689_:KF_INLINE void Int_LL_SetServiceType(const Intr_IrqEnumType IntIndex, const Int_SourceType_t ServiceType)   
##@@@L0690_:{   
##@@@L0691_:    KF_DRV_INT_ASSERT((IntIndex >> POS_9_SHIFT) == 0U);   
##@@@L0692_:    KF_DRV_INT_ASSERT(CHECK_INT_SERVICE(ServiceType));   
##@@@L0693_:    REG_WRITE(INT_PTR->INT_SRC.SRC[IntIndex].bits.TOS, ServiceType);   
8000bec4:	93 7a       	LSL       R2, #11			;->0x0B
8000bec6:	a4 ba       	LDP.W     R4, [R4] << #2
8000bec8:	1d 43       	LD        R3, [PC + #29]        ;->0x8000bf3c  :=0x3800
8000beca:	4c e9       	LD.W      R1, [R4 + R5]
8000becc:	1d 40       	LD        R0, [PC + #29]        ;->0x8000bf40  :=0xffffc7ff
8000bece:	23 69       	ANL       R2, R3
8000bed0:	10 69       	ANL       R1, R0
8000bed2:	12 6a       	ORL       R1, R2
8000bed4:	61 ef       	ST.W      [R4 + R5], R1
8000bed6:	01 10       	MOV       R0, #1			;->0x0001
##@@@F_:Systick_Hw_IntrRequestNodeInit():
##@@@P_:kf32a13k_hw_systick.c:431
##@@@L0428_:        Int_LL_SetServiceType(ServiceRequestNodeIndex, TypeOfService);   
##@@@L0429_:        // Int_LL_SetServiceRequestPriority(ServiceRequestNodeIndex, Priority);   
##@@@L0430_:        // Int_LL_EnableServiceRequest(ServiceRequestNodeIndex, EnableState);   
##@@@L0431_:        __asm__ volatile("PUSH R0");   
8000bed8:	20 5d       	PUSH      R0
##@@@P_:kf32a13k_hw_systick.c:432
##@@@L0432_:        __asm__ volatile("PUSH R1");   
8000beda:	21 5d       	PUSH      R1
##@@@P_:kf32a13k_hw_systick.c:433
##@@@L0433_:        __asm__ volatile("PUSH R2");   
8000bedc:	22 5d       	PUSH      R2
##@@@P_:kf32a13k_hw_systick.c:434
##@@@L0434_:        __asm__ volatile("PUSH R3");   
8000bede:	23 5d       	PUSH      R3
8000bee0:	20 5c c4 02 	MOVL      R0, #708			;->0x02C4
8000bee4:	40 5c 03 f0 	MOVH      R0, #61443			;->0xF003
##@@@P_:kf32a13k_hw_systick.c:435
##@@@L0435_:        __asm__ volatile("MOV R0,#0xF00302C4");   
8000bee8:	22 5c 00 fe 	MOVL      R2, #65024			;->0xFE00
8000beec:	42 5c ff ff 	MOVH      R2, #65535			;->0xFFFF
##@@@P_:kf32a13k_hw_systick.c:437
##@@@L0436_:        __asm__ volatile("MOV R2,#0xfffffe00");   
##@@@L0437_:        __asm__ volatile("LD.W R3, [R0]");   
8000bef0:	30 82       	LD.W      R3, [R0]
##@@@P_:kf32a13k_hw_systick.c:438
##@@@L0438_:        __asm__ volatile("ANL R3, R2");   
8000bef2:	32 69       	ANL       R3, R2
8000bef4:	22 5c ff 01 	MOVL      R2, #511			;->0x01FF
##@@@P_:kf32a13k_hw_systick.c:440
##@@@L0439_:        __asm__ volatile("MOV R2,#0x1FF");   
##@@@L0440_:        __asm__ volatile("MOV R1, #1");   
8000bef8:	11 10       	MOV       R1, #1			;->0x0001
##@@@P_:kf32a13k_hw_systick.c:441
##@@@L0441_:        __asm__ volatile("ANL R1, R2");   
8000befa:	12 69       	ANL       R1, R2
##@@@P_:kf32a13k_hw_systick.c:442
##@@@L0442_:        __asm__ volatile("ORL R3, R1");   
8000befc:	31 6a       	ORL       R3, R1
##@@@P_:kf32a13k_hw_systick.c:443
##@@@L0443_:        __asm__ volatile("ST.W [R0], R3");   
8000befe:	03 85       	ST.W      [R0], R3
##@@@P_:kf32a13k_hw_systick.c:444
##@@@L0444_:        __asm__ volatile("POP R3");   
8000bf00:	03 5d       	POP       R3
##@@@P_:kf32a13k_hw_systick.c:445
##@@@L0445_:        __asm__ volatile("POP R2");   
8000bf02:	02 5d       	POP       R2
##@@@P_:kf32a13k_hw_systick.c:446
##@@@L0446_:        __asm__ volatile("POP R1");   
8000bf04:	01 5d       	POP       R1
##@@@P_:kf32a13k_hw_systick.c:447
##@@@L0447_:        __asm__ volatile("POP R0");   
8000bf06:	00 5d       	POP       R0
##@@@P_:kf32a13k_hw_systick.c:449
##@@@L0448_:
##@@@L0449_:        __asm__ volatile("PUSH R0");   
8000bf08:	20 5d       	PUSH      R0
8000bf0a:	20 5c c4 02 	MOVL      R0, #708			;->0x02C4
8000bf0e:	40 5c 03 f0 	MOVH      R0, #61443			;->0xF003
##@@@P_:kf32a13k_hw_systick.c:451
##@@@L0450_:        __asm__ volatile("MOV R0,#0xF00302C4");   
##@@@L0451_:        __asm__ volatile("SET [R0], #10");   
8000bf12:	82 4c       	SET       [R0], #10			;->0x0A
##@@@P_:kf32a13k_hw_systick.c:452
##@@@L0452_:        __asm__ volatile("POP R0");   
8000bf14:	00 5d       	POP       R0
8000bf16:	02 04       	SJMP      $+2                   ;->0x8000bf1a
8000bf18:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_hw_systick.c:457
##@@@L0453_:    }   
##@@@L0454_:    else   
##@@@L0455_:    {   
##@@@L0456_:    }   
##@@@L0457_:    return ret;   
8000bf1a:	e8 28       	ADD       SP, #8			;->0x08
8000bf1c:	06 5d       	POP       R6
8000bf1e:	1d 5c       	JMP       LR
8000bf20:	00 02 00 f0 	.long     0xf0000200 ->-268434944 
8000bf24:	00 01 00 f0 	.long     0xf0000100 ->-268435200  [!!!@2@:CMN       R0, R0	@@: JZ        $+0                   ;->0x8000bf24
8000bf28:	00 00 03 f0 	.long     0xf0030000 ->-268238848  [!!!@2@:NOP      	@@: JZ        $+3                   ;->0x8000bf2e
8000bf2c:	00 04 00 00 	.long     0x00000400 ->000001024  [!!!@2@:SJMP      $+0                   ;->0x8000bf2c	@@: NOP      
8000bf30:	04 00 00 00 	.long     0x00000004 ->000000004 
8000bf34:	00 00 00 02 	.long     0x02000000 ->033554432 
8000bf38:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
8000bf3c:	00 38 00 00 	.long     0x00003800 ->000014336  [!!!@2@:CMP       R0, #0	@@: NOP      
8000bf40:	ff c7 ff ff 	.long     0xffffc7ff ->-00014337 

8000bf44 <Systick_Hw_UpdateCompare>:
##@@@F_:Systick_LL_UpdateCompare():
##@@@P_:kf32a13k_drv_systick.h:576
##@@@L0571_:KF_INLINE void Systick_LL_UpdateCompare(   
##@@@L0572_:  Systick_RegisterMap_t *const Module, const Systick_Comparator_t Comparator, const uint32_t Ticks)   
##@@@L0573_:{   
##@@@L0574_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_MODULE(Module));   
##@@@L0575_:    KF_DRV_SYSTICK_ASSERT(CHECK_SYSTICK_COMPARATOR(Comparator));   
##@@@L0576_:    REG_WRITE((Module->SYSTICK_CMP)[Comparator].bits.CMPVAL, Ticks);   
8000bf44:	0a 7a       	LSL       R1, #2			;->0x02
8000bf46:	68 c2       	ADD       R5, R0, R1
8000bf48:	2a a4       	ST.W      [R5 + #16], R2
##@@@F_:Systick_Hw_UpdateCompare():
##@@@P_:kf32a13k_hw_systick.c:463
##@@@L0458_:}   
##@@@L0459_:
##@@@L0460_:void Systick_Hw_UpdateCompare(Systick_RegisterMap_t *const Module, Systick_Hw_Comparator_t Comparator, uint32_t Ticks)   
##@@@L0461_:{   
##@@@L0462_:    Systick_LL_UpdateCompare(Module, (Systick_Comparator_t)Comparator, Ticks);   
##@@@L0463_:}   
8000bf4a:	1d 5c       	JMP       LR

8000bf4c <Adcs_LL_SetSyncConvertMaster>:
##@@@F_:Adcs_LL_SetSyncConvertMaster():
##@@@P_:kf32a13k_drv_adcs.c:86
##@@@L0081_: * @param MasterModule   
##@@@L0082_: */   
##@@@L0083_:void Adcs_LL_SetSyncConvertMaster(const Adcs_Module_t CurrentModule, const Adcs_Module_t MasterModule)   
##@@@L0084_:{   
##@@@L0085_:    Adcs_LL_SetSyncConvertMasterIndex(   
##@@@L0086_:      CurrentModule, Adcs_SyncConvertMasterIndex[(uint32_t)CurrentModule][(uint32_t)MasterModule]);   
8000bf4c:	a0 58       	MOV       R5, R0
8000bf4e:	0d 44       	LD        R4, [PC + #13]        ;->0x8000bf80  :=0xd0000000
8000bf50:	2c 7a       	LSL       R5, #4			;->0x04
8000bf52:	6c c3       	ADD       R5, R4, R5
8000bf54:	0a 7a       	LSL       R1, #2			;->0x02
8000bf56:	6d e8       	LD.W      R5, [R5 + R1]
##@@@F_:Adcs_LL_SetSyncConvertMasterIndex():
##@@@P_:kf32a13k_drv_adcs.h:2444
##@@@L2439_:KF_INLINE void   
##@@@L2440_:Adcs_LL_SetSyncConvertMasterIndex(const Adcs_Module_t AdcModule, const Adcs_SyncMasterIndex_t MasterIndex)   
##@@@L2441_:{   
##@@@L2442_:    KF_DRV_ADCS_ASSERT(CHECK_ADC_MODULE(AdcModule));   
##@@@L2443_:    KF_DRV_ADCS_ASSERT(CHECK_ADC_SYNC_MASTER_INDEX(MasterIndex));   
##@@@L2444_:    REG_WRITE(ADCS_PTR->ADCS_SYNCTL[AdcModule].bits.STSEL, MasterIndex);   
8000bf58:	0b 44       	LD        R4, [PC + #11]        ;->0x8000bf84  :=0xf00034e0
8000bf5a:	02 7a       	LSL       R0, #2			;->0x02
8000bf5c:	18 e9       	LD.W      R3, [R0 + R4]
8000bf5e:	0b 42       	LD        R2, [PC + #11]        ;->0x8000bf88  :=0xfffffffc
8000bf60:	32 69       	ANL       R3, R2
8000bf62:	23 10       	MOV       R2, #3			;->0x0003
8000bf64:	25 58       	MOV       R1, R5
8000bf66:	12 69       	ANL       R1, R2
8000bf68:	31 6a       	ORL       R3, R1
##@@@P_:kf32a13k_drv_adcs.h:2445
##@@@L2445_:    if (MasterIndex != ADCS_SYNC_MASTER_SELF)   
8000bf6a:	50 38       	CMP       R5, #0			;->0x00
##@@@P_:kf32a13k_drv_adcs.h:2444
##@@@L2439_:KF_INLINE void   
##@@@L2440_:Adcs_LL_SetSyncConvertMasterIndex(const Adcs_Module_t AdcModule, const Adcs_SyncMasterIndex_t MasterIndex)   
##@@@L2441_:{   
##@@@L2442_:    KF_DRV_ADCS_ASSERT(CHECK_ADC_MODULE(AdcModule));   
##@@@L2443_:    KF_DRV_ADCS_ASSERT(CHECK_ADC_SYNC_MASTER_INDEX(MasterIndex));   
##@@@L2444_:    REG_WRITE(ADCS_PTR->ADCS_SYNCTL[AdcModule].bits.STSEL, MasterIndex);   
8000bf6c:	03 ef       	ST.W      [R0 + R4], R3
##@@@P_:kf32a13k_drv_adcs.h:2445
##@@@L2445_:    if (MasterIndex != ADCS_SYNC_MASTER_SELF)   
8000bf6e:	07 f0       	JZ        $+7                   ;->0x8000bf7c
8000bf70:	20 c3       	ADD       R4, R0, R4
8000bf72:	38 10       	MOV       R3, #8			;->0x0008
##@@@P_:kf32a13k_drv_adcs.h:2447
##@@@L2446_:    {   
##@@@L2447_:        REG_BIT_SET(ADCS_PTR->ADCS_SYNCTL[AdcModule].reg, (0x00000008U << MasterIndex));   
8000bf74:	24 82       	LD.W      R2, [R4]
8000bf76:	35 6c       	LSL       R3, R5
8000bf78:	23 6a       	ORL       R2, R3
8000bf7a:	42 85       	ST.W      [R4], R2
##@@@F_:Adcs_LL_SetSyncConvertMaster():
##@@@P_:kf32a13k_drv_adcs.c:87
##@@@L0087_:}   
8000bf7c:	1d 5c       	JMP       LR
8000bf7e:	00 00       	NOP      NOP      
8000bf80:	00 00 00 d0 	.long     0xd0000000 ->-805306368  [!!!@2@:NOP      	@@: ZXT.H     R0, R0
8000bf84:	e0 34 00 f0 	.long     0xf00034e0 ->-268421920  [!!!@2@:SUB       SP, #64	@@: JZ        $+0                   ;->0x8000bf84
8000bf88:	fc ff ff ff 	.long     0xfffffffc ->-00000004 

8000bf8c <Canfd_LL_GetMaliboxNumber>:
##@@@F_:Canfd_LL_GetMaliboxNumber():
##@@@P_:kf32a13k_drv_canfd.c:158
##@@@L0153_: * @brief get max mailbox number from payload configuration   
##@@@L0154_: * @param PayloadSize   
##@@@L0155_: * @retval void   
##@@@L0156_: */   
##@@@L0157_:uint8_t Canfd_LL_GetMaliboxNumber(const Canfd_PayloadSize_t PayloadSize)   
##@@@L0158_:{   
8000bf8c:	5f 1f       	MOV       R5, #255			;->0x00FF
##@@@P_:kf32a13k_drv_canfd.c:159
##@@@L0159_:    return (kvCanfd_MaxPayLoad[(uint8_t)PayloadSize]);   
8000bf8e:	03 44       	LD        R4, [PC + #3]         ;->0x8000bf98  :=0x8000120c
8000bf90:	05 69       	ANL       R0, R5
8000bf92:	04 e4       	LD.B      R0, [R4 + R0]
8000bf94:	1d 5c       	JMP       LR
8000bf96:	00 00       	NOP      NOP      
8000bf98:	0c 12 00 80 	.long     0x8000120c ->-2147479028  [!!!@2@:MOV       R0, #44	@@: LD.B      R0, [R0]

8000bf9c <Canfd_LL_GetDataLength>:
##@@@F_:Canfd_LL_GetDataLength():
##@@@P_:kf32a13k_drv_canfd.c:170
##@@@L0165_: * @param PayLoadLength   
##@@@L0166_: * @retval void   
##@@@L0167_: */   
##@@@L0168_:uint8_t Canfd_LL_GetDataLength(const uint8_t Dlc)   
##@@@L0169_:{   
##@@@L0170_:    return ((uint8_t)(Dlc > 8U ? kvFd_MaxDataLength[(uint8_t)Dlc - 8U] : Dlc));   
8000bf9c:	09 38       	CMP       R0, #9			;->0x09
8000bf9e:	05 f3       	JNC       $+5                   ;->0x8000bfa8
8000bfa0:	04 45       	LD        R5, [PC + #4]         ;->0x8000bfb0  :=0x80001210
8000bfa2:	68 c3       	ADD       R5, R0, R5
8000bfa4:	58 30       	SUB       R5, #8			;->0x08
8000bfa6:	05 80       	LD.B      R0, [R5]
8000bfa8:	5f 1f       	MOV       R5, #255			;->0x00FF
8000bfaa:	05 69       	ANL       R0, R5
8000bfac:	1d 5c       	JMP       LR
8000bfae:	00 00       	NOP      NOP      
8000bfb0:	10 12 00 80 	.long     0x80001210 ->-2147479024  [!!!@2@:MOV       R1, #32	@@: LD.B      R0, [R0]

8000bfb4 <Canfd_LL_SwapBytesInWord>:
##@@@F_:Canfd_LL_SwapBytesInWord():
##@@@P_:kf32a13k_drv_canfd.c:184
##@@@L0179_: */   
##@@@L0180_:void Canfd_LL_SwapBytesInWord(volatile void *DesPtr, volatile void *SouPtr)   
##@@@L0181_:{   
##@@@L0182_:    volatile uint8_t *sou8Ptr = (uint8_t *)(SouPtr);   
##@@@L0183_:    volatile uint8_t *des8Ptr = (uint8_t *)(DesPtr);   
##@@@L0184_:    CANFD_WRITE8(des8Ptr, *(sou8Ptr + 3U));   
8000bfb4:	e9 88       	LD.B      R5, [R1 + #3]
8000bfb6:	05 83       	ST.B      [R0], R5
##@@@P_:kf32a13k_drv_canfd.c:185
##@@@L0185_:    CANFD_WRITE8(des8Ptr + 1U, *(sou8Ptr + 2U));   
8000bfb8:	a9 88       	LD.B      R5, [R1 + #2]
8000bfba:	45 90       	ST.B      [R0 + #1], R5
##@@@P_:kf32a13k_drv_canfd.c:186
##@@@L0186_:    CANFD_WRITE8(des8Ptr + 2U, *(sou8Ptr + 1U));   
8000bfbc:	69 88       	LD.B      R5, [R1 + #1]
8000bfbe:	85 90       	ST.B      [R0 + #2], R5
##@@@P_:kf32a13k_drv_canfd.c:187
##@@@L0187_:    CANFD_WRITE8(des8Ptr + 3U, *(sou8Ptr));   
8000bfc0:	51 80       	LD.B      R5, [R1]
8000bfc2:	c5 90       	ST.B      [R0 + #3], R5
##@@@P_:kf32a13k_drv_canfd.c:188
##@@@L0188_:}   
8000bfc4:	1d 5c       	JMP       LR
	...

8000bfc8 <Canfd_LL_EnterFreezeMode>:
##@@@F_:Canfd_LL_SetHaltEnabled():
##@@@P_:kf32a13k_drv_canfd.h:617
##@@@L0612_: */   
##@@@L0613_:
##@@@L0614_:KF_INLINE void Canfd_LL_SetHaltEnabled(CanfdPtr Module, const bool Status)   
##@@@L0615_:{   
##@@@L0616_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0617_:    REG_WRITE(Module->CANFD_MCR.bits.HALT, Status);   
8000bfc8:	50 82       	LD.W      R5, [R0]
8000bfca:	11 44       	LD        R4, [PC + #17]        ;->0x8000c00c  :=0x10000000
8000bfcc:	54 6a       	ORL       R5, R4
8000bfce:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_SetFreezeEnabled():
##@@@P_:kf32a13k_drv_canfd.h:578
##@@@L0573_: */   
##@@@L0574_:
##@@@L0575_:KF_INLINE void Canfd_LL_SetFreezeEnabled(CanfdPtr Module, const bool Status)   
##@@@L0576_:{   
##@@@L0577_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0578_:    REG_WRITE(Module->CANFD_MCR.bits.FRZ, Status);   
8000bfd0:	50 82       	LD.W      R5, [R0]
8000bfd2:	10 44       	LD        R4, [PC + #16]        ;->0x8000c010  :=0x40000000
8000bfd4:	54 6a       	ORL       R5, R4
8000bfd6:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_IsDisEnabled():
##@@@P_:kf32a13k_drv_canfd.h:645
##@@@L0640_: *         false:模块未使能   
##@@@L0641_: */   
##@@@L0642_:KF_INLINE bool Canfd_LL_IsDisEnabled(CanfdPtr Module)   
##@@@L0643_:{   
##@@@L0644_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0645_:    return (REG_READ(Module->CANFD_MCR.bits.MDIS));   
8000bfd8:	50 82       	LD.W      R5, [R0]
##@@@F_:Canfd_LL_EnterFreezeMode():
##@@@P_:kf32a13k_drv_canfd.c:201
##@@@L0196_:{   
##@@@L0197_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0198_:    bool enabled = false;   
##@@@L0199_:    Canfd_LL_SetHaltEnabled(Module, true);   
##@@@L0200_:    Canfd_LL_SetFreezeEnabled(Module, true);   
##@@@L0201_:    if (false == Canfd_LL_IsDisEnabled(Module))   
8000bfda:	0f 44       	LD        R4, [PC + #15]        ;->0x8000c014  :=0xffffffff
8000bfdc:	54 70       	CMP       R5, R4
8000bfde:	05 fc       	JGT       $+5                   ;->0x8000bfe8
##@@@F_:Canfd_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_canfd.h:632
##@@@L0627_: */   
##@@@L0628_:
##@@@L0629_:KF_INLINE void Canfd_LL_SetModuleDisabled(CanfdPtr Module, const bool Status)   
##@@@L0630_:{   
##@@@L0631_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0632_:    REG_WRITE(Module->CANFD_MCR.bits.MDIS, Status);   
8000bfe0:	30 82       	LD.W      R3, [R0]
8000bfe2:	0e 42       	LD        R2, [PC + #14]        ;->0x8000c018  :=0x7fffffff
8000bfe4:	32 69       	ANL       R3, R2
8000bfe6:	03 85       	ST.W      [R0], R3
##@@@F_:Canfd_LL_EnterFreezeMode():
8000bfe8:	0d 43       	LD        R3, [PC + #13]        ;->0x8000c01c  :=0x1000000
##@@@F_:Canfd_LL_GetFreezeAck():
##@@@P_:kf32a13k_drv_canfd.h:590
##@@@L0585_: */   
##@@@L0586_:
##@@@L0587_:KF_INLINE bool Canfd_LL_GetFreezeAck(CanfdPtr Module)   
##@@@L0588_:{   
##@@@L0589_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0590_:    return (REG_READ(Module->CANFD_MCR.bits.FRZACK));   
8000bfea:	20 82       	LD.W      R2, [R0]
8000bfec:	23 69       	ANL       R2, R3
##@@@F_:Canfd_LL_EnterFreezeMode():
##@@@P_:kf32a13k_drv_canfd.c:209
##@@@L0204_:    }   
##@@@L0205_:    else   
##@@@L0206_:    {   
##@@@L0207_:        Canfd_LL_SetModuleDisabled(Module, false);   
##@@@L0208_:    }   
##@@@L0209_:    while (false == Canfd_LL_GetFreezeAck(Module))   
8000bfee:	20 38       	CMP       R2, #0			;->0x00
8000bff0:	fd f0       	JZ        $-3                   ;->0x8000bfea
##@@@P_:kf32a13k_drv_canfd.c:211
##@@@L0210_:        ;   
##@@@L0211_:    if (false == enabled)   
8000bff2:	54 70       	CMP       R5, R4
8000bff4:	0a fc       	JGT       $+10                  ;->0x8000c008
##@@@F_:Canfd_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_canfd.h:632
##@@@L0627_: */   
##@@@L0628_:
##@@@L0629_:KF_INLINE void Canfd_LL_SetModuleDisabled(CanfdPtr Module, const bool Status)   
##@@@L0630_:{   
##@@@L0631_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0632_:    REG_WRITE(Module->CANFD_MCR.bits.MDIS, Status);   
8000bff6:	40 82       	LD.W      R4, [R0]
8000bff8:	0a 45       	LD        R5, [PC + #10]        ;->0x8000c020  :=0x80000000
8000bffa:	45 6a       	ORL       R4, R5
8000bffc:	0a 45       	LD        R5, [PC + #10]        ;->0x8000c024  :=0x100000
8000bffe:	04 85       	ST.W      [R0], R4
##@@@F_:Canfd_LL_GetLowPowerModeAck():
##@@@P_:kf32a13k_drv_canfd.h:602
##@@@L0597_: */   
##@@@L0598_:
##@@@L0599_:KF_INLINE bool Canfd_LL_GetLowPowerModeAck(CanfdPtr Module)   
##@@@L0600_:{   
##@@@L0601_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0602_:    return (REG_READ(Module->CANFD_MCR.bits.LPMACK));   
8000c000:	40 82       	LD.W      R4, [R0]
8000c002:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_EnterFreezeMode():
##@@@P_:kf32a13k_drv_canfd.c:214
##@@@L0212_:    {   
##@@@L0213_:        Canfd_LL_SetModuleDisabled(Module, true);   
##@@@L0214_:        while (false == Canfd_LL_GetLowPowerModeAck(Module))   
8000c004:	40 38       	CMP       R4, #0			;->0x00
8000c006:	fd f0       	JZ        $-3                   ;->0x8000c000
##@@@P_:kf32a13k_drv_canfd.c:217
##@@@L0215_:            ;   
##@@@L0216_:    }   
##@@@L0217_:}   
8000c008:	1d 5c       	JMP       LR
8000c00a:	00 00       	NOP      NOP      
8000c00c:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
8000c010:	00 00 00 40 	.long     0x40000000 ->1073741824  [!!!@2@:NOP      	@@: LD        R0, [PC + #0]         ;->0x8000c010  :=0x40000000
8000c014:	ff ff ff ff 	.long     0xffffffff ->-00000001 
8000c018:	ff ff ff 7f 	.long     0x7fffffff ->2147483647 
8000c01c:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
8000c020:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
8000c024:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16

8000c028 <Canfd_LL_ExitFreezeMode>:
##@@@F_:Canfd_LL_SetFreezeEnabled():
##@@@P_:kf32a13k_drv_canfd.h:578
##@@@L0573_: */   
##@@@L0574_:
##@@@L0575_:KF_INLINE void Canfd_LL_SetFreezeEnabled(CanfdPtr Module, const bool Status)   
##@@@L0576_:{   
##@@@L0577_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0578_:    REG_WRITE(Module->CANFD_MCR.bits.FRZ, Status);   
8000c028:	50 82       	LD.W      R5, [R0]
8000c02a:	07 44       	LD        R4, [PC + #7]         ;->0x8000c044  :=0xbfffffff
8000c02c:	54 69       	ANL       R5, R4
8000c02e:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_SetHaltEnabled():
##@@@P_:kf32a13k_drv_canfd.h:617
##@@@L0612_: */   
##@@@L0613_:
##@@@L0614_:KF_INLINE void Canfd_LL_SetHaltEnabled(CanfdPtr Module, const bool Status)   
##@@@L0615_:{   
##@@@L0616_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0617_:    REG_WRITE(Module->CANFD_MCR.bits.HALT, Status);   
8000c030:	40 82       	LD.W      R4, [R0]
8000c032:	06 45       	LD        R5, [PC + #6]         ;->0x8000c048  :=0xefffffff
8000c034:	45 69       	ANL       R4, R5
8000c036:	06 45       	LD        R5, [PC + #6]         ;->0x8000c04c  :=0x1000000
8000c038:	04 85       	ST.W      [R0], R4
##@@@F_:Canfd_LL_GetFreezeAck():
##@@@P_:kf32a13k_drv_canfd.h:590
##@@@L0585_: */   
##@@@L0586_:
##@@@L0587_:KF_INLINE bool Canfd_LL_GetFreezeAck(CanfdPtr Module)   
##@@@L0588_:{   
##@@@L0589_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0590_:    return (REG_READ(Module->CANFD_MCR.bits.FRZACK));   
8000c03a:	40 82       	LD.W      R4, [R0]
8000c03c:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_ExitFreezeMode():
##@@@P_:kf32a13k_drv_canfd.c:229
##@@@L0224_:void Canfd_LL_ExitFreezeMode(CanfdPtr Module)   
##@@@L0225_:{   
##@@@L0226_:    Canfd_LL_SetFreezeEnabled(Module, false);   
##@@@L0227_:    Canfd_LL_SetHaltEnabled(Module, false);   
##@@@L0228_:    /* Wait till exit freeze mode */   
##@@@L0229_:    while (true == Canfd_LL_GetFreezeAck(Module))   
8000c03e:	40 38       	CMP       R4, #0			;->0x00
8000c040:	fd f1       	JNZ       $-3                   ;->0x8000c03a
##@@@P_:kf32a13k_drv_canfd.c:231
##@@@L0230_:        ;   
##@@@L0231_:}   
8000c042:	1d 5c       	JMP       LR
8000c044:	ff ff ff bf 	.long     0xbfffffff ->-1073741825 
8000c048:	ff ff ff ef 	.long     0xefffffff ->-268435457 
8000c04c:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0

8000c050 <Canfd_LL_Disable>:
##@@@F_:Canfd_LL_IsDisEnabled():
##@@@P_:kf32a13k_drv_canfd.h:645
##@@@L0640_: *         false:模块未使能   
##@@@L0641_: */   
##@@@L0642_:KF_INLINE bool Canfd_LL_IsDisEnabled(CanfdPtr Module)   
##@@@L0643_:{   
##@@@L0644_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0645_:    return (REG_READ(Module->CANFD_MCR.bits.MDIS));   
8000c050:	50 82       	LD.W      R5, [R0]
##@@@F_:Canfd_LL_Disable():
##@@@P_:kf32a13k_drv_canfd.c:240
##@@@L0235_: * @param[in] Module 指向CANFD内存结构的指针，取值为CANFD0-CANFD7   
##@@@L0236_: * @return void   
##@@@L0237_: */   
##@@@L0238_:void Canfd_LL_Disable(CanfdPtr Module)   
##@@@L0239_:{   
##@@@L0240_:    if (false == Canfd_LL_IsDisEnabled(Module))   
8000c052:	50 38       	CMP       R5, #0			;->0x00
8000c054:	0a fb       	JLT       $+10                  ;->0x8000c068
##@@@F_:Canfd_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_canfd.h:632
##@@@L0627_: */   
##@@@L0628_:
##@@@L0629_:KF_INLINE void Canfd_LL_SetModuleDisabled(CanfdPtr Module, const bool Status)   
##@@@L0630_:{   
##@@@L0631_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0632_:    REG_WRITE(Module->CANFD_MCR.bits.MDIS, Status);   
8000c056:	40 82       	LD.W      R4, [R0]
8000c058:	05 45       	LD        R5, [PC + #5]         ;->0x8000c06c  :=0x80000000
8000c05a:	45 6a       	ORL       R4, R5
8000c05c:	05 45       	LD        R5, [PC + #5]         ;->0x8000c070  :=0x100000
8000c05e:	04 85       	ST.W      [R0], R4
##@@@F_:Canfd_LL_GetLowPowerModeAck():
##@@@P_:kf32a13k_drv_canfd.h:602
##@@@L0597_: */   
##@@@L0598_:
##@@@L0599_:KF_INLINE bool Canfd_LL_GetLowPowerModeAck(CanfdPtr Module)   
##@@@L0600_:{   
##@@@L0601_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0602_:    return (REG_READ(Module->CANFD_MCR.bits.LPMACK));   
8000c060:	40 82       	LD.W      R4, [R0]
8000c062:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_Disable():
##@@@P_:kf32a13k_drv_canfd.c:245
##@@@L0241_:    {   
##@@@L0242_:        /* Clock disable (module) */   
##@@@L0243_:        Canfd_LL_SetModuleDisabled(Module, true);   
##@@@L0244_:        /* Wait until disable mode acknowledged */   
##@@@L0245_:        while (false == Canfd_LL_GetLowPowerModeAck(Module))   
8000c064:	40 38       	CMP       R4, #0			;->0x00
8000c066:	fd f0       	JZ        $-3                   ;->0x8000c060
##@@@P_:kf32a13k_drv_canfd.c:248
##@@@L0246_:            ;   
##@@@L0247_:    }   
##@@@L0248_:}   
8000c068:	1d 5c       	JMP       LR
8000c06a:	00 00       	NOP      NOP      
8000c06c:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
8000c070:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16

8000c074 <Canfd_LL_Enable>:
##@@@F_:Canfd_LL_GetLowPowerModeAck():
##@@@P_:kf32a13k_drv_canfd.h:602
8000c074:	50 82       	LD.W      R5, [R0]
8000c076:	09 44       	LD        R4, [PC + #9]         ;->0x8000c098  :=0x100000
8000c078:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_Enable():
##@@@P_:kf32a13k_drv_canfd.c:257
##@@@L0252_: * @param[in] Module 指向CANFD内存结构的指针，取值为CANFD0-CANFD7   
##@@@L0253_: * @return void   
##@@@L0254_: */   
##@@@L0255_:void Canfd_LL_Enable(CanfdPtr Module)   
##@@@L0256_:{   
##@@@L0257_:    if (true == Canfd_LL_GetLowPowerModeAck(Module))   
8000c07a:	50 38       	CMP       R5, #0			;->0x00
8000c07c:	0d f0       	JZ        $+13                  ;->0x8000c096
##@@@F_:Canfd_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_canfd.h:632
##@@@L0627_: */   
##@@@L0628_:
##@@@L0629_:KF_INLINE void Canfd_LL_SetModuleDisabled(CanfdPtr Module, const bool Status)   
##@@@L0630_:{   
##@@@L0631_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0632_:    REG_WRITE(Module->CANFD_MCR.bits.MDIS, Status);   
8000c07e:	50 82       	LD.W      R5, [R0]
8000c080:	07 44       	LD        R4, [PC + #7]         ;->0x8000c09c  :=0x7fffffff
8000c082:	54 69       	ANL       R5, R4
8000c084:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_SetFreezeEnabled():
##@@@P_:kf32a13k_drv_canfd.h:578
##@@@L0573_: */   
##@@@L0574_:
##@@@L0575_:KF_INLINE void Canfd_LL_SetFreezeEnabled(CanfdPtr Module, const bool Status)   
##@@@L0576_:{   
##@@@L0577_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0578_:    REG_WRITE(Module->CANFD_MCR.bits.FRZ, Status);   
8000c086:	50 82       	LD.W      R5, [R0]
8000c088:	06 44       	LD        R4, [PC + #6]         ;->0x8000c0a0  :=0xbfffffff
8000c08a:	54 69       	ANL       R5, R4
8000c08c:	05 85       	ST.W      [R0], R5
8000c08e:	06 45       	LD        R5, [PC + #6]         ;->0x8000c0a4  :=0xefffffff
##@@@F_:Canfd_LL_SetHaltEnabled():
##@@@P_:kf32a13k_drv_canfd.h:617
##@@@L0612_: */   
##@@@L0613_:
##@@@L0614_:KF_INLINE void Canfd_LL_SetHaltEnabled(CanfdPtr Module, const bool Status)   
##@@@L0615_:{   
##@@@L0616_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0617_:    REG_WRITE(Module->CANFD_MCR.bits.HALT, Status);   
8000c090:	40 82       	LD.W      R4, [R0]
8000c092:	45 69       	ANL       R4, R5
8000c094:	04 85       	ST.W      [R0], R4
##@@@F_:Canfd_LL_Enable():
##@@@P_:kf32a13k_drv_canfd.c:263
##@@@L0258_:    {   
##@@@L0259_:        Canfd_LL_SetModuleDisabled(Module, false);   
##@@@L0260_:        Canfd_LL_SetFreezeEnabled(Module, false);   
##@@@L0261_:        Canfd_LL_SetHaltEnabled(Module, false);   
##@@@L0262_:    }   
##@@@L0263_:}   
8000c096:	1d 5c       	JMP       LR
8000c098:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16
8000c09c:	ff ff ff 7f 	.long     0x7fffffff ->2147483647 
8000c0a0:	ff ff ff bf 	.long     0xbfffffff ->-1073741825 
8000c0a4:	ff ff ff ef 	.long     0xefffffff ->-268435457 

8000c0a8 <Canfd_LL_SetPayloadSize>:
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.c:276
##@@@L0271_: *            CANFD_PAYLOAD_SIZE_32   
##@@@L0272_: *            CANFD_PAYLOAD_SIZE_64   
##@@@L0273_: * @return void   
##@@@L0274_: */   
##@@@L0275_:void Canfd_LL_SetPayloadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0276_:{   
8000c0a8:	26 5d       	PUSH      R6
8000c0aa:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000c0ac:	50 82       	LD.W      R5, [R0]
8000c0ae:	16 44       	LD        R4, [PC + #22]        ;->0x8000c104  :=0x800
8000c0b0:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_SetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:277
##@@@L0277_:    if (true == Canfd_LL_IsFDEnabled(Module))   
8000c0b2:	50 38       	CMP       R5, #0			;->0x00
8000c0b4:	25 f0       	JZ        $+37                  ;->0x8000c0fe
##@@@F_:Canfd_LL_SetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:803
##@@@L0798_: * @return void   
##@@@L0799_: */   
##@@@L0800_:KF_INLINE void Canfd_LL_SetR0PayLoadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0801_:{   
##@@@L0802_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0803_:    REG_WRITE(Module->CANFD_FDCTRL.bits.MBDSR0, PayloadSize);   
8000c0b6:	81 58       	MOV       R4, R1
8000c0b8:	20 7b       	LSL       R4, #16			;->0x10
8000c0ba:	14 45       	LD        R5, [PC + #20]        ;->0x8000c108  :=0xc00
8000c0bc:	14 43       	LD        R3, [PC + #20]        ;->0x8000c10c  :=0x30000
8000c0be:	50 e9       	LD.W      R2, [R0 + R5]
8000c0c0:	14 46       	LD        R6, [PC + #20]        ;->0x8000c110  :=0xfffcffff
8000c0c2:	43 69       	ANL       R4, R3
8000c0c4:	26 69       	ANL       R2, R6
8000c0c6:	24 6a       	ORL       R2, R4
8000c0c8:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetR1PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:815
##@@@L0810_: * @return void   
##@@@L0811_: */   
##@@@L0812_:KF_INLINE void Canfd_LL_SetR1PayLoadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0813_:{   
##@@@L0814_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0815_:    REG_WRITE(Module->CANFD_FDCTRL.bits.MBDSR1, PayloadSize);   
8000c0ca:	81 58       	MOV       R4, R1
8000c0cc:	23 7b       	LSL       R4, #19			;->0x13
8000c0ce:	12 43       	LD        R3, [PC + #18]        ;->0x8000c114  :=0x180000
8000c0d0:	50 e9       	LD.W      R2, [R0 + R5]
8000c0d2:	12 46       	LD        R6, [PC + #18]        ;->0x8000c118  :=0xffe7ffff
8000c0d4:	43 69       	ANL       R4, R3
8000c0d6:	26 69       	ANL       R2, R6
8000c0d8:	24 6a       	ORL       R2, R4
8000c0da:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetR3PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:839
##@@@L0834_: * @return void   
##@@@L0835_: */   
##@@@L0836_:KF_INLINE void Canfd_LL_SetR3PayLoadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0837_:{   
##@@@L0838_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0839_:    REG_WRITE(Module->CANFD_FDCTRL.bits.MBDSR3, PayloadSize);   
8000c0dc:	81 58       	MOV       R4, R1
8000c0de:	10 43       	LD        R3, [PC + #16]        ;->0x8000c11c  :=0xc00000
##@@@F_:Canfd_LL_SetR2PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:827
##@@@L0822_: * @return void   
##@@@L0823_: */   
##@@@L0824_:KF_INLINE void Canfd_LL_SetR2PayLoadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0825_:{   
##@@@L0826_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0827_:    REG_WRITE(Module->CANFD_FDCTRL.bits.MBDSR2, PayloadSize);   
8000c0e0:	0e 7b       	LSL       R1, #22			;->0x16
8000c0e2:	13 69       	ANL       R1, R3
8000c0e4:	0f 43       	LD        R3, [PC + #15]        ;->0x8000c120  :=0xff3fffff
8000c0e6:	50 e9       	LD.W      R2, [R0 + R5]
##@@@F_:Canfd_LL_SetR3PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:839
##@@@L0834_: * @return void   
##@@@L0835_: */   
##@@@L0836_:KF_INLINE void Canfd_LL_SetR3PayLoadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0837_:{   
##@@@L0838_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0839_:    REG_WRITE(Module->CANFD_FDCTRL.bits.MBDSR3, PayloadSize);   
8000c0e8:	a1 7b       	LSL       R4, #25			;->0x19
##@@@F_:Canfd_LL_SetR2PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:827
##@@@L0822_: * @return void   
##@@@L0823_: */   
##@@@L0824_:KF_INLINE void Canfd_LL_SetR2PayLoadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0825_:{   
##@@@L0826_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0827_:    REG_WRITE(Module->CANFD_FDCTRL.bits.MBDSR2, PayloadSize);   
8000c0ea:	23 69       	ANL       R2, R3
8000c0ec:	0e 43       	LD        R3, [PC + #14]        ;->0x8000c124  :=0x6000000
8000c0ee:	21 6a       	ORL       R2, R1
8000c0f0:	42 ef       	ST.W      [R0 + R5], R2
8000c0f2:	0e 42       	LD        R2, [PC + #14]        ;->0x8000c128  :=0xf9ffffff
##@@@F_:Canfd_LL_SetR3PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:839
##@@@L0834_: * @return void   
##@@@L0835_: */   
##@@@L0836_:KF_INLINE void Canfd_LL_SetR3PayLoadSize(CanfdPtr Module, const Canfd_PayloadSize_t PayloadSize)   
##@@@L0837_:{   
##@@@L0838_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0839_:    REG_WRITE(Module->CANFD_FDCTRL.bits.MBDSR3, PayloadSize);   
8000c0f4:	48 e9       	LD.W      R1, [R0 + R5]
8000c0f6:	43 69       	ANL       R4, R3
8000c0f8:	12 69       	ANL       R1, R2
8000c0fa:	14 6a       	ORL       R1, R4
8000c0fc:	41 ef       	ST.W      [R0 + R5], R1
##@@@F_:Canfd_LL_SetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:284
##@@@L0279_:        Canfd_LL_SetR0PayLoadSize(Module, PayloadSize);   
##@@@L0280_:        Canfd_LL_SetR1PayLoadSize(Module, PayloadSize);   
##@@@L0281_:        Canfd_LL_SetR2PayLoadSize(Module, PayloadSize);   
##@@@L0282_:        Canfd_LL_SetR3PayLoadSize(Module, PayloadSize);   
##@@@L0283_:    }   
##@@@L0284_:}   
8000c0fe:	e4 28       	ADD       SP, #4			;->0x04
8000c100:	06 5d       	POP       R6
8000c102:	1d 5c       	JMP       LR
8000c104:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000c108:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000c10c:	00 00 03 00 	.long     0x00030000 ->000196608 
8000c110:	ff ff fc ff 	.long     0xfffcffff ->-00196609 
8000c114:	00 00 18 00 	.long     0x00180000 ->001572864  [!!!@2@:NOP      	@@: MULS      R0, R0, R24
8000c118:	ff ff e7 ff 	.long     0xffe7ffff ->-01572865 
8000c11c:	00 00 c0 00 	.long     0x00c00000 ->012582912 
8000c120:	ff ff 3f ff 	.long     0xff3fffff ->-12582913 
8000c124:	00 00 00 06 	.long     0x06000000 ->100663296  [!!!@2@:NOP      	@@: SJMP      $-512                 ;->0x8000bd24
8000c128:	ff ff ff f9 	.long     0xf9ffffff ->-100663297 

8000c12c <Canfd_LL_GetPayloadSize>:
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:292
##@@@L0287_: * @brief 获取 邮箱负载尺寸   
##@@@L0288_: * @param[in] Module 指向CANFD内存结构的指针，取值为CANFD0-CANFD7   
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
8000c12c:	a0 58       	MOV       R5, R0
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000c12e:	40 82       	LD.W      R4, [R0]
8000c130:	06 43       	LD        R3, [PC + #6]         ;->0x8000c148  :=0x800
8000c132:	43 69       	ANL       R4, R3
8000c134:	08 10       	MOV       R0, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000c136:	40 38       	CMP       R4, #0			;->0x00
8000c138:	07 f0       	JZ        $+7                   ;->0x8000c146
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000c13a:	05 44       	LD        R4, [PC + #5]         ;->0x8000c14c  :=0xc00
8000c13c:	2d e9       	LD.W      R5, [R5 + R4]
8000c13e:	28 7d       	LSR       R5, #16			;->0x10
8000c140:	43 10       	MOV       R4, #3			;->0x0003
8000c142:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000c144:	05 6c       	LSL       R0, R5
##@@@P_:kf32a13k_drv_canfd.c:302
##@@@L0301_:    }   
##@@@L0302_:    return (payloadSize);   
8000c146:	1d 5c       	JMP       LR
8000c148:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000c14c:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      

8000c150 <Canfd_LL_SetTimeSegments>:
##@@@F_:Canfd_LL_SetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:313
##@@@L0308_: * @param[in] TimeSegPtr 波特率配置参数指针   
##@@@L0309_: * @return void   
##@@@L0310_: */   
##@@@L0311_:void Canfd_LL_SetTimeSegments(CanfdPtr Module, const Canfd_TimeSegment_t *TimeSegPtr)   
##@@@L0312_:{   
##@@@L0313_:    Canfd_LL_SetPropSeg(Module, TimeSegPtr->propSeg);   
8000c150:	51 82       	LD.W      R5, [R1]
8000c152:	47 10       	MOV       R4, #7			;->0x0007
##@@@F_:Canfd_LL_SetPropSeg():
##@@@P_:kf32a13k_drv_canfd.h:975
##@@@L0970_: * @return void   
##@@@L0971_: */   
##@@@L0972_:KF_INLINE void Canfd_LL_SetPropSeg(CanfdPtr Module, const uint32_t Value)   
##@@@L0973_:{   
##@@@L0974_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0975_:    REG_WRITE(Module->CANFD_CTRL1.bits.PROPSEG, Value);   
8000c154:	58 98       	LD.W      R3, [R0 + #1]
8000c156:	15 42       	LD        R2, [PC + #21]        ;->0x8000c1a8  :=0xfffffff8
8000c158:	54 69       	ANL       R5, R4
8000c15a:	32 69       	ANL       R3, R2
8000c15c:	35 6a       	ORL       R3, R5
8000c15e:	43 a0       	ST.W      [R0 + #1], R3
##@@@F_:Canfd_LL_SetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:314
##@@@L0314_:    Canfd_LL_SetPSeg1(Module, TimeSegPtr->phaseSeg1);   
8000c160:	69 98       	LD.W      R5, [R1 + #1]
##@@@F_:Canfd_LL_SetPSeg1():
##@@@P_:kf32a13k_drv_canfd.h:998
##@@@L0993_: * @return void   
##@@@L0994_: */   
##@@@L0995_:KF_INLINE void Canfd_LL_SetPSeg1(CanfdPtr Module, const uint32_t Value)   
##@@@L0996_:{   
##@@@L0997_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0998_:    REG_WRITE(Module->CANFD_CTRL1.bits.PSEG1, Value);   
8000c162:	2b 7b       	LSL       R5, #19			;->0x13
8000c164:	12 44       	LD        R4, [PC + #18]        ;->0x8000c1ac  :=0x380000
8000c166:	13 43       	LD        R3, [PC + #19]        ;->0x8000c1b0  :=0xffc7ffff
8000c168:	50 98       	LD.W      R2, [R0 + #1]
8000c16a:	54 69       	ANL       R5, R4
8000c16c:	23 69       	ANL       R2, R3
8000c16e:	25 6a       	ORL       R2, R5
8000c170:	42 a0       	ST.W      [R0 + #1], R2
##@@@F_:Canfd_LL_SetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:315
##@@@L0315_:    Canfd_LL_SetPSeg2(Module, TimeSegPtr->phaseSeg2);   
8000c172:	a9 98       	LD.W      R5, [R1 + #2]
##@@@F_:Canfd_LL_SetPSeg2():
##@@@P_:kf32a13k_drv_canfd.h:1021
##@@@L1016_: * @return void   
##@@@L1017_: */   
##@@@L1018_:KF_INLINE void Canfd_LL_SetPSeg2(CanfdPtr Module, const uint32_t Value)   
##@@@L1019_:{   
##@@@L1020_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1021_:    REG_WRITE(Module->CANFD_CTRL1.bits.PSEG2, Value);   
8000c174:	28 7b       	LSL       R5, #16			;->0x10
8000c176:	10 44       	LD        R4, [PC + #16]        ;->0x8000c1b4  :=0x70000
8000c178:	10 43       	LD        R3, [PC + #16]        ;->0x8000c1b8  :=0xfff8ffff
8000c17a:	50 98       	LD.W      R2, [R0 + #1]
8000c17c:	54 69       	ANL       R5, R4
8000c17e:	23 69       	ANL       R2, R3
8000c180:	25 6a       	ORL       R2, R5
8000c182:	42 a0       	ST.W      [R0 + #1], R2
8000c184:	0e 45       	LD        R5, [PC + #14]        ;->0x8000c1bc  :=0xffffff
##@@@F_:Canfd_LL_SetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:316
##@@@L0316_:    Canfd_LL_SetPDivide(Module, TimeSegPtr->preDivider);   
8000c186:	e1 98       	LD.W      R4, [R1 + #3]
##@@@F_:Canfd_LL_SetPDivide():
##@@@P_:kf32a13k_drv_canfd.h:1044
##@@@L1039_: * @return void   
##@@@L1040_: */   
##@@@L1041_:KF_INLINE void Canfd_LL_SetPDivide(CanfdPtr Module, const uint32_t Value)   
##@@@L1042_:{   
##@@@L1043_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1044_:    REG_WRITE(Module->CANFD_CTRL1.bits.PRESDIV, Value);   
8000c188:	58 98       	LD.W      R3, [R0 + #1]
8000c18a:	35 69       	ANL       R3, R5
8000c18c:	a0 7b       	LSL       R4, #24			;->0x18
8000c18e:	34 6a       	ORL       R3, R4
8000c190:	43 a0       	ST.W      [R0 + #1], R3
##@@@F_:Canfd_LL_SetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:317
##@@@L0317_:    Canfd_LL_SetPRJW(Module, TimeSegPtr->rJumpwidth);   
8000c192:	29 99       	LD.W      R5, [R1 + #4]
##@@@F_:Canfd_LL_SetPRJW():
##@@@P_:kf32a13k_drv_canfd.h:1067
##@@@L1062_: * @return void   
##@@@L1063_: */   
##@@@L1064_:KF_INLINE void Canfd_LL_SetPRJW(CanfdPtr Module, const uint32_t Value)   
##@@@L1065_:{   
##@@@L1066_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1067_:    REG_WRITE(Module->CANFD_CTRL1.bits.RJW, Value);   
8000c194:	2e 7b       	LSL       R5, #22			;->0x16
8000c196:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c1c0  :=0xc00000
8000c198:	0b 43       	LD        R3, [PC + #11]        ;->0x8000c1c4  :=0xff3fffff
8000c19a:	50 98       	LD.W      R2, [R0 + #1]
8000c19c:	54 69       	ANL       R5, R4
8000c19e:	23 69       	ANL       R2, R3
8000c1a0:	25 6a       	ORL       R2, R5
8000c1a2:	42 a0       	ST.W      [R0 + #1], R2
##@@@F_:Canfd_LL_SetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:318
##@@@L0318_:}   
8000c1a4:	1d 5c       	JMP       LR
8000c1a6:	00 00       	NOP      NOP      
8000c1a8:	f8 ff ff ff 	.long     0xfffffff8 ->-00000008 
8000c1ac:	00 00 38 00 	.long     0x00380000 ->003670016 
8000c1b0:	ff ff c7 ff 	.long     0xffc7ffff ->-03670017 
8000c1b4:	00 00 07 00 	.long     0x00070000 ->000458752  [!!!@2@:NOP      	@@: BREAK    
8000c1b8:	ff ff f8 ff 	.long     0xfff8ffff ->-00458753 
8000c1bc:	ff ff ff 00 	.long     0x00ffffff ->016777215 
8000c1c0:	00 00 c0 00 	.long     0x00c00000 ->012582912 
8000c1c4:	ff ff 3f ff 	.long     0xff3fffff ->-12582913 

8000c1c8 <Canfd_LL_SetExtendedTimeSegments>:
##@@@F_:Canfd_LL_SetExtendedTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:328
##@@@L0323_: * @param[in] TimeSegPtr 波特率配置参数指针   
##@@@L0324_: * @return void   
##@@@L0325_: */   
##@@@L0326_:void Canfd_LL_SetExtendedTimeSegments(CanfdPtr Module, const Canfd_TimeSegment_t *TimeSegPtr)   
##@@@L0327_:{   
##@@@L0328_:    Canfd_LL_SetEPropSeg(Module, TimeSegPtr->propSeg);   
8000c1c8:	51 82       	LD.W      R5, [R1]
##@@@F_:Canfd_LL_SetEPropSeg():
##@@@P_:kf32a13k_drv_canfd.h:1090
##@@@L1085_: * @return void   
##@@@L1086_: */   
##@@@L1087_:KF_INLINE void Canfd_LL_SetEPropSeg(CanfdPtr Module, const uint32_t Value)   
##@@@L1088_:{   
##@@@L1089_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1090_:    REG_WRITE(Module->CANFD_CBT.bits.EPROPSEG, Value);   
8000c1ca:	aa 7a       	LSL       R5, #10			;->0x0A
8000c1cc:	16 44       	LD        R4, [PC + #22]        ;->0x8000c224  :=0xfc00
8000c1ce:	18 9d       	LD.W      R3, [R0 + #20]
8000c1d0:	16 42       	LD        R2, [PC + #22]        ;->0x8000c228  :=0xffff03ff
8000c1d2:	54 69       	ANL       R5, R4
8000c1d4:	32 69       	ANL       R3, R2
8000c1d6:	35 6a       	ORL       R3, R5
8000c1d8:	03 a5       	ST.W      [R0 + #20], R3
##@@@F_:Canfd_LL_SetExtendedTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:329
##@@@L0329_:    Canfd_LL_SetEPSeg1(Module, TimeSegPtr->phaseSeg1);   
8000c1da:	69 98       	LD.W      R5, [R1 + #1]
##@@@F_:Canfd_LL_SetEPSeg1():
##@@@P_:kf32a13k_drv_canfd.h:1102
##@@@L1097_: * @return void   
##@@@L1098_: */   
##@@@L1099_:KF_INLINE void Canfd_LL_SetEPSeg1(CanfdPtr Module, const uint32_t Value)   
##@@@L1100_:{   
##@@@L1101_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1102_:    REG_WRITE(Module->CANFD_CBT.bits.EPSEG1, Value);   
8000c1dc:	2d 7a       	LSL       R5, #5			;->0x05
8000c1de:	14 44       	LD        R4, [PC + #20]        ;->0x8000c22c  :=0x3e0
8000c1e0:	14 43       	LD        R3, [PC + #20]        ;->0x8000c230  :=0xfffffc1f
8000c1e2:	10 9d       	LD.W      R2, [R0 + #20]
8000c1e4:	54 69       	ANL       R5, R4
8000c1e6:	23 69       	ANL       R2, R3
8000c1e8:	25 6a       	ORL       R2, R5
8000c1ea:	02 a5       	ST.W      [R0 + #20], R2
8000c1ec:	5f 11       	MOV       R5, #31			;->0x001F
##@@@F_:Canfd_LL_SetExtendedTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:330
##@@@L0330_:    Canfd_LL_SetEPSeg2(Module, TimeSegPtr->phaseSeg2);   
8000c1ee:	a1 98       	LD.W      R4, [R1 + #2]
8000c1f0:	11 43       	LD        R3, [PC + #17]        ;->0x8000c234  :=0xffffffe0
##@@@F_:Canfd_LL_SetEPSeg2():
##@@@P_:kf32a13k_drv_canfd.h:1114
##@@@L1109_: * @return void   
##@@@L1110_: */   
##@@@L1111_:KF_INLINE void Canfd_LL_SetEPSeg2(CanfdPtr Module, const uint32_t Value)   
##@@@L1112_:{   
##@@@L1113_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1114_:    REG_WRITE(Module->CANFD_CBT.bits.EPSEG2, Value);   
8000c1f2:	10 9d       	LD.W      R2, [R0 + #20]
8000c1f4:	45 69       	ANL       R4, R5
8000c1f6:	23 69       	ANL       R2, R3
8000c1f8:	24 6a       	ORL       R2, R4
8000c1fa:	02 a5       	ST.W      [R0 + #20], R2
##@@@F_:Canfd_LL_SetExtendedTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:331
##@@@L0331_:    Canfd_LL_SetEPDivide(Module, TimeSegPtr->preDivider);   
8000c1fc:	e9 98       	LD.W      R5, [R1 + #3]
##@@@F_:Canfd_LL_SetEPDivide():
##@@@P_:kf32a13k_drv_canfd.h:1126
##@@@L1121_: * @return void   
##@@@L1122_: */   
##@@@L1123_:KF_INLINE void Canfd_LL_SetEPDivide(CanfdPtr Module, const uint32_t Value)   
##@@@L1124_:{   
##@@@L1125_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1126_:    REG_WRITE(Module->CANFD_CBT.bits.EPRESDIV, Value);   
8000c1fe:	2d 7b       	LSL       R5, #21			;->0x15
8000c200:	0e 44       	LD        R4, [PC + #14]        ;->0x8000c238  :=0x7fe00000
8000c202:	0f 43       	LD        R3, [PC + #15]        ;->0x8000c23c  :=0x801fffff
8000c204:	10 9d       	LD.W      R2, [R0 + #20]
8000c206:	54 69       	ANL       R5, R4
8000c208:	23 69       	ANL       R2, R3
8000c20a:	25 6a       	ORL       R2, R5
8000c20c:	02 a5       	ST.W      [R0 + #20], R2
##@@@F_:Canfd_LL_SetExtendedTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:332
##@@@L0332_:    Canfd_LL_SetEPRJW(Module, TimeSegPtr->rJumpwidth);   
8000c20e:	29 99       	LD.W      R5, [R1 + #4]
##@@@F_:Canfd_LL_SetEPRJW():
##@@@P_:kf32a13k_drv_canfd.h:1138
##@@@L1133_: * @return void   
##@@@L1134_: */   
##@@@L1135_:KF_INLINE void Canfd_LL_SetEPRJW(CanfdPtr Module, const uint32_t Value)   
##@@@L1136_:{   
##@@@L1137_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1138_:    REG_WRITE(Module->CANFD_CBT.bits.ERJW, Value);   
8000c210:	28 7b       	LSL       R5, #16			;->0x10
8000c212:	0c 44       	LD        R4, [PC + #12]        ;->0x8000c240  :=0x1f0000
8000c214:	0c 43       	LD        R3, [PC + #12]        ;->0x8000c244  :=0xffe0ffff
8000c216:	10 9d       	LD.W      R2, [R0 + #20]
8000c218:	54 69       	ANL       R5, R4
8000c21a:	23 69       	ANL       R2, R3
8000c21c:	25 6a       	ORL       R2, R5
8000c21e:	02 a5       	ST.W      [R0 + #20], R2
##@@@F_:Canfd_LL_SetExtendedTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:333
##@@@L0333_:}   
8000c220:	1d 5c       	JMP       LR
8000c222:	00 00       	NOP      NOP      
8000c224:	00 fc 00 00 	.long     0x0000fc00 ->000064512  [!!!@2@:JGT       $+0                   ;->0x8000c224	@@: NOP      
8000c228:	ff 03 ff ff 	.long     0xffff03ff ->-00064513  [!!!@4@:JMP       $-1                   ;->0x8000c226
8000c22c:	e0 03 00 00 	.long     0x000003e0 ->000000992  [!!!@4@:JMP       $-2097152             ;->0x7fc0c22c
8000c230:	1f fc ff ff 	.long     0xfffffc1f ->-00000993 
8000c234:	e0 ff ff ff 	.long     0xffffffe0 ->-00000032 
8000c238:	00 00 e0 7f 	.long     0x7fe00000 ->2145386496  [!!!@2@:NOP      	@@: ROR       R12, #24
8000c23c:	ff ff 1f 80 	.long     0x801fffff ->-2145386497 
8000c240:	00 00 1f 00 	.long     0x001f0000 ->002031616  [!!!@2@:NOP      	@@: FST.W           [R31++], S0
8000c244:	ff ff e0 ff 	.long     0xffe0ffff ->-02031617 

8000c248 <Canfd_LL_SetFDTimeSegments>:
##@@@F_:Canfd_LL_SetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:342
##@@@L0337_: * @param[in] Module 指向CANFD内存结构的指针，取值为CANFD0-CANFD7   
##@@@L0338_: * @param[in] TimeSegPtr 波特率配置参数指针   
##@@@L0339_: * @return void   
##@@@L0340_: */   
##@@@L0341_:void Canfd_LL_SetFDTimeSegments(CanfdPtr Module, const Canfd_TimeSegment_t *TimeSegPtr)   
##@@@L0342_:{   
8000c248:	26 5d       	PUSH      R6
8000c24a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kf32a13k_drv_canfd.c:343
##@@@L0343_:    Canfd_LL_SetFDPropSeg(Module, TimeSegPtr->propSeg);   
8000c24c:	41 82       	LD.W      R4, [R1]
##@@@F_:Canfd_LL_SetFDPropSeg():
##@@@P_:kf32a13k_drv_canfd.h:1150
##@@@L1145_: * @return void   
##@@@L1146_: */   
##@@@L1147_:KF_INLINE void Canfd_LL_SetFDPropSeg(CanfdPtr Module, const uint32_t Value)   
##@@@L1148_:{   
##@@@L1149_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1150_:    REG_WRITE(Module->CANFD_FDCBT.bits.FPROPSEG, Value);   
8000c24e:	a2 7a       	LSL       R4, #10			;->0x0A
8000c250:	17 45       	LD        R5, [PC + #23]        ;->0x8000c2ac  :=0xc04
8000c252:	18 43       	LD        R3, [PC + #24]        ;->0x8000c2b0  :=0x7c00
8000c254:	50 e9       	LD.W      R2, [R0 + R5]
8000c256:	18 46       	LD        R6, [PC + #24]        ;->0x8000c2b4  :=0xffff83ff
8000c258:	43 69       	ANL       R4, R3
8000c25a:	26 69       	ANL       R2, R6
8000c25c:	24 6a       	ORL       R2, R4
8000c25e:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:344
##@@@L0344_:    Canfd_LL_SetFDPSeg1(Module, TimeSegPtr->phaseSeg1);   
8000c260:	61 98       	LD.W      R4, [R1 + #1]
##@@@F_:Canfd_LL_SetFDPSeg1():
##@@@P_:kf32a13k_drv_canfd.h:1173
##@@@L1168_: * @return void   
##@@@L1169_: */   
##@@@L1170_:KF_INLINE void Canfd_LL_SetFDPSeg1(CanfdPtr Module, const uint32_t Value)   
##@@@L1171_:{   
##@@@L1172_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1173_:    REG_WRITE(Module->CANFD_FDCBT.bits.FPSEG1, Value);   
8000c262:	25 7a       	LSL       R4, #5			;->0x05
8000c264:	30 1e       	MOV       R3, #224			;->0x00E0
8000c266:	15 42       	LD        R2, [PC + #21]        ;->0x8000c2b8  :=0xffffff1f
8000c268:	70 e9       	LD.W      R6, [R0 + R5]
8000c26a:	43 69       	ANL       R4, R3
8000c26c:	62 69       	ANL       R6, R2
8000c26e:	64 6a       	ORL       R6, R4
8000c270:	46 ef       	ST.W      [R0 + R5], R6
8000c272:	47 10       	MOV       R4, #7			;->0x0007
##@@@F_:Canfd_LL_SetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:345
##@@@L0345_:    Canfd_LL_SetFDPSeg2(Module, TimeSegPtr->phaseSeg2);   
8000c274:	99 98       	LD.W      R3, [R1 + #2]
8000c276:	12 42       	LD        R2, [PC + #18]        ;->0x8000c2bc  :=0xfffffff8
##@@@F_:Canfd_LL_SetFDPSeg2():
##@@@P_:kf32a13k_drv_canfd.h:1196
##@@@L1191_: * @return void   
##@@@L1192_: */   
##@@@L1193_:KF_INLINE void Canfd_LL_SetFDPSeg2(CanfdPtr Module, const uint32_t Value)   
##@@@L1194_:{   
##@@@L1195_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1196_:    REG_WRITE(Module->CANFD_FDCBT.bits.FPSEG2, Value);   
8000c278:	70 e9       	LD.W      R6, [R0 + R5]
8000c27a:	34 69       	ANL       R3, R4
8000c27c:	62 69       	ANL       R6, R2
8000c27e:	63 6a       	ORL       R6, R3
8000c280:	46 ef       	ST.W      [R0 + R5], R6
##@@@F_:Canfd_LL_SetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:346
##@@@L0346_:    Canfd_LL_SetFDPDivide(Module, TimeSegPtr->preDivider);   
8000c282:	e1 98       	LD.W      R4, [R1 + #3]
##@@@F_:Canfd_LL_SetFDPDivide():
##@@@P_:kf32a13k_drv_canfd.h:1220
##@@@L1215_: * @return void   
##@@@L1216_: */   
##@@@L1217_:KF_INLINE void Canfd_LL_SetFDPDivide(CanfdPtr Module, const uint32_t Value)   
##@@@L1218_:{   
##@@@L1219_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1220_:    REG_WRITE(Module->CANFD_FDCBT.bits.FPRESDIV, Value);   
8000c284:	24 7b       	LSL       R4, #20			;->0x14
8000c286:	0f 43       	LD        R3, [PC + #15]        ;->0x8000c2c0  :=0x3ff00000
8000c288:	0f 42       	LD        R2, [PC + #15]        ;->0x8000c2c4  :=0xc00fffff
8000c28a:	70 e9       	LD.W      R6, [R0 + R5]
8000c28c:	43 69       	ANL       R4, R3
8000c28e:	62 69       	ANL       R6, R2
8000c290:	64 6a       	ORL       R6, R4
8000c292:	46 ef       	ST.W      [R0 + R5], R6
##@@@F_:Canfd_LL_SetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:347
##@@@L0347_:    Canfd_LL_SetFDPRJW(Module, TimeSegPtr->rJumpwidth);   
8000c294:	21 99       	LD.W      R4, [R1 + #4]
##@@@F_:Canfd_LL_SetFDPRJW():
##@@@P_:kf32a13k_drv_canfd.h:1244
##@@@L1239_: * @return void   
##@@@L1240_: */   
##@@@L1241_:KF_INLINE void Canfd_LL_SetFDPRJW(CanfdPtr Module, const uint32_t Value)   
##@@@L1242_:{   
##@@@L1243_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1244_:    REG_WRITE(Module->CANFD_FDCBT.bits.FRJW, Value);   
8000c296:	20 7b       	LSL       R4, #16			;->0x10
8000c298:	0c 43       	LD        R3, [PC + #12]        ;->0x8000c2c8  :=0x70000
8000c29a:	0d 42       	LD        R2, [PC + #13]        ;->0x8000c2cc  :=0xfff8ffff
8000c29c:	48 e9       	LD.W      R1, [R0 + R5]
8000c29e:	43 69       	ANL       R4, R3
8000c2a0:	12 69       	ANL       R1, R2
8000c2a2:	14 6a       	ORL       R1, R4
8000c2a4:	41 ef       	ST.W      [R0 + R5], R1
##@@@F_:Canfd_LL_SetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:348
##@@@L0348_:}   
8000c2a6:	e4 28       	ADD       SP, #4			;->0x04
8000c2a8:	06 5d       	POP       R6
8000c2aa:	1d 5c       	JMP       LR
8000c2ac:	04 0c 00 00 	.long     0x00000c04 ->000003076  [!!!@2@:LD.W      R4, [SP + #4]	@@: NOP      
8000c2b0:	00 7c 00 00 	.long     0x00007c00 ->000031744  [!!!@2@:LSR       R0, #0	@@: NOP      
8000c2b4:	ff 83 ff ff 	.long     0xffff83ff ->-00031745 
8000c2b8:	1f ff ff ff 	.long     0xffffff1f ->-00000225 
8000c2bc:	f8 ff ff ff 	.long     0xfffffff8 ->-00000008 
8000c2c0:	00 00 f0 3f 	.long     0x3ff00000 ->1072693248  [!!!@2@:NOP      	@@: CMP       PC, #112
8000c2c4:	ff ff 0f c0 	.long     0xc00fffff ->-1072693249 
8000c2c8:	00 00 07 00 	.long     0x00070000 ->000458752  [!!!@2@:NOP      	@@: BREAK    
8000c2cc:	ff ff f8 ff 	.long     0xfff8ffff ->-00458753 

8000c2d0 <Canfd_LL_GetTimeSegments>:
##@@@F_:Canfd_LL_GetPropSeg():
##@@@P_:kf32a13k_drv_canfd.h:986
##@@@L0981_: * @return uint32_t   
##@@@L0982_: */   
##@@@L0983_:KF_INLINE uint32_t Canfd_LL_GetPropSeg(CanfdPtr Module)   
##@@@L0984_:{   
##@@@L0985_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0986_:    return (REG_READ(Module->CANFD_CTRL1.bits.PROPSEG));   
8000c2d0:	68 98       	LD.W      R5, [R0 + #1]
8000c2d2:	47 10       	MOV       R4, #7			;->0x0007
8000c2d4:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_GetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:358
##@@@L0353_: * @param BitRatePtr   
##@@@L0354_: * @retval void   
##@@@L0355_: */   
##@@@L0356_:void Canfd_LL_GetTimeSegments(CanfdPtr Module, Canfd_TimeSegment_t *BitRatePtr)   
##@@@L0357_:{   
##@@@L0358_:    BitRatePtr->propSeg    = Canfd_LL_GetPropSeg(Module);   
8000c2d6:	15 85       	ST.W      [R1], R5
##@@@F_:Canfd_LL_GetPSeg1():
##@@@P_:kf32a13k_drv_canfd.h:1009
##@@@L1004_: * @return uint32_t   
##@@@L1005_: */   
##@@@L1006_:KF_INLINE uint32_t Canfd_LL_GetPSeg1(CanfdPtr Module)   
##@@@L1007_:{   
##@@@L1008_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1009_:    return (REG_READ(Module->CANFD_CTRL1.bits.PSEG1));   
8000c2d8:	68 98       	LD.W      R5, [R0 + #1]
8000c2da:	2b 7d       	LSR       R5, #19			;->0x13
8000c2dc:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_GetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:359
##@@@L0359_:    BitRatePtr->phaseSeg1  = Canfd_LL_GetPSeg1(Module);   
8000c2de:	4d a0       	ST.W      [R1 + #1], R5
##@@@F_:Canfd_LL_GetPSeg2():
##@@@P_:kf32a13k_drv_canfd.h:1032
##@@@L1027_: * @return uint32_t   
##@@@L1028_: */   
##@@@L1029_:KF_INLINE uint32_t Canfd_LL_GetPSeg2(CanfdPtr Module)   
##@@@L1030_:{   
##@@@L1031_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1032_:    return (REG_READ(Module->CANFD_CTRL1.bits.PSEG2));   
8000c2e0:	68 98       	LD.W      R5, [R0 + #1]
8000c2e2:	28 7d       	LSR       R5, #16			;->0x10
8000c2e4:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_GetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:360
##@@@L0360_:    BitRatePtr->phaseSeg2  = Canfd_LL_GetPSeg2(Module);   
8000c2e6:	8d a0       	ST.W      [R1 + #2], R5
##@@@F_:Canfd_LL_GetPDivide():
##@@@P_:kf32a13k_drv_canfd.h:1055
##@@@L1050_: * @return uint32_t   
##@@@L1051_: */   
##@@@L1052_:KF_INLINE uint32_t Canfd_LL_GetPDivide(CanfdPtr Module)   
##@@@L1053_:{   
##@@@L1054_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1055_:    return (REG_READ(Module->CANFD_CTRL1.bits.PRESDIV));   
8000c2e8:	68 98       	LD.W      R5, [R0 + #1]
8000c2ea:	a8 7d       	LSR       R5, #24			;->0x18
##@@@F_:Canfd_LL_GetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:361
##@@@L0361_:    BitRatePtr->preDivider = Canfd_LL_GetPDivide(Module);   
8000c2ec:	cd a0       	ST.W      [R1 + #3], R5
##@@@F_:Canfd_LL_GetPDivide():
##@@@P_:kf32a13k_drv_canfd.h:1055
8000c2ee:	68 98       	LD.W      R5, [R0 + #1]
8000c2f0:	a8 7d       	LSR       R5, #24			;->0x18
##@@@F_:Canfd_LL_GetTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:362
##@@@L0362_:    BitRatePtr->rJumpwidth = Canfd_LL_GetPDivide(Module);   
8000c2f2:	0d a1       	ST.W      [R1 + #4], R5
##@@@P_:kf32a13k_drv_canfd.c:363
##@@@L0363_:}   
8000c2f4:	1d 5c       	JMP       LR
	...

8000c2f8 <Canfd_LL_GetFDTimeSegments>:
##@@@F_:Canfd_LL_GetFDPropSeg():
##@@@P_:kf32a13k_drv_canfd.h:1161
##@@@L1156_: * @return uint32_t   
##@@@L1157_: */   
##@@@L1158_:KF_INLINE uint32_t Canfd_LL_GetFDPropSeg(CanfdPtr Module)   
##@@@L1159_:{   
##@@@L1160_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1161_:    return (REG_READ(Module->CANFD_FDCBT.bits.FPROPSEG));   
8000c2f8:	0c 45       	LD        R5, [PC + #12]        ;->0x8000c328  :=0xc04
8000c2fa:	60 e9       	LD.W      R4, [R0 + R5]
8000c2fc:	a2 7c       	LSR       R4, #10			;->0x0A
8000c2fe:	3f 11       	MOV       R3, #31			;->0x001F
8000c300:	43 69       	ANL       R4, R3
##@@@F_:Canfd_LL_GetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:373
##@@@L0368_: * @param BitRatePtr   
##@@@L0369_: * @retval void   
##@@@L0370_: */   
##@@@L0371_:void Canfd_LL_GetFDTimeSegments(CanfdPtr Module, Canfd_TimeSegment_t *BitRatePtr)   
##@@@L0372_:{   
##@@@L0373_:    BitRatePtr->propSeg    = Canfd_LL_GetFDPropSeg(Module);   
8000c302:	14 85       	ST.W      [R1], R4
##@@@F_:Canfd_LL_GetFDSeg1():
##@@@P_:kf32a13k_drv_canfd.h:1184
##@@@L1179_: * @return uint32_t   
##@@@L1180_: */   
##@@@L1181_:KF_INLINE uint32_t Canfd_LL_GetFDSeg1(CanfdPtr Module)   
##@@@L1182_:{   
##@@@L1183_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1184_:    return (REG_READ(Module->CANFD_FDCBT.bits.FPSEG1));   
8000c304:	60 e9       	LD.W      R4, [R0 + R5]
8000c306:	25 7c       	LSR       R4, #5			;->0x05
8000c308:	37 10       	MOV       R3, #7			;->0x0007
8000c30a:	43 69       	ANL       R4, R3
##@@@F_:Canfd_LL_GetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:374
##@@@L0374_:    BitRatePtr->phaseSeg1  = Canfd_LL_GetFDSeg1(Module);   
8000c30c:	4c a0       	ST.W      [R1 + #1], R4
##@@@F_:Canfd_LL_GetFDPSeg2():
##@@@P_:kf32a13k_drv_canfd.h:1208
##@@@L1203_: * @return void   
##@@@L1204_: */   
##@@@L1205_:KF_INLINE uint32_t Canfd_LL_GetFDPSeg2(CanfdPtr Module)   
##@@@L1206_:{   
##@@@L1207_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1208_:    return (REG_READ(Module->CANFD_FDCBT.bits.FPSEG2));   
8000c30e:	60 e9       	LD.W      R4, [R0 + R5]
8000c310:	43 69       	ANL       R4, R3
##@@@F_:Canfd_LL_GetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:375
##@@@L0375_:    BitRatePtr->phaseSeg2  = Canfd_LL_GetFDPSeg2(Module);   
8000c312:	8c a0       	ST.W      [R1 + #2], R4
##@@@F_:Canfd_LL_GetFDPDivide():
##@@@P_:kf32a13k_drv_canfd.h:1232
##@@@L1227_: * @return void   
##@@@L1228_: */   
##@@@L1229_:KF_INLINE uint32_t Canfd_LL_GetFDPDivide(CanfdPtr Module)   
##@@@L1230_:{   
##@@@L1231_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1232_:    return (REG_READ(Module->CANFD_FDCBT.bits.FPRESDIV));   
8000c314:	60 e9       	LD.W      R4, [R0 + R5]
8000c316:	06 42       	LD        R2, [PC + #6]         ;->0x8000c32c  :=0x3ff
8000c318:	24 7d       	LSR       R4, #20			;->0x14
8000c31a:	42 69       	ANL       R4, R2
##@@@F_:Canfd_LL_GetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:376
##@@@L0376_:    BitRatePtr->preDivider = Canfd_LL_GetFDPDivide(Module);   
8000c31c:	cc a0       	ST.W      [R1 + #3], R4
##@@@F_:Canfd_LL_GetFDPRJW():
##@@@P_:kf32a13k_drv_canfd.h:1256
##@@@L1251_: * @return void   
##@@@L1252_: */   
##@@@L1253_:KF_INLINE uint32_t Canfd_LL_GetFDPRJW(CanfdPtr Module)   
##@@@L1254_:{   
##@@@L1255_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1256_:    return (REG_READ(Module->CANFD_FDCBT.bits.FRJW));   
8000c31e:	68 e9       	LD.W      R5, [R0 + R5]
8000c320:	28 7d       	LSR       R5, #16			;->0x10
8000c322:	53 69       	ANL       R5, R3
##@@@F_:Canfd_LL_GetFDTimeSegments():
##@@@P_:kf32a13k_drv_canfd.c:377
##@@@L0377_:    BitRatePtr->rJumpwidth = Canfd_LL_GetFDPRJW(Module);   
8000c324:	0d a1       	ST.W      [R1 + #4], R5
##@@@P_:kf32a13k_drv_canfd.c:378
##@@@L0378_:}   
8000c326:	1d 5c       	JMP       LR
8000c328:	04 0c 00 00 	.long     0x00000c04 ->000003076  [!!!@2@:LD.W      R4, [SP + #4]	@@: NOP      
8000c32c:	ff 03 00 00 	.long     0x000003ff ->000001023  [!!!@4@:JMP       $-65536               ;->0x7ffec32c

8000c330 <Canfd_LL_GetNoOfIndividualMB>:
##@@@F_:Canfd_LL_GetLegacyFifoFilterNum():
##@@@P_:kf32a13k_drv_canfd.h:1292
##@@@L1287_: * @return uint32_t   
##@@@L1288_: */   
##@@@L1289_:KF_INLINE uint32_t Canfd_LL_GetLegacyFifoFilterNum(CanfdPtr Module)   
##@@@L1290_:{   
##@@@L1291_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1292_:    return (REG_READ(Module->CANFD_CTRL2.bits.RFFN));   
8000c330:	68 9b       	LD.W      R5, [R0 + #13]
##@@@F_:Canfd_LL_GetNoOfIndividualMB():
##@@@P_:kf32a13k_drv_canfd.c:391
##@@@L0386_:{   
##@@@L0387_:    /* Get the number of RX FIFO Filters*/   
##@@@L0388_:    uint8_t count = Canfd_LL_GetLegacyFifoFilterNum(Module);   
##@@@L0389_:    /* Max filters configured by individual mask are (7 + RFFN * 2) depends on the FIFO size,   
##@@@L0390_:     * max allowed value is 31 RXIMR */   
##@@@L0391_:    count = (uint8_t)(7u + ((uint32_t)count << 1u));   
8000c332:	2f 7d       	LSR       R5, #23			;->0x17
8000c334:	4e 11       	MOV       R4, #30			;->0x001E
8000c336:	54 69       	ANL       R5, R4
8000c338:	c5 c1       	ADD       R0, R5, #7
##@@@P_:kf32a13k_drv_canfd.c:396
##@@@L0392_:    if (count >= CANFD_MAX_MBNUM)   
##@@@L0393_:    {   
##@@@L0394_:        count = (uint8_t)(CANFD_MAX_MBNUM - 1u);   
##@@@L0395_:    }   
##@@@L0396_:    return count;   
8000c33a:	1d 5c       	JMP       LR

8000c33c <Canfd_LL_ClearErrIntStatusFlag>:
##@@@F_:Canfd_LL_ClearErrIntStatusFlag():
##@@@P_:kf32a13k_drv_canfd.c:406
##@@@L0401_: * @param[in] Module 指向CANFD内存结构的指针，取值为CANFD0-CANFD7   
##@@@L0402_: * @return void   
##@@@L0403_: */   
##@@@L0404_:void Canfd_LL_ClearErrIntStatusFlag(CanfdPtr Module)   
##@@@L0405_:{   
##@@@L0406_:    if (0U != (Module->CANFD_ESR1.reg & CANFD_ALL_INT))   
8000c33c:	20 9a       	LD.W      R4, [R0 + #8]
8000c33e:	04 45       	LD        R5, [PC + #4]         ;->0x8000c34c  :=0x3b0007
8000c340:	45 69       	ANL       R4, R5
8000c342:	40 38       	CMP       R4, #0			;->0x00
8000c344:	02 f0       	JZ        $+2                   ;->0x8000c348
##@@@P_:kf32a13k_drv_canfd.c:408
##@@@L0407_:    {   
##@@@L0408_:        Module->CANFD_ESR1.reg = CANFD_ALL_INT;   
8000c346:	05 a2       	ST.W      [R0 + #8], R5
##@@@P_:kf32a13k_drv_canfd.c:410
##@@@L0409_:    }   
##@@@L0410_:}   
8000c348:	1d 5c       	JMP       LR
8000c34a:	00 00       	NOP      NOP      
8000c34c:	07 00 3b 00 	.long     0x003b0007 ->003866631 

8000c350 <Canfd_LL_SetPNIdFilter1>:
##@@@F_:Canfd_LL_SetPNExtendEnabled():
##@@@P_:kf32a13k_drv_canfd.c:419
##@@@L0414_: * @param[in] Module 指向CANFD内存结构的指针，取值为CANFD0-CANFD7   
##@@@L0415_: * @param[in] IdFilter 滤波器1 ID参数   
##@@@L0416_: * @return void   
##@@@L0417_: */   
##@@@L0418_:void Canfd_LL_SetPNIdFilter1(CanfdPtr Module, Canfd_PnIdFilter_t IdFilter)   
##@@@L0419_:{   
8000c350:	03 5f       	PUSH      {R6-R7}
8000c352:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kf32a13k_drv_canfd.h:1899
##@@@L1894_: * @return void   
##@@@L1895_: */   
##@@@L1896_:KF_INLINE void Canfd_LL_SetPNExtendEnabled(CanfdPtr Module, const bool IsExtended)   
##@@@L1897_:{   
##@@@L1898_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1899_:    REG_WRITE(Module->CANFD_FLT_ID1.bits.FLT_IDE, IsExtended);   
8000c354:	11 45       	LD        R5, [PC + #17]        ;->0x8000c398  :=0xb0c
8000c356:	60 e9       	LD.W      R4, [R0 + R5]
8000c358:	11 46       	LD        R6, [PC + #17]        ;->0x8000c39c  :=0xbfffffff
8000c35a:	71 10       	MOV       R7, #1			;->0x0001
##@@@F_:Canfd_LL_SetPNIdFilter1():
##@@@P_:kf32a13k_drv_canfd.c:420
##@@@L0420_:    Canfd_LL_SetPNExtendEnabled(Module, IdFilter.extendedId);   
8000c35c:	61 58       	MOV       R3, R1
8000c35e:	37 69       	ANL       R3, R7
##@@@F_:Canfd_LL_SetPNExtendEnabled():
##@@@P_:kf32a13k_drv_canfd.h:1899
8000c360:	46 69       	ANL       R4, R6
##@@@F_:Canfd_LL_SetPNIdFilter1():
##@@@P_:kf32a13k_drv_canfd.c:422
##@@@L0421_:    Canfd_LL_SetPNRemoteEnabled(Module, IdFilter.remoteFrame);   
##@@@L0422_:    if (IdFilter.extendedId)   
8000c362:	30 38       	CMP       R3, #0			;->0x00
8000c364:	03 f0       	JZ        $+3                   ;->0x8000c36a
8000c366:	0f 46       	LD        R6, [PC + #15]        ;->0x8000c3a0  :=0x1fffffff
8000c368:	03 04       	SJMP      $+3                   ;->0x8000c36e
8000c36a:	0f 46       	LD        R6, [PC + #15]        ;->0x8000c3a4  :=0x1ffc0000
8000c36c:	12 7b       	LSL       R2, #18			;->0x12
8000c36e:	26 69       	ANL       R2, R6
##@@@F_:Canfd_LL_SetPNExtendEnabled():
##@@@P_:kf32a13k_drv_canfd.h:1899
8000c370:	9e 7b       	LSL       R3, #30			;->0x1E
8000c372:	43 6a       	ORL       R4, R3
8000c374:	44 ef       	ST.W      [R0 + R5], R4
##@@@F_:Canfd_LL_SetPNRemoteEnabled():
##@@@P_:kf32a13k_drv_canfd.h:1910
##@@@L1905_: * @return void   
##@@@L1906_: */   
##@@@L1907_:KF_INLINE void Canfd_LL_SetPNRemoteEnabled(CanfdPtr Module, const bool IsRemote)   
##@@@L1908_:{   
##@@@L1909_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1910_:    REG_WRITE(Module->CANFD_FLT_ID1.bits.FLT_RTR, IsRemote);   
8000c376:	0d 7b       	LSL       R1, #21			;->0x15
8000c378:	0c 44       	LD        R4, [PC + #12]        ;->0x8000c3a8  :=0x20000000
8000c37a:	58 e9       	LD.W      R3, [R0 + R5]
8000c37c:	0c 46       	LD        R6, [PC + #12]        ;->0x8000c3ac  :=0xdfffffff
8000c37e:	14 69       	ANL       R1, R4
8000c380:	36 69       	ANL       R3, R6
8000c382:	31 6a       	ORL       R3, R1
8000c384:	43 ef       	ST.W      [R0 + R5], R3
8000c386:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c3b0  :=0xe0000000
##@@@F_:Canfd_LL_SetPNIdFilter1():
8000c388:	58 e9       	LD.W      R3, [R0 + R5]
8000c38a:	34 69       	ANL       R3, R4
8000c38c:	32 6a       	ORL       R3, R2
8000c38e:	43 ef       	ST.W      [R0 + R5], R3
##@@@P_:kf32a13k_drv_canfd.c:430
##@@@L0425_:    }   
##@@@L0426_:    else   
##@@@L0427_:    {   
##@@@L0428_:        Canfd_LL_SetPNStandId(Module, IdFilter.id);   
##@@@L0429_:    }   
##@@@L0430_:}   
8000c390:	e4 28       	ADD       SP, #4			;->0x04
8000c392:	03 5e       	POP       {R6-R7}
8000c394:	1d 5c       	JMP       LR
8000c396:	00 00       	NOP      NOP      
8000c398:	0c 0b 00 00 	.long     0x00000b0c ->000002828  [!!!@2@:LD.W      R3, [SP + #12]	@@: NOP      
8000c39c:	ff ff ff bf 	.long     0xbfffffff ->-1073741825 
8000c3a0:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000c3a4:	00 00 fc 1f 	.long     0x1ffc0000 ->536608768  [!!!@2@:NOP      	@@: MOV       PC, #252
8000c3a8:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000c3ac:	ff ff ff df 	.long     0xdfffffff ->-536870913 
8000c3b0:	00 00 00 e0 	.long     0xe0000000 ->-536870912  [!!!@2@:NOP      	@@: LD.H      R0, [SP + #0]

8000c3b4 <Canfd_LL_SetPNIdFilter2Check>:
##@@@F_:Canfd_LL_GetPNMask():
##@@@P_:kf32a13k_drv_canfd.h:1987
##@@@L1982_: * @return uint32_t   
##@@@L1983_: */   
##@@@L1984_:KF_INLINE uint32_t Canfd_LL_GetPNMask(CanfdPtr Module)   
##@@@L1985_:{   
##@@@L1986_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1987_:    return (REG_READ(Module->CANFD_FLT_ID2_IDMASK.reg));   
8000c3b4:	03 45       	LD        R5, [PC + #3]         ;->0x8000c3c0  :=0xb1c
8000c3b6:	60 e9       	LD.W      R4, [R0 + R5]
8000c3b8:	03 43       	LD        R3, [PC + #3]         ;->0x8000c3c4  :=0x60000000
##@@@F_:Canfd_LL_SetPNIdFilter2Check():
##@@@P_:kf32a13k_drv_canfd.c:441
##@@@L0436_: */   
##@@@L0437_:void Canfd_LL_SetPNIdFilter2Check(CanfdPtr Module)   
##@@@L0438_:{   
##@@@L0439_:    uint32_t temp = 0U;   
##@@@L0440_:    temp          = CAN_FLT_ID2_IDMASK_IDE_MSK_MASK | CAN_FLT_ID2_IDMASK_RTR_MSK_MASK;   
##@@@L0441_:    temp          = Canfd_LL_GetPNMask(Module) | temp;   
8000c3ba:	43 6a       	ORL       R4, R3
##@@@F_:Canfd_LL_SetPNMask():
##@@@P_:kf32a13k_drv_canfd.h:1998
##@@@L1993_: * @return void   
##@@@L1994_: */   
##@@@L1995_:KF_INLINE void Canfd_LL_SetPNMask(CanfdPtr Module, const uint32_t Mask)   
##@@@L1996_:{   
##@@@L1997_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1998_:    REG_WRITE(Module->CANFD_FLT_ID2_IDMASK.reg, Mask);   
8000c3bc:	44 ef       	ST.W      [R0 + R5], R4
##@@@F_:Canfd_LL_SetPNIdFilter2Check():
##@@@P_:kf32a13k_drv_canfd.c:443
##@@@L0442_:    Canfd_LL_SetPNMask(Module, temp);   
##@@@L0443_:}   
8000c3be:	1d 5c       	JMP       LR
8000c3c0:	1c 0b 00 00 	.long     0x00000b1c ->000002844  [!!!@2@:LD.W      R3, [SP + #28]	@@: NOP      
8000c3c4:	00 00 00 60 	.long     0x60000000 ->1610612736  [!!!@2@:NOP      	@@: REV       R0, R0

8000c3c8 <Canfd_LL_SetPNIdFilter2>:
##@@@F_:Canfd_LL_SetPNExtendMask():
##@@@P_:kf32a13k_drv_canfd.c:452
##@@@L0447_: * @param[in] Module 指向CANFD内存结构的指针，取值为CANFD0-CANFD7   
##@@@L0448_: * @param[in] IdFilter 滤波器2 ID参数   
##@@@L0449_: * @return void   
##@@@L0450_: */   
##@@@L0451_:void Canfd_LL_SetPNIdFilter2(CanfdPtr Module, Canfd_PnIdFilter_t IdFilter)   
##@@@L0452_:{   
8000c3c8:	03 5f       	PUSH      {R6-R7}
8000c3ca:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kf32a13k_drv_canfd.h:1943
##@@@L1938_: * @return void   
##@@@L1939_: */   
##@@@L1940_:KF_INLINE void Canfd_LL_SetPNExtendMask(CanfdPtr Module, const bool ExtendedMask)   
##@@@L1941_:{   
##@@@L1942_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1943_:    REG_WRITE(Module->CANFD_FLT_ID2_IDMASK.bits.IDE_MSK, ExtendedMask);   
8000c3cc:	11 45       	LD        R5, [PC + #17]        ;->0x8000c410  :=0xb1c
8000c3ce:	60 e9       	LD.W      R4, [R0 + R5]
8000c3d0:	11 46       	LD        R6, [PC + #17]        ;->0x8000c414  :=0xbfffffff
8000c3d2:	71 10       	MOV       R7, #1			;->0x0001
##@@@F_:Canfd_LL_SetPNIdFilter2():
##@@@P_:kf32a13k_drv_canfd.c:453
##@@@L0453_:    Canfd_LL_SetPNExtendMask(Module, IdFilter.extendedId);   
8000c3d4:	61 58       	MOV       R3, R1
8000c3d6:	37 69       	ANL       R3, R7
##@@@F_:Canfd_LL_SetPNExtendMask():
##@@@P_:kf32a13k_drv_canfd.h:1943
8000c3d8:	46 69       	ANL       R4, R6
##@@@F_:Canfd_LL_SetPNIdFilter2():
##@@@P_:kf32a13k_drv_canfd.c:455
##@@@L0454_:    Canfd_LL_SetPNRemoteMask(Module, IdFilter.remoteFrame);   
##@@@L0455_:    if (IdFilter.extendedId)   
8000c3da:	30 38       	CMP       R3, #0			;->0x00
8000c3dc:	03 f0       	JZ        $+3                   ;->0x8000c3e2
8000c3de:	0f 46       	LD        R6, [PC + #15]        ;->0x8000c418  :=0x1fffffff
8000c3e0:	03 04       	SJMP      $+3                   ;->0x8000c3e6
8000c3e2:	0f 46       	LD        R6, [PC + #15]        ;->0x8000c41c  :=0x1ffc0000
8000c3e4:	12 7b       	LSL       R2, #18			;->0x12
8000c3e6:	26 69       	ANL       R2, R6
##@@@F_:Canfd_LL_SetPNExtendMask():
##@@@P_:kf32a13k_drv_canfd.h:1943
8000c3e8:	9e 7b       	LSL       R3, #30			;->0x1E
8000c3ea:	43 6a       	ORL       R4, R3
8000c3ec:	44 ef       	ST.W      [R0 + R5], R4
##@@@F_:Canfd_LL_SetPNRemoteMask():
##@@@P_:kf32a13k_drv_canfd.h:1954
##@@@L1949_: * @return void   
##@@@L1950_: */   
##@@@L1951_:KF_INLINE void Canfd_LL_SetPNRemoteMask(CanfdPtr Module, const bool RemoteMask)   
##@@@L1952_:{   
##@@@L1953_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1954_:    REG_WRITE(Module->CANFD_FLT_ID2_IDMASK.bits.RTR_MSK, RemoteMask);   
8000c3ee:	0d 7b       	LSL       R1, #21			;->0x15
8000c3f0:	0c 44       	LD        R4, [PC + #12]        ;->0x8000c420  :=0x20000000
8000c3f2:	58 e9       	LD.W      R3, [R0 + R5]
8000c3f4:	0c 46       	LD        R6, [PC + #12]        ;->0x8000c424  :=0xdfffffff
8000c3f6:	14 69       	ANL       R1, R4
8000c3f8:	36 69       	ANL       R3, R6
8000c3fa:	31 6a       	ORL       R3, R1
8000c3fc:	43 ef       	ST.W      [R0 + R5], R3
8000c3fe:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c428  :=0xe0000000
##@@@F_:Canfd_LL_SetPNIdFilter2():
8000c400:	58 e9       	LD.W      R3, [R0 + R5]
8000c402:	34 69       	ANL       R3, R4
8000c404:	32 6a       	ORL       R3, R2
8000c406:	43 ef       	ST.W      [R0 + R5], R3
##@@@P_:kf32a13k_drv_canfd.c:463
##@@@L0458_:    }   
##@@@L0459_:    else   
##@@@L0460_:    {   
##@@@L0461_:        Canfd_LL_SetPNStandIdMask(Module, IdFilter.id);   
##@@@L0462_:    }   
##@@@L0463_:}   
8000c408:	e4 28       	ADD       SP, #4			;->0x04
8000c40a:	03 5e       	POP       {R6-R7}
8000c40c:	1d 5c       	JMP       LR
8000c40e:	00 00       	NOP      NOP      
8000c410:	1c 0b 00 00 	.long     0x00000b1c ->000002844  [!!!@2@:LD.W      R3, [SP + #28]	@@: NOP      
8000c414:	ff ff ff bf 	.long     0xbfffffff ->-1073741825 
8000c418:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000c41c:	00 00 fc 1f 	.long     0x1ffc0000 ->536608768  [!!!@2@:NOP      	@@: MOV       PC, #252
8000c420:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000c424:	ff ff ff df 	.long     0xdfffffff ->-536870913 
8000c428:	00 00 00 e0 	.long     0xe0000000 ->-536870912  [!!!@2@:NOP      	@@: LD.H      R0, [SP + #0]

8000c42c <Canfd_LL_SetPNDlcFilter>:
##@@@F_:Canfd_LL_SetPNLowDLC():
##@@@P_:kf32a13k_drv_canfd.c:473
##@@@L0468_: * @param[in] DlcLow DLC下限   
##@@@L0469_: * @param[in] DlcHigh DLC上限   
##@@@L0470_: * @return void   
##@@@L0471_: */   
##@@@L0472_:void Canfd_LL_SetPNDlcFilter(CanfdPtr Module, uint8_t DlcLow, uint8_t DlcHigh)   
##@@@L0473_:{   
8000c42c:	26 5d       	PUSH      R6
8000c42e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kf32a13k_drv_canfd.h:2009
##@@@L2004_: * @return void   
##@@@L2005_: */   
##@@@L2006_:KF_INLINE void Canfd_LL_SetPNLowDLC(CanfdPtr Module, const uint32_t LowDLC)   
##@@@L2007_:{   
##@@@L2008_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2009_:    REG_WRITE(Module->CANFD_FLT_DLC.bits.FLT_DLC_LO, LowDLC);   
8000c430:	08 7b       	LSL       R1, #16			;->0x10
8000c432:	0a 45       	LD        R5, [PC + #10]        ;->0x8000c458  :=0xb10
8000c434:	0a 44       	LD        R4, [PC + #10]        ;->0x8000c45c  :=0xf0000
8000c436:	58 e9       	LD.W      R3, [R0 + R5]
8000c438:	0a 46       	LD        R6, [PC + #10]        ;->0x8000c460  :=0xfff0ffff
8000c43a:	14 69       	ANL       R1, R4
8000c43c:	36 69       	ANL       R3, R6
8000c43e:	31 6a       	ORL       R3, R1
8000c440:	43 ef       	ST.W      [R0 + R5], R3
8000c442:	4f 10       	MOV       R4, #15			;->0x000F
##@@@F_:Canfd_LL_SetPNHighDLC():
##@@@P_:kf32a13k_drv_canfd.h:2020
##@@@L2015_: * @return void   
##@@@L2016_: */   
##@@@L2017_:KF_INLINE void Canfd_LL_SetPNHighDLC(CanfdPtr Module, const uint32_t HighDLC)   
##@@@L2018_:{   
##@@@L2019_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2020_:    REG_WRITE(Module->CANFD_FLT_DLC.bits.FLT_DLC_HI, HighDLC);   
8000c444:	58 e9       	LD.W      R3, [R0 + R5]
8000c446:	08 41       	LD        R1, [PC + #8]         ;->0x8000c464  :=0xfffffff0
8000c448:	24 69       	ANL       R2, R4
8000c44a:	31 69       	ANL       R3, R1
8000c44c:	32 6a       	ORL       R3, R2
8000c44e:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_SetPNDlcFilter():
##@@@P_:kf32a13k_drv_canfd.c:476
##@@@L0474_:    Canfd_LL_SetPNLowDLC(Module, DlcLow);   
##@@@L0475_:    Canfd_LL_SetPNHighDLC(Module, DlcHigh);   
##@@@L0476_:}   
8000c450:	e4 28       	ADD       SP, #4			;->0x04
8000c452:	06 5d       	POP       R6
8000c454:	1d 5c       	JMP       LR
8000c456:	00 00       	NOP      NOP      
8000c458:	10 0b 00 00 	.long     0x00000b10 ->000002832  [!!!@2@:LD.W      R3, [SP + #16]	@@: NOP      
8000c45c:	00 00 0f 00 	.long     0x000f0000 ->000983040 
8000c460:	ff ff f0 ff 	.long     0xfff0ffff ->-00983041 
8000c464:	f0 ff ff ff 	.long     0xfffffff0 ->-00000016 

8000c468 <Canfd_LL_SetPNPayloadHighFilter1>:
##@@@F_:Canfd_LL_SetPNHighPayLoadByte4():
##@@@P_:kf32a13k_drv_canfd.h:2075
##@@@L2070_: * @return void   
##@@@L2071_: */   
##@@@L2072_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte4(CanfdPtr Module, const uint8_t Data)   
##@@@L2073_:{   
##@@@L2074_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2075_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_4, Data);   
8000c468:	0f 45       	LD        R5, [PC + #15]        ;->0x8000c4a4  :=0xb18
8000c46a:	21 89       	LD.B      R4, [R1 + #4]
8000c46c:	58 e9       	LD.W      R3, [R0 + R5]
8000c46e:	0f 42       	LD        R2, [PC + #15]        ;->0x8000c4a8  :=0xffffff
8000c470:	32 69       	ANL       R3, R2
8000c472:	a0 7b       	LSL       R4, #24			;->0x18
8000c474:	34 6a       	ORL       R3, R4
8000c476:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_SetPNPayloadHighFilter1():
##@@@P_:kf32a13k_drv_canfd.c:488
##@@@L0483_: */   
##@@@L0484_:void Canfd_LL_SetPNPayloadHighFilter1(CanfdPtr Module, const uint8_t *PayloadPtr)   
##@@@L0485_:{   
##@@@L0486_:    // TODO:后续优化数据结构   
##@@@L0487_:    Canfd_LL_SetPNHighPayLoadByte4(Module, PayloadPtr[4]);   
##@@@L0488_:    Canfd_LL_SetPNHighPayLoadByte5(Module, PayloadPtr[5]);   
8000c478:	61 89       	LD.B      R4, [R1 + #5]
8000c47a:	0d 43       	LD        R3, [PC + #13]        ;->0x8000c4ac  :=0xff00ffff
##@@@F_:Canfd_LL_SetPNHighPayLoadByte5():
##@@@P_:kf32a13k_drv_canfd.h:2086
##@@@L2081_: * @return void   
##@@@L2082_: */   
##@@@L2083_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte5(CanfdPtr Module, const uint8_t Data)   
##@@@L2084_:{   
##@@@L2085_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2086_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_5, Data);   
8000c47c:	50 e9       	LD.W      R2, [R0 + R5]
8000c47e:	23 69       	ANL       R2, R3
8000c480:	20 7b       	LSL       R4, #16			;->0x10
8000c482:	24 6a       	ORL       R2, R4
8000c484:	42 ef       	ST.W      [R0 + R5], R2
8000c486:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c4b0  :=0xffff00ff
##@@@F_:Canfd_LL_SetPNPayloadHighFilter1():
##@@@P_:kf32a13k_drv_canfd.c:489
##@@@L0489_:    Canfd_LL_SetPNHighPayLoadByte6(Module, PayloadPtr[6]);   
8000c488:	99 89       	LD.B      R3, [R1 + #6]
##@@@F_:Canfd_LL_SetPNHighPayLoadByte6():
##@@@P_:kf32a13k_drv_canfd.h:2097
##@@@L2092_: * @return void   
##@@@L2093_: */   
##@@@L2094_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte6(CanfdPtr Module, const uint8_t Data)   
##@@@L2095_:{   
##@@@L2096_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2097_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_6, Data);   
8000c48a:	50 e9       	LD.W      R2, [R0 + R5]
8000c48c:	24 69       	ANL       R2, R4
8000c48e:	98 7a       	LSL       R3, #8			;->0x08
8000c490:	23 6a       	ORL       R2, R3
8000c492:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadHighFilter1():
##@@@P_:kf32a13k_drv_canfd.c:490
##@@@L0490_:    Canfd_LL_SetPNHighPayLoadByte7(Module, PayloadPtr[7]);   
8000c494:	e1 89       	LD.B      R4, [R1 + #7]
8000c496:	08 43       	LD        R3, [PC + #8]         ;->0x8000c4b4  :=0xffffff00
##@@@F_:Canfd_LL_SetPNHighPayLoadByte7():
##@@@P_:kf32a13k_drv_canfd.h:2108
##@@@L2103_: * @return void   
##@@@L2104_: */   
##@@@L2105_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte7(CanfdPtr Module, const uint8_t Data)   
##@@@L2106_:{   
##@@@L2107_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2108_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_7, Data);   
8000c498:	50 e9       	LD.W      R2, [R0 + R5]
8000c49a:	23 69       	ANL       R2, R3
8000c49c:	24 6a       	ORL       R2, R4
8000c49e:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadHighFilter1():
##@@@P_:kf32a13k_drv_canfd.c:491
##@@@L0491_:}   
8000c4a0:	1d 5c       	JMP       LR
8000c4a2:	00 00       	NOP      NOP      
8000c4a4:	18 0b 00 00 	.long     0x00000b18 ->000002840  [!!!@2@:LD.W      R3, [SP + #24]	@@: NOP      
8000c4a8:	ff ff ff 00 	.long     0x00ffffff ->016777215 
8000c4ac:	ff ff 00 ff 	.long     0xff00ffff ->-16711681 
8000c4b0:	ff 00 ff ff 	.long     0xffff00ff ->-00065281 
8000c4b4:	00 ff ff ff 	.long     0xffffff00 ->-00000256 

8000c4b8 <Canfd_LL_SetPNPayloadLowFilter1>:
##@@@F_:Canfd_LL_SetPNLowPayLoadByte0():
##@@@P_:kf32a13k_drv_canfd.h:2031
##@@@L2026_: * @return void   
##@@@L2027_: */   
##@@@L2028_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte0(CanfdPtr Module, const uint8_t Data)   
##@@@L2029_:{   
##@@@L2030_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2031_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_0, Data);   
8000c4b8:	0f 45       	LD        R5, [PC + #15]        ;->0x8000c4f4  :=0xb14
8000c4ba:	41 80       	LD.B      R4, [R1]
8000c4bc:	58 e9       	LD.W      R3, [R0 + R5]
8000c4be:	0f 42       	LD        R2, [PC + #15]        ;->0x8000c4f8  :=0xffffff
8000c4c0:	32 69       	ANL       R3, R2
8000c4c2:	a0 7b       	LSL       R4, #24			;->0x18
8000c4c4:	34 6a       	ORL       R3, R4
8000c4c6:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_SetPNPayloadLowFilter1():
##@@@P_:kf32a13k_drv_canfd.c:503
##@@@L0498_: */   
##@@@L0499_:void Canfd_LL_SetPNPayloadLowFilter1(CanfdPtr Module, const uint8_t *PayloadPtr)   
##@@@L0500_:{   
##@@@L0501_:    // TODO:后续优化数据结构   
##@@@L0502_:    Canfd_LL_SetPNLowPayLoadByte0(Module, PayloadPtr[0]);   
##@@@L0503_:    Canfd_LL_SetPNLowPayLoadByte1(Module, PayloadPtr[1]);   
8000c4c8:	61 88       	LD.B      R4, [R1 + #1]
8000c4ca:	0d 43       	LD        R3, [PC + #13]        ;->0x8000c4fc  :=0xff00ffff
##@@@F_:Canfd_LL_SetPNLowPayLoadByte1():
##@@@P_:kf32a13k_drv_canfd.h:2042
##@@@L2037_: * @return void   
##@@@L2038_: */   
##@@@L2039_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte1(CanfdPtr Module, const uint8_t Data)   
##@@@L2040_:{   
##@@@L2041_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2042_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_1, Data);   
8000c4cc:	50 e9       	LD.W      R2, [R0 + R5]
8000c4ce:	23 69       	ANL       R2, R3
8000c4d0:	20 7b       	LSL       R4, #16			;->0x10
8000c4d2:	24 6a       	ORL       R2, R4
8000c4d4:	42 ef       	ST.W      [R0 + R5], R2
8000c4d6:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c500  :=0xffff00ff
##@@@F_:Canfd_LL_SetPNPayloadLowFilter1():
##@@@P_:kf32a13k_drv_canfd.c:504
##@@@L0504_:    Canfd_LL_SetPNLowPayLoadByte2(Module, PayloadPtr[2]);   
8000c4d8:	99 88       	LD.B      R3, [R1 + #2]
##@@@F_:Canfd_LL_SetPNLowPayLoadByte2():
##@@@P_:kf32a13k_drv_canfd.h:2053
##@@@L2048_: * @return void   
##@@@L2049_: */   
##@@@L2050_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte2(CanfdPtr Module, const uint8_t Data)   
##@@@L2051_:{   
##@@@L2052_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2053_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_2, Data);   
8000c4da:	50 e9       	LD.W      R2, [R0 + R5]
8000c4dc:	24 69       	ANL       R2, R4
8000c4de:	98 7a       	LSL       R3, #8			;->0x08
8000c4e0:	23 6a       	ORL       R2, R3
8000c4e2:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadLowFilter1():
##@@@P_:kf32a13k_drv_canfd.c:505
##@@@L0505_:    Canfd_LL_SetPNLowPayLoadByte3(Module, PayloadPtr[3]);   
8000c4e4:	e1 88       	LD.B      R4, [R1 + #3]
8000c4e6:	08 43       	LD        R3, [PC + #8]         ;->0x8000c504  :=0xffffff00
##@@@F_:Canfd_LL_SetPNLowPayLoadByte3():
##@@@P_:kf32a13k_drv_canfd.h:2064
##@@@L2059_: * @return void   
##@@@L2060_: */   
##@@@L2061_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte3(CanfdPtr Module, const uint8_t Data)   
##@@@L2062_:{   
##@@@L2063_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2064_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_3, Data);   
8000c4e8:	50 e9       	LD.W      R2, [R0 + R5]
8000c4ea:	23 69       	ANL       R2, R3
8000c4ec:	24 6a       	ORL       R2, R4
8000c4ee:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadLowFilter1():
##@@@P_:kf32a13k_drv_canfd.c:506
##@@@L0506_:}   
8000c4f0:	1d 5c       	JMP       LR
8000c4f2:	00 00       	NOP      NOP      
8000c4f4:	14 0b 00 00 	.long     0x00000b14 ->000002836  [!!!@2@:LD.W      R3, [SP + #20]	@@: NOP      
8000c4f8:	ff ff ff 00 	.long     0x00ffffff ->016777215 
8000c4fc:	ff ff 00 ff 	.long     0xff00ffff ->-16711681 
8000c500:	ff 00 ff ff 	.long     0xffff00ff ->-00065281 
8000c504:	00 ff ff ff 	.long     0xffffff00 ->-00000256 

8000c508 <Canfd_LL_SetPNPayloadHighFilter2>:
##@@@F_:Canfd_LL_SetPNHighPayLoadByte4Mask():
##@@@P_:kf32a13k_drv_canfd.h:2163
##@@@L2158_: * @return void   
##@@@L2159_: */   
##@@@L2160_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte4Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2161_:{   
##@@@L2162_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2163_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_4, Data);   
8000c508:	0f 45       	LD        R5, [PC + #15]        ;->0x8000c544  :=0xb24
8000c50a:	21 89       	LD.B      R4, [R1 + #4]
8000c50c:	58 e9       	LD.W      R3, [R0 + R5]
8000c50e:	0f 42       	LD        R2, [PC + #15]        ;->0x8000c548  :=0xffffff
8000c510:	32 69       	ANL       R3, R2
8000c512:	a0 7b       	LSL       R4, #24			;->0x18
8000c514:	34 6a       	ORL       R3, R4
8000c516:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_SetPNPayloadHighFilter2():
##@@@P_:kf32a13k_drv_canfd.c:518
##@@@L0513_: */   
##@@@L0514_:void Canfd_LL_SetPNPayloadHighFilter2(CanfdPtr Module, const uint8_t *PayloadPtr)   
##@@@L0515_:{   
##@@@L0516_:    // TODO:后续优化数据结构   
##@@@L0517_:    Canfd_LL_SetPNHighPayLoadByte4Mask(Module, PayloadPtr[4]);   
##@@@L0518_:    Canfd_LL_SetPNHighPayLoadByte5Mask(Module, PayloadPtr[5]);   
8000c518:	61 89       	LD.B      R4, [R1 + #5]
8000c51a:	0d 43       	LD        R3, [PC + #13]        ;->0x8000c54c  :=0xff00ffff
##@@@F_:Canfd_LL_SetPNHighPayLoadByte5Mask():
##@@@P_:kf32a13k_drv_canfd.h:2174
##@@@L2169_: * @return void   
##@@@L2170_: */   
##@@@L2171_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte5Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2172_:{   
##@@@L2173_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2174_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_5, Data);   
8000c51c:	50 e9       	LD.W      R2, [R0 + R5]
8000c51e:	23 69       	ANL       R2, R3
8000c520:	20 7b       	LSL       R4, #16			;->0x10
8000c522:	24 6a       	ORL       R2, R4
8000c524:	42 ef       	ST.W      [R0 + R5], R2
8000c526:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c550  :=0xffff00ff
##@@@F_:Canfd_LL_SetPNPayloadHighFilter2():
##@@@P_:kf32a13k_drv_canfd.c:519
##@@@L0519_:    Canfd_LL_SetPNHighPayLoadByte6Mask(Module, PayloadPtr[6]);   
8000c528:	99 89       	LD.B      R3, [R1 + #6]
##@@@F_:Canfd_LL_SetPNHighPayLoadByte6Mask():
##@@@P_:kf32a13k_drv_canfd.h:2185
##@@@L2180_: * @return void   
##@@@L2181_: */   
##@@@L2182_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte6Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2183_:{   
##@@@L2184_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2185_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_6, Data);   
8000c52a:	50 e9       	LD.W      R2, [R0 + R5]
8000c52c:	24 69       	ANL       R2, R4
8000c52e:	98 7a       	LSL       R3, #8			;->0x08
8000c530:	23 6a       	ORL       R2, R3
8000c532:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadHighFilter2():
##@@@P_:kf32a13k_drv_canfd.c:520
##@@@L0520_:    Canfd_LL_SetPNHighPayLoadByte7Mask(Module, PayloadPtr[7]);   
8000c534:	e1 89       	LD.B      R4, [R1 + #7]
8000c536:	08 43       	LD        R3, [PC + #8]         ;->0x8000c554  :=0xffffff00
##@@@F_:Canfd_LL_SetPNHighPayLoadByte7Mask():
##@@@P_:kf32a13k_drv_canfd.h:2196
##@@@L2191_: * @return void   
##@@@L2192_: */   
##@@@L2193_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte7Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2194_:{   
##@@@L2195_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2196_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_7, Data);   
8000c538:	50 e9       	LD.W      R2, [R0 + R5]
8000c53a:	23 69       	ANL       R2, R3
8000c53c:	24 6a       	ORL       R2, R4
8000c53e:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadHighFilter2():
##@@@P_:kf32a13k_drv_canfd.c:521
##@@@L0521_:}   
8000c540:	1d 5c       	JMP       LR
8000c542:	00 00       	NOP      NOP      
8000c544:	24 0b 00 00 	.long     0x00000b24 ->000002852  [!!!@2@:LD.W      R3, [SP + #36]	@@: NOP      
8000c548:	ff ff ff 00 	.long     0x00ffffff ->016777215 
8000c54c:	ff ff 00 ff 	.long     0xff00ffff ->-16711681 
8000c550:	ff 00 ff ff 	.long     0xffff00ff ->-00065281 
8000c554:	00 ff ff ff 	.long     0xffffff00 ->-00000256 

8000c558 <Canfd_LL_SetPNPayloadLowFilter2>:
##@@@F_:Canfd_LL_SetPNLowPayLoadByte0Mask():
##@@@P_:kf32a13k_drv_canfd.h:2119
##@@@L2114_: * @return void   
##@@@L2115_: */   
##@@@L2116_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte0Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2117_:{   
##@@@L2118_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2119_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_0, Data);   
8000c558:	0f 45       	LD        R5, [PC + #15]        ;->0x8000c594  :=0xb20
8000c55a:	41 80       	LD.B      R4, [R1]
8000c55c:	58 e9       	LD.W      R3, [R0 + R5]
8000c55e:	0f 42       	LD        R2, [PC + #15]        ;->0x8000c598  :=0xffffff
8000c560:	32 69       	ANL       R3, R2
8000c562:	a0 7b       	LSL       R4, #24			;->0x18
8000c564:	34 6a       	ORL       R3, R4
8000c566:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_SetPNPayloadLowFilter2():
##@@@P_:kf32a13k_drv_canfd.c:533
##@@@L0528_: */   
##@@@L0529_:void Canfd_LL_SetPNPayloadLowFilter2(CanfdPtr Module, const uint8_t *PayloadPtr)   
##@@@L0530_:{   
##@@@L0531_:    // TODO:后续优化数据结构   
##@@@L0532_:    Canfd_LL_SetPNLowPayLoadByte0Mask(Module, PayloadPtr[0]);   
##@@@L0533_:    Canfd_LL_SetPNLowPayLoadByte1Mask(Module, PayloadPtr[1]);   
8000c568:	61 88       	LD.B      R4, [R1 + #1]
8000c56a:	0d 43       	LD        R3, [PC + #13]        ;->0x8000c59c  :=0xff00ffff
##@@@F_:Canfd_LL_SetPNLowPayLoadByte1Mask():
##@@@P_:kf32a13k_drv_canfd.h:2130
##@@@L2125_: * @return void   
##@@@L2126_: */   
##@@@L2127_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte1Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2128_:{   
##@@@L2129_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2130_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_1, Data);   
8000c56c:	50 e9       	LD.W      R2, [R0 + R5]
8000c56e:	23 69       	ANL       R2, R3
8000c570:	20 7b       	LSL       R4, #16			;->0x10
8000c572:	24 6a       	ORL       R2, R4
8000c574:	42 ef       	ST.W      [R0 + R5], R2
8000c576:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c5a0  :=0xffff00ff
##@@@F_:Canfd_LL_SetPNPayloadLowFilter2():
##@@@P_:kf32a13k_drv_canfd.c:534
##@@@L0534_:    Canfd_LL_SetPNLowPayLoadByte2Mask(Module, PayloadPtr[2]);   
8000c578:	99 88       	LD.B      R3, [R1 + #2]
##@@@F_:Canfd_LL_SetPNLowPayLoadByte2Mask():
##@@@P_:kf32a13k_drv_canfd.h:2141
##@@@L2136_: * @return void   
##@@@L2137_: */   
##@@@L2138_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte2Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2139_:{   
##@@@L2140_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2141_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_2, Data);   
8000c57a:	50 e9       	LD.W      R2, [R0 + R5]
8000c57c:	24 69       	ANL       R2, R4
8000c57e:	98 7a       	LSL       R3, #8			;->0x08
8000c580:	23 6a       	ORL       R2, R3
8000c582:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadLowFilter2():
##@@@P_:kf32a13k_drv_canfd.c:535
##@@@L0535_:    Canfd_LL_SetPNLowPayLoadByte3Mask(Module, PayloadPtr[3]);   
8000c584:	e1 88       	LD.B      R4, [R1 + #3]
8000c586:	08 43       	LD        R3, [PC + #8]         ;->0x8000c5a4  :=0xffffff00
##@@@F_:Canfd_LL_SetPNLowPayLoadByte3Mask():
##@@@P_:kf32a13k_drv_canfd.h:2152
##@@@L2147_: * @return void   
##@@@L2148_: */   
##@@@L2149_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte3Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2150_:{   
##@@@L2151_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2152_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_3, Data);   
8000c588:	50 e9       	LD.W      R2, [R0 + R5]
8000c58a:	23 69       	ANL       R2, R3
8000c58c:	24 6a       	ORL       R2, R4
8000c58e:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetPNPayloadLowFilter2():
##@@@P_:kf32a13k_drv_canfd.c:536
##@@@L0536_:}   
8000c590:	1d 5c       	JMP       LR
8000c592:	00 00       	NOP      NOP      
8000c594:	20 0b 00 00 	.long     0x00000b20 ->000002848  [!!!@2@:LD.W      R3, [SP + #32]	@@: NOP      
8000c598:	ff ff ff 00 	.long     0x00ffffff ->016777215 
8000c59c:	ff ff 00 ff 	.long     0xff00ffff ->-16711681 
8000c5a0:	ff 00 ff ff 	.long     0xffff00ff ->-00065281 
8000c5a4:	00 ff ff ff 	.long     0xffffff00 ->-00000256 

8000c5a8 <Canfd_LL_SetTDCOffset>:
##@@@F_:Canfd_LL_SetTDCStatus():
##@@@P_:kf32a13k_drv_canfd.h:2210
##@@@L2205_: * @return void   
##@@@L2206_: */   
##@@@L2207_:KF_INLINE void Canfd_LL_SetTDCStatus(CanfdPtr Module, const bool Status)   
##@@@L2208_:{   
##@@@L2209_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2210_:    REG_WRITE(Module->CANFD_FDCTRL.bits.TDCEN, Status);   
8000c5a8:	10 38       	CMP       R1, #0			;->0x00
8000c5aa:	03 f1       	JNZ       $+3                   ;->0x8000c5b0
8000c5ac:	40 10       	MOV       R4, #0			;->0x0000
8000c5ae:	02 04       	SJMP      $+2                   ;->0x8000c5b2
8000c5b0:	08 44       	LD        R4, [PC + #8]         ;->0x8000c5d0  :=0x8000
8000c5b2:	09 45       	LD        R5, [PC + #9]         ;->0x8000c5d4  :=0xc00
8000c5b4:	58 e9       	LD.W      R3, [R0 + R5]
8000c5b6:	09 41       	LD        R1, [PC + #9]         ;->0x8000c5d8  :=0xffff7fff
8000c5b8:	31 69       	ANL       R3, R1
8000c5ba:	34 6a       	ORL       R3, R4
8000c5bc:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_SetTDCOffsetValue():
##@@@P_:kf32a13k_drv_canfd.h:2222
##@@@L2217_: * @return void   
##@@@L2218_: */   
##@@@L2219_:KF_INLINE void Canfd_LL_SetTDCOffsetValue(CanfdPtr Module, const uint8_t Offset)   
##@@@L2220_:{   
##@@@L2221_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2222_:    REG_WRITE(Module->CANFD_FDCTRL.bits.TDCOFF, Offset);   
8000c5be:	60 e9       	LD.W      R4, [R0 + R5]
8000c5c0:	07 43       	LD        R3, [PC + #7]         ;->0x8000c5dc  :=0xffffe0ff
8000c5c2:	43 69       	ANL       R4, R3
8000c5c4:	3f 11       	MOV       R3, #31			;->0x001F
8000c5c6:	23 69       	ANL       R2, R3
8000c5c8:	90 7a       	LSL       R2, #8			;->0x08
8000c5ca:	42 6a       	ORL       R4, R2
8000c5cc:	44 ef       	ST.W      [R0 + R5], R4
##@@@F_:Canfd_LL_SetTDCOffset():
##@@@P_:kf32a13k_drv_canfd.c:549
##@@@L0544_: */   
##@@@L0545_:void Canfd_LL_SetTDCOffset(CanfdPtr Module, const bool Status, uint8_t Offset)   
##@@@L0546_:{   
##@@@L0547_:    Canfd_LL_SetTDCStatus(Module, Status);   
##@@@L0548_:    Canfd_LL_SetTDCOffsetValue(Module, Offset);   
##@@@L0549_:}   
8000c5ce:	1d 5c       	JMP       LR
8000c5d0:	00 80 00 00 	.long     0x00008000 ->000032768  [!!!@2@:LD.B      R0, [R0]	@@: NOP      
8000c5d4:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000c5d8:	ff 7f ff ff 	.long     0xffff7fff ->-00032769 
8000c5dc:	ff e0 ff ff 	.long     0xffffe0ff ->-00007937 

8000c5e0 <Canfd_LL_Init>:
##@@@F_:Canfd_LL_SetSoftReset():
##@@@P_:kf32a13k_drv_canfd.h:536
##@@@L0531_: *         false:Module 取消软件复位   
##@@@L0532_: */   
##@@@L0533_:KF_INLINE void Canfd_LL_SetSoftReset(CanfdPtr Module, const bool Status)   
##@@@L0534_:{   
##@@@L0535_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0536_:    REG_WRITE(Module->CANFD_MCR.bits.SOFTRST, Status);   
8000c5e0:	40 82       	LD.W      R4, [R0]
8000c5e2:	0c 45       	LD        R5, [PC + #12]        ;->0x8000c610  :=0x2000000
8000c5e4:	45 6a       	ORL       R4, R5
8000c5e6:	04 85       	ST.W      [R0], R4
##@@@F_:Canfd_LL_IsSoftReset():
##@@@P_:kf32a13k_drv_canfd.h:523
##@@@L0518_: *         false:Module 未执行软件复位   
##@@@L0519_: */   
##@@@L0520_:KF_INLINE bool Canfd_LL_IsSoftReset(CanfdPtr Module)   
##@@@L0521_:{   
##@@@L0522_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0523_:    return (REG_READ(Module->CANFD_MCR.bits.SOFTRST));   
8000c5e8:	40 82       	LD.W      R4, [R0]
8000c5ea:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_Init():
##@@@P_:kf32a13k_drv_canfd.c:561
##@@@L0556_:void Canfd_LL_Init(CanfdPtr Module)   
##@@@L0557_:{   
##@@@L0558_:    /* Reset the CANFD */   
##@@@L0559_:    Canfd_LL_SetSoftReset(Module, true);   
##@@@L0560_:    /* Wait for reset cycle to complete */   
##@@@L0561_:    while (true == Canfd_LL_IsSoftReset(Module))   
8000c5ec:	40 38       	CMP       R4, #0			;->0x00
8000c5ee:	fd f1       	JNZ       $-3                   ;->0x8000c5e8
8000c5f0:	09 45       	LD        R5, [PC + #9]         ;->0x8000c614  :=0xffffffff
##@@@F_:Canfd_LL_SetRxMbGlobalMask():
##@@@P_:kf32a13k_drv_canfd.h:1339
##@@@L1334_: * @return void   
##@@@L1335_: */   
##@@@L1336_:KF_INLINE void Canfd_LL_SetRxMbGlobalMask(CanfdPtr Module, uint32_t Mask)   
##@@@L1337_:{   
##@@@L1338_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1339_:    REG_WRITE(Module->RXMGMASK.reg, Mask);   
8000c5f2:	05 a1       	ST.W      [R0 + #4], R5
##@@@F_:Canfd_LL_SetRxMb14Mask():
##@@@P_:kf32a13k_drv_canfd.h:1375
##@@@L1370_: * @return void   
##@@@L1371_: */   
##@@@L1372_:KF_INLINE void Canfd_LL_SetRxMb14Mask(CanfdPtr Module, uint32_t Mask)   
##@@@L1373_:{   
##@@@L1374_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1375_:    REG_WRITE((Module->RX14MASK.reg), Mask);   
8000c5f4:	45 a1       	ST.W      [R0 + #5], R5
##@@@F_:Canfd_LL_SetRxMb15Mask():
##@@@P_:kf32a13k_drv_canfd.h:1411
##@@@L1406_: * @return void   
##@@@L1407_: */   
##@@@L1408_:KF_INLINE void Canfd_LL_SetRxMb15Mask(CanfdPtr Module, uint32_t Mask)   
##@@@L1409_:{   
##@@@L1410_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1411_:    REG_WRITE((Module->RX15MASK.reg), Mask);   
8000c5f6:	85 a1       	ST.W      [R0 + #6], R5
8000c5f8:	40 10       	MOV       R4, #0			;->0x0000
##@@@F_:Canfd_LL_SetInt1Mask():
##@@@P_:kf32a13k_drv_canfd.h:1486
##@@@L1481_: * @return void   
##@@@L1482_: */   
##@@@L1483_:KF_INLINE void Canfd_LL_SetInt1Mask(CanfdPtr Module, uint32_t Mask)   
##@@@L1484_:{   
##@@@L1485_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1486_:    REG_WRITE(Module->CANFD_IMASK1.reg, Mask);   
8000c5fa:	84 a2       	ST.W      [R0 + #10], R4
##@@@F_:Canfd_LL_ClearInt1Flag():
##@@@P_:kf32a13k_drv_canfd.h:1509
##@@@L1504_: * @return void   
##@@@L1505_: */   
##@@@L1506_:KF_INLINE void Canfd_LL_ClearInt1Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1507_:{   
##@@@L1508_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1509_:    REG_WRITE(Module->CANFD_IFLAG1.reg, Flag);   
8000c5fc:	05 a3       	ST.W      [R0 + #12], R5
##@@@F_:Canfd_LL_SetInt2Mask():
##@@@P_:kf32a13k_drv_canfd.h:1532
##@@@L1527_: * @return void   
##@@@L1528_: */   
##@@@L1529_:KF_INLINE void Canfd_LL_SetInt2Mask(CanfdPtr Module, uint32_t Mask)   
##@@@L1530_:{   
##@@@L1531_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1532_:    REG_WRITE(Module->CANFD_IMASK2.reg, Mask);   
8000c5fe:	44 a2       	ST.W      [R0 + #9], R4
##@@@F_:Canfd_LL_ClearInt2Flag():
##@@@P_:kf32a13k_drv_canfd.h:1555
##@@@L1550_: * @return void   
##@@@L1551_: */   
##@@@L1552_:KF_INLINE void Canfd_LL_ClearInt2Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1553_:{   
##@@@L1554_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1555_:    REG_WRITE(Module->CANFD_IFLAG2.reg, Flag);   
8000c600:	c5 a2       	ST.W      [R0 + #11], R5
##@@@F_:Canfd_LL_SetInt3Mask():
##@@@P_:kf32a13k_drv_canfd.h:1578
##@@@L1573_: * @return void   
##@@@L1574_: */   
##@@@L1575_:KF_INLINE void Canfd_LL_SetInt3Mask(CanfdPtr Module, uint32_t Mask)   
##@@@L1576_:{   
##@@@L1577_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1578_:    REG_WRITE(Module->CANFD_IMASK3.reg, Mask);   
8000c602:	c4 a6       	ST.W      [R0 + #27], R4
##@@@F_:Canfd_LL_ClearInt3Flag():
##@@@P_:kf32a13k_drv_canfd.h:1601
##@@@L1596_: * @return void   
##@@@L1597_: */   
##@@@L1598_:KF_INLINE void Canfd_LL_ClearInt3Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1599_:{   
##@@@L1600_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1601_:    REG_WRITE(Module->CANFD_IFLAG3.reg, Flag);   
8000c604:	45 a7       	ST.W      [R0 + #29], R5
##@@@F_:Canfd_LL_SetInt4Mask():
##@@@P_:kf32a13k_drv_canfd.h:1624
##@@@L1619_: * @return void   
##@@@L1620_: */   
##@@@L1621_:KF_INLINE void Canfd_LL_SetInt4Mask(CanfdPtr Module, uint32_t Mask)   
##@@@L1622_:{   
##@@@L1623_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1624_:    REG_WRITE(Module->CANFD_IMASK4.reg, Mask);   
8000c606:	84 a6       	ST.W      [R0 + #26], R4
8000c608:	04 44       	LD        R4, [PC + #4]         ;->0x8000c618  :=0x3b0007
##@@@F_:Canfd_LL_ClearInt4Flag():
##@@@P_:kf32a13k_drv_canfd.h:1647
##@@@L1642_: * @return void   
##@@@L1643_: */   
##@@@L1644_:KF_INLINE void Canfd_LL_ClearInt4Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1645_:{   
##@@@L1646_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1647_:    REG_WRITE(Module->CANFD_IFLAG4.reg, Flag);   
8000c60a:	05 a7       	ST.W      [R0 + #28], R5
##@@@F_:Canfd_LL_ClearErrorStatus():
##@@@P_:kf32a13k_drv_canfd.h:1670
##@@@L1665_: * @return void   
##@@@L1666_: */   
##@@@L1667_:KF_INLINE void Canfd_LL_ClearErrorStatus(CanfdPtr Module, uint32_t Status)   
##@@@L1668_:{   
##@@@L1669_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1670_:    REG_WRITE(Module->CANFD_ESR1.reg, Status);   
8000c60c:	04 a2       	ST.W      [R0 + #8], R4
##@@@F_:Canfd_LL_Init():
##@@@P_:kf32a13k_drv_canfd.c:601
##@@@L0596_:        Canfd_LL_ClearInt4Flag(Module, CAN_IMASK4_BUF127TO96M_MASK);   
##@@@L0597_:    }   
##@@@L0598_:#endif   
##@@@L0599_:    /* Clear all error interrupt flags */   
##@@@L0600_:    Canfd_LL_ClearErrorStatus(Module, CANFD_ALL_INT);   
##@@@L0601_:}   
8000c60e:	1d 5c       	JMP       LR
8000c610:	00 00 00 02 	.long     0x02000000 ->033554432 
8000c614:	ff ff ff ff 	.long     0xffffffff ->-00000001 
8000c618:	07 00 3b 00 	.long     0x003b0007 ->003866631 

8000c61c <Canfd_LL_EnableRxFifo>:
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000c61c:	50 82       	LD.W      R5, [R0]
8000c61e:	11 44       	LD        R4, [PC + #17]        ;->0x8000c660  :=0x800
8000c620:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_EnableRxFifo():
##@@@P_:kf32a13k_drv_canfd.c:617
##@@@L0612_:    uint32_t    mailboxIndex = 0U;   
##@@@L0613_:    if (true == Canfd_LL_IsFDEnabled(Module))   
##@@@L0614_:    {   
##@@@L0615_:        retStatus = STATUS_ERROR;   
##@@@L0616_:    }   
##@@@L0617_:    if (STATUS_OK == retStatus)   
8000c622:	50 38       	CMP       R5, #0			;->0x00
8000c624:	1a f1       	JNZ       $+26                  ;->0x8000c658
##@@@F_:Canfd_LL_SetRxFifoEnable():
##@@@P_:kf32a13k_drv_canfd.h:924
##@@@L0919_: * @return void   
##@@@L0920_: */   
##@@@L0921_:KF_INLINE void Canfd_LL_SetRxFifoEnable(CanfdPtr Module, const bool Status)   
##@@@L0922_:{   
##@@@L0923_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0924_:    REG_WRITE(Module->CANFD_MCR.bits.RFEN, Status);   
8000c626:	40 82       	LD.W      R4, [R0]
8000c628:	0f 43       	LD        R3, [PC + #15]        ;->0x8000c664  :=0x20000000
8000c62a:	43 6a       	ORL       R4, R3
8000c62c:	04 85       	ST.W      [R0], R4
##@@@F_:Canfd_LL_SetLegacyFifoFilterNum():
##@@@P_:kf32a13k_drv_canfd.h:1281
##@@@L1276_: * @return void   
##@@@L1277_: */   
##@@@L1278_:KF_INLINE void Canfd_LL_SetLegacyFifoFilterNum(CanfdPtr Module, uint32_t FilterNumber)   
##@@@L1279_:{   
##@@@L1280_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1281_:    REG_WRITE(Module->CANFD_CTRL2.bits.RFFN, FilterNumber);   
8000c62e:	88 7b       	LSL       R1, #24			;->0x18
8000c630:	0e 44       	LD        R4, [PC + #14]        ;->0x8000c668  :=0xf000000
8000c632:	58 9b       	LD.W      R3, [R0 + #13]
8000c634:	0e 42       	LD        R2, [PC + #14]        ;->0x8000c66c  :=0xf0ffffff
8000c636:	14 69       	ANL       R1, R4
8000c638:	32 69       	ANL       R3, R2
8000c63a:	31 6a       	ORL       R3, R1
8000c63c:	43 a3       	ST.W      [R0 + #13], R3
8000c63e:	0d 44       	LD        R4, [PC + #13]        ;->0x8000c670  :=0xffffffff
8000c640:	0d 43       	LD        R3, [PC + #13]        ;->0x8000c674  :=0x890
##@@@F_:Canfd_LL_SetRxMbGlobalMask():
##@@@P_:kf32a13k_drv_canfd.h:1339
##@@@L1334_: * @return void   
##@@@L1335_: */   
##@@@L1336_:KF_INLINE void Canfd_LL_SetRxMbGlobalMask(CanfdPtr Module, uint32_t Mask)   
##@@@L1337_:{   
##@@@L1338_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1339_:    REG_WRITE(Module->RXMGMASK.reg, Mask);   
8000c642:	04 a1       	ST.W      [R0 + #4], R4
##@@@F_:Canfd_LL_EnableRxFifo():
##@@@P_:kf32a13k_drv_canfd.c:622
##@@@L0618_:    {   
##@@@L0619_:        Canfd_LL_SetRxFifoEnable(Module, true);   
##@@@L0620_:        Canfd_LL_SetLegacyFifoFilterNum(Module, NumberOfFilters);   
##@@@L0621_:        Canfd_LL_SetRxMbGlobalMask(Module, (uint32_t)0xFFFFFFFFU);   
##@@@L0622_:        for (mailboxIndex = 0; mailboxIndex < CANFD_MAX_MBNUM; mailboxIndex++)   
8000c644:	e0 c2       	ADD       R4, R0, R3
8000c646:	0d 43       	LD        R3, [PC + #13]        ;->0x8000c678  :=0x1fffffff
8000c648:	0d 42       	LD        R2, [PC + #13]        ;->0x8000c67c  :=0x200
8000c64a:	10 10       	MOV       R1, #0			;->0x0000
##@@@F_:Canfd_LL_SetRxIndividualExtMask():
##@@@P_:kf32a13k_drv_canfd.h:1474
##@@@L1469_: * @return void   
##@@@L1470_: */   
##@@@L1471_:KF_INLINE void Canfd_LL_SetRxIndividualExtMask(CanfdPtr Module, uint32_t MbIndex, uint32_t ExtMask)   
##@@@L1472_:{   
##@@@L1473_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1474_:    REG_WRITE(Module->CANFD_RXIMR[MbIndex].EFF.MASK, ExtMask);   
8000c64c:	44 e8       	LD.W      R0, [R4 + R1]
8000c64e:	03 6a       	ORL       R0, R3
8000c650:	60 ee       	ST.W      [R4 + R1], R0
##@@@F_:Canfd_LL_EnableRxFifo():
##@@@P_:kf32a13k_drv_canfd.c:622
8000c652:	09 c1       	ADD       R1, R1, #4
8000c654:	12 70       	CMP       R1, R2
8000c656:	fb f1       	JNZ       $-5                   ;->0x8000c64c
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000c658:	50 38       	CMP       R5, #0			;->0x00
8000c65a:	13 f1       	JNZ       $+19                  ;->0x8000c680
##@@@F_:Canfd_LL_EnableRxFifo():
8000c65c:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:627
##@@@L0623_:        {   
##@@@L0624_:            Canfd_LL_SetRxIndividualExtMask(Module, mailboxIndex, 0x1FFFFFFFU);   
##@@@L0625_:        }   
##@@@L0626_:    }   
##@@@L0627_:    return (retStatus);   
8000c65e:	1d 5c       	JMP       LR
8000c660:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000c664:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000c668:	00 00 00 0f 	.long     0x0f000000 ->251658240  [!!!@2@:NOP      	@@: LD.W      R7, [SP + #0]
8000c66c:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
8000c670:	ff ff ff ff 	.long     0xffffffff ->-00000001 
8000c674:	90 08 00 00 	.long     0x00000890 ->000002192  [!!!@2@:LD.W      R0, [SP + #144]	@@: NOP      
8000c678:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000c67c:	00 02 00 00 	.long     0x00000200 ->000000512 
8000c680:	01 10       	MOV       R0, #1			;->0x0001
8000c682:	1d 5c       	JMP       LR

8000c684 <Canfd_LL_WaitSemaphorephore>:
##@@@F_:Canfd_LL_WaitSemaphorephore():
##@@@P_:kf32a13k_drv_canfd.c:637
##@@@L0632_: * @param SemaphorePtr   
##@@@L0633_: * @param Timeout   
##@@@L0634_: * @retval kf_status_t   
##@@@L0635_: */   
##@@@L0636_:kf_status_t Canfd_LL_WaitSemaphorephore(Semaphore_t *const SemaphorePtr, const uint32_t Timeout)   
##@@@L0637_:{   
8000c684:	50 80       	LD.B      R5, [R0]
8000c686:	50 38       	CMP       R5, #0			;->0x00
8000c688:	16 f0       	JZ        $+22                  ;->0x8000c6b4
##@@@P_:kf32a13k_drv_canfd.c:662
##@@@L0657_:            }   
##@@@L0658_:        }   
##@@@L0659_:    }   
##@@@L0660_:    if (STATUS_OK == retStatus)   
##@@@L0661_:    {   
##@@@L0662_:        DISABLE_INTERRUPT();   
8000c68a:	20 5d       	PUSH      R0
8000c68c:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000c690:	08 00       	SYNC     SYNC     
8000c692:	a0 5d 87 01 	CSRCLR    R0, R0, #0x0187  // @imm 391
8000c696:	08 00       	SYNC     SYNC     
8000c698:	00 5d       	POP       R0
##@@@P_:kf32a13k_drv_canfd.c:663
##@@@L0663_:        --(*SemaphorePtr);   
8000c69a:	50 80       	LD.B      R5, [R0]
8000c69c:	6d cc       	SUB       R5, R5, #1
8000c69e:	05 83       	ST.B      [R0], R5
8000c6a0:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:664
##@@@L0664_:        ENABLE_INTERRUPT();   
8000c6a2:	20 5d       	PUSH      R0
8000c6a4:	20 5c 00 80 	MOVL      R0, #32768			;->0x8000
8000c6a8:	08 00       	SYNC     SYNC     
8000c6aa:	b0 5d 87 01 	CSRSET    R0, R0, #0x0187  // @imm 391
8000c6ae:	08 00       	SYNC     SYNC     
8000c6b0:	00 5d       	POP       R0
##@@@P_:kf32a13k_drv_canfd.c:666
##@@@L0665_:    }   
##@@@L0666_:    return retStatus;   
8000c6b2:	1d 5c       	JMP       LR
8000c6b4:	03 10       	MOV       R0, #3			;->0x0003
8000c6b6:	1d 5c       	JMP       LR

8000c6b8 <Canfd_LL_GetMailboxAddr>:
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
8000c6b8:	40 82       	LD.W      R4, [R0]
8000c6ba:	0e 45       	LD        R5, [PC + #14]        ;->0x8000c6f0  :=0x800
8000c6bc:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000c6be:	40 38       	CMP       R4, #0			;->0x00
8000c6c0:	03 f1       	JNZ       $+3                   ;->0x8000c6c6
8000c6c2:	40 11       	MOV       R4, #16			;->0x0010
8000c6c4:	09 04       	SJMP      $+9                   ;->0x8000c6d6
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000c6c6:	0c 44       	LD        R4, [PC + #12]        ;->0x8000c6f4  :=0xc00
8000c6c8:	18 e9       	LD.W      R3, [R0 + R4]
8000c6ca:	18 7d       	LSR       R3, #16			;->0x10
8000c6cc:	43 10       	MOV       R4, #3			;->0x0003
8000c6ce:	34 69       	ANL       R3, R4
8000c6d0:	48 10       	MOV       R4, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000c6d2:	43 6c       	LSL       R4, R3
8000c6d4:	48 28       	ADD       R4, #8			;->0x08
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:682
##@@@L0677_:    uint8_t  payloadSize          = Canfd_LL_GetPayloadSize(Module);   
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
8000c6d6:	2d d3       	DIVU      R5, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000c6d8:	59 d3       	DIVU      R3, R1, R5
8000c6da:	6b cb       	MULS      R5, R3, R5
8000c6dc:	69 c7       	SUB       R5, R1, R5
8000c6de:	9b 7a       	LSL       R3, #11			;->0x0B
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000c6e0:	22 7c       	LSR       R4, #2			;->0x02
8000c6e2:	19 00 a4 0c 	MADD32    R3, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000c6e6:	1a 7a       	LSL       R3, #2			;->0x02
8000c6e8:	e8 c2       	ADD       R5, R0, R3
8000c6ea:	40 19       	MOV       R4, #144			;->0x0090
8000c6ec:	05 c3       	ADD       R0, R5, R4
8000c6ee:	1d 5c       	JMP       LR
8000c6f0:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000c6f4:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      

8000c6f8 <Canfd_LL_SetMaxMbNum>:
##@@@F_:Canfd_LL_SetMaxMbNum():
##@@@P_:kf32a13k_drv_canfd.c:696
##@@@L0691_: * @param Module   
##@@@L0692_: * @param MaxMbNum   
##@@@L0693_: * @retval kf_status_t   
##@@@L0694_: */   
##@@@L0695_:kf_status_t Canfd_LL_SetMaxMbNum(CanfdPtr Module, uint32_t MaxMbNum)   
##@@@L0696_:{   
8000c6f8:	1f 5f       	PUSH      {R6-R10}
8000c6fa:	e0 31       	SUB       SP, #16			;->0x10
8000c6fc:	80 58       	MOV       R4, R0
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000c6fe:	50 82       	LD.W      R5, [R0]
8000c700:	3e 42       	LD        R2, [PC + #62]        ;->0x8000c7f8  :=0x800
8000c702:	52 69       	ANL       R5, R2
8000c704:	98 10       	MOV       R9, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000c706:	50 38       	CMP       R5, #0			;->0x00
8000c708:	a9 58       	MOV       R5, R9
8000c70a:	03 25       	ST.W      [SP + #3], R5
8000c70c:	09 f0       	JZ        $+9                   ;->0x8000c71e
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000c70e:	3c 45       	LD        R5, [PC + #60]        ;->0x8000c7fc  :=0xc00
8000c710:	6c e9       	LD.W      R5, [R4 + R5]
8000c712:	28 7d       	LSR       R5, #16			;->0x10
8000c714:	33 10       	MOV       R3, #3			;->0x0003
8000c716:	53 69       	ANL       R5, R3
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000c718:	69 58       	MOV       R3, R9
8000c71a:	35 6c       	LSL       R3, R5
8000c71c:	03 23       	ST.W      [SP + #3], R3
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000c71e:	54 82       	LD.W      R5, [R4]
8000c720:	52 69       	ANL       R5, R2
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000c722:	50 38       	CMP       R5, #0			;->0x00
8000c724:	03 f1       	JNZ       $+3                   ;->0x8000c72a
8000c726:	60 11       	MOV       R6, #16			;->0x0010
8000c728:	09 04       	SJMP      $+9                   ;->0x8000c73a
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000c72a:	35 45       	LD        R5, [PC + #53]        ;->0x8000c7fc  :=0xc00
8000c72c:	6c e9       	LD.W      R5, [R4 + R5]
8000c72e:	28 7d       	LSR       R5, #16			;->0x10
8000c730:	33 10       	MOV       R3, #3			;->0x0003
8000c732:	53 69       	ANL       R5, R3
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000c734:	c9 58       	MOV       R6, R9
8000c736:	65 6c       	LSL       R6, R5
8000c738:	68 28       	ADD       R6, #8			;->0x08
##@@@F_:Canfd_LL_SetMaxMbNum():
8000c73a:	32 40       	LD        R0, [PC + #50]        ;->0x8000c800  :=0x380
##@@@P_:kf32a13k_drv_canfd.c:707
##@@@L0702_:    uint32_t           endMb        = (uint32_t)endMbPointer + payloadSize + CANFD_ARBITRATION_RAMSIZE;   
##@@@L0703_:    if ((endMb > (uint32_t)(&Module->CANFD_RAM[CANFD_MAX_MBNUM])) || (MaxMbNum > CANFD_MAX_MBNUM))   
##@@@L0704_:    {   
##@@@L0705_:        retStatus = STATUS_CANFD_BUFF_OUT_OF_RANGE;   
##@@@L0706_:    }   
##@@@L0707_:    if (STATUS_OK == retStatus)   
8000c73c:	50 18       	MOV       R5, #128			;->0x0080
8000c73e:	15 70       	CMP       R1, R5
8000c740:	02 f9       	JLS       $+2                   ;->0x8000c744
8000c742:	58 04       	SJMP      $+88                  ;->0x8000c7f2
8000c744:	02 22       	ST.W      [SP + #2], R2
8000c746:	aa d3       	DIVU      R5, R2, R6
8000c748:	59 cc       	SUB       R3, R1, #1
8000c74a:	53 d3       	DIVU      R2, R3, R5
8000c74c:	6a cb       	MULS      R5, R2, R5
8000c74e:	6b c7       	SUB       R5, R3, R5
8000c750:	93 7a       	LSL       R2, #11			;->0x0B
8000c752:	32 7c       	LSR       R6, #2			;->0x02
8000c754:	19 00 a6 08 	MADD32    R2, R5, R6
8000c758:	2b 45       	LD        R5, [PC + #43]        ;->0x8000c804  :=0x290
8000c75a:	12 7a       	LSL       R2, #2			;->0x02
8000c75c:	6c c3       	ADD       R5, R4, R5
8000c75e:	94 c2       	ADD       R2, R4, R2
8000c760:	03 09       	LD.W      R1, [SP + #3]
8000c762:	52 c2       	ADD       R2, R2, R1
8000c764:	18 19       	MOV       R1, #152			;->0x0098
8000c766:	01 21       	ST.W      [SP + #1], R1
8000c768:	52 c2       	ADD       R2, R2, R1
8000c76a:	25 70       	CMP       R2, R5
8000c76c:	02 f9       	JLS       $+2                   ;->0x8000c770
8000c76e:	42 04       	SJMP      $+66                  ;->0x8000c7f2
8000c770:	5f 17       	MOV       R5, #127			;->0x007F
##@@@F_:Canfd_LL_SetMaxMbCount():
##@@@P_:kf32a13k_drv_canfd.h:862
##@@@L0857_: * @return void   
##@@@L0858_: */   
##@@@L0859_:KF_INLINE void Canfd_LL_SetMaxMbCount(CanfdPtr Module, uint32_t MaxMailboxNumber)   
##@@@L0860_:{   
##@@@L0861_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0862_:    REG_WRITE(Module->CANFD_MCR.bits.MAXMB, MaxMailboxNumber);   
8000c772:	24 82       	LD.W      R2, [R4]
8000c774:	25 40       	LD        R0, [PC + #37]        ;->0x8000c808  :=0xffffff80
8000c776:	35 69       	ANL       R3, R5
8000c778:	20 69       	ANL       R2, R0
8000c77a:	23 6a       	ORL       R2, R3
8000c77c:	42 85       	ST.W      [R4], R2
##@@@F_:Canfd_LL_IsRxFifoEnabled():
##@@@P_:kf32a13k_drv_canfd.h:935
##@@@L0930_: * @return bool   
##@@@L0931_: */   
##@@@L0932_:KF_INLINE bool Canfd_LL_IsRxFifoEnabled(CanfdPtr Module)   
##@@@L0933_:{   
##@@@L0934_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0935_:    return (REG_READ(Module->CANFD_MCR.bits.RFEN));   
8000c77e:	54 82       	LD.W      R5, [R4]
8000c780:	23 43       	LD        R3, [PC + #35]        ;->0x8000c80c  :=0x20000000
8000c782:	53 69       	ANL       R5, R3
8000c784:	00 10       	MOV       R0, #0			;->0x0000
##@@@F_:Canfd_LL_SetMaxMbNum():
##@@@P_:kf32a13k_drv_canfd.c:711
##@@@L0708_:    {   
##@@@L0709_:        /* Set the maximum number of MBs*/   
##@@@L0710_:        Canfd_LL_SetMaxMbCount(Module, (MaxMbNum - 1U));   
##@@@L0711_:        if (false == Canfd_LL_IsRxFifoEnabled(Module))   
8000c786:	50 38       	CMP       R5, #0			;->0x00
8000c788:	35 f1       	JNZ       $+53                  ;->0x8000c7f2
8000c78a:	a0 11       	MOV       R10, #16			;->0x0010
8000c78c:	7f 1f       	MOV       R7, #255			;->0x00FF
8000c78e:	83 10       	MOV       R8, #3			;->0x0003
8000c790:	60 58       	MOV       R3, R0
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000c792:	54 82       	LD.W      R5, [R4]
8000c794:	02 0a       	LD.W      R2, [SP + #2]
8000c796:	52 69       	ANL       R5, R2
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000c798:	50 38       	CMP       R5, #0			;->0x00
8000c79a:	ca 58       	MOV       R6, R10
8000c79c:	08 f0       	JZ        $+8                   ;->0x8000c7ac
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000c79e:	18 45       	LD        R5, [PC + #24]        ;->0x8000c7fc  :=0xc00
8000c7a0:	6c e9       	LD.W      R5, [R4 + R5]
8000c7a2:	28 7d       	LSR       R5, #16			;->0x10
8000c7a4:	58 69       	ANL       R5, R8
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000c7a6:	c9 58       	MOV       R6, R9
8000c7a8:	65 6c       	LSL       R6, R5
8000c7aa:	68 28       	ADD       R6, #8			;->0x08
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:682
##@@@L0677_:    uint8_t  payloadSize          = Canfd_LL_GetPayloadSize(Module);   
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
8000c7ac:	8a d3       	DIVU      R1, R2, R6
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000c7ae:	43 58       	MOV       R2, R3
8000c7b0:	27 69       	ANL       R2, R7
8000c7b2:	a1 58       	MOV       R5, R1
8000c7b4:	57 69       	ANL       R5, R7
8000c7b6:	6a d3       	DIVU      R5, R2, R5
8000c7b8:	55 ca       	MULS      R2, R5, R1
8000c7ba:	93 c6       	SUB       R2, R3, R2
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000c7bc:	27 69       	ANL       R2, R7
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000c7be:	ab 7a       	LSL       R5, #11			;->0x0B
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000c7c0:	32 7c       	LSR       R6, #2			;->0x02
8000c7c2:	19 00 c2 14 	MADD32    R5, R6, R2
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000c7c6:	2a 7a       	LSL       R5, #2			;->0x02
8000c7c8:	6c c3       	ADD       R5, R4, R5
##@@@F_:Canfd_LL_SetMaxMbNum():
8000c7ca:	68 00 a0 94 	ST        [R5 + #37], R0			;->0x25
##@@@P_:kf32a13k_drv_canfd.c:720
##@@@L0715_:            {   
##@@@L0716_:                volatile uint32_t *mailboxPtr     = Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L0717_:                volatile uint32_t *mailboxIdPtr   = &mailboxPtr[1];   
##@@@L0718_:                volatile uint8_t  *mailboxDataPtr = (volatile uint8_t *)(&mailboxPtr[2]);   
##@@@L0719_:                CANFD_WRITE32(mailboxPtr, 0U);   
##@@@L0720_:                CANFD_WRITE32(mailboxIdPtr, 0U);   
8000c7ce:	68 00 a0 90 	ST        [R5 + #36], R0			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:718
##@@@L0713_:            /* Initialize all message buffers as inactive */   
##@@@L0714_:            for (MbIndex = 0; MbIndex < CANFD_MAX_MBNUM; MbIndex++)   
##@@@L0715_:            {   
##@@@L0716_:                volatile uint32_t *mailboxPtr     = Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L0717_:                volatile uint32_t *mailboxIdPtr   = &mailboxPtr[1];   
##@@@L0718_:                volatile uint8_t  *mailboxDataPtr = (volatile uint8_t *)(&mailboxPtr[2]);   
8000c7d2:	01 0a       	LD.W      R2, [SP + #1]
8000c7d4:	b5 c2       	ADD       R6, R5, R2
8000c7d6:	03 0a       	LD.W      R2, [SP + #3]
8000c7d8:	a0 58       	MOV       R5, R0
##@@@P_:kf32a13k_drv_canfd.c:723
##@@@L0719_:                CANFD_WRITE32(mailboxPtr, 0U);   
##@@@L0720_:                CANFD_WRITE32(mailboxIdPtr, 0U);   
##@@@L0721_:                for (dataByte = 0; dataByte < payloadSize; dataByte++)   
##@@@L0722_:                {   
##@@@L0723_:                    CANFD_WRITE8(mailboxDataPtr + dataByte, 0U);   
8000c7da:	70 eb       	ST.B      [R6 + R5], R0
##@@@P_:kf32a13k_drv_canfd.c:721
##@@@L0716_:                volatile uint32_t *mailboxPtr     = Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L0717_:                volatile uint32_t *mailboxIdPtr   = &mailboxPtr[1];   
##@@@L0718_:                volatile uint8_t  *mailboxDataPtr = (volatile uint8_t *)(&mailboxPtr[2]);   
##@@@L0719_:                CANFD_WRITE32(mailboxPtr, 0U);   
##@@@L0720_:                CANFD_WRITE32(mailboxIdPtr, 0U);   
##@@@L0721_:                for (dataByte = 0; dataByte < payloadSize; dataByte++)   
8000c7dc:	6d c0       	ADD       R5, R5, #1
8000c7de:	52 cc       	SUB       R2, R2, #1
8000c7e0:	20 38       	CMP       R2, #0			;->0x00
8000c7e2:	fc f1       	JNZ       $-4                   ;->0x8000c7da
8000c7e4:	0b 45       	LD        R5, [PC + #11]        ;->0x8000c810  :=0x1000000
##@@@P_:kf32a13k_drv_canfd.c:714
##@@@L0709_:        /* Set the maximum number of MBs*/   
##@@@L0710_:        Canfd_LL_SetMaxMbCount(Module, (MaxMbNum - 1U));   
##@@@L0711_:        if (false == Canfd_LL_IsRxFifoEnabled(Module))   
##@@@L0712_:        {   
##@@@L0713_:            /* Initialize all message buffers as inactive */   
##@@@L0714_:            for (MbIndex = 0; MbIndex < CANFD_MAX_MBNUM; MbIndex++)   
8000c7e6:	98 7b       	LSL       R3, #24			;->0x18
8000c7e8:	5b c3       	ADD       R3, R3, R5
8000c7ea:	0b 45       	LD        R5, [PC + #11]        ;->0x8000c814  :=0xffffffff
8000c7ec:	98 79       	ASR       R3, #24			;->0x18
8000c7ee:	35 70       	CMP       R3, R5
8000c7f0:	d1 fc       	JGT       $-47                  ;->0x8000c792
##@@@P_:kf32a13k_drv_canfd.c:728
##@@@L0723_:                    CANFD_WRITE8(mailboxDataPtr + dataByte, 0U);   
##@@@L0724_:                }   
##@@@L0725_:            }   
##@@@L0726_:        }   
##@@@L0727_:    }   
##@@@L0728_:    return (retStatus);   
8000c7f2:	e0 29       	ADD       SP, #16			;->0x10
8000c7f4:	1f 5e       	POP       {R6-R10}
8000c7f6:	1d 5c       	JMP       LR
8000c7f8:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000c7fc:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000c800:	80 03 00 00 	.long     0x00000380 ->000000896  [!!!@4@:JMP       $-8388608             ;->0x7f00c800
8000c804:	90 02 00 00 	.long     0x00000290 ->000000656 
8000c808:	80 ff ff ff 	.long     0xffffff80 ->-00000128 
8000c80c:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000c810:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
8000c814:	ff ff ff ff 	.long     0xffffffff ->-00000001 

8000c818 <Canfd_LL_SetOperationMode>:
##@@@F_:Canfd_LL_SetOperationMode():
##@@@P_:kf32a13k_drv_canfd.c:739
##@@@L0734_: * @param Mode   
##@@@L0735_: * @retval void   
##@@@L0736_: */   
##@@@L0737_:void Canfd_LL_SetOperationMode(CanfdPtr Module, Canfd_OpMode_t Mode)   
##@@@L0738_:{   
##@@@L0739_:    switch (Mode)   
8000c818:	14 38       	CMP       R1, #4			;->0x04
8000c81a:	02 f9       	JLS       $+2                   ;->0x8000c81e
8000c81c:	4c 04       	SJMP      $+76                  ;->0x8000c8b4
8000c81e:	09 45       	LD        R5, [PC + #9]         ;->0x8000c840  :=0x800011f8
8000c820:	0a 7a       	LSL       R1, #2			;->0x02
8000c822:	6d e8       	LD.W      R5, [R5 + R1]
8000c824:	15 5c       	JMP       R5
##@@@F_:Canfd_LL_SetSuperVisorMode():
##@@@P_:kf32a13k_drv_canfd.h:660
##@@@L0655_: */   
##@@@L0656_:
##@@@L0657_:KF_INLINE void Canfd_LL_SetSuperVisorMode(CanfdPtr Module, const bool Status)   
##@@@L0658_:{   
##@@@L0659_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0660_:    REG_WRITE(Module->CANFD_MCR.bits.SUPV, Status);   
8000c826:	50 82       	LD.W      R5, [R0]
8000c828:	07 44       	LD        R4, [PC + #7]         ;->0x8000c844  :=0xff7fffff
8000c82a:	54 69       	ANL       R5, R4
8000c82c:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_SetListenOnlyMode():
##@@@P_:kf32a13k_drv_canfd.h:675
##@@@L0670_: */   
##@@@L0671_:
##@@@L0672_:KF_INLINE void Canfd_LL_SetListenOnlyMode(CanfdPtr Module, const bool Status)   
##@@@L0673_:{   
##@@@L0674_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0675_:    REG_WRITE(Module->CANFD_CTRL1.bits.LOM, Status);   
8000c82e:	68 98       	LD.W      R5, [R0 + #1]
8000c830:	06 44       	LD        R4, [PC + #6]         ;->0x8000c848  :=0xfffffff7
8000c832:	54 69       	ANL       R5, R4
8000c834:	45 a0       	ST.W      [R0 + #1], R5
8000c836:	06 45       	LD        R5, [PC + #6]         ;->0x8000c84c  :=0xffffefff
##@@@F_:Canfd_LL_SetLoopBackMode():
##@@@P_:kf32a13k_drv_canfd.h:690
##@@@L0685_: */   
##@@@L0686_:
##@@@L0687_:KF_INLINE void Canfd_LL_SetLoopBackMode(CanfdPtr Module, const bool Status)   
##@@@L0688_:{   
##@@@L0689_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0690_:    REG_WRITE(Module->CANFD_CTRL1.bits.LPB, Status);   
8000c838:	60 98       	LD.W      R4, [R0 + #1]
8000c83a:	45 69       	ANL       R4, R5
8000c83c:	44 a0       	ST.W      [R0 + #1], R4
##@@@F_:Canfd_LL_SetOperationMode():
##@@@P_:kf32a13k_drv_canfd.c:767
##@@@L0762_:        break;   
##@@@L0763_:    default:   
##@@@L0764_:        /* Should not get here */   
##@@@L0765_:        break;   
##@@@L0766_:    }   
##@@@L0767_:}   
8000c83e:	1d 5c       	JMP       LR
8000c840:	f8 11 00 80 	.long     0x800011f8 ->-2147479048  [!!!@2@:MOV       PC, #24	@@: LD.B      R0, [R0]
8000c844:	ff ff 7f ff 	.long     0xff7fffff ->-08388609 
8000c848:	f7 ff ff ff 	.long     0xfffffff7 ->-00000009 
8000c84c:	ff ef ff ff 	.long     0xffffefff ->-00004097 
##@@@F_:Canfd_LL_SetListenOnlyMode():
##@@@P_:kf32a13k_drv_canfd.h:675
##@@@L0670_: */   
##@@@L0671_:
##@@@L0672_:KF_INLINE void Canfd_LL_SetListenOnlyMode(CanfdPtr Module, const bool Status)   
##@@@L0673_:{   
##@@@L0674_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0675_:    REG_WRITE(Module->CANFD_CTRL1.bits.LOM, Status);   
8000c850:	68 98       	LD.W      R5, [R0 + #1]
8000c852:	48 10       	MOV       R4, #8			;->0x0008
8000c854:	54 6a       	ORL       R5, R4
8000c856:	45 a0       	ST.W      [R0 + #1], R5
##@@@F_:Canfd_LL_SetOperationMode():
##@@@P_:kf32a13k_drv_canfd.c:767
8000c858:	1d 5c       	JMP       LR
##@@@F_:Canfd_LL_SetListenOnlyMode():
##@@@P_:kf32a13k_drv_canfd.h:675
8000c85a:	68 98       	LD.W      R5, [R0 + #1]
8000c85c:	17 44       	LD        R4, [PC + #23]        ;->0x8000c8b8  :=0xfffffff7
8000c85e:	54 69       	ANL       R5, R4
8000c860:	45 a0       	ST.W      [R0 + #1], R5
##@@@F_:Canfd_LL_SetLoopBackMode():
##@@@P_:kf32a13k_drv_canfd.h:690
##@@@L0685_: */   
##@@@L0686_:
##@@@L0687_:KF_INLINE void Canfd_LL_SetLoopBackMode(CanfdPtr Module, const bool Status)   
##@@@L0688_:{   
##@@@L0689_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0690_:    REG_WRITE(Module->CANFD_CTRL1.bits.LPB, Status);   
8000c862:	68 98       	LD.W      R5, [R0 + #1]
8000c864:	16 44       	LD        R4, [PC + #22]        ;->0x8000c8bc  :=0x1000
8000c866:	54 6a       	ORL       R5, R4
8000c868:	45 a0       	ST.W      [R0 + #1], R5
8000c86a:	16 45       	LD        R5, [PC + #22]        ;->0x8000c8c0  :=0xfffdffff
##@@@F_:Canfd_LL_SetSelfReception():
##@@@P_:kf32a13k_drv_canfd.h:902
##@@@L0897_: * @return void   
##@@@L0898_: */   
##@@@L0899_:KF_INLINE void Canfd_LL_SetSelfReception(CanfdPtr Module, const bool Status)   
##@@@L0900_:{   
##@@@L0901_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0902_:    REG_WRITE(Module->CANFD_MCR.bits.SRXDIS, Status ? false : true);   
8000c86c:	40 82       	LD.W      R4, [R0]
8000c86e:	45 69       	ANL       R4, R5
8000c870:	04 85       	ST.W      [R0], R4
8000c872:	21 04       	SJMP      $+33                  ;->0x8000c8b4
##@@@F_:Canfd_LL_SetHaltEnabled():
##@@@P_:kf32a13k_drv_canfd.h:617
##@@@L0612_: */   
##@@@L0613_:
##@@@L0614_:KF_INLINE void Canfd_LL_SetHaltEnabled(CanfdPtr Module, const bool Status)   
##@@@L0615_:{   
##@@@L0616_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0617_:    REG_WRITE(Module->CANFD_MCR.bits.HALT, Status);   
8000c874:	50 82       	LD.W      R5, [R0]
8000c876:	14 44       	LD        R4, [PC + #20]        ;->0x8000c8c4  :=0x10000000
8000c878:	54 6a       	ORL       R5, R4
8000c87a:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_SetFreezeEnabled():
##@@@P_:kf32a13k_drv_canfd.h:578
##@@@L0573_: */   
##@@@L0574_:
##@@@L0575_:KF_INLINE void Canfd_LL_SetFreezeEnabled(CanfdPtr Module, const bool Status)   
##@@@L0576_:{   
##@@@L0577_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0578_:    REG_WRITE(Module->CANFD_MCR.bits.FRZ, Status);   
8000c87c:	50 82       	LD.W      R5, [R0]
8000c87e:	13 44       	LD        R4, [PC + #19]        ;->0x8000c8c8  :=0x40000000
8000c880:	54 6a       	ORL       R5, R4
8000c882:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_IsDisEnabled():
##@@@P_:kf32a13k_drv_canfd.h:645
##@@@L0640_: *         false:模块未使能   
##@@@L0641_: */   
##@@@L0642_:KF_INLINE bool Canfd_LL_IsDisEnabled(CanfdPtr Module)   
##@@@L0643_:{   
##@@@L0644_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0645_:    return (REG_READ(Module->CANFD_MCR.bits.MDIS));   
8000c884:	50 82       	LD.W      R5, [R0]
##@@@F_:Canfd_LL_EnterFreezeMode():
##@@@P_:kf32a13k_drv_canfd.c:201
##@@@L0196_:{   
##@@@L0197_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0198_:    bool enabled = false;   
##@@@L0199_:    Canfd_LL_SetHaltEnabled(Module, true);   
##@@@L0200_:    Canfd_LL_SetFreezeEnabled(Module, true);   
##@@@L0201_:    if (false == Canfd_LL_IsDisEnabled(Module))   
8000c886:	12 44       	LD        R4, [PC + #18]        ;->0x8000c8cc  :=0xffffffff
8000c888:	54 70       	CMP       R5, R4
8000c88a:	05 fc       	JGT       $+5                   ;->0x8000c894
##@@@F_:Canfd_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_canfd.h:632
##@@@L0627_: */   
##@@@L0628_:
##@@@L0629_:KF_INLINE void Canfd_LL_SetModuleDisabled(CanfdPtr Module, const bool Status)   
##@@@L0630_:{   
##@@@L0631_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0632_:    REG_WRITE(Module->CANFD_MCR.bits.MDIS, Status);   
8000c88c:	30 82       	LD.W      R3, [R0]
8000c88e:	11 42       	LD        R2, [PC + #17]        ;->0x8000c8d0  :=0x7fffffff
8000c890:	32 69       	ANL       R3, R2
8000c892:	03 85       	ST.W      [R0], R3
##@@@F_:Canfd_LL_EnterFreezeMode():
8000c894:	10 43       	LD        R3, [PC + #16]        ;->0x8000c8d4  :=0x1000000
##@@@F_:Canfd_LL_GetFreezeAck():
##@@@P_:kf32a13k_drv_canfd.h:590
##@@@L0585_: */   
##@@@L0586_:
##@@@L0587_:KF_INLINE bool Canfd_LL_GetFreezeAck(CanfdPtr Module)   
##@@@L0588_:{   
##@@@L0589_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0590_:    return (REG_READ(Module->CANFD_MCR.bits.FRZACK));   
8000c896:	20 82       	LD.W      R2, [R0]
8000c898:	23 69       	ANL       R2, R3
##@@@F_:Canfd_LL_EnterFreezeMode():
##@@@P_:kf32a13k_drv_canfd.c:209
##@@@L0204_:    }   
##@@@L0205_:    else   
##@@@L0206_:    {   
##@@@L0207_:        Canfd_LL_SetModuleDisabled(Module, false);   
##@@@L0208_:    }   
##@@@L0209_:    while (false == Canfd_LL_GetFreezeAck(Module))   
8000c89a:	20 38       	CMP       R2, #0			;->0x00
8000c89c:	fd f0       	JZ        $-3                   ;->0x8000c896
##@@@P_:kf32a13k_drv_canfd.c:211
##@@@L0210_:        ;   
##@@@L0211_:    if (false == enabled)   
8000c89e:	54 70       	CMP       R5, R4
8000c8a0:	0a fc       	JGT       $+10                  ;->0x8000c8b4
##@@@F_:Canfd_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_canfd.h:632
##@@@L0627_: */   
##@@@L0628_:
##@@@L0629_:KF_INLINE void Canfd_LL_SetModuleDisabled(CanfdPtr Module, const bool Status)   
##@@@L0630_:{   
##@@@L0631_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0632_:    REG_WRITE(Module->CANFD_MCR.bits.MDIS, Status);   
8000c8a2:	40 82       	LD.W      R4, [R0]
8000c8a4:	0d 45       	LD        R5, [PC + #13]        ;->0x8000c8d8  :=0x80000000
8000c8a6:	45 6a       	ORL       R4, R5
8000c8a8:	0d 45       	LD        R5, [PC + #13]        ;->0x8000c8dc  :=0x100000
8000c8aa:	04 85       	ST.W      [R0], R4
##@@@F_:Canfd_LL_GetLowPowerModeAck():
##@@@P_:kf32a13k_drv_canfd.h:602
##@@@L0597_: */   
##@@@L0598_:
##@@@L0599_:KF_INLINE bool Canfd_LL_GetLowPowerModeAck(CanfdPtr Module)   
##@@@L0600_:{   
##@@@L0601_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0602_:    return (REG_READ(Module->CANFD_MCR.bits.LPMACK));   
8000c8ac:	40 82       	LD.W      R4, [R0]
8000c8ae:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_EnterFreezeMode():
##@@@P_:kf32a13k_drv_canfd.c:214
##@@@L0212_:    {   
##@@@L0213_:        Canfd_LL_SetModuleDisabled(Module, true);   
##@@@L0214_:        while (false == Canfd_LL_GetLowPowerModeAck(Module))   
8000c8b0:	40 38       	CMP       R4, #0			;->0x00
8000c8b2:	fd f0       	JZ        $-3                   ;->0x8000c8ac
##@@@F_:Canfd_LL_SetOperationMode():
##@@@P_:kf32a13k_drv_canfd.c:767
##@@@L0762_:        break;   
##@@@L0763_:    default:   
##@@@L0764_:        /* Should not get here */   
##@@@L0765_:        break;   
##@@@L0766_:    }   
##@@@L0767_:}   
8000c8b4:	1d 5c       	JMP       LR
8000c8b6:	00 00       	NOP      NOP      
8000c8b8:	f7 ff ff ff 	.long     0xfffffff7 ->-00000009 
8000c8bc:	00 10 00 00 	.long     0x00001000 ->000004096  [!!!@2@:MOV       R0, #0	@@: NOP      
8000c8c0:	ff ff fd ff 	.long     0xfffdffff ->-00131073 
8000c8c4:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
8000c8c8:	00 00 00 40 	.long     0x40000000 ->1073741824  [!!!@2@:NOP      	@@: LD        R0, [PC + #0]         ;->0x8000c8c8  :=0x40000000
8000c8cc:	ff ff ff ff 	.long     0xffffffff ->-00000001 
8000c8d0:	ff ff ff 7f 	.long     0x7fffffff ->2147483647 
8000c8d4:	00 00 00 01 	.long     0x01000000 ->016777216  [!!!@2@:NOP      	@@: CMN       R0, R0
8000c8d8:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
8000c8dc:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16
##@@@F_:Canfd_LL_SetModuleDisabled():
##@@@P_:kf32a13k_drv_canfd.h:632
##@@@L0627_: */   
##@@@L0628_:
##@@@L0629_:KF_INLINE void Canfd_LL_SetModuleDisabled(CanfdPtr Module, const bool Status)   
##@@@L0630_:{   
##@@@L0631_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0632_:    REG_WRITE(Module->CANFD_MCR.bits.MDIS, Status);   
8000c8e0:	50 82       	LD.W      R5, [R0]
8000c8e2:	03 44       	LD        R4, [PC + #3]         ;->0x8000c8ec  :=0x80000000
8000c8e4:	54 6a       	ORL       R5, R4
8000c8e6:	05 85       	ST.W      [R0], R5
##@@@F_:Canfd_LL_SetOperationMode():
##@@@P_:kf32a13k_drv_canfd.c:767
8000c8e8:	1d 5c       	JMP       LR
8000c8ea:	00 00       	NOP      NOP      
8000c8ec:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]

8000c8f0 <Canfd_LL_ClearMbIntrFlag>:
##@@@F_:Canfd_LL_ClearMbIntrFlag():
##@@@P_:kf32a13k_drv_canfd.c:776
##@@@L0771_: * @param Module   
##@@@L0772_: * @param MbIndex   
##@@@L0773_: * @retval void   
##@@@L0774_: */   
##@@@L0775_:void Canfd_LL_ClearMbIntrFlag(CanfdPtr Module, const uint32_t MbIndex)   
##@@@L0776_:{   
8000c8f0:	5f 11       	MOV       R5, #31			;->0x001F
##@@@P_:kf32a13k_drv_canfd.c:777
##@@@L0777_:    uint32_t flag = ((uint32_t)1U << (MbIndex % 32U));   
8000c8f2:	81 58       	MOV       R4, R1
8000c8f4:	45 69       	ANL       R4, R5
8000c8f6:	51 10       	MOV       R5, #1			;->0x0001
8000c8f8:	54 6c       	LSL       R5, R4
##@@@P_:kf32a13k_drv_canfd.c:779
##@@@L0778_:    /* Clear the corresponding message buffer interrupt flag*/   
##@@@L0779_:    if (MbIndex < 32U)   
8000c8fa:	1f 39       	CMP       R1, #31			;->0x1F
8000c8fc:	02 f8       	JHI       $+2                   ;->0x8000c900
##@@@F_:Canfd_LL_ClearInt1Flag():
##@@@P_:kf32a13k_drv_canfd.h:1509
##@@@L1504_: * @return void   
##@@@L1505_: */   
##@@@L1506_:KF_INLINE void Canfd_LL_ClearInt1Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1507_:{   
##@@@L1508_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1509_:    REG_WRITE(Module->CANFD_IFLAG1.reg, Flag);   
8000c8fe:	05 a3       	ST.W      [R0 + #12], R5
##@@@F_:Canfd_LL_ClearMbIntrFlag():
8000c900:	08 44       	LD        R4, [PC + #8]         ;->0x8000c920  :=0xffffffe0
##@@@P_:kf32a13k_drv_canfd.c:784
##@@@L0780_:    {   
##@@@L0781_:        Canfd_LL_ClearInt1Flag(Module, flag);   
##@@@L0782_:    }   
##@@@L0783_:#if CANFD_MAX_MBNUM > 32U   
##@@@L0784_:    if ((MbIndex >= 32U) && (MbIndex < 64U))   
8000c902:	14 69       	ANL       R1, R4
8000c904:	10 3e       	CMP       R1, #96			;->0x60
8000c906:	07 f0       	JZ        $+7                   ;->0x8000c914
8000c908:	10 3c       	CMP       R1, #64			;->0x40
8000c90a:	07 f0       	JZ        $+7                   ;->0x8000c918
8000c90c:	10 3a       	CMP       R1, #32			;->0x20
8000c90e:	07 f1       	JNZ       $+7                   ;->0x8000c91c
##@@@F_:Canfd_LL_ClearInt2Flag():
##@@@P_:kf32a13k_drv_canfd.h:1555
##@@@L1550_: * @return void   
##@@@L1551_: */   
##@@@L1552_:KF_INLINE void Canfd_LL_ClearInt2Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1553_:{   
##@@@L1554_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1555_:    REG_WRITE(Module->CANFD_IFLAG2.reg, Flag);   
8000c910:	0c 2a       	ADD       R0, #44			;->0x2C
8000c912:	04 04       	SJMP      $+4                   ;->0x8000c91a
##@@@F_:Canfd_LL_ClearInt4Flag():
##@@@P_:kf32a13k_drv_canfd.h:1647
##@@@L1642_: * @return void   
##@@@L1643_: */   
##@@@L1644_:KF_INLINE void Canfd_LL_ClearInt4Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1645_:{   
##@@@L1646_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1647_:    REG_WRITE(Module->CANFD_IFLAG4.reg, Flag);   
8000c914:	00 2f       	ADD       R0, #112			;->0x70
8000c916:	02 04       	SJMP      $+2                   ;->0x8000c91a
##@@@F_:Canfd_LL_ClearInt3Flag():
##@@@P_:kf32a13k_drv_canfd.h:1601
##@@@L1596_: * @return void   
##@@@L1597_: */   
##@@@L1598_:KF_INLINE void Canfd_LL_ClearInt3Flag(CanfdPtr Module, uint32_t Flag)   
##@@@L1599_:{   
##@@@L1600_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1601_:    REG_WRITE(Module->CANFD_IFLAG3.reg, Flag);   
8000c918:	04 2f       	ADD       R0, #116			;->0x74
##@@@F_:Canfd_LL_ClearMbIntrFlag():
8000c91a:	05 85       	ST.W      [R0], R5
##@@@P_:kf32a13k_drv_canfd.c:801
##@@@L0796_:    if ((MbIndex >= 96U) & (MbIndex < 128U))   
##@@@L0797_:    {   
##@@@L0798_:        Canfd_LL_ClearInt4Flag(Module, flag);   
##@@@L0799_:    }   
##@@@L0800_:#endif   
##@@@L0801_:}   
8000c91c:	1d 5c       	JMP       LR
8000c91e:	00 00       	NOP      NOP      
8000c920:	e0 ff ff ff 	.long     0xffffffe0 ->-00000032 

8000c924 <Canfd_LL_GetMbIntrFlag>:
##@@@F_:Canfd_LL_GetMbIntrFlag():
##@@@P_:kf32a13k_drv_canfd.c:812
##@@@L0807_: * @retval bool   
##@@@L0808_: */   
##@@@L0809_:bool Canfd_LL_GetMbIntrFlag(CanfdPtr Module, const uint32_t MbIndex)   
##@@@L0810_:{   
##@@@L0811_:    bool flag = false;   
##@@@L0812_:    if (MbIndex < 32U)   
8000c924:	1f 39       	CMP       R1, #31			;->0x1F
8000c926:	06 f8       	JHI       $+6                   ;->0x8000c932
##@@@F_:Canfd_LL_GetInt1Flag():
##@@@P_:kf32a13k_drv_canfd.h:1520
##@@@L1515_: * @return void   
##@@@L1516_: */   
##@@@L1517_:KF_INLINE uint32_t Canfd_LL_GetInt1Flag(CanfdPtr Module)   
##@@@L1518_:{   
##@@@L1519_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1520_:    return(REG_READ(Module->CANFD_IFLAG1.reg));   
8000c928:	28 9b       	LD.W      R5, [R0 + #12]
##@@@F_:Canfd_LL_GetMbIntrFlag():
##@@@P_:kf32a13k_drv_canfd.c:814
##@@@L0813_:    {   
##@@@L0814_:        flag = ((Canfd_LL_GetInt1Flag(Module) & ((uint32_t)1U << (MbIndex % 32U))) != 0U ? true : false);   
8000c92a:	51 6d       	LSR       R5, R1
8000c92c:	41 10       	MOV       R4, #1			;->0x0001
8000c92e:	54 69       	ANL       R5, R4
8000c930:	02 04       	SJMP      $+2                   ;->0x8000c934
8000c932:	50 10       	MOV       R5, #0			;->0x0000
8000c934:	0b 43       	LD        R3, [PC + #11]        ;->0x8000c960  :=0xffffffe0
##@@@P_:kf32a13k_drv_canfd.c:817
##@@@L0815_:    }   
##@@@L0816_:#if CANFD_MAX_MBNUM > 32U   
##@@@L0817_:    if ((MbIndex >= 32U) && (MbIndex < 64U))   
8000c936:	81 58       	MOV       R4, R1
8000c938:	43 69       	ANL       R4, R3
8000c93a:	40 3c       	CMP       R4, #64			;->0x40
8000c93c:	05 f0       	JZ        $+5                   ;->0x8000c946
8000c93e:	40 3a       	CMP       R4, #32			;->0x20
8000c940:	05 f1       	JNZ       $+5                   ;->0x8000c94a
##@@@F_:Canfd_LL_GetInt2Flag():
##@@@P_:kf32a13k_drv_canfd.h:1566
##@@@L1561_: * @return void   
##@@@L1562_: */   
##@@@L1563_:KF_INLINE uint32_t Canfd_LL_GetInt2Flag(CanfdPtr Module)   
##@@@L1564_:{   
##@@@L1565_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1566_:    return(REG_READ(Module->CANFD_IFLAG2.reg));   
8000c942:	0c 2a       	ADD       R0, #44			;->0x2C
8000c944:	06 04       	SJMP      $+6                   ;->0x8000c950
##@@@F_:Canfd_LL_GetInt3Flag():
##@@@P_:kf32a13k_drv_canfd.h:1612
##@@@L1607_: * @return void   
##@@@L1608_: */   
##@@@L1609_:KF_INLINE uint32_t Canfd_LL_GetInt3Flag(CanfdPtr Module)   
##@@@L1610_:{   
##@@@L1611_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1612_:    return(REG_READ(Module->CANFD_IFLAG3.reg));   
8000c946:	04 2f       	ADD       R0, #116			;->0x74
8000c948:	04 04       	SJMP      $+4                   ;->0x8000c950
##@@@F_:Canfd_LL_GetMbIntrFlag():
##@@@P_:kf32a13k_drv_canfd.c:829
##@@@L0824_:    {   
##@@@L0825_:        flag = ((Canfd_LL_GetInt3Flag(Module) & ((uint32_t)1U << (MbIndex % 32U))) != 0U ? true : false);   
##@@@L0826_:    }   
##@@@L0827_:#endif   
##@@@L0828_:#if CANFD_MAX_MBNUM > 96U   
##@@@L0829_:    if (MbIndex >= 96U)   
8000c94a:	10 3e       	CMP       R1, #96			;->0x60
8000c94c:	08 f3       	JNC       $+8                   ;->0x8000c95c
##@@@F_:Canfd_LL_GetInt4Flag():
##@@@P_:kf32a13k_drv_canfd.h:1658
##@@@L1653_: * @return void   
##@@@L1654_: */   
##@@@L1655_:KF_INLINE uint32_t Canfd_LL_GetInt4Flag(CanfdPtr Module)   
##@@@L1656_:{   
##@@@L1657_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1658_:    return(REG_READ(Module->CANFD_IFLAG4.reg));   
8000c94e:	00 2f       	ADD       R0, #112			;->0x70
##@@@F_:Canfd_LL_GetMbIntrFlag():
8000c950:	4f 11       	MOV       R4, #31			;->0x001F
8000c952:	50 82       	LD.W      R5, [R0]
8000c954:	14 69       	ANL       R1, R4
8000c956:	51 6d       	LSR       R5, R1
8000c958:	41 10       	MOV       R4, #1			;->0x0001
8000c95a:	54 69       	ANL       R5, R4
##@@@P_:kf32a13k_drv_canfd.c:834
##@@@L0830_:    {   
##@@@L0831_:        flag = ((Canfd_LL_GetInt4Flag(Module) & ((uint32_t)1U << (MbIndex % 32U))) != 0U ? true : false);   
##@@@L0832_:    }   
##@@@L0833_:#endif   
##@@@L0834_:    return flag;   
8000c95c:	05 58       	MOV       R0, R5
8000c95e:	1d 5c       	JMP       LR
8000c960:	e0 ff ff ff 	.long     0xffffffe0 ->-00000032 

8000c964 <Canfd_LL_SetMbIntr>:
##@@@F_:Canfd_LL_GetMaxMbNum():
##@@@P_:kf32a13k_drv_canfd.h:850
##@@@L0845_: * @return void   
##@@@L0846_: */   
##@@@L0847_:KF_INLINE uint8_t Canfd_LL_GetMaxMbNum(CanfdPtr Module)   
##@@@L0848_:{   
##@@@L0849_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0850_:    return (REG_READ(Module->CANFD_MCR.bits.MAXMB));   
8000c964:	50 82       	LD.W      R5, [R0]
8000c966:	4f 17       	MOV       R4, #127			;->0x007F
8000c968:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_SetMbIntr():
##@@@L0845_:{   
##@@@L0846_:    kf_status_t retStatus = STATUS_OK;   
##@@@L0847_:    uint32_t    intBefore = 0U;   
##@@@L0848_:    uint32_t    intCmd    = 0U;   
##@@@L0849_:    uint32_t    intClear  = 0U;   
##@@@L0850_:    if (MbIndex > Canfd_LL_GetMaxMbNum(Module))   
8000c96a:	51 70       	CMP       R5, R1
8000c96c:	1a f3       	JNC       $+26                  ;->0x8000c9a0
8000c96e:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:kf32a13k_drv_canfd.c:856
##@@@L0851_:    {   
##@@@L0852_:        retStatus = STATUS_CANFD_BUFF_OUT_OF_RANGE;   
##@@@L0853_:    }   
##@@@L0854_:    else   
##@@@L0855_:    {   
##@@@L0856_:        intClear = ~(true << (MbIndex));   
8000c970:	51 6c       	LSL       R5, R1
8000c972:	55 68       	NOT       R5, R5
##@@@P_:kf32a13k_drv_canfd.c:859
##@@@L0857_:        intCmd   = (intCmd << (MbIndex));   
##@@@L0858_:        /* Enable the corresponding message buffer Interrupt */   
##@@@L0859_:        if (MbIndex < 32U)   
8000c974:	1f 39       	CMP       R1, #31			;->0x1F
8000c976:	04 f8       	JHI       $+4                   ;->0x8000c97e
##@@@F_:Canfd_LL_GetInt1Mask():
##@@@P_:kf32a13k_drv_canfd.h:1497
##@@@L1492_: * @return void   
##@@@L1493_: */   
##@@@L1494_:KF_INLINE uint32_t Canfd_LL_GetInt1Mask(CanfdPtr Module)   
##@@@L1495_:{   
##@@@L1496_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1497_:    return (REG_READ(Module->CANFD_IMASK1.reg));   
8000c978:	a0 9a       	LD.W      R4, [R0 + #10]
##@@@F_:Canfd_LL_SetMbIntr():
##@@@P_:kf32a13k_drv_canfd.c:862
##@@@L0860_:        {   
##@@@L0861_:            intBefore = Canfd_LL_GetInt1Mask(Module);   
##@@@L0862_:            intBefore &= intClear;   
8000c97a:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_SetInt1Mask():
##@@@P_:kf32a13k_drv_canfd.h:1486
##@@@L1481_: * @return void   
##@@@L1482_: */   
##@@@L1483_:KF_INLINE void Canfd_LL_SetInt1Mask(CanfdPtr Module, uint32_t Mask)   
##@@@L1484_:{   
##@@@L1485_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1486_:    REG_WRITE(Module->CANFD_IMASK1.reg, Mask);   
8000c97c:	84 a2       	ST.W      [R0 + #10], R4
##@@@F_:Canfd_LL_SetMbIntr():
8000c97e:	0a 43       	LD        R3, [PC + #10]        ;->0x8000c9a4  :=0xffffffe0
##@@@P_:kf32a13k_drv_canfd.c:867
##@@@L0863_:            intBefore |= intCmd;   
##@@@L0864_:            Canfd_LL_SetInt1Mask(Module, intBefore);   
##@@@L0865_:        }   
##@@@L0866_:#if CANFD_MAX_MBNUM > 32U   
##@@@L0867_:        if ((MbIndex >= 32U) && (MbIndex < 64U))   
8000c980:	81 58       	MOV       R4, R1
8000c982:	43 69       	ANL       R4, R3
8000c984:	40 3c       	CMP       R4, #64			;->0x40
8000c986:	05 f0       	JZ        $+5                   ;->0x8000c990
8000c988:	40 3a       	CMP       R4, #32			;->0x20
8000c98a:	05 f1       	JNZ       $+5                   ;->0x8000c994
##@@@F_:Canfd_LL_GetInt2Mask():
##@@@P_:kf32a13k_drv_canfd.h:1543
##@@@L1538_: * @return void   
##@@@L1539_: */   
##@@@L1540_:KF_INLINE uint32_t Canfd_LL_GetInt2Mask(CanfdPtr Module)   
##@@@L1541_:{   
##@@@L1542_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1543_:    return (REG_READ(Module->CANFD_IMASK2.reg));   
8000c98c:	04 2a       	ADD       R0, #36			;->0x24
8000c98e:	06 04       	SJMP      $+6                   ;->0x8000c99a
##@@@F_:Canfd_LL_GetInt3Mask():
##@@@P_:kf32a13k_drv_canfd.h:1589
##@@@L1584_: * @return void   
##@@@L1585_: */   
##@@@L1586_:KF_INLINE uint32_t Canfd_LL_GetInt3Mask(CanfdPtr Module)   
##@@@L1587_:{   
##@@@L1588_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1589_:    return (REG_READ(Module->CANFD_IMASK3.reg));   
8000c990:	0c 2e       	ADD       R0, #108			;->0x6C
8000c992:	04 04       	SJMP      $+4                   ;->0x8000c99a
##@@@F_:Canfd_LL_SetMbIntr():
##@@@P_:kf32a13k_drv_canfd.c:885
##@@@L0880_:            intBefore |= intCmd;   
##@@@L0881_:            Canfd_LL_SetInt3Mask(Module, intBefore);   
##@@@L0882_:        }   
##@@@L0883_:#endif   
##@@@L0884_:#if CANFD_MAX_MBNUM > 96U   
##@@@L0885_:        if (MbIndex >= 96U)   
8000c994:	10 3e       	CMP       R1, #96			;->0x60
8000c996:	05 f3       	JNC       $+5                   ;->0x8000c9a0
##@@@F_:Canfd_LL_GetInt4Mask():
##@@@P_:kf32a13k_drv_canfd.h:1635
##@@@L1630_: * @return void   
##@@@L1631_: */   
##@@@L1632_:KF_INLINE uint32_t Canfd_LL_GetInt4Mask(CanfdPtr Module)   
##@@@L1633_:{   
##@@@L1634_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1635_:    return (REG_READ(Module->CANFD_IMASK4.reg));   
8000c998:	08 2e       	ADD       R0, #104			;->0x68
##@@@F_:Canfd_LL_SetMbIntr():
8000c99a:	40 82       	LD.W      R4, [R0]
8000c99c:	45 69       	ANL       R4, R5
8000c99e:	04 85       	ST.W      [R0], R4
8000c9a0:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:895
##@@@L0890_:            Canfd_LL_SetInt4Mask(Module, intBefore);   
##@@@L0891_:        }   
##@@@L0892_:#endif   
##@@@L0893_:    }   
##@@@L0894_:    retStatus = STATUS_OK;   
##@@@L0895_:    return (retStatus);   
8000c9a2:	1d 5c       	JMP       LR
8000c9a4:	e0 ff ff ff 	.long     0xffffffe0 ->-00000032 

8000c9a8 <Canfd_LL_SetErrIntCmd>:
##@@@F_:Canfd_LL_SetErrIntCmd():
##@@@P_:kf32a13k_drv_canfd.c:908
##@@@L0903_: * @retval kf_status_t   
##@@@L0904_: */   
##@@@L0905_:void Canfd_LL_SetErrIntCmd(CanfdPtr Module, Canfd_Inttype_t ErrType, const bool Status)   
##@@@L0906_:{   
##@@@L0907_:    uint32_t intBefore = 0U;   
##@@@L0908_:    if ((ErrType == CANFD_INT_RX_WARNING) || (ErrType == CANFD_INT_TX_WARNING))   
8000c9a8:	0c 45       	LD        R5, [PC + #12]        ;->0x8000c9d8  :=0x400
8000c9aa:	15 70       	CMP       R1, R5
8000c9ac:	07 f0       	JZ        $+7                   ;->0x8000c9ba
8000c9ae:	0c 45       	LD        R5, [PC + #12]        ;->0x8000c9dc  :=0x4000
8000c9b0:	15 70       	CMP       R1, R5
8000c9b2:	1d f0       	JZ        $+29                  ;->0x8000c9ec
8000c9b4:	0b 45       	LD        R5, [PC + #11]        ;->0x8000c9e0  :=0x800
8000c9b6:	15 70       	CMP       R1, R5
8000c9b8:	0b f1       	JNZ       $+11                  ;->0x8000c9ce
8000c9ba:	0b 45       	LD        R5, [PC + #11]        ;->0x8000c9e4  :=0xffdfffff
8000c9bc:	0b 44       	LD        R4, [PC + #11]        ;->0x8000c9e8  :=0x200000
8000c9be:	60 58       	MOV       R3, R0
8000c9c0:	20 38       	CMP       R2, #0			;->0x00
8000c9c2:	02 f1       	JNZ       $+2                   ;->0x8000c9c6
8000c9c4:	40 10       	MOV       R4, #0			;->0x0000
8000c9c6:	23 82       	LD.W      R2, [R3]
8000c9c8:	25 69       	ANL       R2, R5
8000c9ca:	24 6a       	ORL       R2, R4
8000c9cc:	32 85       	ST.W      [R3], R2
##@@@F_:Canfd_LL_GetErrorIntMask():
##@@@P_:kf32a13k_drv_canfd.h:732
##@@@L0727_: */   
##@@@L0728_:
##@@@L0729_:KF_INLINE uint32_t Canfd_LL_GetErrorIntMask(CanfdPtr Module)   
##@@@L0730_:{   
##@@@L0731_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0732_:    return (REG_READ(Module->CANFD_CTRL1.reg));   
8000c9ce:	68 98       	LD.W      R5, [R0 + #1]
##@@@F_:Canfd_LL_SetErrIntCmd():
##@@@P_:kf32a13k_drv_canfd.c:917
##@@@L0912_:    if (ErrType == CANFD_INT_ERR)   
##@@@L0913_:    {   
##@@@L0914_:        Canfd_LL_EnableErrorFastIntr(Module, Status);   
##@@@L0915_:    }   
##@@@L0916_:    intBefore = Canfd_LL_GetErrorIntMask(Module);   
##@@@L0917_:    intBefore |= ErrType;   
8000c9d0:	51 6a       	ORL       R5, R1
##@@@F_:Canfd_LL_SetErrorIntMask():
##@@@P_:kf32a13k_drv_canfd.h:747
##@@@L0742_: */   
##@@@L0743_:
##@@@L0744_:KF_INLINE void Canfd_LL_SetErrorIntMask(CanfdPtr Module, const uint32_t IntMask)   
##@@@L0745_:{   
##@@@L0746_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0747_:    REG_WRITE(Module->CANFD_CTRL1.reg, IntMask);   
8000c9d2:	45 a0       	ST.W      [R0 + #1], R5
##@@@F_:Canfd_LL_SetErrIntCmd():
##@@@P_:kf32a13k_drv_canfd.c:919
##@@@L0918_:    Canfd_LL_SetErrorIntMask(Module, intBefore);   
##@@@L0919_:}   
8000c9d4:	1d 5c       	JMP       LR
8000c9d6:	00 00       	NOP      NOP      
8000c9d8:	00 04 00 00 	.long     0x00000400 ->000001024  [!!!@2@:SJMP      $+0                   ;->0x8000c9d8	@@: NOP      
8000c9dc:	00 40 00 00 	.long     0x00004000 ->000016384  [!!!@2@:LD        R0, [PC + #0]         ;->0x8000c9dc  :=0x4000	@@: NOP      
8000c9e0:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000c9e4:	ff ff df ff 	.long     0xffdfffff ->-02097153 
8000c9e8:	00 00 20 00 	.long     0x00200000 ->002097152  [!!!@2@:NOP      	@@: FST.W            [R0+#0],	S1
8000c9ec:	04 45       	LD        R5, [PC + #4]         ;->0x8000c9fc  :=0x7fffffff
8000c9ee:	05 44       	LD        R4, [PC + #5]         ;->0x8000ca00  :=0x80000000
##@@@F_:Canfd_LL_EnableErrorFastIntr():
##@@@P_:kf32a13k_drv_canfd.h:720
##@@@L0715_: */   
##@@@L0716_:
##@@@L0717_:KF_INLINE void Canfd_LL_EnableErrorFastIntr(CanfdPtr Module, const bool Status)   
##@@@L0718_:{   
##@@@L0719_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0720_:    REG_WRITE(Module->CANFD_CTRL2.bits.ERRMSK_FAST, Status);   
8000c9f0:	60 58       	MOV       R3, R0
8000c9f2:	34 2b       	ADD       R3, #52			;->0x34
##@@@F_:Canfd_LL_SetErrIntCmd():
8000c9f4:	20 38       	CMP       R2, #0			;->0x00
8000c9f6:	e7 f0       	JZ        $-25                  ;->0x8000c9c4
8000c9f8:	e7 07       	SJMP      $-25                  ;->0x8000c9c6
8000c9fa:	00 00       	NOP      NOP      
8000c9fc:	ff ff ff 7f 	.long     0x7fffffff ->2147483647 
8000ca00:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]

8000ca04 <Canfd_LL_AbortTxMb>:
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000ca04:	40 82       	LD.W      R4, [R0]
8000ca06:	11 45       	LD        R5, [PC + #17]        ;->0x8000ca48  :=0x800
8000ca08:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000ca0a:	40 38       	CMP       R4, #0			;->0x00
8000ca0c:	03 f1       	JNZ       $+3                   ;->0x8000ca12
8000ca0e:	40 11       	MOV       R4, #16			;->0x0010
8000ca10:	09 04       	SJMP      $+9                   ;->0x8000ca22
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000ca12:	0f 44       	LD        R4, [PC + #15]        ;->0x8000ca4c  :=0xc00
8000ca14:	18 e9       	LD.W      R3, [R0 + R4]
8000ca16:	18 7d       	LSR       R3, #16			;->0x10
8000ca18:	43 10       	MOV       R4, #3			;->0x0003
8000ca1a:	34 69       	ANL       R3, R4
8000ca1c:	48 10       	MOV       R4, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000ca1e:	43 6c       	LSL       R4, R3
8000ca20:	48 28       	ADD       R4, #8			;->0x08
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:682
##@@@L0677_:    uint8_t  payloadSize          = Canfd_LL_GetPayloadSize(Module);   
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
8000ca22:	2d d3       	DIVU      R5, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000ca24:	59 d3       	DIVU      R3, R1, R5
8000ca26:	6b cb       	MULS      R5, R3, R5
8000ca28:	69 c7       	SUB       R5, R1, R5
8000ca2a:	9b 7a       	LSL       R3, #11			;->0x0B
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000ca2c:	22 7c       	LSR       R4, #2			;->0x02
8000ca2e:	19 00 a4 0c 	MADD32    R3, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000ca32:	1a 7a       	LSL       R3, #2			;->0x02
8000ca34:	e8 c2       	ADD       R5, R0, R3
8000ca36:	07 44       	LD        R4, [PC + #7]         ;->0x8000ca50  :=0xf0ffffff
##@@@F_:Canfd_LL_AbortTxMb():
8000ca38:	40 00 a3 90 	LD.W      R3, [R5 + #36]			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:931
##@@@L0926_: */   
##@@@L0927_:void Canfd_LL_AbortTxMb(CanfdPtr Module, uint32_t MbIndex)   
##@@@L0928_:{   
##@@@L0929_:    uint32_t           csInfor    = 0;   
##@@@L0930_:    volatile uint32_t *mailboxPtr = Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L0931_:    csInfor                       = *mailboxPtr;   
8000ca3c:	06 42       	LD        R2, [PC + #6]         ;->0x8000ca54  :=0x9000000
##@@@P_:kf32a13k_drv_canfd.c:933
##@@@L0932_:    /* reset the code */   
##@@@L0933_:    csInfor &= (~CAN_CS_CODE_MASK);   
8000ca3e:	34 69       	ANL       R3, R4
##@@@P_:kf32a13k_drv_canfd.c:935
##@@@L0934_:    /* set abort code */   
##@@@L0935_:    csInfor |= (CANFD_TX_ABORT << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK;   
8000ca40:	32 6a       	ORL       R3, R2
8000ca42:	68 00 a3 90 	ST        [R5 + #36], R3			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:938
##@@@L0936_:    /* reload the code */   
##@@@L0937_:    *mailboxPtr = csInfor;   
##@@@L0938_:}   
8000ca46:	1d 5c       	JMP       LR
8000ca48:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000ca4c:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000ca50:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
8000ca54:	00 00 00 09 	.long     0x09000000 ->150994944  [!!!@2@:NOP      	@@: LD.W      R1, [SP + #0]

8000ca58 <Canfd_LL_SetTxMb>:
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:950
##@@@L0945_: * @param DataPtr   
##@@@L0946_: * @retval kf_status_t   
##@@@L0947_: */   
##@@@L0948_:kf_status_t   
##@@@L0949_:Canfd_LL_SetTxMb(CanfdPtr Module, uint32_t MbIndex, uint32_t Code, Canfd_PduInfo_t *PduInfoPtr, uint8_t *DataPtr)   
##@@@L0950_:{   
8000ca58:	3f 5f       	PUSH      {R6-R11}
8000ca5a:	e4 31       	SUB       SP, #20			;->0x14
##@@@F_:Canfd_LL_GetMaxMbNum():
##@@@P_:kf32a13k_drv_canfd.h:850
##@@@L0845_: * @return void   
##@@@L0846_: */   
##@@@L0847_:KF_INLINE uint8_t Canfd_LL_GetMaxMbNum(CanfdPtr Module)   
##@@@L0848_:{   
##@@@L0849_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0850_:    return (REG_READ(Module->CANFD_MCR.bits.MAXMB));   
8000ca5c:	60 82       	LD.W      R6, [R0]
8000ca5e:	5f 17       	MOV       R5, #127			;->0x007F
8000ca60:	65 69       	ANL       R6, R5
8000ca62:	8e 45       	LD        R5, [PC + #142]       ;->0x8000cc98  :=0x380
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:957
##@@@L0952_:    uint8_t     rxfifoFilterNum = 0U;   
##@@@L0953_:    uint32_t    databyte        = 0U;   
##@@@L0954_:    uint8_t     realDlc         = 0U;   
##@@@L0955_:    uint8_t     payloadLength   = 0U;   
##@@@L0956_:    uint8_t     maxMailboxIndex = Canfd_LL_GetMaxMbNum(Module);   
##@@@L0957_:    if (MbIndex > maxMailboxIndex)   
8000ca64:	61 70       	CMP       R6, R1
8000ca66:	02 f2       	JC        $+2                   ;->0x8000ca6a
8000ca68:	13 05       	SJMP      $+275                 ;->0x8000cc8e
##@@@F_:Canfd_LL_IsRxFifoEnabled():
##@@@P_:kf32a13k_drv_canfd.h:935
##@@@L0930_: * @return bool   
##@@@L0931_: */   
##@@@L0932_:KF_INLINE bool Canfd_LL_IsRxFifoEnabled(CanfdPtr Module)   
##@@@L0933_:{   
##@@@L0934_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0935_:    return (REG_READ(Module->CANFD_MCR.bits.RFEN));   
8000ca6a:	60 82       	LD.W      R6, [R0]
8000ca6c:	8c 47       	LD        R7, [PC + #140]       ;->0x8000cc9c  :=0x20000000
8000ca6e:	67 69       	ANL       R6, R7
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:961
##@@@L0958_:    {   
##@@@L0959_:        retStatus = STATUS_CANFD_BUFF_OUT_OF_RANGE;   
##@@@L0960_:    }   
##@@@L0961_:    else if (true == Canfd_LL_IsRxFifoEnabled(Module))   
8000ca70:	60 38       	CMP       R6, #0			;->0x00
8000ca72:	0c f1       	JNZ       $+12                  ;->0x8000ca8a
8000ca74:	62 59       	MOV       R11, R2
8000ca76:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:972
##@@@L0967_:        }   
##@@@L0968_:    }   
##@@@L0969_:    else   
##@@@L0970_:    {   
##@@@L0971_:        /* Clean up the arbitration field area */   
##@@@L0972_:        volatile CANFD_CS_T  csInfor          = {0U};   
8000ca78:	04 25       	ST.W      [SP + #4], R5
##@@@P_:kf32a13k_drv_canfd.c:973
##@@@L0973_:        volatile CANFD_ID_T  mailboxId        = {0U};   
8000ca7a:	03 25       	ST.W      [SP + #3], R5
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000ca7c:	50 82       	LD.W      R5, [R0]
8000ca7e:	89 42       	LD        R2, [PC + #137]       ;->0x8000cca0  :=0x800
8000ca80:	52 69       	ANL       R5, R2
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000ca82:	50 38       	CMP       R5, #0			;->0x00
8000ca84:	0e f1       	JNZ       $+14                  ;->0x8000caa0
##@@@F_:Canfd_LL_SetTxMb():
8000ca86:	50 11       	MOV       R5, #16			;->0x0010
8000ca88:	14 04       	SJMP      $+20                  ;->0x8000cab0
##@@@F_:Canfd_LL_GetLegacyFifoFilterNum():
##@@@P_:kf32a13k_drv_canfd.h:1292
##@@@L1287_: * @return uint32_t   
##@@@L1288_: */   
##@@@L1289_:KF_INLINE uint32_t Canfd_LL_GetLegacyFifoFilterNum(CanfdPtr Module)   
##@@@L1290_:{   
##@@@L1291_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1292_:    return (REG_READ(Module->CANFD_CTRL2.bits.RFFN));   
8000ca8a:	60 9b       	LD.W      R4, [R0 + #13]
##@@@F_:Canfd_LL_RxFifoOcuppiedLastMsgBuff():
##@@@P_:kf32a13k_drv_canfd.h:913
##@@@L0908_: * @return bool   
##@@@L0909_: */   
##@@@L0910_:KF_INLINE uint32_t Canfd_LL_RxFifoOcuppiedLastMsgBuff(uint32_t FilterNumber)   
##@@@L0911_:{   
##@@@L0912_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0913_:    return (5U + ((((FilterNumber) + 1U) * 8U) / 4U));   
8000ca8c:	25 7d       	LSR       R4, #21			;->0x15
8000ca8e:	38 17       	MOV       R3, #120			;->0x0078
8000ca90:	43 69       	ANL       R4, R3
8000ca92:	48 28       	ADD       R4, #8			;->0x08
8000ca94:	22 7c       	LSR       R4, #2			;->0x02
8000ca96:	64 c1       	ADD       R4, R4, #5
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:964
##@@@L0959_:        retStatus = STATUS_CANFD_BUFF_OUT_OF_RANGE;   
##@@@L0960_:    }   
##@@@L0961_:    else if (true == Canfd_LL_IsRxFifoEnabled(Module))   
##@@@L0962_:    {   
##@@@L0963_:        rxfifoFilterNum = Canfd_LL_GetLegacyFifoFilterNum(Module);   
##@@@L0964_:        if (MbIndex <= Canfd_LL_RxFifoOcuppiedLastMsgBuff(rxfifoFilterNum))   
8000ca98:	41 70       	CMP       R4, R1
8000ca9a:	02 f2       	JC        $+2                   ;->0x8000ca9e
8000ca9c:	f8 04       	SJMP      $+248                 ;->0x8000cc8c
8000ca9e:	f8 04       	SJMP      $+248                 ;->0x8000cc8e
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000caa0:	81 45       	LD        R5, [PC + #129]       ;->0x8000cca4  :=0xc00
8000caa2:	78 e9       	LD.W      R7, [R0 + R5]
8000caa4:	38 7d       	LSR       R7, #16			;->0x10
8000caa6:	53 10       	MOV       R5, #3			;->0x0003
8000caa8:	75 69       	ANL       R7, R5
8000caaa:	58 10       	MOV       R5, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000caac:	57 6c       	LSL       R5, R7
8000caae:	58 28       	ADD       R5, #8			;->0x08
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:682
##@@@L0677_:    uint8_t  payloadSize          = Canfd_LL_GetPayloadSize(Module);   
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
8000cab0:	7a d3       	DIVU      R7, R2, R5
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000cab2:	f1 d3       	DIVU      R6, R1, R7
8000cab4:	fe cb       	MULS      R7, R6, R7
8000cab6:	c9 c7       	SUB       R1, R1, R7
8000cab8:	b3 7a       	LSL       R6, #11			;->0x0B
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000caba:	2a 7c       	LSR       R5, #2			;->0x02
8000cabc:	19 00 25 18 	MADD32    R6, R1, R5
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000cac0:	32 7a       	LSL       R6, #2			;->0x02
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000cac2:	50 82       	LD.W      R5, [R0]
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:686
8000cac4:	88 c3       	ADD       R1, R0, R6
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
8000cac6:	52 69       	ANL       R5, R2
8000cac8:	28 19       	MOV       R2, #152			;->0x0098
8000caca:	02 21       	ST.W      [SP + #2], R1
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:976
##@@@L0971_:        /* Clean up the arbitration field area */   
##@@@L0972_:        volatile CANFD_CS_T  csInfor          = {0U};   
##@@@L0973_:        volatile CANFD_ID_T  mailboxId        = {0U};   
##@@@L0974_:        volatile CANFD_CS_T *csInforPtr       = (CANFD_CS_T *)Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L0975_:        volatile CANFD_ID_T *mailboxIdPtr     = (CANFD_ID_T *)&csInforPtr[1];   
##@@@L0976_:        volatile uint8_t    *mailboxDataPtr   = (volatile uint8_t *)(&csInforPtr[2]);   
8000cacc:	b1 c2       	ADD       R6, R1, R2
##@@@P_:kf32a13k_drv_canfd.c:979
##@@@L0977_:        volatile uint32_t   *mailboxData32Ptr = (volatile uint32_t *)(&csInforPtr[2]);   
##@@@L0978_:        volatile uint32_t   *msgData32pPtr    = (volatile uint32_t *)DataPtr;   
##@@@L0979_:        if ((true == Canfd_LL_IsFDEnabled(Module)) && (PduInfoPtr->brsEnable))   
8000cace:	50 38       	CMP       R5, #0			;->0x00
8000cad0:	09 f0       	JZ        $+9                   ;->0x8000cae2
8000cad2:	eb 8a       	LD.B      R5, [R3 + #11]
8000cad4:	50 38       	CMP       R5, #0			;->0x00
8000cad6:	06 f0       	JZ        $+6                   ;->0x8000cae2
##@@@F_:Canfd_LL_SetFdRateSwitch():
##@@@P_:kf32a13k_drv_canfd.h:963
##@@@L0958_: * @return void   
##@@@L0959_: */   
##@@@L0960_:KF_INLINE void Canfd_LL_SetFdRateSwitch(CanfdPtr Module, const bool Status)   
##@@@L0961_:{   
##@@@L0962_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0963_:    REG_WRITE(Module->CANFD_FDCTRL.bits.FDRATE, Status);   
8000cad8:	73 45       	LD        R5, [PC + #115]       ;->0x8000cca4  :=0xc00
8000cada:	50 e9       	LD.W      R2, [R0 + R5]
8000cadc:	73 41       	LD        R1, [PC + #115]       ;->0x8000cca8  :=0x80000000
8000cade:	21 6a       	ORL       R2, R1
8000cae0:	42 ef       	ST.W      [R0 + R5], R2
##@@@F_:Canfd_LL_SetTxMb():
8000cae2:	20 19       	MOV       R2, #144			;->0x0090
##@@@P_:kf32a13k_drv_canfd.c:984
##@@@L0980_:        {   
##@@@L0981_:            Canfd_LL_SetFdRateSwitch(Module, true);   
##@@@L0982_:        }   
##@@@L0983_:        Canfd_LL_FormatPaddingValue(   
##@@@L0984_:          PduInfoPtr->msgId, PduInfoPtr->fdEnable, DataPtr, &PduInfoPtr->dataLength, &realDlc, PduInfoPtr->fdPadding);   
8000cae4:	6b 8a       	LD.B      R5, [R3 + #9]
##@@@F_:Canfd_LL_FormatPaddingValue():
8000cae6:	03 8a       	LD.B      R0, [R3 + #8]
##@@@P_:kf32a13k_drv_canfd.c:89
##@@@L0084_:static void Canfd_LL_FormatPaddingValue(const uint32_t MsgId, bool FdEnable, uint8_t *SduDataPtr, uint8_t *SduLenPtr,   
##@@@L0085_:                                        uint8_t *RealDlc, const uint8_t PaddingValue)   
##@@@L0086_:{   
##@@@L0087_:    uint8_t dataLengthCount        = 0U;   
##@@@L0088_:    uint8_t paddingDataLengthCount = 0U;   
##@@@L0089_:    if (true == FdEnable)   
8000cae8:	50 38       	CMP       R5, #0			;->0x00
8000caea:	18 f0       	JZ        $+24                  ;->0x8000cb1a
##@@@P_:kf32a13k_drv_canfd.c:92
##@@@L0090_:    {   
##@@@L0091_:        /* FD Frame */   
##@@@L0092_:        if ((*SduLenPtr) <= (uint8_t)kvFd_MaxDataLength[0])   
8000caec:	09 38       	CMP       R0, #9			;->0x09
8000caee:	00 59       	MOV       R8, R0
8000caf0:	32 f3       	JNC       $+50                  ;->0x8000cb54
##@@@F_:Canfd_LL_SetTxMb():
8000caf2:	bb 8a       	LD.B      R7, [R3 + #10]
##@@@F_:Canfd_LL_FormatPaddingValue():
##@@@P_:kf32a13k_drv_canfd.c:100
##@@@L0095_:        }   
##@@@L0096_:        else   
##@@@L0097_:        {   
##@@@L0098_:            for (dataLengthCount = 1U; dataLengthCount < 8U; dataLengthCount++)   
##@@@L0099_:            {   
##@@@L0100_:                if (((*SduLenPtr) <= (uint8_t)kvFd_MaxDataLength[dataLengthCount]) &&   
8000caf4:	0c 38       	CMP       R0, #12			;->0x0C
8000caf6:	17 f9       	JLS       $+23                  ;->0x8000cb24
8000caf8:	01 39       	CMP       R0, #17			;->0x11
8000cafa:	18 f3       	JNC       $+24                  ;->0x8000cb2a
8000cafc:	05 39       	CMP       R0, #21			;->0x15
8000cafe:	19 f3       	JNC       $+25                  ;->0x8000cb30
8000cb00:	09 39       	CMP       R0, #25			;->0x19
8000cb02:	1a f3       	JNC       $+26                  ;->0x8000cb36
8000cb04:	01 3a       	CMP       R0, #33			;->0x21
8000cb06:	1b f3       	JNC       $+27                  ;->0x8000cb3c
8000cb08:	01 3b       	CMP       R0, #49			;->0x31
8000cb0a:	1c f3       	JNC       $+28                  ;->0x8000cb42
8000cb0c:	00 3c       	CMP       R0, #64			;->0x40
8000cb0e:	1d f9       	JLS       $+29                  ;->0x8000cb48
##@@@F_:Canfd_LL_SetTxMb():
8000cb10:	70 10       	MOV       R7, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:985
##@@@L0980_:        {   
##@@@L0981_:            Canfd_LL_SetFdRateSwitch(Module, true);   
##@@@L0982_:        }   
##@@@L0983_:        Canfd_LL_FormatPaddingValue(   
##@@@L0984_:          PduInfoPtr->msgId, PduInfoPtr->fdEnable, DataPtr, &PduInfoPtr->dataLength, &realDlc, PduInfoPtr->fdPadding);   
##@@@L0985_:        if (NULL_PTR != DataPtr)   
8000cb12:	40 38       	CMP       R4, #0			;->0x00
8000cb14:	07 59       	MOV       R8, R7
8000cb16:	3c f1       	JNZ       $+60                  ;->0x8000cb8e
8000cb18:	6c 04       	SJMP      $+108                 ;->0x8000cbf0
##@@@F_:Canfd_LL_FormatPaddingValue():
##@@@P_:kf32a13k_drv_canfd.c:124
##@@@L0119_:            }   
##@@@L0120_:        }   
##@@@L0121_:    }   
##@@@L0122_:    else   
##@@@L0123_:    {   
##@@@L0124_:        (*SduLenPtr) = (*SduLenPtr > 8U) ? (8U) : (*SduLenPtr);   
8000cb1a:	08 38       	CMP       R0, #8			;->0x08
8000cb1c:	02 f3       	JNC       $+2                   ;->0x8000cb20
8000cb1e:	08 10       	MOV       R0, #8			;->0x0008
8000cb20:	00 59       	MOV       R8, R0
8000cb22:	18 04       	SJMP      $+24                  ;->0x8000cb52
8000cb24:	9c 10       	MOV       R9, #12			;->0x000C
8000cb26:	89 10       	MOV       R8, #9			;->0x0009
8000cb28:	12 04       	SJMP      $+18                  ;->0x8000cb4c
8000cb2a:	90 11       	MOV       R9, #16			;->0x0010
8000cb2c:	8a 10       	MOV       R8, #10			;->0x000A
8000cb2e:	0f 04       	SJMP      $+15                  ;->0x8000cb4c
8000cb30:	94 11       	MOV       R9, #20			;->0x0014
8000cb32:	8b 10       	MOV       R8, #11			;->0x000B
8000cb34:	0c 04       	SJMP      $+12                  ;->0x8000cb4c
8000cb36:	98 11       	MOV       R9, #24			;->0x0018
8000cb38:	8c 10       	MOV       R8, #12			;->0x000C
8000cb3a:	09 04       	SJMP      $+9                   ;->0x8000cb4c
8000cb3c:	90 12       	MOV       R9, #32			;->0x0020
8000cb3e:	8d 10       	MOV       R8, #13			;->0x000D
8000cb40:	06 04       	SJMP      $+6                   ;->0x8000cb4c
8000cb42:	90 13       	MOV       R9, #48			;->0x0030
8000cb44:	8e 10       	MOV       R8, #14			;->0x000E
8000cb46:	03 04       	SJMP      $+3                   ;->0x8000cb4c
8000cb48:	90 14       	MOV       R9, #64			;->0x0040
8000cb4a:	8f 10       	MOV       R8, #15			;->0x000F
##@@@P_:kf32a13k_drv_canfd.c:104
##@@@L0099_:            {   
##@@@L0100_:                if (((*SduLenPtr) <= (uint8_t)kvFd_MaxDataLength[dataLengthCount]) &&   
##@@@L0101_:                    ((*SduLenPtr) >= (uint8_t)kvFd_MinDataLength[dataLengthCount]))   
##@@@L0102_:                {   
##@@@L0103_:                    (*RealDlc) = dataLengthCount + 8U;   
##@@@L0104_:                    for (paddingDataLengthCount = (*SduLenPtr);   
8000cb4c:	09 70       	CMP       R0, R9
8000cb4e:	1c f3       	JNC       $+28                  ;->0x8000cb86
8000cb50:	09 58       	MOV       R0, R9
8000cb52:	18 92       	ST.B      [R3 + #8], R0
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:985
##@@@L0980_:        {   
##@@@L0981_:            Canfd_LL_SetFdRateSwitch(Module, true);   
##@@@L0982_:        }   
##@@@L0983_:        Canfd_LL_FormatPaddingValue(   
##@@@L0984_:          PduInfoPtr->msgId, PduInfoPtr->fdEnable, DataPtr, &PduInfoPtr->dataLength, &realDlc, PduInfoPtr->fdPadding);   
##@@@L0985_:        if (NULL_PTR != DataPtr)   
8000cb54:	40 38       	CMP       R4, #0			;->0x00
8000cb56:	02 f1       	JNZ       $+2                   ;->0x8000cb5a
8000cb58:	48 04       	SJMP      $+72                  ;->0x8000cbe8
8000cb5a:	1f 1f       	MOV       R1, #255			;->0x00FF
##@@@F_:Canfd_LL_GetDataLength():
##@@@P_:kf32a13k_drv_canfd.c:170
##@@@L0165_: * @param PayLoadLength   
##@@@L0166_: * @retval void   
##@@@L0167_: */   
##@@@L0168_:uint8_t Canfd_LL_GetDataLength(const uint8_t Dlc)   
##@@@L0169_:{   
##@@@L0170_:    return ((uint8_t)(Dlc > 8U ? kvFd_MaxDataLength[(uint8_t)Dlc - 8U] : Dlc));   
8000cb5c:	a8 58       	MOV       R5, R8
8000cb5e:	51 69       	ANL       R5, R1
8000cb60:	59 38       	CMP       R5, #9			;->0x09
8000cb62:	e8 58       	MOV       R7, R8
8000cb64:	07 f3       	JNC       $+7                   ;->0x8000cb72
8000cb66:	e2 58       	MOV       R7, R2
8000cb68:	51 42       	LD        R2, [PC + #81]        ;->0x8000ccac  :=0x80001210
8000cb6a:	ad c2       	ADD       R5, R5, R2
8000cb6c:	47 58       	MOV       R2, R7
8000cb6e:	58 30       	SUB       R5, #8			;->0x08
8000cb70:	75 80       	LD.B      R7, [R5]
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:988
##@@@L0983_:        Canfd_LL_FormatPaddingValue(   
##@@@L0984_:          PduInfoPtr->msgId, PduInfoPtr->fdEnable, DataPtr, &PduInfoPtr->dataLength, &realDlc, PduInfoPtr->fdPadding);   
##@@@L0985_:        if (NULL_PTR != DataPtr)   
##@@@L0986_:        {   
##@@@L0987_:            payloadLength = Canfd_LL_GetDataLength(realDlc);   
##@@@L0988_:            for (databyte = 0; databyte < (PduInfoPtr->dataLength & ~3U); databyte += 4U)   
8000cb72:	a0 58       	MOV       R5, R0
8000cb74:	51 69       	ANL       R5, R1
8000cb76:	54 38       	CMP       R5, #4			;->0x04
8000cb78:	0b f2       	JC        $+11                  ;->0x8000cb8e
8000cb7a:	01 22       	ST.W      [SP + #1], R2
8000cb7c:	10 10       	MOV       R1, #0			;->0x0000
8000cb7e:	1b 04       	SJMP      $+27                  ;->0x8000cbb4
##@@@F_:Canfd_LL_FormatPaddingValue():
##@@@P_:kf32a13k_drv_canfd.c:105
##@@@L0100_:                if (((*SduLenPtr) <= (uint8_t)kvFd_MaxDataLength[dataLengthCount]) &&   
##@@@L0101_:                    ((*SduLenPtr) >= (uint8_t)kvFd_MinDataLength[dataLengthCount]))   
##@@@L0102_:                {   
##@@@L0103_:                    (*RealDlc) = dataLengthCount + 8U;   
##@@@L0104_:                    for (paddingDataLengthCount = (*SduLenPtr);   
##@@@L0105_:                         paddingDataLengthCount < kvFd_MaxDataLength[dataLengthCount]; paddingDataLengthCount++)   
8000cb80:	40 c0       	ADD       R0, R0, #1
##@@@P_:kf32a13k_drv_canfd.c:104
##@@@L0099_:            {   
##@@@L0100_:                if (((*SduLenPtr) <= (uint8_t)kvFd_MaxDataLength[dataLengthCount]) &&   
##@@@L0101_:                    ((*SduLenPtr) >= (uint8_t)kvFd_MinDataLength[dataLengthCount]))   
##@@@L0102_:                {   
##@@@L0103_:                    (*RealDlc) = dataLengthCount + 8U;   
##@@@L0104_:                    for (paddingDataLengthCount = (*SduLenPtr);   
8000cb82:	09 70       	CMP       R0, R9
8000cb84:	e6 f2       	JC        $-26                  ;->0x8000cb50
##@@@P_:kf32a13k_drv_canfd.c:107
##@@@L0105_:                         paddingDataLengthCount < kvFd_MaxDataLength[dataLengthCount]; paddingDataLengthCount++)   
##@@@L0106_:                    {   
##@@@L0107_:                        if (NULL_PTR != SduDataPtr)   
8000cb86:	40 38       	CMP       R4, #0			;->0x00
8000cb88:	fc f0       	JZ        $-4                   ;->0x8000cb80
##@@@P_:kf32a13k_drv_canfd.c:109
##@@@L0108_:                        {   
##@@@L0109_:                            SduDataPtr[paddingDataLengthCount] = PaddingValue;   
8000cb8a:	27 ea       	ST.B      [R4 + R0], R7
8000cb8c:	fa 07       	SJMP      $-6                   ;->0x8000cb80
##@@@F_:Canfd_LL_SetTxMb():
8000cb8e:	01 22       	ST.W      [SP + #1], R2
8000cb90:	10 10       	MOV       R1, #0			;->0x0000
8000cb92:	9c 1f       	MOV       R9, #252			;->0x00FC
##@@@P_:kf32a13k_drv_canfd.c:990
##@@@L0985_:        if (NULL_PTR != DataPtr)   
##@@@L0986_:        {   
##@@@L0987_:            payloadLength = Canfd_LL_GetDataLength(realDlc);   
##@@@L0988_:            for (databyte = 0; databyte < (PduInfoPtr->dataLength & ~3U); databyte += 4U)   
##@@@L0989_:            {   
##@@@L0990_:                Canfd_LL_SwapBytesInWord(&msgData32pPtr[databyte >> 2U], &mailboxData32Ptr[databyte >> 2U]);   
8000cb94:	6e c2       	ADD       R5, R6, R1
##@@@F_:Canfd_LL_SwapBytesInWord():
##@@@P_:kf32a13k_drv_canfd.c:184
##@@@L0179_: */   
##@@@L0180_:void Canfd_LL_SwapBytesInWord(volatile void *DesPtr, volatile void *SouPtr)   
##@@@L0181_:{   
##@@@L0182_:    volatile uint8_t *sou8Ptr = (uint8_t *)(SouPtr);   
##@@@L0183_:    volatile uint8_t *des8Ptr = (uint8_t *)(DesPtr);   
##@@@L0184_:    CANFD_WRITE8(des8Ptr, *(sou8Ptr + 3U));   
8000cb96:	d5 88       	LD.B      R2, [R5 + #3]
8000cb98:	62 ea       	ST.B      [R4 + R1], R2
##@@@P_:kf32a13k_drv_canfd.c:185
##@@@L0185_:    CANFD_WRITE8(des8Ptr + 1U, *(sou8Ptr + 2U));   
8000cb9a:	95 88       	LD.B      R2, [R5 + #2]
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:990
##@@@L0985_:        if (NULL_PTR != DataPtr)   
##@@@L0986_:        {   
##@@@L0987_:            payloadLength = Canfd_LL_GetDataLength(realDlc);   
##@@@L0988_:            for (databyte = 0; databyte < (PduInfoPtr->dataLength & ~3U); databyte += 4U)   
##@@@L0989_:            {   
##@@@L0990_:                Canfd_LL_SwapBytesInWord(&msgData32pPtr[databyte >> 2U], &mailboxData32Ptr[databyte >> 2U]);   
8000cb9c:	44 c2       	ADD       R0, R4, R1
##@@@F_:Canfd_LL_SwapBytesInWord():
##@@@P_:kf32a13k_drv_canfd.c:185
##@@@L0180_:void Canfd_LL_SwapBytesInWord(volatile void *DesPtr, volatile void *SouPtr)   
##@@@L0181_:{   
##@@@L0182_:    volatile uint8_t *sou8Ptr = (uint8_t *)(SouPtr);   
##@@@L0183_:    volatile uint8_t *des8Ptr = (uint8_t *)(DesPtr);   
##@@@L0184_:    CANFD_WRITE8(des8Ptr, *(sou8Ptr + 3U));   
##@@@L0185_:    CANFD_WRITE8(des8Ptr + 1U, *(sou8Ptr + 2U));   
8000cb9e:	42 90       	ST.B      [R0 + #1], R2
##@@@P_:kf32a13k_drv_canfd.c:186
##@@@L0186_:    CANFD_WRITE8(des8Ptr + 2U, *(sou8Ptr + 1U));   
8000cba0:	6d 88       	LD.B      R5, [R5 + #1]
8000cba2:	85 90       	ST.B      [R0 + #2], R5
##@@@P_:kf32a13k_drv_canfd.c:187
##@@@L0187_:    CANFD_WRITE8(des8Ptr + 3U, *(sou8Ptr));   
8000cba4:	6e e4       	LD.B      R5, [R6 + R1]
8000cba6:	c5 90       	ST.B      [R0 + #3], R5
##@@@F_:Canfd_LL_SetTxMb():
##@@@P_:kf32a13k_drv_canfd.c:988
##@@@L0983_:        Canfd_LL_FormatPaddingValue(   
##@@@L0984_:          PduInfoPtr->msgId, PduInfoPtr->fdEnable, DataPtr, &PduInfoPtr->dataLength, &realDlc, PduInfoPtr->fdPadding);   
##@@@L0985_:        if (NULL_PTR != DataPtr)   
##@@@L0986_:        {   
##@@@L0987_:            payloadLength = Canfd_LL_GetDataLength(realDlc);   
##@@@L0988_:            for (databyte = 0; databyte < (PduInfoPtr->dataLength & ~3U); databyte += 4U)   
8000cba8:	03 8a       	LD.B      R0, [R3 + #8]
8000cbaa:	a0 58       	MOV       R5, R0
8000cbac:	59 69       	ANL       R5, R9
8000cbae:	09 c1       	ADD       R1, R1, #4
8000cbb0:	15 70       	CMP       R1, R5
8000cbb2:	f1 f3       	JNC       $-15                  ;->0x8000cb94
8000cbb4:	9f 1f       	MOV       R9, #255			;->0x00FF
8000cbb6:	09 69       	ANL       R0, R9
##@@@P_:kf32a13k_drv_canfd.c:992
##@@@L0989_:            {   
##@@@L0990_:                Canfd_LL_SwapBytesInWord(&msgData32pPtr[databyte >> 2U], &mailboxData32Ptr[databyte >> 2U]);   
##@@@L0991_:            }   
##@@@L0992_:            for (; databyte < PduInfoPtr->dataLength; databyte++)   
8000cbb8:	10 70       	CMP       R1, R0
8000cbba:	0a f2       	JC        $+10                  ;->0x8000cbce
8000cbbc:	a3 10       	MOV       R10, #3			;->0x0003
##@@@P_:kf32a13k_drv_canfd.c:994
##@@@L0993_:            {   
##@@@L0994_:                CANFD_WRITE32(mailboxDataPtr + SwapBytesInWordIndex(databyte), DataPtr[databyte]);   
8000cbbe:	6c e4       	LD.B      R5, [R4 + R1]
##@@@P_:kf32a13k_drv_canfd.c:992
##@@@L0987_:            payloadLength = Canfd_LL_GetDataLength(realDlc);   
##@@@L0988_:            for (databyte = 0; databyte < (PduInfoPtr->dataLength & ~3U); databyte += 4U)   
##@@@L0989_:            {   
##@@@L0990_:                Canfd_LL_SwapBytesInWord(&msgData32pPtr[databyte >> 2U], &mailboxData32Ptr[databyte >> 2U]);   
##@@@L0991_:            }   
##@@@L0992_:            for (; databyte < PduInfoPtr->dataLength; databyte++)   
8000cbc0:	51 c0       	ADD       R2, R1, #1
##@@@P_:kf32a13k_drv_canfd.c:994
##@@@L0993_:            {   
##@@@L0994_:                CANFD_WRITE32(mailboxDataPtr + SwapBytesInWordIndex(databyte), DataPtr[databyte]);   
8000cbc2:	1a 6b       	XRL       R1, R10
8000cbc4:	0a 7a       	LSL       R1, #2			;->0x02
##@@@P_:kf32a13k_drv_canfd.c:992
##@@@L0987_:            payloadLength = Canfd_LL_GetDataLength(realDlc);   
##@@@L0988_:            for (databyte = 0; databyte < (PduInfoPtr->dataLength & ~3U); databyte += 4U)   
##@@@L0989_:            {   
##@@@L0990_:                Canfd_LL_SwapBytesInWord(&msgData32pPtr[databyte >> 2U], &mailboxData32Ptr[databyte >> 2U]);   
##@@@L0991_:            }   
##@@@L0992_:            for (; databyte < PduInfoPtr->dataLength; databyte++)   
8000cbc6:	20 70       	CMP       R2, R0
##@@@P_:kf32a13k_drv_canfd.c:994
##@@@L0993_:            {   
##@@@L0994_:                CANFD_WRITE32(mailboxDataPtr + SwapBytesInWordIndex(databyte), DataPtr[databyte]);   
8000cbc8:	75 ee       	ST.W      [R6 + R1], R5
8000cbca:	22 58       	MOV       R1, R2
8000cbcc:	f9 f3       	JNC       $-7                   ;->0x8000cbbe
8000cbce:	79 69       	ANL       R7, R9
##@@@P_:kf32a13k_drv_canfd.c:997
##@@@L0995_:            }   
##@@@L0996_:            /* Add padding, if needed */   
##@@@L0997_:            for (databyte = PduInfoPtr->dataLength; databyte < payloadLength; databyte++)   
8000cbd0:	07 70       	CMP       R0, R7
8000cbd2:	0d f2       	JC        $+13                  ;->0x8000cbec
8000cbd4:	a3 8a       	LD.B      R4, [R3 + #10]
8000cbd6:	13 10       	MOV       R1, #3			;->0x0003
8000cbd8:	01 0a       	LD.W      R2, [SP + #1]
8000cbda:	68 c0       	ADD       R5, R0, #1
##@@@P_:kf32a13k_drv_canfd.c:999
##@@@L0998_:            {   
##@@@L0999_:                CANFD_WRITE32(mailboxDataPtr + SwapBytesInWordIndex(databyte), PduInfoPtr->fdPadding);   
8000cbdc:	01 6b       	XRL       R0, R1
8000cbde:	02 7a       	LSL       R0, #2			;->0x02
##@@@P_:kf32a13k_drv_canfd.c:997
##@@@L0992_:            for (; databyte < PduInfoPtr->dataLength; databyte++)   
##@@@L0993_:            {   
##@@@L0994_:                CANFD_WRITE32(mailboxDataPtr + SwapBytesInWordIndex(databyte), DataPtr[databyte]);   
##@@@L0995_:            }   
##@@@L0996_:            /* Add padding, if needed */   
##@@@L0997_:            for (databyte = PduInfoPtr->dataLength; databyte < payloadLength; databyte++)   
8000cbe0:	57 70       	CMP       R5, R7
##@@@P_:kf32a13k_drv_canfd.c:999
##@@@L0998_:            {   
##@@@L0999_:                CANFD_WRITE32(mailboxDataPtr + SwapBytesInWordIndex(databyte), PduInfoPtr->fdPadding);   
8000cbe2:	34 ee       	ST.W      [R6 + R0], R4
8000cbe4:	05 58       	MOV       R0, R5
8000cbe6:	fa f3       	JNC       $-6                   ;->0x8000cbda
8000cbe8:	e8 58       	MOV       R7, R8
8000cbea:	03 04       	SJMP      $+3                   ;->0x8000cbf0
8000cbec:	e8 58       	MOV       R7, R8
8000cbee:	01 0a       	LD.W      R2, [SP + #1]
8000cbf0:	30 45       	LD        R5, [PC + #48]        ;->0x8000ccb0  :=0xfff0ffff
##@@@P_:kf32a13k_drv_canfd.c:1003
##@@@L1000_:            }   
##@@@L1001_:        }   
##@@@L1002_:        /* Set the length of data in bytes */   
##@@@L1003_:        csInfor.DLC = realDlc;   
8000cbf2:	04 0c       	LD.W      R4, [SP + #4]
8000cbf4:	45 69       	ANL       R4, R5
8000cbf6:	5f 10       	MOV       R5, #15			;->0x000F
8000cbf8:	75 69       	ANL       R7, R5
8000cbfa:	38 7b       	LSL       R7, #16			;->0x10
8000cbfc:	74 6a       	ORL       R7, R4
8000cbfe:	04 27       	ST.W      [SP + #4], R7
##@@@P_:kf32a13k_drv_canfd.c:1004
##@@@L1004_:        if (CANFD_MSG_ID_EXT == PduInfoPtr->msgIdType)   
8000cc00:	43 82       	LD.W      R4, [R3]
8000cc02:	02 0d       	LD.W      R5, [SP + #2]
8000cc04:	ad c2       	ADD       R5, R5, R2
8000cc06:	40 38       	CMP       R4, #0			;->0x00
8000cc08:	0f f0       	JZ        $+15                  ;->0x8000cc26
8000cc0a:	41 38       	CMP       R4, #1			;->0x01
8000cc0c:	1e f1       	JNZ       $+30                  ;->0x8000cc48
##@@@P_:kf32a13k_drv_canfd.c:1007
##@@@L1005_:        {   
##@@@L1006_:            /* ID [28-0] */   
##@@@L1007_:            mailboxId.EFF.ID = PduInfoPtr->msgId;   
8000cc0e:	63 98       	LD.W      R4, [R3 + #1]
8000cc10:	29 42       	LD        R2, [PC + #41]        ;->0x8000ccb4  :=0x1fffffff
8000cc12:	2a 41       	LD        R1, [PC + #42]        ;->0x8000ccb8  :=0xe0000000
8000cc14:	03 08       	LD.W      R0, [SP + #3]
8000cc16:	42 69       	ANL       R4, R2
8000cc18:	01 69       	ANL       R0, R1
8000cc1a:	04 6a       	ORL       R0, R4
8000cc1c:	03 20       	ST.W      [SP + #3], R0
8000cc1e:	28 44       	LD        R4, [PC + #40]        ;->0x8000ccbc  :=0x200000
##@@@P_:kf32a13k_drv_canfd.c:1009
##@@@L1008_:            /* Set IDE */   
##@@@L1009_:            csInfor.IDE = true;   
8000cc20:	04 0a       	LD.W      R2, [SP + #4]
8000cc22:	24 6a       	ORL       R2, R4
8000cc24:	0d 04       	SJMP      $+13                  ;->0x8000cc3e
##@@@P_:kf32a13k_drv_canfd.c:1016
##@@@L1011_:            csInfor.SRR = false;   
##@@@L1012_:        }   
##@@@L1013_:        else if (CANFD_MSG_ID_STD == PduInfoPtr->msgIdType)   
##@@@L1014_:        {   
##@@@L1015_:            /* ID[28-18] */   
##@@@L1016_:            mailboxId.SFF.ID = PduInfoPtr->msgId;   
8000cc26:	63 98       	LD.W      R4, [R3 + #1]
8000cc28:	22 7b       	LSL       R4, #18			;->0x12
8000cc2a:	26 42       	LD        R2, [PC + #38]        ;->0x8000ccc0  :=0x1ffc0000
8000cc2c:	26 41       	LD        R1, [PC + #38]        ;->0x8000ccc4  :=0xe003ffff
8000cc2e:	03 08       	LD.W      R0, [SP + #3]
8000cc30:	42 69       	ANL       R4, R2
8000cc32:	01 69       	ANL       R0, R1
8000cc34:	04 6a       	ORL       R0, R4
8000cc36:	03 20       	ST.W      [SP + #3], R0
8000cc38:	24 44       	LD        R4, [PC + #36]        ;->0x8000ccc8  :=0xffdfffff
##@@@P_:kf32a13k_drv_canfd.c:1018
##@@@L1017_:            /* make sure IDE and SRR are not set */   
##@@@L1018_:            csInfor.IDE = false;   
8000cc3a:	04 0a       	LD.W      R2, [SP + #4]
8000cc3c:	24 69       	ANL       R2, R4
8000cc3e:	04 22       	ST.W      [SP + #4], R2
8000cc40:	23 44       	LD        R4, [PC + #35]        ;->0x8000cccc  :=0xffbfffff
8000cc42:	04 0a       	LD.W      R2, [SP + #4]
8000cc44:	24 69       	ANL       R2, R4
8000cc46:	04 22       	ST.W      [SP + #4], R2
##@@@P_:kf32a13k_drv_canfd.c:1021
##@@@L1019_:            csInfor.SRR = false;   
##@@@L1020_:        }   
##@@@L1021_:        CANFD_WRITE32(&mailboxIdPtr->reg, mailboxId.reg);   
8000cc48:	03 0c       	LD.W      R4, [SP + #3]
##@@@P_:kf32a13k_drv_canfd.c:1022
##@@@L1022_:        if ((uint32_t)CANFD_TX_NOTUSED != Code)   
8000cc4a:	bf 38       	CMP       R11, #15			;->0x0F
##@@@P_:kf32a13k_drv_canfd.c:1021
##@@@L1016_:            mailboxId.SFF.ID = PduInfoPtr->msgId;   
##@@@L1017_:            /* make sure IDE and SRR are not set */   
##@@@L1018_:            csInfor.IDE = false;   
##@@@L1019_:            csInfor.SRR = false;   
##@@@L1020_:        }   
##@@@L1021_:        CANFD_WRITE32(&mailboxIdPtr->reg, mailboxId.reg);   
8000cc4c:	6c a0       	ST.W      [R5 + #1], R4
##@@@P_:kf32a13k_drv_canfd.c:1022
##@@@L1022_:        if ((uint32_t)CANFD_TX_NOTUSED != Code)   
8000cc4e:	1f f0       	JZ        $+31                  ;->0x8000cc8c
8000cc50:	bc 39       	CMP       R11, #28			;->0x1C
8000cc52:	05 f1       	JNZ       $+5                   ;->0x8000cc5c
8000cc54:	1f 44       	LD        R4, [PC + #31]        ;->0x8000ccd0  :=0x100000
##@@@P_:kf32a13k_drv_canfd.c:1026
##@@@L1023_:        {   
##@@@L1024_:            if ((uint32_t)CANFD_TX_REMOTE == Code)   
##@@@L1025_:            {   
##@@@L1026_:                csInfor.RTR = true;   
8000cc56:	04 0a       	LD.W      R2, [SP + #4]
8000cc58:	24 6a       	ORL       R2, R4
8000cc5a:	04 22       	ST.W      [SP + #4], R2
##@@@P_:kf32a13k_drv_canfd.c:1029
##@@@L1027_:            }   
##@@@L1028_:            /* Set the code */   
##@@@L1029_:            if (PduInfoPtr->fdEnable)   
8000cc5c:	63 8a       	LD.B      R4, [R3 + #9]
8000cc5e:	40 38       	CMP       R4, #0			;->0x00
8000cc60:	05 f0       	JZ        $+5                   ;->0x8000cc6a
8000cc62:	12 44       	LD        R4, [PC + #18]        ;->0x8000cca8  :=0x80000000
##@@@P_:kf32a13k_drv_canfd.c:1031
##@@@L1030_:            {   
##@@@L1031_:                csInfor.EDL = true;   
8000cc64:	04 0a       	LD.W      R2, [SP + #4]
8000cc66:	24 6a       	ORL       R2, R4
8000cc68:	04 22       	ST.W      [SP + #4], R2
##@@@P_:kf32a13k_drv_canfd.c:1033
##@@@L1032_:            }   
##@@@L1033_:            if (PduInfoPtr->brsEnable)   
8000cc6a:	e3 8a       	LD.B      R4, [R3 + #11]
8000cc6c:	40 38       	CMP       R4, #0			;->0x00
8000cc6e:	05 f0       	JZ        $+5                   ;->0x8000cc78
8000cc70:	19 44       	LD        R4, [PC + #25]        ;->0x8000ccd4  :=0x40000000
##@@@P_:kf32a13k_drv_canfd.c:1035
##@@@L1034_:            {   
##@@@L1035_:                csInfor.BRS = true;   
8000cc72:	04 0b       	LD.W      R3, [SP + #4]
8000cc74:	34 6a       	ORL       R3, R4
8000cc76:	04 23       	ST.W      [SP + #4], R3
8000cc78:	18 44       	LD        R4, [PC + #24]        ;->0x8000ccd8  :=0xf0ffffff
##@@@P_:kf32a13k_drv_canfd.c:1037
##@@@L1036_:            }   
##@@@L1037_:            csInfor.CODE = Code;   
8000cc7a:	04 0b       	LD.W      R3, [SP + #4]
8000cc7c:	34 69       	ANL       R3, R4
8000cc7e:	18 44       	LD        R4, [PC + #24]        ;->0x8000ccdc  :=0xf000000
8000cc80:	d8 7b       	LSL       R11, #24			;->0x18
8000cc82:	b4 69       	ANL       R11, R4
8000cc84:	3b 6a       	ORL       R3, R11
8000cc86:	04 23       	ST.W      [SP + #4], R3
##@@@P_:kf32a13k_drv_canfd.c:1038
##@@@L1038_:            CANFD_WRITE32(&csInforPtr->CS_CODE, csInfor.CS_CODE);   
8000cc88:	04 0c       	LD.W      R4, [SP + #4]
8000cc8a:	54 85       	ST.W      [R5], R4
8000cc8c:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:1041
##@@@L1039_:        }   
##@@@L1040_:    }   
##@@@L1041_:    return (retStatus);   
8000cc8e:	05 58       	MOV       R0, R5
8000cc90:	e4 29       	ADD       SP, #20			;->0x14
8000cc92:	3f 5e       	POP       {R6-R11}
8000cc94:	1d 5c       	JMP       LR
8000cc96:	00 00       	NOP      NOP      
8000cc98:	80 03 00 00 	.long     0x00000380 ->000000896  [!!!@4@:JMP       $-8388608             ;->0x7f00cc98
8000cc9c:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000cca0:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000cca4:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000cca8:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]
8000ccac:	10 12 00 80 	.long     0x80001210 ->-2147479024  [!!!@2@:MOV       R1, #32	@@: LD.B      R0, [R0]
8000ccb0:	ff ff f0 ff 	.long     0xfff0ffff ->-00983041 
8000ccb4:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000ccb8:	00 00 00 e0 	.long     0xe0000000 ->-536870912  [!!!@2@:NOP      	@@: LD.H      R0, [SP + #0]
8000ccbc:	00 00 20 00 	.long     0x00200000 ->002097152  [!!!@2@:NOP      	@@: FST.W            [R0+#0],	S1
8000ccc0:	00 00 fc 1f 	.long     0x1ffc0000 ->536608768  [!!!@2@:NOP      	@@: MOV       PC, #252
8000ccc4:	ff ff 03 e0 	.long     0xe003ffff ->-536608769 
8000ccc8:	ff ff df ff 	.long     0xffdfffff ->-02097153 
8000cccc:	ff ff bf ff 	.long     0xffbfffff ->-04194305 
8000ccd0:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16
8000ccd4:	00 00 00 40 	.long     0x40000000 ->1073741824  [!!!@2@:NOP      	@@: LD        R0, [PC + #0]         ;->0x8000ccd4  :=0x40000000
8000ccd8:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
8000ccdc:	00 00 00 0f 	.long     0x0f000000 ->251658240  [!!!@2@:NOP      	@@: LD.W      R7, [SP + #0]

8000cce0 <Canfd_LL_SetRxMb>:
##@@@F_:Canfd_LL_SetRxMb():
##@@@P_:kf32a13k_drv_canfd.c:1052
##@@@L1047_: * @param MbIndex   
##@@@L1048_: * @param PduInfoPtr   
##@@@L1049_: * @retval kf_status_t   
##@@@L1050_: */   
##@@@L1051_:kf_status_t Canfd_LL_SetRxMb(CanfdPtr Module, uint32_t MbIndex, uint32_t Code, const Canfd_PduInfo_t *PduInfoPtr)   
##@@@L1052_:{   
8000cce0:	26 5d       	PUSH      R6
8000cce2:	ec 30       	SUB       SP, #12			;->0x0C
##@@@F_:Canfd_LL_GetMaxMbNum():
##@@@P_:kf32a13k_drv_canfd.h:850
##@@@L0845_: * @return void   
##@@@L0846_: */   
##@@@L0847_:KF_INLINE uint8_t Canfd_LL_GetMaxMbNum(CanfdPtr Module)   
##@@@L0848_:{   
##@@@L0849_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0850_:    return (REG_READ(Module->CANFD_MCR.bits.MAXMB));   
8000cce4:	40 82       	LD.W      R4, [R0]
8000cce6:	5f 17       	MOV       R5, #127			;->0x007F
8000cce8:	45 69       	ANL       R4, R5
8000ccea:	30 45       	LD        R5, [PC + #48]        ;->0x8000cda8  :=0x380
##@@@F_:Canfd_LL_SetRxMb():
##@@@P_:kf32a13k_drv_canfd.c:1058
##@@@L1053_:    kf_status_t retStatus          = STATUS_OK;   
##@@@L1054_:    uint8_t     rxfifoFilterNum    = 0U;   
##@@@L1055_:    uint32_t    databyte           = 0U;   
##@@@L1056_:    uint32_t    canfdMailboxConfig = 0U;   
##@@@L1057_:    uint8_t     maxMailboxIndex    = Canfd_LL_GetMaxMbNum(Module);   
##@@@L1058_:    if (MbIndex > maxMailboxIndex)   
8000ccec:	41 70       	CMP       R4, R1
8000ccee:	02 f2       	JC        $+2                   ;->0x8000ccf2
8000ccf0:	58 04       	SJMP      $+88                  ;->0x8000cda0
##@@@F_:Canfd_LL_IsRxFifoEnabled():
##@@@P_:kf32a13k_drv_canfd.h:935
##@@@L0930_: * @return bool   
##@@@L0931_: */   
##@@@L0932_:KF_INLINE bool Canfd_LL_IsRxFifoEnabled(CanfdPtr Module)   
##@@@L0933_:{   
##@@@L0934_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0935_:    return (REG_READ(Module->CANFD_MCR.bits.RFEN));   
8000ccf2:	40 82       	LD.W      R4, [R0]
8000ccf4:	2e 46       	LD        R6, [PC + #46]        ;->0x8000cdac  :=0x20000000
8000ccf6:	46 69       	ANL       R4, R6
##@@@F_:Canfd_LL_SetRxMb():
##@@@P_:kf32a13k_drv_canfd.c:1062
##@@@L1059_:    {   
##@@@L1060_:        retStatus = STATUS_CANFD_BUFF_OUT_OF_RANGE;   
##@@@L1061_:    }   
##@@@L1062_:    else if (true == Canfd_LL_IsRxFifoEnabled(Module))   
8000ccf8:	40 38       	CMP       R4, #0			;->0x00
8000ccfa:	0b f1       	JNZ       $+11                  ;->0x8000cd10
8000ccfc:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:1073
##@@@L1068_:        }   
##@@@L1069_:    }   
##@@@L1070_:    else   
##@@@L1071_:    {   
##@@@L1072_:        /* Clean up the arbitration field area */   
##@@@L1073_:        volatile CANFD_CS_T  csInfor      = {0U};   
8000ccfe:	02 25       	ST.W      [SP + #2], R5
##@@@P_:kf32a13k_drv_canfd.c:1074
##@@@L1074_:        volatile CANFD_ID_T  mailboxId    = {0U};   
8000cd00:	01 25       	ST.W      [SP + #1], R5
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000cd02:	40 82       	LD.W      R4, [R0]
8000cd04:	2b 45       	LD        R5, [PC + #43]        ;->0x8000cdb0  :=0x800
8000cd06:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000cd08:	40 38       	CMP       R4, #0			;->0x00
8000cd0a:	0d f1       	JNZ       $+13                  ;->0x8000cd24
##@@@F_:Canfd_LL_SetRxMb():
8000cd0c:	40 11       	MOV       R4, #16			;->0x0010
8000cd0e:	13 04       	SJMP      $+19                  ;->0x8000cd34
##@@@F_:Canfd_LL_GetLegacyFifoFilterNum():
##@@@P_:kf32a13k_drv_canfd.h:1292
##@@@L1287_: * @return uint32_t   
##@@@L1288_: */   
##@@@L1289_:KF_INLINE uint32_t Canfd_LL_GetLegacyFifoFilterNum(CanfdPtr Module)   
##@@@L1290_:{   
##@@@L1291_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1292_:    return (REG_READ(Module->CANFD_CTRL2.bits.RFFN));   
8000cd10:	60 9b       	LD.W      R4, [R0 + #13]
##@@@F_:Canfd_LL_RxFifoOcuppiedLastMsgBuff():
##@@@P_:kf32a13k_drv_canfd.h:913
##@@@L0908_: * @return bool   
##@@@L0909_: */   
##@@@L0910_:KF_INLINE uint32_t Canfd_LL_RxFifoOcuppiedLastMsgBuff(uint32_t FilterNumber)   
##@@@L0911_:{   
##@@@L0912_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0913_:    return (5U + ((((FilterNumber) + 1U) * 8U) / 4U));   
8000cd12:	25 7d       	LSR       R4, #21			;->0x15
8000cd14:	38 17       	MOV       R3, #120			;->0x0078
8000cd16:	43 69       	ANL       R4, R3
8000cd18:	48 28       	ADD       R4, #8			;->0x08
8000cd1a:	22 7c       	LSR       R4, #2			;->0x02
8000cd1c:	64 c1       	ADD       R4, R4, #5
##@@@F_:Canfd_LL_SetRxMb():
##@@@P_:kf32a13k_drv_canfd.c:1065
##@@@L1060_:        retStatus = STATUS_CANFD_BUFF_OUT_OF_RANGE;   
##@@@L1061_:    }   
##@@@L1062_:    else if (true == Canfd_LL_IsRxFifoEnabled(Module))   
##@@@L1063_:    {   
##@@@L1064_:        rxfifoFilterNum = Canfd_LL_GetLegacyFifoFilterNum(Module);   
##@@@L1065_:        if (MbIndex <= Canfd_LL_RxFifoOcuppiedLastMsgBuff(rxfifoFilterNum))   
8000cd1e:	41 70       	CMP       R4, R1
8000cd20:	3f f3       	JNC       $+63                  ;->0x8000cd9e
8000cd22:	3f 04       	SJMP      $+63                  ;->0x8000cda0
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000cd24:	24 44       	LD        R4, [PC + #36]        ;->0x8000cdb4  :=0xc00
8000cd26:	30 e9       	LD.W      R6, [R0 + R4]
8000cd28:	30 7d       	LSR       R6, #16			;->0x10
8000cd2a:	43 10       	MOV       R4, #3			;->0x0003
8000cd2c:	64 69       	ANL       R6, R4
8000cd2e:	48 10       	MOV       R4, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000cd30:	46 6c       	LSL       R4, R6
8000cd32:	48 28       	ADD       R4, #8			;->0x08
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:682
##@@@L0677_:    uint8_t  payloadSize          = Canfd_LL_GetPayloadSize(Module);   
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
8000cd34:	2d d3       	DIVU      R5, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000cd36:	71 d3       	DIVU      R6, R1, R5
8000cd38:	6e cb       	MULS      R5, R6, R5
8000cd3a:	69 c7       	SUB       R5, R1, R5
8000cd3c:	b3 7a       	LSL       R6, #11			;->0x0B
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000cd3e:	22 7c       	LSR       R4, #2			;->0x02
8000cd40:	19 00 a4 18 	MADD32    R6, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000cd44:	32 7a       	LSL       R6, #2			;->0x02
8000cd46:	a8 c3       	ADD       R5, R0, R6
8000cd48:	10 19       	MOV       R1, #144			;->0x0090
##@@@F_:Canfd_LL_SetRxMb():
##@@@P_:kf32a13k_drv_canfd.c:1077
##@@@L1072_:        /* Clean up the arbitration field area */   
##@@@L1073_:        volatile CANFD_CS_T  csInfor      = {0U};   
##@@@L1074_:        volatile CANFD_ID_T  mailboxId    = {0U};   
##@@@L1075_:        volatile CANFD_CS_T *csInforPtr   = (CANFD_CS_T *)Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L1076_:        volatile CANFD_ID_T *mailboxIdPtr = (CANFD_ID_T *)&csInforPtr[1];   
##@@@L1077_:        if (CANFD_MSG_ID_EXT == PduInfoPtr->msgIdType)   
8000cd4a:	43 82       	LD.W      R4, [R3]
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000cd4c:	6d c2       	ADD       R5, R5, R1
##@@@F_:Canfd_LL_SetRxMb():
##@@@P_:kf32a13k_drv_canfd.c:1077
##@@@L1072_:        /* Clean up the arbitration field area */   
##@@@L1073_:        volatile CANFD_CS_T  csInfor      = {0U};   
##@@@L1074_:        volatile CANFD_ID_T  mailboxId    = {0U};   
##@@@L1075_:        volatile CANFD_CS_T *csInforPtr   = (CANFD_CS_T *)Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L1076_:        volatile CANFD_ID_T *mailboxIdPtr = (CANFD_ID_T *)&csInforPtr[1];   
##@@@L1077_:        if (CANFD_MSG_ID_EXT == PduInfoPtr->msgIdType)   
8000cd4e:	40 38       	CMP       R4, #0			;->0x00
8000cd50:	10 f0       	JZ        $+16                  ;->0x8000cd70
8000cd52:	41 38       	CMP       R4, #1			;->0x01
8000cd54:	17 f1       	JNZ       $+23                  ;->0x8000cd82
##@@@P_:kf32a13k_drv_canfd.c:1080
##@@@L1078_:        {   
##@@@L1079_:            /* ID [28-0] */   
##@@@L1080_:            mailboxId.EFF.ID = PduInfoPtr->msgId;   
8000cd56:	63 98       	LD.W      R4, [R3 + #1]
8000cd58:	18 43       	LD        R3, [PC + #24]        ;->0x8000cdb8  :=0x1fffffff
8000cd5a:	19 41       	LD        R1, [PC + #25]        ;->0x8000cdbc  :=0xe0000000
8000cd5c:	01 08       	LD.W      R0, [SP + #1]
8000cd5e:	43 69       	ANL       R4, R3
8000cd60:	01 69       	ANL       R0, R1
8000cd62:	04 6a       	ORL       R0, R4
8000cd64:	01 20       	ST.W      [SP + #1], R0
8000cd66:	17 44       	LD        R4, [PC + #23]        ;->0x8000cdc0  :=0x200000
##@@@P_:kf32a13k_drv_canfd.c:1082
##@@@L1081_:            /* Set IDE */   
##@@@L1082_:            csInfor.IDE = true;   
8000cd68:	02 0b       	LD.W      R3, [SP + #2]
8000cd6a:	34 6a       	ORL       R3, R4
8000cd6c:	02 23       	ST.W      [SP + #2], R3
8000cd6e:	0a 04       	SJMP      $+10                  ;->0x8000cd82
##@@@P_:kf32a13k_drv_canfd.c:1087
##@@@L1083_:        }   
##@@@L1084_:        else if (CANFD_MSG_ID_STD == PduInfoPtr->msgIdType)   
##@@@L1085_:        {   
##@@@L1086_:            /* ID[28-18] */   
##@@@L1087_:            mailboxId.SFF.ID = PduInfoPtr->msgId;   
8000cd70:	63 98       	LD.W      R4, [R3 + #1]
8000cd72:	22 7b       	LSL       R4, #18			;->0x12
8000cd74:	14 43       	LD        R3, [PC + #20]        ;->0x8000cdc4  :=0x1ffc0000
8000cd76:	15 41       	LD        R1, [PC + #21]        ;->0x8000cdc8  :=0xe003ffff
8000cd78:	01 08       	LD.W      R0, [SP + #1]
8000cd7a:	43 69       	ANL       R4, R3
8000cd7c:	01 69       	ANL       R0, R1
8000cd7e:	04 6a       	ORL       R0, R4
8000cd80:	01 20       	ST.W      [SP + #1], R0
##@@@P_:kf32a13k_drv_canfd.c:1090
##@@@L1088_:            /* make sure IDE and SRR are not set */   
##@@@L1089_:        }   
##@@@L1090_:        CANFD_WRITE32(&mailboxIdPtr->reg, mailboxId.reg);   
8000cd82:	01 0c       	LD.W      R4, [SP + #1]
##@@@P_:kf32a13k_drv_canfd.c:1091
##@@@L1091_:        if ((uint32_t)CANFD_TX_NOTUSED != Code)   
8000cd84:	2f 38       	CMP       R2, #15			;->0x0F
##@@@P_:kf32a13k_drv_canfd.c:1090
##@@@L1085_:        {   
##@@@L1086_:            /* ID[28-18] */   
##@@@L1087_:            mailboxId.SFF.ID = PduInfoPtr->msgId;   
##@@@L1088_:            /* make sure IDE and SRR are not set */   
##@@@L1089_:        }   
##@@@L1090_:        CANFD_WRITE32(&mailboxIdPtr->reg, mailboxId.reg);   
8000cd86:	6c a0       	ST.W      [R5 + #1], R4
##@@@P_:kf32a13k_drv_canfd.c:1091
##@@@L1091_:        if ((uint32_t)CANFD_TX_NOTUSED != Code)   
8000cd88:	09 f0       	JZ        $+9                   ;->0x8000cd9a
8000cd8a:	11 44       	LD        R4, [PC + #17]        ;->0x8000cdcc  :=0xf0ffffff
##@@@P_:kf32a13k_drv_canfd.c:1094
##@@@L1092_:        {   
##@@@L1093_:            /* Set the code */   
##@@@L1094_:            csInfor.CODE = Code;   
8000cd8c:	02 0b       	LD.W      R3, [SP + #2]
8000cd8e:	34 69       	ANL       R3, R4
8000cd90:	10 44       	LD        R4, [PC + #16]        ;->0x8000cdd0  :=0xf000000
8000cd92:	90 7b       	LSL       R2, #24			;->0x18
8000cd94:	24 69       	ANL       R2, R4
8000cd96:	32 6a       	ORL       R3, R2
8000cd98:	02 23       	ST.W      [SP + #2], R3
##@@@P_:kf32a13k_drv_canfd.c:1096
##@@@L1095_:        }   
##@@@L1096_:        CANFD_WRITE32(&csInforPtr->CS_CODE, csInfor.CS_CODE);   
8000cd9a:	02 0c       	LD.W      R4, [SP + #2]
8000cd9c:	54 85       	ST.W      [R5], R4
8000cd9e:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:1098
##@@@L1097_:    }   
##@@@L1098_:    return (retStatus);   
8000cda0:	05 58       	MOV       R0, R5
8000cda2:	ec 28       	ADD       SP, #12			;->0x0C
8000cda4:	06 5d       	POP       R6
8000cda6:	1d 5c       	JMP       LR
8000cda8:	80 03 00 00 	.long     0x00000380 ->000000896  [!!!@4@:JMP       $-8388608             ;->0x7f00cda8
8000cdac:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000cdb0:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000cdb4:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000cdb8:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000cdbc:	00 00 00 e0 	.long     0xe0000000 ->-536870912  [!!!@2@:NOP      	@@: LD.H      R0, [SP + #0]
8000cdc0:	00 00 20 00 	.long     0x00200000 ->002097152  [!!!@2@:NOP      	@@: FST.W            [R0+#0],	S1
8000cdc4:	00 00 fc 1f 	.long     0x1ffc0000 ->536608768  [!!!@2@:NOP      	@@: MOV       PC, #252
8000cdc8:	ff ff 03 e0 	.long     0xe003ffff ->-536608769 
8000cdcc:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
8000cdd0:	00 00 00 0f 	.long     0x0f000000 ->251658240  [!!!@2@:NOP      	@@: LD.W      R7, [SP + #0]

8000cdd4 <Canfd_LL_ReadRxFifo>:
##@@@F_:Canfd_LL_ReadRxFifo():
##@@@P_:kf32a13k_drv_canfd.c:1108
##@@@L1103_: * @param Module   
##@@@L1104_: * @param RxMsgPtr   
##@@@L1105_: * @retval void   
##@@@L1106_: */   
##@@@L1107_:void Canfd_LL_ReadRxFifo(CanfdPtr Module, Canfd_MsgBuff_t *RxMsgPtr)   
##@@@L1108_:{   
8000cdd4:	40 00 04 90 	LD.W      R4, [R0 + #36]			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:1117
##@@@L1112_:    volatile const uint32_t *mailboxPtr     = Module->CANFD_RAM;   
##@@@L1113_:    volatile const uint32_t *mailboxIdPtr   = &Module->CANFD_RAM[1];   
##@@@L1114_:    volatile const uint32_t *mailboxDataPtr = &mailboxPtr[2];   
##@@@L1115_:    uint32_t                *msgData32Ptr   = (uint32_t *)(RxMsgPtr->data);   
##@@@L1116_:
##@@@L1117_:    uint8_t realDlc   = (uint8_t)(((*mailboxPtr) & CAN_CS_DLC_MASK) >> 16);   
8000cdd8:	a4 58       	MOV       R5, R4
8000cdda:	28 7d       	LSR       R5, #16			;->0x10
8000cddc:	3f 10       	MOV       R3, #15			;->0x000F
8000cdde:	53 69       	ANL       R5, R3
##@@@F_:Canfd_LL_GetDataLength():
##@@@P_:kf32a13k_drv_canfd.c:170
##@@@L0165_: * @param PayLoadLength   
##@@@L0166_: * @retval void   
##@@@L0167_: */   
##@@@L0168_:uint8_t Canfd_LL_GetDataLength(const uint8_t Dlc)   
##@@@L0169_:{   
##@@@L0170_:    return ((uint8_t)(Dlc > 8U ? kvFd_MaxDataLength[(uint8_t)Dlc - 8U] : Dlc));   
8000cde0:	59 38       	CMP       R5, #9			;->0x09
8000cde2:	05 f3       	JNC       $+5                   ;->0x8000cdec
8000cde4:	0f 43       	LD        R3, [PC + #15]        ;->0x8000ce20  :=0x80001210
8000cde6:	ed c2       	ADD       R5, R5, R3
8000cde8:	58 30       	SUB       R5, #8			;->0x08
8000cdea:	55 80       	LD.B      R5, [R5]
##@@@F_:Canfd_LL_ReadRxFifo():
8000cdec:	0e 43       	LD        R3, [PC + #14]        ;->0x8000ce24  :=0x200000
##@@@P_:kf32a13k_drv_canfd.c:1120
##@@@L1115_:    uint32_t                *msgData32Ptr   = (uint32_t *)(RxMsgPtr->data);   
##@@@L1116_:
##@@@L1117_:    uint8_t realDlc   = (uint8_t)(((*mailboxPtr) & CAN_CS_DLC_MASK) >> 16);   
##@@@L1118_:    payloadLength     = Canfd_LL_GetDataLength(realDlc);   
##@@@L1119_:    RxMsgPtr->dataLen = payloadLength;   
##@@@L1120_:    RxMsgPtr->cs      = CANFD_READ32(mailboxPtr);   
8000cdee:	14 85       	ST.W      [R1], R4
##@@@P_:kf32a13k_drv_canfd.c:1121
##@@@L1121_:    if ((RxMsgPtr->cs & CAN_CS_IDE_MASK) != 0U)   
8000cdf0:	43 69       	ANL       R4, R3
8000cdf2:	79 00 25 20 	ST.B      [R1 + #72], R5			;->0x48
##@@@P_:kf32a13k_drv_canfd.c:1119
##@@@L1114_:    volatile const uint32_t *mailboxDataPtr = &mailboxPtr[2];   
##@@@L1115_:    uint32_t                *msgData32Ptr   = (uint32_t *)(RxMsgPtr->data);   
##@@@L1116_:
##@@@L1117_:    uint8_t realDlc   = (uint8_t)(((*mailboxPtr) & CAN_CS_DLC_MASK) >> 16);   
##@@@L1118_:    payloadLength     = Canfd_LL_GetDataLength(realDlc);   
##@@@L1119_:    RxMsgPtr->dataLen = payloadLength;   
8000cdf6:	40 00 03 94 	LD.W      R3, [R0 + #37]			;->0x25
##@@@P_:kf32a13k_drv_canfd.c:1121
##@@@L1120_:    RxMsgPtr->cs      = CANFD_READ32(mailboxPtr);   
##@@@L1121_:    if ((RxMsgPtr->cs & CAN_CS_IDE_MASK) != 0U)   
8000cdfa:	40 38       	CMP       R4, #0			;->0x00
8000cdfc:	02 f1       	JNZ       $+2                   ;->0x8000ce00
8000cdfe:	1a 7d       	LSR       R3, #18			;->0x12
8000ce00:	4f 1f       	MOV       R4, #255			;->0x00FF
##@@@P_:kf32a13k_drv_canfd.c:1119
##@@@L1114_:    volatile const uint32_t *mailboxDataPtr = &mailboxPtr[2];   
##@@@L1115_:    uint32_t                *msgData32Ptr   = (uint32_t *)(RxMsgPtr->data);   
##@@@L1116_:
##@@@L1117_:    uint8_t realDlc   = (uint8_t)(((*mailboxPtr) & CAN_CS_DLC_MASK) >> 16);   
##@@@L1118_:    payloadLength     = Canfd_LL_GetDataLength(realDlc);   
##@@@L1119_:    RxMsgPtr->dataLen = payloadLength;   
8000ce02:	54 69       	ANL       R5, R4
##@@@P_:kf32a13k_drv_canfd.c:1130
##@@@L1125_:    else   
##@@@L1126_:    {   
##@@@L1127_:        RxMsgPtr->msgId = (CANFD_READ32(mailboxIdPtr)) >> CAN_ID_STD_SHIFT;   
##@@@L1128_:    }   
##@@@L1129_:    /* Copy MB[0] data field into user's buffer */   
##@@@L1130_:    for (databyte = 0U; databyte < payloadLength; databyte += 4U)   
8000ce04:	50 38       	CMP       R5, #0			;->0x00
##@@@P_:kf32a13k_drv_canfd.c:1127
##@@@L1122_:    {   
##@@@L1123_:        RxMsgPtr->msgId = CANFD_READ32(mailboxIdPtr);   
##@@@L1124_:    }   
##@@@L1125_:    else   
##@@@L1126_:    {   
##@@@L1127_:        RxMsgPtr->msgId = (CANFD_READ32(mailboxIdPtr)) >> CAN_ID_STD_SHIFT;   
8000ce06:	4b a0       	ST.W      [R1 + #1], R3
##@@@P_:kf32a13k_drv_canfd.c:1130
##@@@L1128_:    }   
##@@@L1129_:    /* Copy MB[0] data field into user's buffer */   
##@@@L1130_:    for (databyte = 0U; databyte < payloadLength; databyte += 4U)   
8000ce08:	0a f0       	JZ        $+10                  ;->0x8000ce1c
8000ce0a:	40 10       	MOV       R4, #0			;->0x0000
##@@@F_:Canfd_LL_SwapBytesInWord():
##@@@P_:kf32a13k_drv_canfd.c:184
##@@@L0179_: */   
##@@@L0180_:void Canfd_LL_SwapBytesInWord(volatile void *DesPtr, volatile void *SouPtr)   
##@@@L0181_:{   
##@@@L0182_:    volatile uint8_t *sou8Ptr = (uint8_t *)(SouPtr);   
##@@@L0183_:    volatile uint8_t *des8Ptr = (uint8_t *)(DesPtr);   
##@@@L0184_:    CANFD_WRITE8(des8Ptr, *(sou8Ptr + 3U));   
8000ce0c:	19 c3       	ADD       R3, R1, R4
8000ce0e:	d3 8a       	LD.B      R2, [R3 + #11]
##@@@P_:kf32a13k_drv_canfd.c:185
##@@@L0185_:    CANFD_WRITE8(des8Ptr + 1U, *(sou8Ptr + 2U));   
8000ce10:	93 8a       	LD.B      R2, [R3 + #10]
##@@@P_:kf32a13k_drv_canfd.c:186
##@@@L0186_:    CANFD_WRITE8(des8Ptr + 2U, *(sou8Ptr + 1U));   
8000ce12:	53 8a       	LD.B      R2, [R3 + #9]
##@@@P_:kf32a13k_drv_canfd.c:187
##@@@L0187_:    CANFD_WRITE8(des8Ptr + 3U, *(sou8Ptr));   
8000ce14:	1b 8a       	LD.B      R3, [R3 + #8]
##@@@F_:Canfd_LL_ReadRxFifo():
##@@@P_:kf32a13k_drv_canfd.c:1130
##@@@L1125_:    else   
##@@@L1126_:    {   
##@@@L1127_:        RxMsgPtr->msgId = (CANFD_READ32(mailboxIdPtr)) >> CAN_ID_STD_SHIFT;   
##@@@L1128_:    }   
##@@@L1129_:    /* Copy MB[0] data field into user's buffer */   
##@@@L1130_:    for (databyte = 0U; databyte < payloadLength; databyte += 4U)   
8000ce16:	24 c1       	ADD       R4, R4, #4
8000ce18:	45 70       	CMP       R4, R5
8000ce1a:	f9 f3       	JNC       $-7                   ;->0x8000ce0c
##@@@P_:kf32a13k_drv_canfd.c:1135
##@@@L1131_:    {   
##@@@L1132_:        mbWord = (CANFD_READ32(&mailboxDataPtr[databyte >> 2U]));   
##@@@L1133_:        Canfd_LL_SwapBytesInWord(&mbWord, &msgData32Ptr[databyte >> 2U]);   
##@@@L1134_:    }   
##@@@L1135_:}   
8000ce1c:	1d 5c       	JMP       LR
8000ce1e:	00 00       	NOP      NOP      
8000ce20:	10 12 00 80 	.long     0x80001210 ->-2147479024  [!!!@2@:MOV       R1, #32	@@: LD.B      R0, [R0]
8000ce24:	00 00 20 00 	.long     0x00200000 ->002097152  [!!!@2@:NOP      	@@: FST.W            [R0+#0],	S1

8000ce28 <Canfd_LL_GetRxFifoMask>:
##@@@F_:Canfd_LL_GetRxFifoMask():
##@@@P_:kf32a13k_drv_canfd.c:1145
##@@@L1140_: * @param FormatType   
##@@@L1141_: * @param Mask   
##@@@L1142_: * @retval uint32_t   
##@@@L1143_: */   
##@@@L1144_:uint32_t Canfd_LL_GetRxFifoMask(Canfd_IdType_t IdType, Canfd_RxFifoIdFormat_t FormatType, uint32_t Mask)   
##@@@L1145_:{   
8000ce28:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:1147
##@@@L1146_:    uint32_t val = 0;   
##@@@L1147_:    switch (FormatType)   
8000ce2a:	12 38       	CMP       R1, #2			;->0x02
8000ce2c:	17 f0       	JZ        $+23                  ;->0x8000ce5a
8000ce2e:	11 38       	CMP       R1, #1			;->0x01
8000ce30:	0b f0       	JZ        $+11                  ;->0x8000ce46
8000ce32:	10 38       	CMP       R1, #0			;->0x00
8000ce34:	1c f1       	JNZ       $+28                  ;->0x8000ce6c
8000ce36:	0f 44       	LD        R4, [PC + #15]        ;->0x8000ce70  :=0xc0000000
##@@@P_:kf32a13k_drv_canfd.c:1151
##@@@L1148_:    {   
##@@@L1149_:    case CANFD_RX_FIFO_ID_FORMAT_A: {   
##@@@L1150_:        /* Set RTR bit encoded as bit 31 and IDE bit encoded as bit 30 in mask */   
##@@@L1151_:        val = Mask & ((1UL << CANFD_FORMATAB_RTR_SHIFT) | (1UL << CANFD_FORMATAB_IDE_SHIFT));   
8000ce38:	a2 58       	MOV       R5, R2
8000ce3a:	54 69       	ANL       R5, R4
##@@@P_:kf32a13k_drv_canfd.c:1152
##@@@L1152_:        if (IdType == CANFD_MSG_ID_STD)   
8000ce3c:	01 38       	CMP       R0, #1			;->0x01
8000ce3e:	09 f1       	JNZ       $+9                   ;->0x8000ce50
8000ce40:	0d 44       	LD        R4, [PC + #13]        ;->0x8000ce74  :=0x3ffffffe
##@@@P_:kf32a13k_drv_canfd.c:1160
##@@@L1155_:            val |= ((Mask << CANFD_FORMATA_STD_SHIFT) & CANFD_FORMATA_STD_MASK);   
##@@@L1156_:        }   
##@@@L1157_:        else if (IdType == CANFD_MSG_ID_EXT)   
##@@@L1158_:        {   
##@@@L1159_:            /* Set extended global mask for RX FIFO and IDE will be 0 and don't check the FIFO filter ide */   
##@@@L1160_:            val |= ((Mask << CANFD_FORMATA_EXT_SHIFT) & CANFD_FORMATA_EXT_MASK);   
8000ce42:	11 7a       	LSL       R2, #1			;->0x01
8000ce44:	11 04       	SJMP      $+17                  ;->0x8000ce66
8000ce46:	0b 44       	LD        R4, [PC + #11]        ;->0x8000ce70  :=0xc0000000
##@@@P_:kf32a13k_drv_canfd.c:1170
##@@@L1165_:        }   
##@@@L1166_:    }   
##@@@L1167_:    break;   
##@@@L1168_:    case CANFD_RX_FIFO_ID_FORMAT_B: {   
##@@@L1169_:        /* Set RTR bit encoded as bit 31 and IDE bit encoded as bit 30 in mask */   
##@@@L1170_:        val = Mask & ((1UL << CANFD_FORMATAB_RTR_SHIFT) | (1UL << CANFD_FORMATAB_IDE_SHIFT));   
8000ce48:	a2 58       	MOV       R5, R2
8000ce4a:	54 69       	ANL       R5, R4
##@@@P_:kf32a13k_drv_canfd.c:1171
##@@@L1171_:        if (IdType == CANFD_MSG_ID_STD)   
8000ce4c:	01 38       	CMP       R0, #1			;->0x01
8000ce4e:	0a f0       	JZ        $+10                  ;->0x8000ce62
8000ce50:	00 38       	CMP       R0, #0			;->0x00
8000ce52:	0d f1       	JNZ       $+13                  ;->0x8000ce6c
8000ce54:	09 44       	LD        R4, [PC + #9]         ;->0x8000ce78  :=0x3ff80000
8000ce56:	13 7b       	LSL       R2, #19			;->0x13
8000ce58:	07 04       	SJMP      $+7                   ;->0x8000ce66
##@@@P_:kf32a13k_drv_canfd.c:1188
##@@@L1183_:            /* Should not get here */   
##@@@L1184_:        }   
##@@@L1185_:    }   
##@@@L1186_:    break;   
##@@@L1187_:    case CANFD_RX_FIFO_ID_FORMAT_C: {   
##@@@L1188_:        if ((IdType == CANFD_MSG_ID_EXT) || (IdType == CANFD_MSG_ID_STD))   
8000ce5a:	02 38       	CMP       R0, #2			;->0x02
8000ce5c:	08 f2       	JC        $+8                   ;->0x8000ce6c
8000ce5e:	90 7b       	LSL       R2, #24			;->0x18
8000ce60:	05 04       	SJMP      $+5                   ;->0x8000ce6a
8000ce62:	07 44       	LD        R4, [PC + #7]         ;->0x8000ce7c  :=0x3fff0000
##@@@P_:kf32a13k_drv_canfd.c:1179
##@@@L1174_:            val |= ((Mask & CANFD_FORMATB_STD_MASK) << CANFD_FORMATB_STD_SHIFT1);   
##@@@L1175_:        }   
##@@@L1176_:        else if (IdType == CANFD_MSG_ID_EXT)   
##@@@L1177_:        {   
##@@@L1178_:            /* Set extended global mask for RX FIFO  */   
##@@@L1179_:            val |= ((Mask & CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK1) << CANFD_FORMATB_EXT_SHIFT1);   
8000ce64:	10 7b       	LSL       R2, #16			;->0x10
8000ce66:	24 69       	ANL       R2, R4
8000ce68:	25 6a       	ORL       R2, R5
8000ce6a:	a2 58       	MOV       R5, R2
##@@@P_:kf32a13k_drv_canfd.c:1203
##@@@L1198_:    case CANFD_RX_FIFO_ID_FORMAT_D:   
##@@@L1199_:        break;   
##@@@L1200_:    default:   
##@@@L1201_:        break;   
##@@@L1202_:    }   
##@@@L1203_:    return val;   
8000ce6c:	05 58       	MOV       R0, R5
8000ce6e:	1d 5c       	JMP       LR
8000ce70:	00 00 00 c0 	.long     0xc0000000 ->-1073741824  [!!!@2@:NOP      	@@: ADD       R0, R0, #0
8000ce74:	fe ff ff 3f 	.long     0x3ffffffe ->1073741822 
8000ce78:	00 00 f8 3f 	.long     0x3ff80000 ->1073217536  [!!!@2@:NOP      	@@: CMP       PC, #120
8000ce7c:	00 00 ff 3f 	.long     0x3fff0000 ->1073676288  [!!!@2@:NOP      	@@: CMP       PC, #127

8000ce80 <Canfd_LL_SetRxFifoFilter>:
##@@@F_:Canfd_LL_SetRxFifoFilter():
##@@@P_:kf32a13k_drv_canfd.c:1214
##@@@L1209_: * @param IdFormat   
##@@@L1210_: * @param IdFilterTablePtr   
##@@@L1211_: * @retval void   
##@@@L1212_: */   
##@@@L1213_:void Canfd_LL_SetRxFifoFilter(CanfdPtr Module, Canfd_RxFifoIdFormat_t IdFormat, const Canfd_IdTable_t *IdFilterTablePtr)   
##@@@L1214_:{   
8000ce80:	3f 5f       	PUSH      {R6-R11}
8000ce82:	e0 31       	SUB       SP, #16			;->0x10
8000ce84:	c2 58       	MOV       R6, R2
##@@@F_:Canfd_LL_SetRxFifoIdFormat():
##@@@P_:kf32a13k_drv_canfd.h:1304
##@@@L1299_: * @return void   
##@@@L1300_: */   
##@@@L1301_:KF_INLINE void Canfd_LL_SetRxFifoIdFormat(CanfdPtr Module, Canfd_RxFifoIdFormat_t Mode)   
##@@@L1302_:{   
##@@@L1303_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1304_:    REG_WRITE(Module->CANFD_MCR.bits.IDAM, Mode);   
8000ce86:	81 58       	MOV       R4, R1
8000ce88:	a0 7a       	LSL       R4, #8			;->0x08
8000ce8a:	68 43       	LD        R3, [PC + #104]       ;->0x8000d028  :=0x300
##@@@F_:Canfd_LL_GetLegacyFifoFilterNum():
##@@@P_:kf32a13k_drv_canfd.h:1292
##@@@L1287_: * @return uint32_t   
##@@@L1288_: */   
##@@@L1289_:KF_INLINE uint32_t Canfd_LL_GetLegacyFifoFilterNum(CanfdPtr Module)   
##@@@L1290_:{   
##@@@L1291_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1292_:    return (REG_READ(Module->CANFD_CTRL2.bits.RFFN));   
8000ce8c:	68 9b       	LD.W      R5, [R0 + #13]
##@@@F_:Canfd_LL_SetRxFifoIdFormat():
##@@@P_:kf32a13k_drv_canfd.h:1304
##@@@L1299_: * @return void   
##@@@L1300_: */   
##@@@L1301_:KF_INLINE void Canfd_LL_SetRxFifoIdFormat(CanfdPtr Module, Canfd_RxFifoIdFormat_t Mode)   
##@@@L1302_:{   
##@@@L1303_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1304_:    REG_WRITE(Module->CANFD_MCR.bits.IDAM, Mode);   
8000ce8e:	70 82       	LD.W      R7, [R0]
8000ce90:	67 42       	LD        R2, [PC + #103]       ;->0x8000d02c  :=0xfffffcff
8000ce92:	43 69       	ANL       R4, R3
8000ce94:	72 69       	ANL       R7, R2
8000ce96:	74 6a       	ORL       R7, R4
8000ce98:	40 1f       	MOV       R4, #240			;->0x00F0
##@@@F_:Canfd_LL_SetRxFifoFilter():
##@@@P_:kf32a13k_drv_canfd.c:1217
##@@@L1215_:    uint32_t           val1 = 0U, val2 = 0U, val = 0U;   
##@@@L1216_:    uint32_t           filterNumber, filterIndex, filterTableIndex;   
##@@@L1217_:    volatile uint32_t *filterTablePtr = &Module->CANFD_RAM[RXFIFO_FILTER_TABLE_OFFSET];   
8000ce9a:	10 c3       	ADD       R2, R0, R4
##@@@F_:Canfd_LL_GetLegacyFifoFilterNum():
##@@@P_:kf32a13k_drv_canfd.h:1292
##@@@L1287_: * @return uint32_t   
##@@@L1288_: */   
##@@@L1289_:KF_INLINE uint32_t Canfd_LL_GetLegacyFifoFilterNum(CanfdPtr Module)   
##@@@L1290_:{   
##@@@L1291_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1292_:    return (REG_READ(Module->CANFD_CTRL2.bits.RFFN));   
8000ce9c:	a8 7d       	LSR       R5, #24			;->0x18
8000ce9e:	4f 10       	MOV       R4, #15			;->0x000F
8000cea0:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_SetRxFifoFilter():
##@@@P_:kf32a13k_drv_canfd.c:1220
##@@@L1218_:    filterNumber                      = Canfd_LL_GetLegacyFifoFilterNum(Module);   
##@@@L1219_:    Canfd_LL_SetRxFifoIdFormat(Module, IdFormat);   
##@@@L1220_:    switch (IdFormat)   
8000cea2:	10 38       	CMP       R1, #0			;->0x00
##@@@F_:Canfd_LL_SetRxFifoIdFormat():
##@@@P_:kf32a13k_drv_canfd.h:1304
##@@@L1299_: * @return void   
##@@@L1300_: */   
##@@@L1301_:KF_INLINE void Canfd_LL_SetRxFifoIdFormat(CanfdPtr Module, Canfd_RxFifoIdFormat_t Mode)   
##@@@L1302_:{   
##@@@L1303_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1304_:    REG_WRITE(Module->CANFD_MCR.bits.IDAM, Mode);   
8000cea4:	07 85       	ST.W      [R0], R7
##@@@F_:Canfd_LL_SetRxFifoFilter():
##@@@P_:kf32a13k_drv_canfd.c:1220
8000cea6:	02 f1       	JNZ       $+2                   ;->0x8000ceaa
8000cea8:	97 04       	SJMP      $+151                 ;->0x8000cfd6
8000ceaa:	11 38       	CMP       R1, #1			;->0x01
8000ceac:	02 f1       	JNZ       $+2                   ;->0x8000ceb0
8000ceae:	50 04       	SJMP      $+80                  ;->0x8000cf4e
8000ceb0:	12 38       	CMP       R1, #2			;->0x02
8000ceb2:	02 f0       	JZ        $+2                   ;->0x8000ceb6
8000ceb4:	b7 04       	SJMP      $+183                 ;->0x8000d022
8000ceb6:	85 58       	MOV       R4, R5
8000ceb8:	22 7a       	LSL       R4, #2			;->0x02
8000ceba:	22 c3       	ADD       R4, R2, R4
##@@@P_:kf32a13k_drv_canfd.c:1291
##@@@L1286_:        }   
##@@@L1287_:    }   
##@@@L1288_:    break;   
##@@@L1289_:    case CANFD_RX_FIFO_ID_FORMAT_C: {   
##@@@L1290_:        filterTableIndex = 0;   
##@@@L1291_:        for (filterIndex = 0; filterIndex < RxFifoFilterElementNum(filterNumber); filterIndex++)   
8000cebc:	61 29       	ADD       R6, #17			;->0x11
8000cebe:	2b 7a       	LSL       R5, #3			;->0x03
8000cec0:	58 28       	ADD       R5, #8			;->0x08
8000cec2:	33 10       	MOV       R3, #3			;->0x0003
8000cec4:	15 11       	MOV       R1, #21			;->0x0015
8000cec6:	5b 42       	LD        R2, [PC + #91]        ;->0x8000d030  :=0xff000000
8000cec8:	03 22       	ST.W      [SP + #3], R2
8000ceca:	5b 42       	LD        R2, [PC + #91]        ;->0x8000d034  :=0xff0000
8000cecc:	02 22       	ST.W      [SP + #2], R2
8000cece:	5b 42       	LD        R2, [PC + #91]        ;->0x8000d038  :=0xff00
8000ced0:	01 22       	ST.W      [SP + #1], R2
8000ced2:	8f 1f       	MOV       R8, #255			;->0x00FF
8000ced4:	0c 04       	SJMP      $+12                  ;->0x8000ceec
8000ced6:	96 98       	LD.W      R2, [R6 + #2]
8000ced8:	20 6d       	LSR       R2, R0
8000ceda:	04 82       	LD.W      R0, [R4]
8000cedc:	28 69       	ANL       R2, R8
8000cede:	20 6a       	ORL       R2, R0
8000cee0:	60 2a       	ADD       R6, #32			;->0x20
8000cee2:	6d cc       	SUB       R5, R5, #1
8000cee4:	50 38       	CMP       R5, #0			;->0x00
8000cee6:	42 85       	ST.W      [R4], R2
8000cee8:	02 f1       	JNZ       $+2                   ;->0x8000ceec
8000ceea:	9c 04       	SJMP      $+156                 ;->0x8000d022
##@@@P_:kf32a13k_drv_canfd.c:1293
##@@@L1292_:        {   
##@@@L1293_:            if (IdFilterTablePtr[filterTableIndex].isExtendedFrame)   
8000ceec:	06 58       	MOV       R0, R6
8000ceee:	00 31       	SUB       R0, #16			;->0x10
8000cef0:	90 80       	LD.B      R9, [R0]
8000cef2:	01 58       	MOV       R0, R1
8000cef4:	90 38       	CMP       R9, #0			;->0x00
8000cef6:	02 f0       	JZ        $+2                   ;->0x8000cefa
8000cef8:	03 58       	MOV       R0, R3
8000cefa:	46 58       	MOV       R2, R6
8000cefc:	2d 30       	SUB       R2, #13			;->0x0D
8000cefe:	22 82       	LD.W      R2, [R2]
8000cf00:	20 6c       	LSL       R2, R0
8000cf02:	04 82       	LD.W      R0, [R4]
8000cf04:	03 0f       	LD.W      R7, [SP + #3]
8000cf06:	27 69       	ANL       R2, R7
8000cf08:	20 6a       	ORL       R2, R0
8000cf0a:	42 85       	ST.W      [R4], R2
##@@@P_:kf32a13k_drv_canfd.c:1307
##@@@L1302_:                filterTablePtr[filterNumber] |=   
##@@@L1303_:                  val1 + (((IdFilterTablePtr[filterTableIndex].id & CANFD_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>   
##@@@L1304_:                           CANFD_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT)   
##@@@L1305_:                          << CANFD_FORMATC_SHIFT1);   
##@@@L1306_:            }   
##@@@L1307_:            if (IdFilterTablePtr[filterTableIndex + 1U].isExtendedFrame)   
8000cf0c:	46 58       	MOV       R2, R6
8000cf0e:	28 30       	SUB       R2, #8			;->0x08
8000cf10:	22 80       	LD.B      R2, [R2]
8000cf12:	46 cd       	SUB       R0, R6, #5
8000cf14:	90 82       	LD.W      R9, [R0]
8000cf16:	20 38       	CMP       R2, #0			;->0x00
8000cf18:	03 f0       	JZ        $+3                   ;->0x8000cf1e
8000cf1a:	4d 7c       	LSR       R9, #5			;->0x05
8000cf1c:	02 04       	SJMP      $+2                   ;->0x8000cf20
8000cf1e:	cd 7a       	LSL       R9, #13			;->0x0D
8000cf20:	24 82       	LD.W      R2, [R4]
8000cf22:	02 08       	LD.W      R0, [SP + #2]
8000cf24:	90 69       	ANL       R9, R0
8000cf26:	92 6a       	ORL       R9, R2
8000cf28:	49 85       	ST.W      [R4], R9
##@@@P_:kf32a13k_drv_canfd.c:1321
##@@@L1316_:                filterTablePtr[filterNumber] |=   
##@@@L1317_:                  val1 + (((IdFilterTablePtr[filterTableIndex + 1U].id & CANFD_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>   
##@@@L1318_:                           CANFD_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT)   
##@@@L1319_:                          << CANFD_RX_FIFO_ID_FILTER_FORMATC_SHIFT2);   
##@@@L1320_:            }   
##@@@L1321_:            if (IdFilterTablePtr[filterTableIndex + 2U].isExtendedFrame)   
8000cf2a:	26 80       	LD.B      R2, [R6]
8000cf2c:	06 98       	LD.W      R0, [R6 + #0]
8000cf2e:	20 38       	CMP       R2, #0			;->0x00
8000cf30:	03 f0       	JZ        $+3                   ;->0x8000cf36
8000cf32:	85 7c       	LSR       R0, #13			;->0x0D
8000cf34:	02 04       	SJMP      $+2                   ;->0x8000cf38
8000cf36:	05 7a       	LSL       R0, #5			;->0x05
8000cf38:	24 82       	LD.W      R2, [R4]
8000cf3a:	01 0f       	LD.W      R7, [SP + #1]
8000cf3c:	07 69       	ANL       R0, R7
8000cf3e:	02 6a       	ORL       R0, R2
8000cf40:	40 85       	ST.W      [R4], R0
##@@@P_:kf32a13k_drv_canfd.c:1335
##@@@L1330_:                filterTablePtr[filterNumber] |=   
##@@@L1331_:                  val1 + (((IdFilterTablePtr[filterTableIndex + 2U].id & CANFD_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>   
##@@@L1332_:                           CANFD_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT)   
##@@@L1333_:                          << CANFD_RX_FIFO_ID_FILTER_FORMATC_SHIFT3);   
##@@@L1334_:            }   
##@@@L1335_:            if (IdFilterTablePtr[filterTableIndex + 3U].isExtendedFrame)   
8000cf42:	16 8a       	LD.B      R2, [R6 + #8]
8000cf44:	03 58       	MOV       R0, R3
8000cf46:	20 38       	CMP       R2, #0			;->0x00
8000cf48:	c7 f0       	JZ        $-57                  ;->0x8000ced6
8000cf4a:	01 58       	MOV       R0, R1
8000cf4c:	c5 07       	SJMP      $-59                  ;->0x8000ced6
8000cf4e:	85 58       	MOV       R4, R5
8000cf50:	22 7a       	LSL       R4, #2			;->0x02
8000cf52:	22 c3       	ADD       R4, R2, R4
##@@@P_:kf32a13k_drv_canfd.c:1246
##@@@L1241_:        }   
##@@@L1242_:    }   
##@@@L1243_:    break;   
##@@@L1244_:    case CANFD_RX_FIFO_ID_FORMAT_B: {   
##@@@L1245_:        filterTableIndex = 0;   
##@@@L1246_:        for (filterIndex = 0; filterIndex < RxFifoFilterElementNum(filterNumber); filterIndex++)   
8000cf54:	68 28       	ADD       R6, #8			;->0x08
8000cf56:	2b 7a       	LSL       R5, #3			;->0x03
8000cf58:	58 28       	ADD       R5, #8			;->0x08
8000cf5a:	b0 10       	MOV       R11, #0			;->0x0000
8000cf5c:	38 42       	LD        R2, [PC + #56]        ;->0x8000d03c  :=0x3ff80000
8000cf5e:	03 22       	ST.W      [SP + #3], R2
8000cf60:	38 42       	LD        R2, [PC + #56]        ;->0x8000d040  :=0x3ff8
8000cf62:	02 22       	ST.W      [SP + #2], R2
8000cf64:	38 42       	LD        R2, [PC + #56]        ;->0x8000d044  :=0x3fff
8000cf66:	71 10       	MOV       R7, #1			;->0x0001
8000cf68:	02 0b       	LD.W      R3, [SP + #2]
8000cf6a:	0d 04       	SJMP      $+13                  ;->0x8000cf84
##@@@P_:kf32a13k_drv_canfd.c:1283
##@@@L1278_:            }   
##@@@L1279_:            else   
##@@@L1280_:            {   
##@@@L1281_:                filterTablePtr[filterNumber] |=   
##@@@L1282_:                  val2 + ((IdFilterTablePtr[filterTableIndex + 1U].id & CANFD_FORMATB_STD_MASK)   
##@@@L1283_:                          << CANFD_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2);   
8000cf6c:	0b 7a       	LSL       R1, #3			;->0x03
##@@@P_:kf32a13k_drv_canfd.c:1281
##@@@L1276_:                           CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT)   
##@@@L1277_:                          << CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2);   
##@@@L1278_:            }   
##@@@L1279_:            else   
##@@@L1280_:            {   
##@@@L1281_:                filterTablePtr[filterNumber] |=   
8000cf6e:	04 82       	LD.W      R0, [R4]
##@@@P_:kf32a13k_drv_canfd.c:1283
##@@@L1282_:                  val2 + ((IdFilterTablePtr[filterTableIndex + 1U].id & CANFD_FORMATB_STD_MASK)   
##@@@L1283_:                          << CANFD_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2);   
8000cf70:	13 69       	ANL       R1, R3
##@@@P_:kf32a13k_drv_canfd.c:1282
##@@@L1277_:                          << CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2);   
##@@@L1278_:            }   
##@@@L1279_:            else   
##@@@L1280_:            {   
##@@@L1281_:                filterTablePtr[filterNumber] |=   
##@@@L1282_:                  val2 + ((IdFilterTablePtr[filterTableIndex + 1U].id & CANFD_FORMATB_STD_MASK)   
8000cf72:	08 6a       	ORL       R0, R8
##@@@P_:kf32a13k_drv_canfd.c:1281
##@@@L1276_:                           CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT)   
##@@@L1277_:                          << CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2);   
##@@@L1278_:            }   
##@@@L1279_:            else   
##@@@L1280_:            {   
##@@@L1281_:                filterTablePtr[filterNumber] |=   
8000cf74:	01 6a       	ORL       R0, R1
8000cf76:	00 59       	MOV       R8, R0
##@@@P_:kf32a13k_drv_canfd.c:1246
##@@@L1241_:        }   
##@@@L1242_:    }   
##@@@L1243_:    break;   
##@@@L1244_:    case CANFD_RX_FIFO_ID_FORMAT_B: {   
##@@@L1245_:        filterTableIndex = 0;   
##@@@L1246_:        for (filterIndex = 0; filterIndex < RxFifoFilterElementNum(filterNumber); filterIndex++)   
8000cf78:	60 29       	ADD       R6, #16			;->0x10
8000cf7a:	6d cc       	SUB       R5, R5, #1
8000cf7c:	50 38       	CMP       R5, #0			;->0x00
8000cf7e:	48 85       	ST.W      [R4], R8
8000cf80:	02 f1       	JNZ       $+2                   ;->0x8000cf84
8000cf82:	50 04       	SJMP      $+80                  ;->0x8000d022
##@@@P_:kf32a13k_drv_canfd.c:1250
##@@@L1247_:        {   
##@@@L1248_:            val1 = 0;   
##@@@L1249_:            val2 = 0;   
##@@@L1250_:            if (IdFilterTablePtr[filterTableIndex].isRemoteFrame)   
8000cf84:	26 58       	MOV       R1, R6
8000cf86:	18 30       	SUB       R1, #8			;->0x08
8000cf88:	11 80       	LD.B      R1, [R1]
8000cf8a:	27 59       	MOV       R9, R7
8000cf8c:	10 38       	CMP       R1, #0			;->0x00
8000cf8e:	02 f1       	JNZ       $+2                   ;->0x8000cf92
8000cf90:	2b 59       	MOV       R9, R11
8000cf92:	0e cd       	SUB       R1, R6, #4
8000cf94:	a1 82       	LD.W      R10, [R1]
##@@@P_:kf32a13k_drv_canfd.c:1254
##@@@L1251_:            {   
##@@@L1252_:                val1 = CAFND_RX_FIFO_ACCEPT_REMOTE_FRAME << CANFD_FORMATAB_RTR_SHIFT;   
##@@@L1253_:            }   
##@@@L1254_:            if (IdFilterTablePtr[filterTableIndex + 1U].isRemoteFrame)   
8000cf96:	86 80       	LD.B      R8, [R6]
##@@@P_:kf32a13k_drv_canfd.c:1258
##@@@L1255_:            {   
##@@@L1256_:                val2 = CAFND_RX_FIFO_ACCEPT_REMOTE_FRAME << CANFD_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT;   
##@@@L1257_:            }   
##@@@L1258_:            if (IdFilterTablePtr[filterTableIndex].isExtendedFrame)   
8000cf98:	ce cd       	SUB       R1, R6, #7
8000cf9a:	11 80       	LD.B      R1, [R1]
##@@@P_:kf32a13k_drv_canfd.c:1250
##@@@L1245_:        filterTableIndex = 0;   
##@@@L1246_:        for (filterIndex = 0; filterIndex < RxFifoFilterElementNum(filterNumber); filterIndex++)   
##@@@L1247_:        {   
##@@@L1248_:            val1 = 0;   
##@@@L1249_:            val2 = 0;   
##@@@L1250_:            if (IdFilterTablePtr[filterTableIndex].isRemoteFrame)   
8000cf9c:	cf 7b       	LSL       R9, #31			;->0x1F
##@@@P_:kf32a13k_drv_canfd.c:1258
##@@@L1253_:            }   
##@@@L1254_:            if (IdFilterTablePtr[filterTableIndex + 1U].isRemoteFrame)   
##@@@L1255_:            {   
##@@@L1256_:                val2 = CAFND_RX_FIFO_ACCEPT_REMOTE_FRAME << CANFD_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT;   
##@@@L1257_:            }   
##@@@L1258_:            if (IdFilterTablePtr[filterTableIndex].isExtendedFrame)   
8000cf9e:	10 38       	CMP       R1, #0			;->0x00
8000cfa0:	08 f0       	JZ        $+8                   ;->0x8000cfb0
8000cfa2:	2a 41       	LD        R1, [PC + #42]        ;->0x8000d048  :=0x3fff0000
##@@@P_:kf32a13k_drv_canfd.c:1264
##@@@L1259_:            {   
##@@@L1260_:                val1 |= CAFND_RX_FIFO_ACCEPT_EXT_FRAME << CANFD_FORMATAB_IDE_SHIFT;   
##@@@L1261_:                filterTablePtr[filterNumber] =   
##@@@L1262_:                  val1 + (((IdFilterTablePtr[filterTableIndex].id & CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>   
##@@@L1263_:                           CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT)   
##@@@L1264_:                          << CANFD_FORMATB_EXT_SHIFT1);   
8000cfa4:	51 7a       	LSL       R10, #1			;->0x01
8000cfa6:	a1 69       	ANL       R10, R1
8000cfa8:	29 41       	LD        R1, [PC + #41]        ;->0x8000d04c  :=0x40000000
##@@@P_:kf32a13k_drv_canfd.c:1262
##@@@L1257_:            }   
##@@@L1258_:            if (IdFilterTablePtr[filterTableIndex].isExtendedFrame)   
##@@@L1259_:            {   
##@@@L1260_:                val1 |= CAFND_RX_FIFO_ACCEPT_EXT_FRAME << CANFD_FORMATAB_IDE_SHIFT;   
##@@@L1261_:                filterTablePtr[filterNumber] =   
##@@@L1262_:                  val1 + (((IdFilterTablePtr[filterTableIndex].id & CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>   
8000cfaa:	9a 6a       	ORL       R9, R10
8000cfac:	91 6a       	ORL       R9, R1
8000cfae:	06 04       	SJMP      $+6                   ;->0x8000cfba
##@@@P_:kf32a13k_drv_canfd.c:1269
##@@@L1264_:                          << CANFD_FORMATB_EXT_SHIFT1);   
##@@@L1265_:            }   
##@@@L1266_:            else   
##@@@L1267_:            {   
##@@@L1268_:                filterTablePtr[filterNumber] =   
##@@@L1269_:                  val1 + ((IdFilterTablePtr[filterTableIndex].id & CANFD_FORMATB_STD_MASK) << CANFD_FORMATB_STD_SHIFT1);   
8000cfb0:	53 7b       	LSL       R10, #19			;->0x13
8000cfb2:	03 09       	LD.W      R1, [SP + #3]
8000cfb4:	a1 69       	ANL       R10, R1
8000cfb6:	a9 6a       	ORL       R10, R9
8000cfb8:	2a 59       	MOV       R9, R10
8000cfba:	c7 7a       	LSL       R8, #15			;->0x0F
8000cfbc:	49 85       	ST.W      [R4], R9
##@@@P_:kf32a13k_drv_canfd.c:1271
##@@@L1270_:            }   
##@@@L1271_:            if (IdFilterTablePtr[filterTableIndex + 1U].isExtendedFrame)   
8000cfbe:	46 88       	LD.B      R0, [R6 + #1]
8000cfc0:	4e 98       	LD.W      R1, [R6 + #1]
8000cfc2:	00 38       	CMP       R0, #0			;->0x00
8000cfc4:	d4 f0       	JZ        $-44                  ;->0x8000cf6c
##@@@P_:kf32a13k_drv_canfd.c:1275
##@@@L1272_:            {   
##@@@L1273_:                val2 |= CAFND_RX_FIFO_ACCEPT_EXT_FRAME << CANFD_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;   
##@@@L1274_:                filterTablePtr[filterNumber] |=   
##@@@L1275_:                  val2 + (((IdFilterTablePtr[filterTableIndex + 1U].id & CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>   
8000cfc6:	8f 7c       	LSR       R1, #15			;->0x0F
##@@@P_:kf32a13k_drv_canfd.c:1274
##@@@L1269_:                  val1 + ((IdFilterTablePtr[filterTableIndex].id & CANFD_FORMATB_STD_MASK) << CANFD_FORMATB_STD_SHIFT1);   
##@@@L1270_:            }   
##@@@L1271_:            if (IdFilterTablePtr[filterTableIndex + 1U].isExtendedFrame)   
##@@@L1272_:            {   
##@@@L1273_:                val2 |= CAFND_RX_FIFO_ACCEPT_EXT_FRAME << CANFD_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;   
##@@@L1274_:                filterTablePtr[filterNumber] |=   
8000cfc8:	04 82       	LD.W      R0, [R4]
##@@@P_:kf32a13k_drv_canfd.c:1275
##@@@L1275_:                  val2 + (((IdFilterTablePtr[filterTableIndex + 1U].id & CANFD_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>   
8000cfca:	12 69       	ANL       R1, R2
8000cfcc:	80 6a       	ORL       R8, R0
8000cfce:	21 40       	LD        R0, [PC + #33]        ;->0x8000d050  :=0x4000
##@@@P_:kf32a13k_drv_canfd.c:1274
##@@@L1269_:                  val1 + ((IdFilterTablePtr[filterTableIndex].id & CANFD_FORMATB_STD_MASK) << CANFD_FORMATB_STD_SHIFT1);   
##@@@L1270_:            }   
##@@@L1271_:            if (IdFilterTablePtr[filterTableIndex + 1U].isExtendedFrame)   
##@@@L1272_:            {   
##@@@L1273_:                val2 |= CAFND_RX_FIFO_ACCEPT_EXT_FRAME << CANFD_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;   
##@@@L1274_:                filterTablePtr[filterNumber] |=   
8000cfd0:	81 6a       	ORL       R8, R1
8000cfd2:	80 6a       	ORL       R8, R0
8000cfd4:	d2 07       	SJMP      $-46                  ;->0x8000cf78
8000cfd6:	85 58       	MOV       R4, R5
8000cfd8:	23 7a       	LSL       R4, #3			;->0x03
8000cfda:	1e e5       	LD.B      R3, [R6 + R4]
8000cfdc:	30 38       	CMP       R3, #0			;->0x00
8000cfde:	03 f1       	JNZ       $+3                   ;->0x8000cfe4
8000cfe0:	30 10       	MOV       R3, #0			;->0x0000
8000cfe2:	02 04       	SJMP      $+2                   ;->0x8000cfe6
8000cfe4:	31 10       	MOV       R3, #1			;->0x0001
8000cfe6:	2a 7a       	LSL       R5, #2			;->0x02
8000cfe8:	6a c3       	ADD       R5, R2, R5
8000cfea:	0e c3       	ADD       R1, R6, R4
##@@@P_:kf32a13k_drv_canfd.c:1223
##@@@L1218_:    filterNumber                      = Canfd_LL_GetLegacyFifoFilterNum(Module);   
##@@@L1219_:    Canfd_LL_SetRxFifoIdFormat(Module, IdFormat);   
##@@@L1220_:    switch (IdFormat)   
##@@@L1221_:    {   
##@@@L1222_:    case CANFD_RX_FIFO_ID_FORMAT_A: {   
##@@@L1223_:        for (filterIndex = 0; filterIndex < RxFifoFilterElementNum(filterNumber); filterIndex++)   
8000cfec:	48 28       	ADD       R4, #8			;->0x08
8000cfee:	11 c1       	ADD       R2, R1, #4
8000cff0:	49 88       	LD.B      R1, [R1 + #1]
8000cff2:	9f 7b       	LSL       R3, #31			;->0x1F
8000cff4:	8f 1f       	MOV       R8, #255			;->0x00FF
8000cff6:	12 40       	LD        R0, [PC + #18]        ;->0x8000d03c  :=0x3ff80000
8000cff8:	17 46       	LD        R6, [PC + #23]        ;->0x8000d054  :=0x3ffffffe
8000cffa:	15 47       	LD        R7, [PC + #21]        ;->0x8000d04c  :=0x40000000
8000cffc:	18 69       	ANL       R1, R8
8000cffe:	09 04       	SJMP      $+9                   ;->0x8000d010
##@@@P_:kf32a13k_drv_canfd.c:1239
##@@@L1234_:                  val + ((IdFilterTablePtr[filterNumber].id << CANFD_FORMATA_EXT_SHIFT) & CANFD_FORMATA_EXT_MASK);   
##@@@L1235_:            }   
##@@@L1236_:            else   
##@@@L1237_:            {   
##@@@L1238_:                filterTablePtr[filterNumber] =   
##@@@L1239_:                  val + ((IdFilterTablePtr[filterNumber].id << CANFD_FORMATA_STD_SHIFT) & CANFD_FORMATA_STD_MASK);   
8000d000:	43 7b       	LSL       R8, #19			;->0x13
8000d002:	80 69       	ANL       R8, R0
8000d004:	83 6a       	ORL       R8, R3
8000d006:	28 59       	MOV       R9, R8
##@@@P_:kf32a13k_drv_canfd.c:1223
##@@@L1218_:    filterNumber                      = Canfd_LL_GetLegacyFifoFilterNum(Module);   
##@@@L1219_:    Canfd_LL_SetRxFifoIdFormat(Module, IdFormat);   
##@@@L1220_:    switch (IdFormat)   
##@@@L1221_:    {   
##@@@L1222_:    case CANFD_RX_FIFO_ID_FORMAT_A: {   
##@@@L1223_:        for (filterIndex = 0; filterIndex < RxFifoFilterElementNum(filterNumber); filterIndex++)   
8000d008:	64 cc       	SUB       R4, R4, #1
8000d00a:	40 38       	CMP       R4, #0			;->0x00
8000d00c:	59 85       	ST.W      [R5], R9
8000d00e:	0a f0       	JZ        $+10                  ;->0x8000d022
8000d010:	82 82       	LD.W      R8, [R2]
##@@@P_:kf32a13k_drv_canfd.c:1230
##@@@L1225_:            val = 0;   
##@@@L1226_:            if (IdFilterTablePtr[filterNumber].isRemoteFrame)   
##@@@L1227_:            {   
##@@@L1228_:                val = CAFND_RX_FIFO_ACCEPT_REMOTE_FRAME << CANFD_FORMATAB_RTR_SHIFT;   
##@@@L1229_:            }   
##@@@L1230_:            if (IdFilterTablePtr[filterNumber].isExtendedFrame)   
8000d012:	10 38       	CMP       R1, #0			;->0x00
8000d014:	f6 f0       	JZ        $-10                  ;->0x8000d000
##@@@P_:kf32a13k_drv_canfd.c:1234
##@@@L1231_:            {   
##@@@L1232_:                val |= CAFND_RX_FIFO_ACCEPT_EXT_FRAME << CANFD_FORMATAB_IDE_SHIFT;   
##@@@L1233_:                filterTablePtr[filterNumber] =   
##@@@L1234_:                  val + ((IdFilterTablePtr[filterNumber].id << CANFD_FORMATA_EXT_SHIFT) & CANFD_FORMATA_EXT_MASK);   
8000d016:	41 7a       	LSL       R8, #1			;->0x01
8000d018:	86 69       	ANL       R8, R6
8000d01a:	23 59       	MOV       R9, R3
8000d01c:	98 6a       	ORL       R9, R8
8000d01e:	97 6a       	ORL       R9, R7
8000d020:	f4 07       	SJMP      $-12                  ;->0x8000d008
##@@@P_:kf32a13k_drv_canfd.c:1358
##@@@L1353_:    case CANFD_RX_FIFO_ID_FORMAT_D:   
##@@@L1354_:        break;   
##@@@L1355_:    default:   
##@@@L1356_:        break;   
##@@@L1357_:    }   
##@@@L1358_:}   
8000d022:	e0 29       	ADD       SP, #16			;->0x10
8000d024:	3f 5e       	POP       {R6-R11}
8000d026:	1d 5c       	JMP       LR
8000d028:	00 03 00 00 	.long     0x00000300 ->000000768  [!!!@4@:JMP       $+0                   ;->0x8000d028
8000d02c:	ff fc ff ff 	.long     0xfffffcff ->-00000769 
8000d030:	00 00 00 ff 	.long     0xff000000 ->-16777216 
8000d034:	00 00 ff 00 	.long     0x00ff0000 ->016711680 
8000d038:	00 ff 00 00 	.long     0x0000ff00 ->000065280 
8000d03c:	00 00 f8 3f 	.long     0x3ff80000 ->1073217536  [!!!@2@:NOP      	@@: CMP       PC, #120
8000d040:	f8 3f 00 00 	.long     0x00003ff8 ->000016376  [!!!@2@:CMP       PC, #120	@@: NOP      
8000d044:	ff 3f 00 00 	.long     0x00003fff ->000016383  [!!!@2@:CMP       PC, #127	@@: NOP      
8000d048:	00 00 ff 3f 	.long     0x3fff0000 ->1073676288  [!!!@2@:NOP      	@@: CMP       PC, #127
8000d04c:	00 00 00 40 	.long     0x40000000 ->1073741824  [!!!@2@:NOP      	@@: LD        R0, [PC + #0]         ;->0x8000d04c  :=0x40000000
8000d050:	00 40 00 00 	.long     0x00004000 ->000016384  [!!!@2@:LD        R0, [PC + #0]         ;->0x8000d050  :=0x4000	@@: NOP      
8000d054:	fe ff ff 3f 	.long     0x3ffffffe ->1073741822 

8000d058 <Canfd_LL_GetMbData>:
##@@@F_:Canfd_LL_GetMbData():
##@@@P_:kf32a13k_drv_canfd.c:1368
##@@@L1363_: * @param MbIndex   
##@@@L1364_: * @param RxMsgPtr   
##@@@L1365_: * @retval kf_status_t   
##@@@L1366_: */   
##@@@L1367_:kf_status_t Canfd_LL_GetMbData(CanfdPtr Module, const uint32_t MbIndex, Canfd_MsgBuff_t *RxMsgPtr)   
##@@@L1368_:{   
8000d058:	26 5d       	PUSH      R6
8000d05a:	e4 30       	SUB       SP, #4			;->0x04
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000d05c:	40 82       	LD.W      R4, [R0]
8000d05e:	34 45       	LD        R5, [PC + #52]        ;->0x8000d12c  :=0x800
8000d060:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000d062:	40 38       	CMP       R4, #0			;->0x00
8000d064:	03 f1       	JNZ       $+3                   ;->0x8000d06a
8000d066:	40 11       	MOV       R4, #16			;->0x0010
8000d068:	09 04       	SJMP      $+9                   ;->0x8000d07a
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000d06a:	32 44       	LD        R4, [PC + #50]        ;->0x8000d130  :=0xc00
8000d06c:	18 e9       	LD.W      R3, [R0 + R4]
8000d06e:	18 7d       	LSR       R3, #16			;->0x10
8000d070:	43 10       	MOV       R4, #3			;->0x0003
8000d072:	34 69       	ANL       R3, R4
8000d074:	48 10       	MOV       R4, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000d076:	43 6c       	LSL       R4, R3
8000d078:	48 28       	ADD       R4, #8			;->0x08
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:682
##@@@L0677_:    uint8_t  payloadSize          = Canfd_LL_GetPayloadSize(Module);   
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
8000d07a:	2d d3       	DIVU      R5, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000d07c:	59 d3       	DIVU      R3, R1, R5
8000d07e:	6b cb       	MULS      R5, R3, R5
8000d080:	69 c7       	SUB       R5, R1, R5
8000d082:	9b 7a       	LSL       R3, #11			;->0x0B
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000d084:	22 7c       	LSR       R4, #2			;->0x02
8000d086:	19 00 a4 0c 	MADD32    R3, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000d08a:	1a 7a       	LSL       R3, #2			;->0x02
8000d08c:	e0 c2       	ADD       R4, R0, R3
##@@@F_:Canfd_LL_GetMbData():
8000d08e:	40 00 85 90 	LD.W      R5, [R4 + #36]			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:1379
##@@@L1374_:    volatile const uint8_t  *mailboxDataPtr     = (volatile const uint8_t *)(&mailboxPtr[2]);   
##@@@L1375_:    volatile const uint32_t *mailBoxPtr_data_32 = &mailboxPtr[2];   
##@@@L1376_:    uint32_t                *mailboxData32Ptr   = (uint32_t *)(RxMsgPtr->data);   
##@@@L1377_:    uint32_t                 mbWord;   
##@@@L1378_:
##@@@L1379_:    uint8_t realDlc   = (uint8_t)(((*mailboxPtr) & CAN_CS_DLC_MASK) >> 16);   
8000d092:	28 7d       	LSR       R5, #16			;->0x10
8000d094:	3f 10       	MOV       R3, #15			;->0x000F
8000d096:	53 69       	ANL       R5, R3
##@@@F_:Canfd_LL_GetDataLength():
##@@@P_:kf32a13k_drv_canfd.c:170
##@@@L0165_: * @param PayLoadLength   
##@@@L0166_: * @retval void   
##@@@L0167_: */   
##@@@L0168_:uint8_t Canfd_LL_GetDataLength(const uint8_t Dlc)   
##@@@L0169_:{   
##@@@L0170_:    return ((uint8_t)(Dlc > 8U ? kvFd_MaxDataLength[(uint8_t)Dlc - 8U] : Dlc));   
8000d098:	59 38       	CMP       R5, #9			;->0x09
8000d09a:	05 f3       	JNC       $+5                   ;->0x8000d0a4
8000d09c:	26 43       	LD        R3, [PC + #38]        ;->0x8000d134  :=0x80001210
8000d09e:	ed c2       	ADD       R5, R5, R3
8000d0a0:	58 30       	SUB       R5, #8			;->0x08
8000d0a2:	55 80       	LD.B      R5, [R5]
##@@@F_:Canfd_LL_GetMbData():
8000d0a4:	79 00 45 20 	ST.B      [R2 + #72], R5			;->0x48
##@@@F_:Canfd_LL_IsRxFifoEnabled():
##@@@P_:kf32a13k_drv_canfd.h:935
##@@@L0930_: * @return bool   
##@@@L0931_: */   
##@@@L0932_:KF_INLINE bool Canfd_LL_IsRxFifoEnabled(CanfdPtr Module)   
##@@@L0933_:{   
##@@@L0934_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0935_:    return (REG_READ(Module->CANFD_MCR.bits.RFEN));   
8000d0a8:	30 82       	LD.W      R3, [R0]
8000d0aa:	24 46       	LD        R6, [PC + #36]        ;->0x8000d138  :=0x20000000
8000d0ac:	36 69       	ANL       R3, R6
##@@@F_:Canfd_LL_GetMbData():
##@@@P_:kf32a13k_drv_canfd.c:1383
##@@@L1378_:
##@@@L1379_:    uint8_t realDlc   = (uint8_t)(((*mailboxPtr) & CAN_CS_DLC_MASK) >> 16);   
##@@@L1380_:    payloadLength     = Canfd_LL_GetDataLength(realDlc);   
##@@@L1381_:    RxMsgPtr->dataLen = payloadLength;   
##@@@L1382_:    /* Check if RX FIFO is enabled */   
##@@@L1383_:    if (true == Canfd_LL_IsRxFifoEnabled(Module))   
8000d0ae:	30 38       	CMP       R3, #0			;->0x00
8000d0b0:	0a f0       	JZ        $+10                  ;->0x8000d0c4
##@@@F_:Canfd_LL_GetLegacyFifoFilterNum():
##@@@P_:kf32a13k_drv_canfd.h:1292
##@@@L1287_: * @return uint32_t   
##@@@L1288_: */   
##@@@L1289_:KF_INLINE uint32_t Canfd_LL_GetLegacyFifoFilterNum(CanfdPtr Module)   
##@@@L1290_:{   
##@@@L1291_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1292_:    return (REG_READ(Module->CANFD_CTRL2.bits.RFFN));   
8000d0b2:	58 9b       	LD.W      R3, [R0 + #13]
##@@@F_:Canfd_LL_RxFifoOcuppiedLastMsgBuff():
##@@@P_:kf32a13k_drv_canfd.h:913
##@@@L0908_: * @return bool   
##@@@L0909_: */   
##@@@L0910_:KF_INLINE uint32_t Canfd_LL_RxFifoOcuppiedLastMsgBuff(uint32_t FilterNumber)   
##@@@L0911_:{   
##@@@L0912_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0913_:    return (5U + ((((FilterNumber) + 1U) * 8U) / 4U));   
8000d0b4:	1d 7d       	LSR       R3, #21			;->0x15
8000d0b6:	08 17       	MOV       R0, #120			;->0x0078
8000d0b8:	30 69       	ANL       R3, R0
8000d0ba:	38 28       	ADD       R3, #8			;->0x08
8000d0bc:	1a 7c       	LSR       R3, #2			;->0x02
8000d0be:	5b c1       	ADD       R3, R3, #5
##@@@F_:Canfd_LL_GetMbData():
##@@@P_:kf32a13k_drv_canfd.c:1397
##@@@L1392_:        if (MbIndex <= val2)   
##@@@L1393_:        {   
##@@@L1394_:            retStatus = STATUS_CANFD_BUFF_OUT_OF_RANGE;   
##@@@L1395_:        }   
##@@@L1396_:    }   
##@@@L1397_:    if (STATUS_OK == retStatus)   
8000d0c0:	31 70       	CMP       R3, R1
8000d0c2:	31 f2       	JC        $+49                  ;->0x8000d124
8000d0c4:	30 19       	MOV       R3, #144			;->0x0090
8000d0c6:	dc c2       	ADD       R3, R4, R3
##@@@P_:kf32a13k_drv_canfd.c:1400
##@@@L1398_:    {   
##@@@L1399_:        /* Get a MB field values */   
##@@@L1400_:        RxMsgPtr->cs = *mailboxPtr;   
8000d0c8:	03 82       	LD.W      R0, [R3]
8000d0ca:	1d 41       	LD        R1, [PC + #29]        ;->0x8000d13c  :=0x200000
8000d0cc:	20 85       	ST.W      [R2], R0
##@@@P_:kf32a13k_drv_canfd.c:1401
##@@@L1401_:        if ((RxMsgPtr->cs & CAN_CS_IDE_MASK) != 0U)   
8000d0ce:	01 69       	ANL       R0, R1
8000d0d0:	5b 98       	LD.W      R3, [R3 + #1]
8000d0d2:	18 19       	MOV       R1, #152			;->0x0098
8000d0d4:	00 38       	CMP       R0, #0			;->0x00
8000d0d6:	02 f1       	JNZ       $+2                   ;->0x8000d0da
8000d0d8:	1a 7d       	LSR       R3, #18			;->0x12
8000d0da:	64 c2       	ADD       R4, R4, R1
8000d0dc:	0c 1f       	MOV       R0, #252			;->0x00FC
8000d0de:	25 58       	MOV       R1, R5
8000d0e0:	10 69       	ANL       R1, R0
##@@@P_:kf32a13k_drv_canfd.c:1409
##@@@L1404_:        }   
##@@@L1405_:        else   
##@@@L1406_:        {   
##@@@L1407_:            RxMsgPtr->msgId = CANFD_READ32(mailboxIdPtr) >> CAN_ID_STD_SHIFT;   
##@@@L1408_:        }   
##@@@L1409_:        for (i = 0U; i < (payloadLength & ~3U); i += 4U)   
8000d0e2:	10 38       	CMP       R1, #0			;->0x00
##@@@P_:kf32a13k_drv_canfd.c:1407
##@@@L1402_:        {   
##@@@L1403_:            RxMsgPtr->msgId = CANFD_READ32(mailboxIdPtr);   
##@@@L1404_:        }   
##@@@L1405_:        else   
##@@@L1406_:        {   
##@@@L1407_:            RxMsgPtr->msgId = CANFD_READ32(mailboxIdPtr) >> CAN_ID_STD_SHIFT;   
8000d0e4:	53 a0       	ST.W      [R2 + #1], R3
##@@@P_:kf32a13k_drv_canfd.c:1409
##@@@L1408_:        }   
##@@@L1409_:        for (i = 0U; i < (payloadLength & ~3U); i += 4U)   
8000d0e6:	0c f0       	JZ        $+12                  ;->0x8000d0fe
8000d0e8:	30 10       	MOV       R3, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:1411
##@@@L1410_:        {   
##@@@L1411_:            mbWord = CANFD_READ32(mailBoxPtr_data_32[i >> 2U]);   
8000d0ea:	c4 e8       	LD.W      R0, [R4 + R3]
##@@@F_:Canfd_LL_SwapBytesInWord():
##@@@P_:kf32a13k_drv_canfd.c:184
##@@@L0179_: */   
##@@@L0180_:void Canfd_LL_SwapBytesInWord(volatile void *DesPtr, volatile void *SouPtr)   
##@@@L0181_:{   
##@@@L0182_:    volatile uint8_t *sou8Ptr = (uint8_t *)(SouPtr);   
##@@@L0183_:    volatile uint8_t *des8Ptr = (uint8_t *)(DesPtr);   
##@@@L0184_:    CANFD_WRITE8(des8Ptr, *(sou8Ptr + 3U));   
8000d0ec:	c2 c2       	ADD       R0, R2, R3
8000d0ee:	f0 8a       	LD.B      R6, [R0 + #11]
##@@@P_:kf32a13k_drv_canfd.c:185
##@@@L0185_:    CANFD_WRITE8(des8Ptr + 1U, *(sou8Ptr + 2U));   
8000d0f0:	b0 8a       	LD.B      R6, [R0 + #10]
##@@@P_:kf32a13k_drv_canfd.c:186
##@@@L0186_:    CANFD_WRITE8(des8Ptr + 2U, *(sou8Ptr + 1U));   
8000d0f2:	70 8a       	LD.B      R6, [R0 + #9]
##@@@P_:kf32a13k_drv_canfd.c:187
##@@@L0187_:    CANFD_WRITE8(des8Ptr + 3U, *(sou8Ptr));   
8000d0f4:	00 8a       	LD.B      R0, [R0 + #8]
##@@@F_:Canfd_LL_GetMbData():
##@@@P_:kf32a13k_drv_canfd.c:1409
##@@@L1404_:        }   
##@@@L1405_:        else   
##@@@L1406_:        {   
##@@@L1407_:            RxMsgPtr->msgId = CANFD_READ32(mailboxIdPtr) >> CAN_ID_STD_SHIFT;   
##@@@L1408_:        }   
##@@@L1409_:        for (i = 0U; i < (payloadLength & ~3U); i += 4U)   
8000d0f6:	1b c1       	ADD       R3, R3, #4
8000d0f8:	31 70       	CMP       R3, R1
8000d0fa:	f8 f3       	JNC       $-8                   ;->0x8000d0ea
8000d0fc:	02 04       	SJMP      $+2                   ;->0x8000d100
8000d0fe:	30 10       	MOV       R3, #0			;->0x0000
8000d100:	1f 1f       	MOV       R1, #255			;->0x00FF
##@@@P_:kf32a13k_drv_canfd.c:1414
##@@@L1410_:        {   
##@@@L1411_:            mbWord = CANFD_READ32(mailBoxPtr_data_32[i >> 2U]);   
##@@@L1412_:            Canfd_LL_SwapBytesInWord(&mbWord, &mailboxData32Ptr[i >> 2U]);   
##@@@L1413_:        }   
##@@@L1414_:        for (; i < payloadLength; i++)   
8000d102:	51 69       	ANL       R5, R1
8000d104:	31 69       	ANL       R3, R1
8000d106:	35 70       	CMP       R3, R5
8000d108:	0c f2       	JC        $+12                  ;->0x8000d120
8000d10a:	28 28       	ADD       R2, #8			;->0x08
8000d10c:	13 10       	MOV       R1, #3			;->0x0003
8000d10e:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:kf32a13k_drv_canfd.c:1416
##@@@L1415_:        { /* Max allowed value for index is 63 */   
##@@@L1416_:            RxMsgPtr->data[i] = mailboxDataPtr[SwapBytesInWordIndex(i)];   
8000d110:	c3 58       	MOV       R6, R3
8000d112:	61 6b       	XRL       R6, R1
8000d114:	b4 e5       	LD.B      R6, [R4 + R6]
8000d116:	d6 ea       	ST.B      [R2 + R3], R6
##@@@P_:kf32a13k_drv_canfd.c:1414
##@@@L1409_:        for (i = 0U; i < (payloadLength & ~3U); i += 4U)   
##@@@L1410_:        {   
##@@@L1411_:            mbWord = CANFD_READ32(mailBoxPtr_data_32[i >> 2U]);   
##@@@L1412_:            Canfd_LL_SwapBytesInWord(&mbWord, &mailboxData32Ptr[i >> 2U]);   
##@@@L1413_:        }   
##@@@L1414_:        for (; i < payloadLength; i++)   
8000d118:	5b c0       	ADD       R3, R3, #1
8000d11a:	35 70       	CMP       R3, R5
8000d11c:	fa f3       	JNC       $-6                   ;->0x8000d110
8000d11e:	04 04       	SJMP      $+4                   ;->0x8000d126
8000d120:	00 10       	MOV       R0, #0			;->0x0000
8000d122:	02 04       	SJMP      $+2                   ;->0x8000d126
8000d124:	07 40       	LD        R0, [PC + #7]         ;->0x8000d140  :=0x380
##@@@P_:kf32a13k_drv_canfd.c:1419
##@@@L1415_:        { /* Max allowed value for index is 63 */   
##@@@L1416_:            RxMsgPtr->data[i] = mailboxDataPtr[SwapBytesInWordIndex(i)];   
##@@@L1417_:        }   
##@@@L1418_:    }   
##@@@L1419_:    return retStatus;   
8000d126:	e4 28       	ADD       SP, #4			;->0x04
8000d128:	06 5d       	POP       R6
8000d12a:	1d 5c       	JMP       LR
8000d12c:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000d130:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000d134:	10 12 00 80 	.long     0x80001210 ->-2147479024  [!!!@2@:MOV       R1, #32	@@: LD.B      R0, [R0]
8000d138:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000d13c:	00 00 20 00 	.long     0x00200000 ->002097152  [!!!@2@:NOP      	@@: FST.W            [R0+#0],	S1
8000d140:	80 03 00 00 	.long     0x00000380 ->000000896  [!!!@4@:JMP       $-8388608             ;->0x7f00d140

8000d144 <Canfd_LL_LockRxMailBox>:
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000d144:	50 82       	LD.W      R5, [R0]
8000d146:	04 44       	LD        R4, [PC + #4]         ;->0x8000d154  :=0x800
8000d148:	54 69       	ANL       R5, R4
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000d14a:	50 38       	CMP       R5, #0			;->0x00
8000d14c:	03 f0       	JZ        $+3                   ;->0x8000d152
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000d14e:	03 45       	LD        R5, [PC + #3]         ;->0x8000d158  :=0xc00
8000d150:	68 e9       	LD.W      R5, [R0 + R5]
##@@@F_:Canfd_LL_LockRxMailBox():
##@@@P_:kf32a13k_drv_canfd.c:1433
##@@@L1428_:void Canfd_LL_LockRxMailBox(CanfdPtr Module, uint32_t MbIndex)   
##@@@L1429_:{   
##@@@L1430_:    volatile uint32_t *mailboxPtr = Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L1431_:    /* Lock the mailbox by reading it */   
##@@@L1432_:    (void)mailboxPtr;   
##@@@L1433_:}   
8000d152:	1d 5c       	JMP       LR
8000d154:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000d158:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      

8000d15c <Canfd_LL_ResetRxMalibox>:
##@@@F_:Canfd_LL_IsFDEnabled():
##@@@P_:kf32a13k_drv_canfd.h:495
##@@@L0490_: *         true:canfd feeature 已经使能   
##@@@L0491_: */   
##@@@L0492_:KF_INLINE bool Canfd_LL_IsFDEnabled(CanfdPtr Module)   
##@@@L0493_:{   
##@@@L0494_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0495_:    return (REG_READ(Module->CANFD_MCR.bits.FDEN));   
8000d15c:	40 82       	LD.W      R4, [R0]
8000d15e:	12 45       	LD        R5, [PC + #18]        ;->0x8000d1a4  :=0x800
8000d160:	45 69       	ANL       R4, R5
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:294
##@@@L0289_: * @return uint32_t   
##@@@L0290_: */   
##@@@L0291_:uint32_t Canfd_LL_GetPayloadSize(CanfdPtr Module)   
##@@@L0292_:{   
##@@@L0293_:    uint32_t payloadSize;   
##@@@L0294_:    if (false == Canfd_LL_IsFDEnabled(Module))   
8000d162:	40 38       	CMP       R4, #0			;->0x00
8000d164:	03 f1       	JNZ       $+3                   ;->0x8000d16a
8000d166:	40 11       	MOV       R4, #16			;->0x0010
8000d168:	09 04       	SJMP      $+9                   ;->0x8000d17a
##@@@F_:Canfd_LL_GetR0PayLoadSize():
##@@@P_:kf32a13k_drv_canfd.h:758
##@@@L0753_: * @return Canfd_PayloadSize_t   
##@@@L0754_: */   
##@@@L0755_:KF_INLINE Canfd_PayloadSize_t Canfd_LL_GetR0PayLoadSize(CanfdPtr Module)   
##@@@L0756_:{   
##@@@L0757_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L0758_:    return ((Canfd_PayloadSize_t)REG_READ(Module->CANFD_FDCTRL.bits.MBDSR0));   
8000d16a:	10 44       	LD        R4, [PC + #16]        ;->0x8000d1a8  :=0xc00
8000d16c:	18 e9       	LD.W      R3, [R0 + R4]
8000d16e:	18 7d       	LSR       R3, #16			;->0x10
8000d170:	43 10       	MOV       R4, #3			;->0x0003
8000d172:	34 69       	ANL       R3, R4
8000d174:	48 10       	MOV       R4, #8			;->0x0008
##@@@F_:Canfd_LL_GetPayloadSize():
##@@@P_:kf32a13k_drv_canfd.c:300
##@@@L0295_:    {   
##@@@L0296_:        payloadSize = 8U;   
##@@@L0297_:    }   
##@@@L0298_:    else   
##@@@L0299_:    {   
##@@@L0300_:        payloadSize = (1U << (Canfd_LL_GetR0PayLoadSize(Module) + 3U));   
8000d176:	43 6c       	LSL       R4, R3
8000d178:	48 28       	ADD       R4, #8			;->0x08
##@@@F_:Canfd_LL_GetMailboxAddr():
##@@@P_:kf32a13k_drv_canfd.c:682
##@@@L0677_:    uint8_t  payloadSize          = Canfd_LL_GetPayloadSize(Module);   
##@@@L0678_:    uint8_t  arbitrationFieldSize = CANFD_ARBITRATION_RAMSIZE;   
##@@@L0679_:    uint32_t ramBlockSize         = CANFD_MAX_RAMSIZE;   
##@@@L0680_:    uint32_t ramBlockOffset;   
##@@@L0681_:    uint8_t  mbSize   = (uint8_t)(payloadSize + arbitrationFieldSize);   
##@@@L0682_:    uint8_t  maxMbNum = (uint8_t)(ramBlockSize / mbSize);   
8000d17a:	2d d3       	DIVU      R5, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:683
##@@@L0683_:    ramBlockOffset    = CANFD_MAX_RAMSIZE * (MbIndex / (uint32_t)maxMbNum);   
8000d17c:	59 d3       	DIVU      R3, R1, R5
8000d17e:	6b cb       	MULS      R5, R3, R5
8000d180:	69 c7       	SUB       R5, R1, R5
8000d182:	9b 7a       	LSL       R3, #11			;->0x0B
##@@@P_:kf32a13k_drv_canfd.c:685
##@@@L0684_:    /*TODO: Multiply the MB index by the MB size (in words) */   
##@@@L0685_:    uint32_t mbIndex = ramBlockOffset + ((MbIndex % (uint32_t)maxMbNum) * ((uint32_t)mbSize >> 2U));   
8000d184:	22 7c       	LSR       R4, #2			;->0x02
8000d186:	19 00 a4 0c 	MADD32    R3, R5, R4
##@@@P_:kf32a13k_drv_canfd.c:686
##@@@L0686_:    return &(Module->CANFD_RAM[mbIndex]);   
8000d18a:	1a 7a       	LSL       R3, #2			;->0x02
8000d18c:	e8 c2       	ADD       R5, R0, R3
8000d18e:	08 44       	LD        R4, [PC + #8]         ;->0x8000d1ac  :=0xf0ffffff
##@@@F_:Canfd_LL_ResetRxMalibox():
8000d190:	40 00 a3 90 	LD.W      R3, [R5 + #36]			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:1449
##@@@L1444_:    uint32_t code   = CANFD_RX_INACTIVE;   
##@@@L1445_:
##@@@L1446_:    volatile uint32_t *mailBoxPtr = Canfd_LL_GetMailboxAddr(Module, MbIndex);   
##@@@L1447_:    csInfo                        = *mailBoxPtr;   
##@@@L1448_:    /* Reset the code and unlock the MB */   
##@@@L1449_:    csInfo &= (~CAN_CS_CODE_MASK);   
8000d194:	34 69       	ANL       R3, R4
8000d196:	07 44       	LD        R4, [PC + #7]         ;->0x8000d1b0  :=0x4000000
8000d198:	68 00 a3 90 	ST        [R5 + #36], R3			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:1456
##@@@L1451_:    *mailBoxPtr = csInfo;   
##@@@L1452_:
##@@@L1453_:    /* Reconfigure The MB as left by RxMBconfig */   
##@@@L1454_:    code = CANFD_RX_EMPTY;   
##@@@L1455_:    csInfo &= (~CAN_CS_CODE_MASK);   
##@@@L1456_:    csInfo |= (code << CAN_CS_CODE_SHIFT) & CAN_CS_CODE_MASK;   
8000d19c:	34 6a       	ORL       R3, R4
8000d19e:	68 00 a3 90 	ST        [R5 + #36], R3			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:1458
##@@@L1457_:    *mailBoxPtr = csInfo;   
##@@@L1458_:}   
8000d1a2:	1d 5c       	JMP       LR
8000d1a4:	00 08 00 00 	.long     0x00000800 ->000002048  [!!!@2@:LD.W      R0, [SP + #0]	@@: NOP      
8000d1a8:	00 0c 00 00 	.long     0x00000c00 ->000003072  [!!!@2@:LD.W      R4, [SP + #0]	@@: NOP      
8000d1ac:	ff ff ff f0 	.long     0xf0ffffff ->-251658241 
8000d1b0:	00 00 00 04 	.long     0x04000000 ->067108864  [!!!@2@:NOP      	@@: SJMP      $+0                   ;->0x8000d1b0

8000d1b4 <Canfd_LL_ConfigPN>:
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1467
##@@@L1462_: * @param Module   
##@@@L1463_: * @param PnConfigPtr   
##@@@L1464_: * @retval void   
##@@@L1465_: */   
##@@@L1466_:void Canfd_LL_ConfigPN(CanfdPtr Module, const Canfd_PNConfig_t *PnConfigPtr)   
##@@@L1467_:{   
8000d1b4:	07 5f       	PUSH      {R6-R8}
8000d1b6:	e4 32       	SUB       SP, #36			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:1470
##@@@L1468_:    /* Configure specific pretended networking settings */   
##@@@L1469_:    Canfd_LL_SetPNFilter(Module, PnConfigPtr->wakeUpTimeout, PnConfigPtr->wakeUpMatch, PnConfigPtr->numMatches,   
##@@@L1470_:                         PnConfigPtr->filterComb, PnConfigPtr->idFilterType, PnConfigPtr->payloadFilterType);   
8000d1b8:	a1 58       	MOV       R5, R1
8000d1ba:	5c 29       	ADD       R5, #28			;->0x1C
##@@@F_:Canfd_LL_SetIdFilterSelection():
##@@@P_:kf32a13k_drv_canfd.h:1786
##@@@L1781_: * @return void   
##@@@L1782_: */   
##@@@L1783_:KF_INLINE void Canfd_LL_SetIdFilterSelection(CanfdPtr Module, const Canfd_PnFilterSeletion_t IdFilterType)   
##@@@L1784_:{   
##@@@L1785_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1786_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.IDFS, IdFilterType);   
8000d1bc:	ad ba       	LDP.W     R5, [R5] << #2
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1469
##@@@L1464_: * @retval void   
##@@@L1465_: */   
##@@@L1466_:void Canfd_LL_ConfigPN(CanfdPtr Module, const Canfd_PNConfig_t *PnConfigPtr)   
##@@@L1467_:{   
##@@@L1468_:    /* Configure specific pretended networking settings */   
##@@@L1469_:    Canfd_LL_SetPNFilter(Module, PnConfigPtr->wakeUpTimeout, PnConfigPtr->wakeUpMatch, PnConfigPtr->numMatches,   
8000d1be:	07 25       	ST.W      [SP + #7], R5
8000d1c0:	79 88       	LD.B      R7, [R1 + #1]
##@@@F_:Canfd_LL_SetPNFilter():
##@@@P_:kf32a13k_drv_canfd.c:146
##@@@L0141_:  CanfdPtr Module, bool WakeUpTimeout, bool WakeUpMatch, uint16_t NumMatches, Canfd_PnCombinationFilter_t FilterComb,   
##@@@L0142_:  Canfd_PnFilterSeletion_t IdFilterType, Canfd_PnFilterSeletion_t PayloadFilterType)   
##@@@L0143_:{   
##@@@L0144_:    Canfd_LL_SetWkupTimeoutMask(Module, WakeUpTimeout);   
##@@@L0145_:    Canfd_LL_SetWkupMatchMask(Module, WakeUpMatch);   
##@@@L0146_:    Canfd_LL_SetWkupMatchNumber(Module, NumMatches);   
8000d1c2:	71 a8       	LD.H      R6, [R1 + #1]
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1470
##@@@L1465_: */   
##@@@L1466_:void Canfd_LL_ConfigPN(CanfdPtr Module, const Canfd_PNConfig_t *PnConfigPtr)   
##@@@L1467_:{   
##@@@L1468_:    /* Configure specific pretended networking settings */   
##@@@L1469_:    Canfd_LL_SetPNFilter(Module, PnConfigPtr->wakeUpTimeout, PnConfigPtr->wakeUpMatch, PnConfigPtr->numMatches,   
##@@@L1470_:                         PnConfigPtr->filterComb, PnConfigPtr->idFilterType, PnConfigPtr->payloadFilterType);   
8000d1c4:	a9 98       	LD.W      R5, [R1 + #2]
8000d1c6:	06 25       	ST.W      [SP + #6], R5
8000d1c8:	21 9a       	LD.W      R4, [R1 + #8]
##@@@F_:Canfd_LL_SetWkupTimeoutMask():
##@@@P_:kf32a13k_drv_canfd.h:1738
##@@@L1733_: * @return void   
##@@@L1734_: */   
##@@@L1735_:KF_INLINE void Canfd_LL_SetWkupTimeoutMask(CanfdPtr Module, const bool Status)   
##@@@L1736_:{   
##@@@L1737_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1738_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.WTOF_MSK, Status);   
8000d1ca:	99 43       	LD        R3, [PC + #153]       ;->0x8000d42c  :=0xb00
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1469
##@@@L1464_: * @retval void   
##@@@L1465_: */   
##@@@L1466_:void Canfd_LL_ConfigPN(CanfdPtr Module, const Canfd_PNConfig_t *PnConfigPtr)   
##@@@L1467_:{   
##@@@L1468_:    /* Configure specific pretended networking settings */   
##@@@L1469_:    Canfd_LL_SetPNFilter(Module, PnConfigPtr->wakeUpTimeout, PnConfigPtr->wakeUpMatch, PnConfigPtr->numMatches,   
8000d1cc:	81 80       	LD.B      R8, [R1]
##@@@F_:Canfd_LL_SetWkupTimeoutMask():
##@@@P_:kf32a13k_drv_canfd.h:1738
8000d1ce:	e8 e8       	LD.W      R5, [R0 + R3]
8000d1d0:	98 42       	LD        R2, [PC + #152]       ;->0x8000d430  :=0xfffdffff
8000d1d2:	52 69       	ANL       R5, R2
8000d1d4:	41 7b       	LSL       R8, #17			;->0x11
8000d1d6:	58 6a       	ORL       R5, R8
8000d1d8:	c5 ee       	ST.W      [R0 + R3], R5
8000d1da:	97 45       	LD        R5, [PC + #151]       ;->0x8000d434  :=0xfffeffff
##@@@F_:Canfd_LL_SetWkupMatchMask():
##@@@P_:kf32a13k_drv_canfd.h:1750
##@@@L1745_: * @return void   
##@@@L1746_: */   
##@@@L1747_:KF_INLINE void Canfd_LL_SetWkupMatchMask(CanfdPtr Module, const bool Status)   
##@@@L1748_:{   
##@@@L1749_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1750_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.WUMF_MSK, Status);   
8000d1dc:	d0 e8       	LD.W      R2, [R0 + R3]
8000d1de:	25 69       	ANL       R2, R5
8000d1e0:	38 7b       	LSL       R7, #16			;->0x10
8000d1e2:	27 6a       	ORL       R2, R7
##@@@F_:Canfd_LL_SetWkupMatchNumber():
##@@@P_:kf32a13k_drv_canfd.h:1762
##@@@L1757_: * @return void   
##@@@L1758_: */   
##@@@L1759_:KF_INLINE void Canfd_LL_SetWkupMatchNumber(CanfdPtr Module, const uint32_t MatchNumber)   
##@@@L1760_:{   
##@@@L1761_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1762_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.NMATCH, MatchNumber);   
8000d1e4:	b0 7a       	LSL       R6, #8			;->0x08
##@@@F_:Canfd_LL_SetWkupMatchMask():
##@@@P_:kf32a13k_drv_canfd.h:1750
##@@@L1745_: * @return void   
##@@@L1746_: */   
##@@@L1747_:KF_INLINE void Canfd_LL_SetWkupMatchMask(CanfdPtr Module, const bool Status)   
##@@@L1748_:{   
##@@@L1749_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1750_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.WUMF_MSK, Status);   
8000d1e6:	c2 ee       	ST.W      [R0 + R3], R2
8000d1e8:	94 45       	LD        R5, [PC + #148]       ;->0x8000d438  :=0xff00
8000d1ea:	95 47       	LD        R7, [PC + #149]       ;->0x8000d43c  :=0xffff00ff
##@@@F_:Canfd_LL_SetWkupMatchNumber():
##@@@P_:kf32a13k_drv_canfd.h:1762
##@@@L1757_: * @return void   
##@@@L1758_: */   
##@@@L1759_:KF_INLINE void Canfd_LL_SetWkupMatchNumber(CanfdPtr Module, const uint32_t MatchNumber)   
##@@@L1760_:{   
##@@@L1761_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1762_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.NMATCH, MatchNumber);   
8000d1ec:	d0 e8       	LD.W      R2, [R0 + R3]
8000d1ee:	65 69       	ANL       R6, R5
8000d1f0:	08 27       	ST.W      [SP + #8], R7
8000d1f2:	27 69       	ANL       R2, R7
8000d1f4:	26 6a       	ORL       R2, R6
8000d1f6:	c2 ee       	ST.W      [R0 + R3], R2
8000d1f8:	92 45       	LD        R5, [PC + #146]       ;->0x8000d440  :=0xfffffffc
##@@@F_:Canfd_LL_SetFilterComb():
##@@@P_:kf32a13k_drv_canfd.h:1774
##@@@L1769_: * @return void   
##@@@L1770_: */   
##@@@L1771_:KF_INLINE void Canfd_LL_SetFilterComb(CanfdPtr Module, const Canfd_PnCombinationFilter_t FilterComb)   
##@@@L1772_:{   
##@@@L1773_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1774_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.FCS, FilterComb);   
8000d1fa:	d0 e8       	LD.W      R2, [R0 + R3]
8000d1fc:	25 69       	ANL       R2, R5
##@@@F_:Canfd_LL_SetPayloadFilterSelection():
##@@@P_:kf32a13k_drv_canfd.h:1798
##@@@L1793_: * @return void   
##@@@L1794_: */   
##@@@L1795_:KF_INLINE void Canfd_LL_SetPayloadFilterSelection(CanfdPtr Module, const Canfd_PnFilterSeletion_t PayloadFilterType)   
##@@@L1796_:{   
##@@@L1797_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1798_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.PLFS, PayloadFilterType);   
8000d1fe:	24 7a       	LSL       R4, #4			;->0x04
8000d200:	80 13       	MOV       R8, #48			;->0x0030
8000d202:	6c 10       	MOV       R6, #12			;->0x000C
8000d204:	73 10       	MOV       R7, #3			;->0x0003
8000d206:	06 0d       	LD.W      R5, [SP + #6]
##@@@F_:Canfd_LL_SetFilterComb():
##@@@P_:kf32a13k_drv_canfd.h:1774
##@@@L1769_: * @return void   
##@@@L1770_: */   
##@@@L1771_:KF_INLINE void Canfd_LL_SetFilterComb(CanfdPtr Module, const Canfd_PnCombinationFilter_t FilterComb)   
##@@@L1772_:{   
##@@@L1773_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1774_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.FCS, FilterComb);   
8000d208:	57 69       	ANL       R5, R7
8000d20a:	25 6a       	ORL       R2, R5
8000d20c:	c2 ee       	ST.W      [R0 + R3], R2
8000d20e:	8e 42       	LD        R2, [PC + #142]       ;->0x8000d444  :=0xfffffff3
##@@@F_:Canfd_LL_SetIdFilterSelection():
##@@@P_:kf32a13k_drv_canfd.h:1786
##@@@L1781_: * @return void   
##@@@L1782_: */   
##@@@L1783_:KF_INLINE void Canfd_LL_SetIdFilterSelection(CanfdPtr Module, const Canfd_PnFilterSeletion_t IdFilterType)   
##@@@L1784_:{   
##@@@L1785_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1786_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.IDFS, IdFilterType);   
8000d210:	f8 e8       	LD.W      R7, [R0 + R3]
8000d212:	07 0d       	LD.W      R5, [SP + #7]
8000d214:	56 69       	ANL       R5, R6
8000d216:	72 69       	ANL       R7, R2
8000d218:	75 6a       	ORL       R7, R5
8000d21a:	c7 ee       	ST.W      [R0 + R3], R7
8000d21c:	8b 42       	LD        R2, [PC + #139]       ;->0x8000d448  :=0xffffffcf
##@@@F_:Canfd_LL_SetPayloadFilterSelection():
##@@@P_:kf32a13k_drv_canfd.h:1798
##@@@L1793_: * @return void   
##@@@L1794_: */   
##@@@L1795_:KF_INLINE void Canfd_LL_SetPayloadFilterSelection(CanfdPtr Module, const Canfd_PnFilterSeletion_t PayloadFilterType)   
##@@@L1796_:{   
##@@@L1797_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1798_:    REG_WRITE(Module->CANFD_CTRL1_PN.bits.PLFS, PayloadFilterType);   
8000d21e:	f0 e8       	LD.W      R6, [R0 + R3]
8000d220:	48 69       	ANL       R4, R8
8000d222:	62 69       	ANL       R6, R2
8000d224:	64 6a       	ORL       R6, R4
8000d226:	c6 ee       	ST.W      [R0 + R3], R6
8000d228:	89 45       	LD        R5, [PC + #137]       ;->0x8000d44c  :=0xffff0000
##@@@F_:Canfd_LL_SetPNTimeoutValue():
##@@@P_:kf32a13k_drv_canfd.h:1865
##@@@L1860_: * @return void   
##@@@L1861_: */   
##@@@L1862_:KF_INLINE void Canfd_LL_SetPNTimeoutValue(CanfdPtr Module, uint16_t Timeout)   
##@@@L1863_:{   
##@@@L1864_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1865_:    REG_WRITE(Module->CANFD_CTRL2_PN.bits.MATCHTO, Timeout);   
8000d22a:	8a 44       	LD        R4, [PC + #138]       ;->0x8000d450  :=0xb04
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1471
##@@@L1470_:                         PnConfigPtr->filterComb, PnConfigPtr->idFilterType, PnConfigPtr->payloadFilterType);   
##@@@L1471_:    Canfd_LL_SetPNTimeoutValue(Module, PnConfigPtr->matchTimeout);   
8000d22c:	99 a8       	LD.H      R3, [R1 + #2]
##@@@F_:Canfd_LL_SetPNTimeoutValue():
##@@@P_:kf32a13k_drv_canfd.h:1865
8000d22e:	10 e9       	LD.W      R2, [R0 + R4]
8000d230:	25 69       	ANL       R2, R5
8000d232:	23 6a       	ORL       R2, R3
8000d234:	02 ef       	ST.W      [R0 + R4], R2
8000d236:	88 44       	LD        R4, [PC + #136]       ;->0x8000d454  :=0xbfffffff
##@@@F_:Canfd_LL_SetPNExtendEnabled():
##@@@P_:kf32a13k_drv_canfd.h:1899
##@@@L1894_: * @return void   
##@@@L1895_: */   
##@@@L1896_:KF_INLINE void Canfd_LL_SetPNExtendEnabled(CanfdPtr Module, const bool IsExtended)   
##@@@L1897_:{   
##@@@L1898_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1899_:    REG_WRITE(Module->CANFD_FLT_ID1.bits.FLT_IDE, IsExtended);   
8000d238:	88 42       	LD        R2, [PC + #136]       ;->0x8000d458  :=0xb0c
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1473
##@@@L1472_:    /* Configure ID filtering */   
##@@@L1473_:    Canfd_LL_SetPNIdFilter1(Module, PnConfigPtr->idFilter1);   
8000d23a:	d9 98       	LD.W      R3, [R1 + #3]
8000d23c:	06 21       	ST.W      [SP + #6], R1
8000d23e:	09 99       	LD.W      R1, [R1 + #4]
8000d240:	81 10       	MOV       R8, #1			;->0x0001
##@@@F_:Canfd_LL_SetPNIdFilter1():
##@@@P_:kf32a13k_drv_canfd.c:420
##@@@L0415_: * @param[in] IdFilter 滤波器1 ID参数   
##@@@L0416_: * @return void   
##@@@L0417_: */   
##@@@L0418_:void Canfd_LL_SetPNIdFilter1(CanfdPtr Module, Canfd_PnIdFilter_t IdFilter)   
##@@@L0419_:{   
##@@@L0420_:    Canfd_LL_SetPNExtendEnabled(Module, IdFilter.extendedId);   
8000d242:	a3 58       	MOV       R5, R3
8000d244:	58 69       	ANL       R5, R8
##@@@F_:Canfd_LL_SetPNExtendEnabled():
##@@@P_:kf32a13k_drv_canfd.h:1899
8000d246:	b0 e8       	LD.W      R6, [R0 + R2]
8000d248:	85 47       	LD        R7, [PC + #133]       ;->0x8000d45c  :=0x1fffffff
8000d24a:	07 27       	ST.W      [SP + #7], R7
8000d24c:	85 47       	LD        R7, [PC + #133]       ;->0x8000d460  :=0x1ffc0000
8000d24e:	05 24       	ST.W      [SP + #5], R4
8000d250:	64 69       	ANL       R6, R4
##@@@F_:Canfd_LL_SetPNIdFilter1():
##@@@P_:kf32a13k_drv_canfd.c:422
##@@@L0421_:    Canfd_LL_SetPNRemoteEnabled(Module, IdFilter.remoteFrame);   
##@@@L0422_:    if (IdFilter.extendedId)   
8000d252:	04 27       	ST.W      [SP + #4], R7
8000d254:	50 38       	CMP       R5, #0			;->0x00
8000d256:	04 f0       	JZ        $+4                   ;->0x8000d25e
8000d258:	07 0c       	LD.W      R4, [SP + #7]
8000d25a:	14 69       	ANL       R1, R4
8000d25c:	04 04       	SJMP      $+4                   ;->0x8000d264
8000d25e:	0a 7b       	LSL       R1, #18			;->0x12
8000d260:	17 69       	ANL       R1, R7
8000d262:	07 0c       	LD.W      R4, [SP + #7]
##@@@F_:Canfd_LL_SetPNExtendEnabled():
##@@@P_:kf32a13k_drv_canfd.h:1899
8000d264:	ae 7b       	LSL       R5, #30			;->0x1E
8000d266:	65 6a       	ORL       R6, R5
8000d268:	86 ee       	ST.W      [R0 + R2], R6
##@@@F_:Canfd_LL_SetPNRemoteEnabled():
##@@@P_:kf32a13k_drv_canfd.h:1910
##@@@L1905_: * @return void   
##@@@L1906_: */   
##@@@L1907_:KF_INLINE void Canfd_LL_SetPNRemoteEnabled(CanfdPtr Module, const bool IsRemote)   
##@@@L1908_:{   
##@@@L1909_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1910_:    REG_WRITE(Module->CANFD_FLT_ID1.bits.FLT_RTR, IsRemote);   
8000d26a:	1d 7b       	LSL       R3, #21			;->0x15
8000d26c:	7e 46       	LD        R6, [PC + #126]       ;->0x8000d464  :=0x20000000
8000d26e:	7f 47       	LD        R7, [PC + #127]       ;->0x8000d468  :=0xdfffffff
8000d270:	a8 e8       	LD.W      R5, [R0 + R2]
8000d272:	36 69       	ANL       R3, R6
8000d274:	57 69       	ANL       R5, R7
8000d276:	53 6a       	ORL       R5, R3
8000d278:	85 ee       	ST.W      [R0 + R2], R5
8000d27a:	7d 43       	LD        R3, [PC + #125]       ;->0x8000d46c  :=0xe0000000
##@@@F_:Canfd_LL_SetPNIdFilter1():
8000d27c:	a8 e8       	LD.W      R5, [R0 + R2]
8000d27e:	53 69       	ANL       R5, R3
8000d280:	51 6a       	ORL       R5, R1
8000d282:	85 ee       	ST.W      [R0 + R2], R5
8000d284:	06 09       	LD.W      R1, [SP + #6]
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1475
##@@@L1470_:                         PnConfigPtr->filterComb, PnConfigPtr->idFilterType, PnConfigPtr->payloadFilterType);   
##@@@L1471_:    Canfd_LL_SetPNTimeoutValue(Module, PnConfigPtr->matchTimeout);   
##@@@L1472_:    /* Configure ID filtering */   
##@@@L1473_:    Canfd_LL_SetPNIdFilter1(Module, PnConfigPtr->idFilter1);   
##@@@L1474_:    /* Configure the second ID, if needed (as mask for exact matching or higher limit for range matching) */   
##@@@L1475_:    if ((PnConfigPtr->idFilterType == CANFD_FILTER_MATCH_EXACT) ||   
8000d286:	e9 99       	LD.W      R5, [R1 + #7]
8000d288:	53 38       	CMP       R5, #3			;->0x03
8000d28a:	03 f0       	JZ        $+3                   ;->0x8000d290
8000d28c:	50 38       	CMP       R5, #0			;->0x00
8000d28e:	10 f1       	JNZ       $+16                  ;->0x8000d2ae
8000d290:	01 23       	ST.W      [SP + #1], R3
8000d292:	02 27       	ST.W      [SP + #2], R7
8000d294:	03 26       	ST.W      [SP + #3], R6
##@@@P_:kf32a13k_drv_canfd.c:1478
##@@@L1476_:        (PnConfigPtr->idFilterType == CANFD_FILTER_MATCH_RANGE))   
##@@@L1477_:    {   
##@@@L1478_:        Canfd_LL_SetPNIdFilter2(Module, PnConfigPtr->idFilter2);   
8000d296:	69 99       	LD.W      R5, [R1 + #5]
##@@@F_:Canfd_LL_SetPNExtendMask():
##@@@P_:kf32a13k_drv_canfd.h:1943
##@@@L1938_: * @return void   
##@@@L1939_: */   
##@@@L1940_:KF_INLINE void Canfd_LL_SetPNExtendMask(CanfdPtr Module, const bool ExtendedMask)   
##@@@L1941_:{   
##@@@L1942_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1943_:    REG_WRITE(Module->CANFD_FLT_ID2_IDMASK.bits.IDE_MSK, ExtendedMask);   
8000d298:	76 44       	LD        R4, [PC + #118]       ;->0x8000d470  :=0xb1c
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1478
8000d29a:	91 99       	LD.W      R2, [R1 + #6]
##@@@F_:Canfd_LL_SetPNExtendMask():
##@@@P_:kf32a13k_drv_canfd.h:1943
8000d29c:	38 e9       	LD.W      R7, [R0 + R4]
##@@@F_:Canfd_LL_SetPNIdFilter2():
##@@@P_:kf32a13k_drv_canfd.c:453
##@@@L0448_: * @param[in] IdFilter 滤波器2 ID参数   
##@@@L0449_: * @return void   
##@@@L0450_: */   
##@@@L0451_:void Canfd_LL_SetPNIdFilter2(CanfdPtr Module, Canfd_PnIdFilter_t IdFilter)   
##@@@L0452_:{   
##@@@L0453_:    Canfd_LL_SetPNExtendMask(Module, IdFilter.extendedId);   
8000d29e:	c5 58       	MOV       R6, R5
8000d2a0:	68 69       	ANL       R6, R8
##@@@F_:Canfd_LL_SetPNExtendMask():
##@@@P_:kf32a13k_drv_canfd.h:1943
8000d2a2:	05 0b       	LD.W      R3, [SP + #5]
8000d2a4:	73 69       	ANL       R7, R3
##@@@F_:Canfd_LL_SetPNIdFilter2():
##@@@P_:kf32a13k_drv_canfd.c:455
##@@@L0454_:    Canfd_LL_SetPNRemoteMask(Module, IdFilter.remoteFrame);   
##@@@L0455_:    if (IdFilter.extendedId)   
8000d2a6:	60 38       	CMP       R6, #0			;->0x00
8000d2a8:	09 f0       	JZ        $+9                   ;->0x8000d2ba
##@@@F_:Canfd_LL_ConfigPN():
8000d2aa:	07 0b       	LD.W      R3, [SP + #7]
8000d2ac:	09 04       	SJMP      $+9                   ;->0x8000d2be
##@@@F_:Canfd_LL_GetPNMask():
##@@@P_:kf32a13k_drv_canfd.h:1987
##@@@L1982_: * @return uint32_t   
##@@@L1983_: */   
##@@@L1984_:KF_INLINE uint32_t Canfd_LL_GetPNMask(CanfdPtr Module)   
##@@@L1985_:{   
##@@@L1986_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1987_:    return (REG_READ(Module->CANFD_FLT_ID2_IDMASK.reg));   
8000d2ae:	71 45       	LD        R5, [PC + #113]       ;->0x8000d470  :=0xb1c
8000d2b0:	60 e9       	LD.W      R4, [R0 + R5]
8000d2b2:	71 43       	LD        R3, [PC + #113]       ;->0x8000d474  :=0x60000000
##@@@F_:Canfd_LL_SetPNIdFilter2Check():
##@@@P_:kf32a13k_drv_canfd.c:441
##@@@L0436_: */   
##@@@L0437_:void Canfd_LL_SetPNIdFilter2Check(CanfdPtr Module)   
##@@@L0438_:{   
##@@@L0439_:    uint32_t temp = 0U;   
##@@@L0440_:    temp          = CAN_FLT_ID2_IDMASK_IDE_MSK_MASK | CAN_FLT_ID2_IDMASK_RTR_MSK_MASK;   
##@@@L0441_:    temp          = Canfd_LL_GetPNMask(Module) | temp;   
8000d2b4:	43 6a       	ORL       R4, R3
##@@@F_:Canfd_LL_SetPNMask():
##@@@P_:kf32a13k_drv_canfd.h:1998
##@@@L1993_: * @return void   
##@@@L1994_: */   
##@@@L1995_:KF_INLINE void Canfd_LL_SetPNMask(CanfdPtr Module, const uint32_t Mask)   
##@@@L1996_:{   
##@@@L1997_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1998_:    REG_WRITE(Module->CANFD_FLT_ID2_IDMASK.reg, Mask);   
8000d2b6:	44 ef       	ST.W      [R0 + R5], R4
8000d2b8:	14 04       	SJMP      $+20                  ;->0x8000d2e0
##@@@F_:Canfd_LL_ConfigPN():
8000d2ba:	12 7b       	LSL       R2, #18			;->0x12
8000d2bc:	04 0b       	LD.W      R3, [SP + #4]
8000d2be:	23 69       	ANL       R2, R3
##@@@F_:Canfd_LL_SetPNExtendMask():
##@@@P_:kf32a13k_drv_canfd.h:1943
##@@@L1938_: * @return void   
##@@@L1939_: */   
##@@@L1940_:KF_INLINE void Canfd_LL_SetPNExtendMask(CanfdPtr Module, const bool ExtendedMask)   
##@@@L1941_:{   
##@@@L1942_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1943_:    REG_WRITE(Module->CANFD_FLT_ID2_IDMASK.bits.IDE_MSK, ExtendedMask);   
8000d2c0:	b6 7b       	LSL       R6, #30			;->0x1E
8000d2c2:	76 6a       	ORL       R7, R6
8000d2c4:	07 ef       	ST.W      [R0 + R4], R7
##@@@F_:Canfd_LL_SetPNRemoteMask():
##@@@P_:kf32a13k_drv_canfd.h:1954
##@@@L1949_: * @return void   
##@@@L1950_: */   
##@@@L1951_:KF_INLINE void Canfd_LL_SetPNRemoteMask(CanfdPtr Module, const bool RemoteMask)   
##@@@L1952_:{   
##@@@L1953_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L1954_:    REG_WRITE(Module->CANFD_FLT_ID2_IDMASK.bits.RTR_MSK, RemoteMask);   
8000d2c6:	2d 7b       	LSL       R5, #21			;->0x15
8000d2c8:	30 e9       	LD.W      R6, [R0 + R4]
8000d2ca:	03 0b       	LD.W      R3, [SP + #3]
8000d2cc:	53 69       	ANL       R5, R3
8000d2ce:	02 0b       	LD.W      R3, [SP + #2]
8000d2d0:	63 69       	ANL       R6, R3
8000d2d2:	65 6a       	ORL       R6, R5
8000d2d4:	06 ef       	ST.W      [R0 + R4], R6
##@@@F_:Canfd_LL_SetPNIdFilter2():
8000d2d6:	28 e9       	LD.W      R5, [R0 + R4]
8000d2d8:	01 0b       	LD.W      R3, [SP + #1]
8000d2da:	53 69       	ANL       R5, R3
8000d2dc:	52 6a       	ORL       R5, R2
8000d2de:	05 ef       	ST.W      [R0 + R4], R5
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1486
##@@@L1481_:    {   
##@@@L1482_:        /* In other case need only to check the IDE and RTR match the ID_MASK is not considered */   
##@@@L1483_:        Canfd_LL_SetPNIdFilter2Check(Module);   
##@@@L1484_:    }   
##@@@L1485_:    /* Configure payload filtering, if requested */   
##@@@L1486_:    if ((PnConfigPtr->filterComb == CANFD_FILTER_ID_PAYLOAD) ||   
8000d2e0:	a9 98       	LD.W      R5, [R1 + #2]
8000d2e2:	42 10       	MOV       R4, #2			;->0x0002
8000d2e4:	54 6a       	ORL       R5, R4
8000d2e6:	53 38       	CMP       R5, #3			;->0x03
8000d2e8:	02 f0       	JZ        $+2                   ;->0x8000d2ec
8000d2ea:	9e 04       	SJMP      $+158                 ;->0x8000d426
##@@@F_:Canfd_LL_SetPNDlcFilter():
8000d2ec:	50 00 25 90 	LD.B      R5, [R1 + #36]			;->0x24
##@@@P_:kf32a13k_drv_canfd.c:474
##@@@L0469_: * @param[in] DlcHigh DLC上限   
##@@@L0470_: * @return void   
##@@@L0471_: */   
##@@@L0472_:void Canfd_LL_SetPNDlcFilter(CanfdPtr Module, uint8_t DlcLow, uint8_t DlcHigh)   
##@@@L0473_:{   
##@@@L0474_:    Canfd_LL_SetPNLowDLC(Module, DlcLow);   
8000d2f0:	45 62       	SXT.B     R4, R5
##@@@F_:Canfd_LL_SetPNLowDLC():
##@@@P_:kf32a13k_drv_canfd.h:2009
##@@@L2004_: * @return void   
##@@@L2005_: */   
##@@@L2006_:KF_INLINE void Canfd_LL_SetPNLowDLC(CanfdPtr Module, const uint32_t LowDLC)   
##@@@L2007_:{   
##@@@L2008_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2009_:    REG_WRITE(Module->CANFD_FLT_DLC.bits.FLT_DLC_LO, LowDLC);   
8000d2f2:	20 7b       	LSL       R4, #16			;->0x10
8000d2f4:	61 43       	LD        R3, [PC + #97]        ;->0x8000d478  :=0xf0000
8000d2f6:	62 45       	LD        R5, [PC + #98]        ;->0x8000d47c  :=0xb10
##@@@F_:Canfd_LL_ConfigPN():
8000d2f8:	50 00 22 94 	LD.B      R2, [R1 + #37]			;->0x25
##@@@F_:Canfd_LL_SetPNLowDLC():
8000d2fc:	70 e9       	LD.W      R6, [R0 + R5]
8000d2fe:	61 47       	LD        R7, [PC + #97]        ;->0x8000d480  :=0xfff0ffff
8000d300:	43 69       	ANL       R4, R3
8000d302:	67 69       	ANL       R6, R7
8000d304:	64 6a       	ORL       R6, R4
8000d306:	46 ef       	ST.W      [R0 + R5], R6
8000d308:	4f 10       	MOV       R4, #15			;->0x000F
8000d30a:	5f 43       	LD        R3, [PC + #95]        ;->0x8000d484  :=0xfffffff0
##@@@F_:Canfd_LL_SetPNHighDLC():
##@@@P_:kf32a13k_drv_canfd.h:2020
##@@@L2015_: * @return void   
##@@@L2016_: */   
##@@@L2017_:KF_INLINE void Canfd_LL_SetPNHighDLC(CanfdPtr Module, const uint32_t HighDLC)   
##@@@L2018_:{   
##@@@L2019_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2020_:    REG_WRITE(Module->CANFD_FLT_DLC.bits.FLT_DLC_HI, HighDLC);   
8000d30c:	70 e9       	LD.W      R6, [R0 + R5]
8000d30e:	24 69       	ANL       R2, R4
8000d310:	63 69       	ANL       R6, R3
8000d312:	62 6a       	ORL       R6, R2
8000d314:	46 ef       	ST.W      [R0 + R5], R6
##@@@F_:Canfd_LL_SetPNHighPayLoadByte4():
8000d316:	50 00 25 a8 	LD.B      R5, [R1 + #42]			;->0x2A
##@@@P_:kf32a13k_drv_canfd.h:2075
##@@@L2070_: * @return void   
##@@@L2071_: */   
##@@@L2072_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte4(CanfdPtr Module, const uint8_t Data)   
##@@@L2073_:{   
##@@@L2074_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2075_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_4, Data);   
8000d31a:	45 62       	SXT.B     R4, R5
8000d31c:	5b 45       	LD        R5, [PC + #91]        ;->0x8000d488  :=0xb18
8000d31e:	5c 43       	LD        R3, [PC + #92]        ;->0x8000d48c  :=0xffffff
8000d320:	50 e9       	LD.W      R2, [R0 + R5]
8000d322:	23 69       	ANL       R2, R3
8000d324:	a0 7b       	LSL       R4, #24			;->0x18
8000d326:	24 6a       	ORL       R2, R4
8000d328:	42 ef       	ST.W      [R0 + R5], R2
8000d32a:	5a 44       	LD        R4, [PC + #90]        ;->0x8000d490  :=0xff00ffff
##@@@F_:Canfd_LL_SetPNPayloadHighFilter1():
8000d32c:	50 00 22 ac 	LD.B      R2, [R1 + #43]			;->0x2B
##@@@F_:Canfd_LL_SetPNHighPayLoadByte5():
##@@@P_:kf32a13k_drv_canfd.h:2086
##@@@L2081_: * @return void   
##@@@L2082_: */   
##@@@L2083_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte5(CanfdPtr Module, const uint8_t Data)   
##@@@L2084_:{   
##@@@L2085_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2086_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_5, Data);   
8000d330:	70 e9       	LD.W      R6, [R0 + R5]
8000d332:	64 69       	ANL       R6, R4
8000d334:	10 7b       	LSL       R2, #16			;->0x10
8000d336:	62 6a       	ORL       R6, R2
8000d338:	46 ef       	ST.W      [R0 + R5], R6
##@@@F_:Canfd_LL_SetPNPayloadHighFilter1():
8000d33a:	50 00 22 b0 	LD.B      R2, [R1 + #44]			;->0x2C
##@@@F_:Canfd_LL_SetPNHighPayLoadByte6():
##@@@P_:kf32a13k_drv_canfd.h:2097
##@@@L2092_: * @return void   
##@@@L2093_: */   
##@@@L2094_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte6(CanfdPtr Module, const uint8_t Data)   
##@@@L2095_:{   
##@@@L2096_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2097_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_6, Data);   
8000d33e:	70 e9       	LD.W      R6, [R0 + R5]
8000d340:	08 0f       	LD.W      R7, [SP + #8]
8000d342:	67 69       	ANL       R6, R7
8000d344:	90 7a       	LSL       R2, #8			;->0x08
8000d346:	62 6a       	ORL       R6, R2
8000d348:	46 ef       	ST.W      [R0 + R5], R6
8000d34a:	53 42       	LD        R2, [PC + #83]        ;->0x8000d494  :=0xffffff00
##@@@F_:Canfd_LL_SetPNPayloadHighFilter1():
8000d34c:	50 00 26 b4 	LD.B      R6, [R1 + #45]			;->0x2D
##@@@F_:Canfd_LL_SetPNHighPayLoadByte7():
##@@@P_:kf32a13k_drv_canfd.h:2108
##@@@L2103_: * @return void   
##@@@L2104_: */   
##@@@L2105_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte7(CanfdPtr Module, const uint8_t Data)   
##@@@L2106_:{   
##@@@L2107_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2108_:    REG_WRITE(Module->CANFD_PL1_HI.bits.DATA_BYTE_7, Data);   
8000d350:	78 e9       	LD.W      R7, [R0 + R5]
8000d352:	72 69       	ANL       R7, R2
8000d354:	76 6a       	ORL       R7, R6
8000d356:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNLowPayLoadByte0():
8000d358:	50 00 26 98 	LD.B      R6, [R1 + #38]			;->0x26
##@@@P_:kf32a13k_drv_canfd.h:2031
##@@@L2026_: * @return void   
##@@@L2027_: */   
##@@@L2028_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte0(CanfdPtr Module, const uint8_t Data)   
##@@@L2029_:{   
##@@@L2030_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2031_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_0, Data);   
8000d35c:	4f 45       	LD        R5, [PC + #79]        ;->0x8000d498  :=0xb14
8000d35e:	66 62       	SXT.B     R6, R6
8000d360:	78 e9       	LD.W      R7, [R0 + R5]
8000d362:	04 23       	ST.W      [SP + #4], R3
8000d364:	73 69       	ANL       R7, R3
8000d366:	b0 7b       	LSL       R6, #24			;->0x18
8000d368:	76 6a       	ORL       R7, R6
8000d36a:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNPayloadLowFilter1():
8000d36c:	50 00 26 9c 	LD.B      R6, [R1 + #39]			;->0x27
##@@@F_:Canfd_LL_SetPNLowPayLoadByte1():
##@@@P_:kf32a13k_drv_canfd.h:2042
##@@@L2037_: * @return void   
##@@@L2038_: */   
##@@@L2039_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte1(CanfdPtr Module, const uint8_t Data)   
##@@@L2040_:{   
##@@@L2041_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2042_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_1, Data);   
8000d370:	78 e9       	LD.W      R7, [R0 + R5]
8000d372:	05 24       	ST.W      [SP + #5], R4
8000d374:	74 69       	ANL       R7, R4
8000d376:	30 7b       	LSL       R6, #16			;->0x10
8000d378:	76 6a       	ORL       R7, R6
8000d37a:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNPayloadLowFilter1():
8000d37c:	50 00 26 a0 	LD.B      R6, [R1 + #40]			;->0x28
##@@@F_:Canfd_LL_SetPNLowPayLoadByte2():
##@@@P_:kf32a13k_drv_canfd.h:2053
##@@@L2048_: * @return void   
##@@@L2049_: */   
##@@@L2050_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte2(CanfdPtr Module, const uint8_t Data)   
##@@@L2051_:{   
##@@@L2052_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2053_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_2, Data);   
8000d380:	78 e9       	LD.W      R7, [R0 + R5]
8000d382:	08 0c       	LD.W      R4, [SP + #8]
8000d384:	74 69       	ANL       R7, R4
8000d386:	b0 7a       	LSL       R6, #8			;->0x08
8000d388:	76 6a       	ORL       R7, R6
8000d38a:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNPayloadLowFilter1():
8000d38c:	50 00 26 a4 	LD.B      R6, [R1 + #41]			;->0x29
##@@@F_:Canfd_LL_SetPNLowPayLoadByte3():
##@@@P_:kf32a13k_drv_canfd.h:2064
##@@@L2059_: * @return void   
##@@@L2060_: */   
##@@@L2061_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte3(CanfdPtr Module, const uint8_t Data)   
##@@@L2062_:{   
##@@@L2063_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2064_:    REG_WRITE(Module->CANFD_PL1_LO.bits.DATA_BYTE_3, Data);   
8000d390:	78 e9       	LD.W      R7, [R0 + R5]
8000d392:	07 22       	ST.W      [SP + #7], R2
8000d394:	72 69       	ANL       R7, R2
8000d396:	76 6a       	ORL       R7, R6
8000d398:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1493
##@@@L1488_:    {   
##@@@L1489_:        Canfd_LL_SetPNDlcFilter(Module, PnConfigPtr->payloadFilter.dlcLow, PnConfigPtr->payloadFilter.dlcHigh);   
##@@@L1490_:        Canfd_LL_SetPNPayloadHighFilter1(Module, PnConfigPtr->payloadFilter.payload1);   
##@@@L1491_:        Canfd_LL_SetPNPayloadLowFilter1(Module, PnConfigPtr->payloadFilter.payload1);   
##@@@L1492_:        /* Configure the second payload, if needed (as mask for exact matching or higher limit for range matching) */   
##@@@L1493_:        if ((PnConfigPtr->payloadFilterType == CANFD_FILTER_MATCH_EXACT) ||   
8000d39a:	29 9a       	LD.W      R5, [R1 + #8]
8000d39c:	53 38       	CMP       R5, #3			;->0x03
8000d39e:	04 f0       	JZ        $+4                   ;->0x8000d3a6
8000d3a0:	50 38       	CMP       R5, #0			;->0x00
8000d3a2:	02 f0       	JZ        $+2                   ;->0x8000d3a6
8000d3a4:	41 04       	SJMP      $+65                  ;->0x8000d426
##@@@F_:Canfd_LL_SetPNHighPayLoadByte4Mask():
8000d3a6:	50 00 26 c8 	LD.B      R6, [R1 + #50]			;->0x32
##@@@P_:kf32a13k_drv_canfd.h:2163
##@@@L2158_: * @return void   
##@@@L2159_: */   
##@@@L2160_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte4Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2161_:{   
##@@@L2162_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2163_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_4, Data);   
8000d3aa:	3d 45       	LD        R5, [PC + #61]        ;->0x8000d49c  :=0xb24
8000d3ac:	66 62       	SXT.B     R6, R6
8000d3ae:	78 e9       	LD.W      R7, [R0 + R5]
8000d3b0:	04 0b       	LD.W      R3, [SP + #4]
8000d3b2:	73 69       	ANL       R7, R3
8000d3b4:	b0 7b       	LSL       R6, #24			;->0x18
8000d3b6:	76 6a       	ORL       R7, R6
8000d3b8:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNPayloadHighFilter2():
8000d3ba:	50 00 26 cc 	LD.B      R6, [R1 + #51]			;->0x33
##@@@F_:Canfd_LL_SetPNHighPayLoadByte5Mask():
##@@@P_:kf32a13k_drv_canfd.h:2174
##@@@L2169_: * @return void   
##@@@L2170_: */   
##@@@L2171_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte5Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2172_:{   
##@@@L2173_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2174_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_5, Data);   
8000d3be:	78 e9       	LD.W      R7, [R0 + R5]
8000d3c0:	05 0c       	LD.W      R4, [SP + #5]
8000d3c2:	74 69       	ANL       R7, R4
8000d3c4:	30 7b       	LSL       R6, #16			;->0x10
8000d3c6:	76 6a       	ORL       R7, R6
8000d3c8:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNPayloadHighFilter2():
8000d3ca:	50 00 26 d0 	LD.B      R6, [R1 + #52]			;->0x34
##@@@F_:Canfd_LL_SetPNHighPayLoadByte6Mask():
##@@@P_:kf32a13k_drv_canfd.h:2185
##@@@L2180_: * @return void   
##@@@L2181_: */   
##@@@L2182_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte6Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2183_:{   
##@@@L2184_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2185_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_6, Data);   
8000d3ce:	78 e9       	LD.W      R7, [R0 + R5]
8000d3d0:	08 0a       	LD.W      R2, [SP + #8]
8000d3d2:	72 69       	ANL       R7, R2
8000d3d4:	b0 7a       	LSL       R6, #8			;->0x08
8000d3d6:	76 6a       	ORL       R7, R6
8000d3d8:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNPayloadHighFilter2():
8000d3da:	50 00 26 d4 	LD.B      R6, [R1 + #53]			;->0x35
##@@@F_:Canfd_LL_SetPNHighPayLoadByte7Mask():
##@@@P_:kf32a13k_drv_canfd.h:2196
##@@@L2191_: * @return void   
##@@@L2192_: */   
##@@@L2193_:KF_INLINE void Canfd_LL_SetPNHighPayLoadByte7Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2194_:{   
##@@@L2195_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2196_:    REG_WRITE(Module->CANFD_PL2_PLMASK_HI.bits.DATA_BYTE_7, Data);   
8000d3de:	78 e9       	LD.W      R7, [R0 + R5]
8000d3e0:	07 0c       	LD.W      R4, [SP + #7]
8000d3e2:	74 69       	ANL       R7, R4
8000d3e4:	76 6a       	ORL       R7, R6
8000d3e6:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNLowPayLoadByte0Mask():
8000d3e8:	50 00 26 b8 	LD.B      R6, [R1 + #46]			;->0x2E
##@@@P_:kf32a13k_drv_canfd.h:2119
##@@@L2114_: * @return void   
##@@@L2115_: */   
##@@@L2116_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte0Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2117_:{   
##@@@L2118_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2119_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_0, Data);   
8000d3ec:	2d 45       	LD        R5, [PC + #45]        ;->0x8000d4a0  :=0xb20
8000d3ee:	66 62       	SXT.B     R6, R6
8000d3f0:	78 e9       	LD.W      R7, [R0 + R5]
8000d3f2:	73 69       	ANL       R7, R3
8000d3f4:	b0 7b       	LSL       R6, #24			;->0x18
8000d3f6:	76 6a       	ORL       R7, R6
8000d3f8:	47 ef       	ST.W      [R0 + R5], R7
##@@@F_:Canfd_LL_SetPNPayloadLowFilter2():
8000d3fa:	50 00 23 bc 	LD.B      R3, [R1 + #47]			;->0x2F
##@@@F_:Canfd_LL_SetPNLowPayLoadByte1Mask():
##@@@P_:kf32a13k_drv_canfd.h:2130
##@@@L2125_: * @return void   
##@@@L2126_: */   
##@@@L2127_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte1Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2128_:{   
##@@@L2129_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2130_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_1, Data);   
8000d3fe:	70 e9       	LD.W      R6, [R0 + R5]
8000d400:	05 0c       	LD.W      R4, [SP + #5]
8000d402:	64 69       	ANL       R6, R4
8000d404:	18 7b       	LSL       R3, #16			;->0x10
8000d406:	63 6a       	ORL       R6, R3
8000d408:	46 ef       	ST.W      [R0 + R5], R6
##@@@F_:Canfd_LL_SetPNPayloadLowFilter2():
8000d40a:	50 00 24 c0 	LD.B      R4, [R1 + #48]			;->0x30
##@@@F_:Canfd_LL_SetPNLowPayLoadByte2Mask():
##@@@P_:kf32a13k_drv_canfd.h:2141
##@@@L2136_: * @return void   
##@@@L2137_: */   
##@@@L2138_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte2Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2139_:{   
##@@@L2140_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2141_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_2, Data);   
8000d40e:	58 e9       	LD.W      R3, [R0 + R5]
8000d410:	32 69       	ANL       R3, R2
8000d412:	a0 7a       	LSL       R4, #8			;->0x08
8000d414:	34 6a       	ORL       R3, R4
8000d416:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_SetPNPayloadLowFilter2():
8000d418:	50 00 24 c4 	LD.B      R4, [R1 + #49]			;->0x31
##@@@F_:Canfd_LL_SetPNLowPayLoadByte3Mask():
##@@@P_:kf32a13k_drv_canfd.h:2152
##@@@L2147_: * @return void   
##@@@L2148_: */   
##@@@L2149_:KF_INLINE void Canfd_LL_SetPNLowPayLoadByte3Mask(CanfdPtr Module, const uint8_t Data)   
##@@@L2150_:{   
##@@@L2151_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2152_:    REG_WRITE(Module->CANFD_PL2_PLMASK_LO.bits.DATA_BYTE_3, Data);   
8000d41c:	58 e9       	LD.W      R3, [R0 + R5]
8000d41e:	07 0a       	LD.W      R2, [SP + #7]
8000d420:	32 69       	ANL       R3, R2
8000d422:	34 6a       	ORL       R3, R4
8000d424:	43 ef       	ST.W      [R0 + R5], R3
##@@@F_:Canfd_LL_ConfigPN():
##@@@P_:kf32a13k_drv_canfd.c:1500
##@@@L1495_:        {   
##@@@L1496_:            Canfd_LL_SetPNPayloadHighFilter2(Module, PnConfigPtr->payloadFilter.payload2);   
##@@@L1497_:            Canfd_LL_SetPNPayloadLowFilter2(Module, PnConfigPtr->payloadFilter.payload2);   
##@@@L1498_:        }   
##@@@L1499_:    }   
##@@@L1500_:}   
8000d426:	e4 2a       	ADD       SP, #36			;->0x24
8000d428:	07 5e       	POP       {R6-R8}
8000d42a:	1d 5c       	JMP       LR
8000d42c:	00 0b 00 00 	.long     0x00000b00 ->000002816  [!!!@2@:LD.W      R3, [SP + #0]	@@: NOP      
8000d430:	ff ff fd ff 	.long     0xfffdffff ->-00131073 
8000d434:	ff ff fe ff 	.long     0xfffeffff ->-00065537 
8000d438:	00 ff 00 00 	.long     0x0000ff00 ->000065280 
8000d43c:	ff 00 ff ff 	.long     0xffff00ff ->-00065281 
8000d440:	fc ff ff ff 	.long     0xfffffffc ->-00000004 
8000d444:	f3 ff ff ff 	.long     0xfffffff3 ->-00000013 
8000d448:	cf ff ff ff 	.long     0xffffffcf ->-00000049 
8000d44c:	00 00 ff ff 	.long     0xffff0000 ->-00065536 
8000d450:	04 0b 00 00 	.long     0x00000b04 ->000002820  [!!!@2@:LD.W      R3, [SP + #4]	@@: NOP      
8000d454:	ff ff ff bf 	.long     0xbfffffff ->-1073741825 
8000d458:	0c 0b 00 00 	.long     0x00000b0c ->000002828  [!!!@2@:LD.W      R3, [SP + #12]	@@: NOP      
8000d45c:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000d460:	00 00 fc 1f 	.long     0x1ffc0000 ->536608768  [!!!@2@:NOP      	@@: MOV       PC, #252
8000d464:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000d468:	ff ff ff df 	.long     0xdfffffff ->-536870913 
8000d46c:	00 00 00 e0 	.long     0xe0000000 ->-536870912  [!!!@2@:NOP      	@@: LD.H      R0, [SP + #0]
8000d470:	1c 0b 00 00 	.long     0x00000b1c ->000002844  [!!!@2@:LD.W      R3, [SP + #28]	@@: NOP      
8000d474:	00 00 00 60 	.long     0x60000000 ->1610612736  [!!!@2@:NOP      	@@: REV       R0, R0
8000d478:	00 00 0f 00 	.long     0x000f0000 ->000983040 
8000d47c:	10 0b 00 00 	.long     0x00000b10 ->000002832  [!!!@2@:LD.W      R3, [SP + #16]	@@: NOP      
8000d480:	ff ff f0 ff 	.long     0xfff0ffff ->-00983041 
8000d484:	f0 ff ff ff 	.long     0xfffffff0 ->-00000016 
8000d488:	18 0b 00 00 	.long     0x00000b18 ->000002840  [!!!@2@:LD.W      R3, [SP + #24]	@@: NOP      
8000d48c:	ff ff ff 00 	.long     0x00ffffff ->016777215 
8000d490:	ff ff 00 ff 	.long     0xff00ffff ->-16711681 
8000d494:	00 ff ff ff 	.long     0xffffff00 ->-00000256 
8000d498:	14 0b 00 00 	.long     0x00000b14 ->000002836  [!!!@2@:LD.W      R3, [SP + #20]	@@: NOP      
8000d49c:	24 0b 00 00 	.long     0x00000b24 ->000002852  [!!!@2@:LD.W      R3, [SP + #36]	@@: NOP      
8000d4a0:	20 0b 00 00 	.long     0x00000b20 ->000002848  [!!!@2@:LD.W      R3, [SP + #32]	@@: NOP      

8000d4a4 <Canfd_LL_DisableMemErrorDetection>:
##@@@F_:Canfd_LL_ErrorCorrectConfigurateEnable():
##@@@P_:kf32a13k_drv_canfd.h:2236
##@@@L2231_: * @retval void   
##@@@L2232_: */   
##@@@L2233_:KF_INLINE void Canfd_LL_ErrorCorrectConfigurateEnable(CanfdPtr Module, const bool Status)   
##@@@L2234_:{   
##@@@L2235_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2236_:    REG_WRITE(Module->CANFD_CTRL2.bits.ECRWRE, Status);   
8000d4a4:	68 9b       	LD.W      R5, [R0 + #13]
8000d4a6:	09 44       	LD        R4, [PC + #9]         ;->0x8000d4c8  :=0x20000000
8000d4a8:	54 6a       	ORL       R5, R4
##@@@F_:Canfd_LL_ErrorCorrectConfigurateWriteDisable():
##@@@P_:kf32a13k_drv_canfd.h:2250
##@@@L2245_: * @retval void   
##@@@L2246_: */   
##@@@L2247_:KF_INLINE void Canfd_LL_ErrorCorrectConfigurateWriteDisable(CanfdPtr Module, const bool Status)   
##@@@L2248_:{   
##@@@L2249_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2250_:    REG_WRITE(Module->CANFD_MECR.bits.ECRWRDIS, Status);   
8000d4aa:	09 44       	LD        R4, [PC + #9]         ;->0x8000d4cc  :=0xae0
##@@@F_:Canfd_LL_ErrorCorrectConfigurateEnable():
##@@@P_:kf32a13k_drv_canfd.h:2236
##@@@L2231_: * @retval void   
##@@@L2232_: */   
##@@@L2233_:KF_INLINE void Canfd_LL_ErrorCorrectConfigurateEnable(CanfdPtr Module, const bool Status)   
##@@@L2234_:{   
##@@@L2235_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2236_:    REG_WRITE(Module->CANFD_CTRL2.bits.ECRWRE, Status);   
8000d4ac:	45 a3       	ST.W      [R0 + #13], R5
##@@@F_:Canfd_LL_ErrorCorrectConfigurateWriteDisable():
##@@@P_:kf32a13k_drv_canfd.h:2250
##@@@L2245_: * @retval void   
##@@@L2246_: */   
##@@@L2247_:KF_INLINE void Canfd_LL_ErrorCorrectConfigurateWriteDisable(CanfdPtr Module, const bool Status)   
##@@@L2248_:{   
##@@@L2249_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2250_:    REG_WRITE(Module->CANFD_MECR.bits.ECRWRDIS, Status);   
8000d4ae:	28 e9       	LD.W      R5, [R0 + R4]
8000d4b0:	08 43       	LD        R3, [PC + #8]         ;->0x8000d4d0  :=0x7fffffff
8000d4b2:	53 69       	ANL       R5, R3
8000d4b4:	05 ef       	ST.W      [R0 + R4], R5
8000d4b6:	08 45       	LD        R5, [PC + #8]         ;->0x8000d4d4  :=0xffffff7f
##@@@F_:Canfd_LL_ErrorCorrectInFreeze():
##@@@P_:kf32a13k_drv_canfd.h:2264
##@@@L2259_: * @retval void   
##@@@L2260_: */   
##@@@L2261_:KF_INLINE void Canfd_LL_ErrorCorrectInFreeze(CanfdPtr Module, const bool Status)   
##@@@L2262_:{   
##@@@L2263_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2264_:    REG_WRITE(Module->CANFD_MECR.bits.NCEFAFRZ, Status);   
8000d4b8:	18 e9       	LD.W      R3, [R0 + R4]
8000d4ba:	35 69       	ANL       R3, R5
8000d4bc:	03 ef       	ST.W      [R0 + R4], R3
8000d4be:	07 45       	LD        R5, [PC + #7]         ;->0x8000d4d8  :=0xdfffffff
##@@@F_:Canfd_LL_ErrorCorrectConfigurateEnable():
##@@@P_:kf32a13k_drv_canfd.h:2236
##@@@L2231_: * @retval void   
##@@@L2232_: */   
##@@@L2233_:KF_INLINE void Canfd_LL_ErrorCorrectConfigurateEnable(CanfdPtr Module, const bool Status)   
##@@@L2234_:{   
##@@@L2235_:    KF_CANFD_ASSERT(CHECK_CANFD_ALL_PERIPH_ADDR(Module));   
##@@@L2236_:    REG_WRITE(Module->CANFD_CTRL2.bits.ECRWRE, Status);   
8000d4c0:	60 9b       	LD.W      R4, [R0 + #13]
8000d4c2:	45 69       	ANL       R4, R5
8000d4c4:	44 a3       	ST.W      [R0 + #13], R4
##@@@F_:Canfd_LL_DisableMemErrorDetection():
##@@@P_:kf32a13k_drv_canfd.c:1514
##@@@L1509_:{   
##@@@L1510_:    Canfd_LL_ErrorCorrectConfigurateEnable(Module, true);   
##@@@L1511_:    Canfd_LL_ErrorCorrectConfigurateWriteDisable(Module, false);   
##@@@L1512_:    Canfd_LL_ErrorCorrectInFreeze(Module, false);   
##@@@L1513_:    Canfd_LL_ErrorCorrectConfigurateEnable(Module, false);   
##@@@L1514_:}   
8000d4c6:	1d 5c       	JMP       LR
8000d4c8:	00 00 00 20 	.long     0x20000000 ->536870912  [!!!@2@:NOP      	@@: ST.W      [SP + #0], R0
8000d4cc:	e0 0a 00 00 	.long     0x00000ae0 ->000002784  [!!!@2@:LD.W      R2, [SP + #224]	@@: NOP      
8000d4d0:	ff ff ff 7f 	.long     0x7fffffff ->2147483647 
8000d4d4:	7f ff ff ff 	.long     0xffffff7f ->-00000129 
8000d4d8:	ff ff ff df 	.long     0xdfffffff ->-536870913 

8000d4dc <kfStdLib_MemSet>:
##@@@F_:kfStdLib_MemSet():
##@@@P_:kfstdlib.c:711
##@@@L0706_: * @param DstPtr   
##@@@L0707_: * @param U8Src   
##@@@L0708_: * @param Length   
##@@@L0709_: */   
##@@@L0710_:void kfStdLib_MemSet(void *DstPtr, uint8_t U8Src, kfStdLib_LengthType Length)   
##@@@L0711_:{   
8000d4dc:	07 5f       	PUSH      {R6-R8}
8000d4de:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kfstdlib.c:717
##@@@L0712_:    KF_STDLIB_ASSERT(DstPtr != NULL_PTR);   
##@@@L0713_:    kfStdLib_LengthType RemainLength = Length;   
##@@@L0714_:#if (KFSTDLIB_RUNTIME_OPTIMIZATION == STD_ON)   
##@@@L0715_:    RemainLength = Length;   
##@@@L0716_:    /*  If less than 32 bytes have to be initialized */   
##@@@L0717_:    if (RemainLength < 32U)   
8000d4e0:	2f 39       	CMP       R2, #31			;->0x1F
8000d4e2:	26 f8       	JHI       $+38                  ;->0x8000d52e
##@@@F_:kfStdLib_MemSet_8bits_31bytes():
##@@@P_:kfstdlib.c:109
##@@@L0104_: */   
##@@@L0105_:KF_FORCE_INLINE void kfStdLib_MemSet_8bits_31bytes(uint8_t *const Dst8Ptr, uint8_t U8Src, uint32_t Length)   
##@@@L0106_:{   
##@@@L0107_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0108_:    /*  Initialize up to 31 bytes using a jump table */   
##@@@L0109_:    switch (Length)   
8000d4e4:	6a cc       	SUB       R5, R2, #1
8000d4e6:	5e 39       	CMP       R5, #30			;->0x1E
8000d4e8:	02 f9       	JLS       $+2                   ;->0x8000d4ec
8000d4ea:	5b 04       	SJMP      $+91                  ;->0x8000d5a0
8000d4ec:	2f 44       	LD        R4, [PC + #47]        ;->0x8000d5a8  :=0x80001264
8000d4ee:	2a 7a       	LSL       R5, #2			;->0x02
8000d4f0:	6c e9       	LD.W      R5, [R4 + R5]
8000d4f2:	15 5c       	JMP       R5
##@@@P_:kfstdlib.c:112
##@@@L0110_:    {   
##@@@L0111_:    case 31U:   
##@@@L0112_:        Dst8Ptr[30] = U8Src;   
8000d4f4:	81 97       	ST.B      [R0 + #30], R1
##@@@P_:kfstdlib.c:115
##@@@L0113_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0114_:    case 30U:   
##@@@L0115_:        Dst8Ptr[29] = U8Src;   
8000d4f6:	41 97       	ST.B      [R0 + #29], R1
##@@@P_:kfstdlib.c:118
##@@@L0116_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0117_:    case 29U:   
##@@@L0118_:        Dst8Ptr[28] = U8Src;   
8000d4f8:	01 97       	ST.B      [R0 + #28], R1
##@@@P_:kfstdlib.c:121
##@@@L0119_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0120_:    case 28U:   
##@@@L0121_:        Dst8Ptr[27] = U8Src;   
8000d4fa:	c1 96       	ST.B      [R0 + #27], R1
##@@@P_:kfstdlib.c:124
##@@@L0122_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0123_:    case 27U:   
##@@@L0124_:        Dst8Ptr[26] = U8Src;   
8000d4fc:	81 96       	ST.B      [R0 + #26], R1
##@@@P_:kfstdlib.c:127
##@@@L0125_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0126_:    case 26U:   
##@@@L0127_:        Dst8Ptr[25] = U8Src;   
8000d4fe:	41 96       	ST.B      [R0 + #25], R1
##@@@P_:kfstdlib.c:130
##@@@L0128_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0129_:    case 25U:   
##@@@L0130_:        Dst8Ptr[24] = U8Src;   
8000d500:	01 96       	ST.B      [R0 + #24], R1
##@@@P_:kfstdlib.c:133
##@@@L0131_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0132_:    case 24U:   
##@@@L0133_:        Dst8Ptr[23] = U8Src;   
8000d502:	c1 95       	ST.B      [R0 + #23], R1
##@@@P_:kfstdlib.c:136
##@@@L0134_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0135_:    case 23U:   
##@@@L0136_:        Dst8Ptr[22] = U8Src;   
8000d504:	81 95       	ST.B      [R0 + #22], R1
##@@@P_:kfstdlib.c:139
##@@@L0137_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0138_:    case 22U:   
##@@@L0139_:        Dst8Ptr[21] = U8Src;   
8000d506:	41 95       	ST.B      [R0 + #21], R1
##@@@P_:kfstdlib.c:142
##@@@L0140_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0141_:    case 21U:   
##@@@L0142_:        Dst8Ptr[20] = U8Src;   
8000d508:	01 95       	ST.B      [R0 + #20], R1
##@@@P_:kfstdlib.c:145
##@@@L0143_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0144_:    case 20U:   
##@@@L0145_:        Dst8Ptr[19] = U8Src;   
8000d50a:	c1 94       	ST.B      [R0 + #19], R1
##@@@P_:kfstdlib.c:148
##@@@L0146_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0147_:    case 19U:   
##@@@L0148_:        Dst8Ptr[18] = U8Src;   
8000d50c:	81 94       	ST.B      [R0 + #18], R1
##@@@P_:kfstdlib.c:151
##@@@L0149_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0150_:    case 18U:   
##@@@L0151_:        Dst8Ptr[17] = U8Src;   
8000d50e:	41 94       	ST.B      [R0 + #17], R1
##@@@P_:kfstdlib.c:154
##@@@L0152_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0153_:    case 17U:   
##@@@L0154_:        Dst8Ptr[16] = U8Src;   
8000d510:	01 94       	ST.B      [R0 + #16], R1
##@@@P_:kfstdlib.c:157
##@@@L0155_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0156_:    case 16U:   
##@@@L0157_:        Dst8Ptr[15] = U8Src;   
8000d512:	c1 93       	ST.B      [R0 + #15], R1
##@@@P_:kfstdlib.c:160
##@@@L0158_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0159_:    case 15U:   
##@@@L0160_:        Dst8Ptr[14] = U8Src;   
8000d514:	81 93       	ST.B      [R0 + #14], R1
##@@@P_:kfstdlib.c:163
##@@@L0161_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0162_:    case 14U:   
##@@@L0163_:        Dst8Ptr[13] = U8Src;   
8000d516:	41 93       	ST.B      [R0 + #13], R1
##@@@P_:kfstdlib.c:166
##@@@L0164_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0165_:    case 13U:   
##@@@L0166_:        Dst8Ptr[12] = U8Src;   
8000d518:	01 93       	ST.B      [R0 + #12], R1
##@@@P_:kfstdlib.c:169
##@@@L0167_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0168_:    case 12U:   
##@@@L0169_:        Dst8Ptr[11] = U8Src;   
8000d51a:	c1 92       	ST.B      [R0 + #11], R1
##@@@P_:kfstdlib.c:172
##@@@L0170_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0171_:    case 11U:   
##@@@L0172_:        Dst8Ptr[10] = U8Src;   
8000d51c:	81 92       	ST.B      [R0 + #10], R1
##@@@P_:kfstdlib.c:175
##@@@L0173_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0174_:    case 10U:   
##@@@L0175_:        Dst8Ptr[9] = U8Src;   
8000d51e:	41 92       	ST.B      [R0 + #9], R1
##@@@P_:kfstdlib.c:178
##@@@L0176_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0177_:    case 9U:   
##@@@L0178_:        Dst8Ptr[8] = U8Src;   
8000d520:	01 92       	ST.B      [R0 + #8], R1
##@@@P_:kfstdlib.c:181
##@@@L0179_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0180_:    case 8U:   
##@@@L0181_:        Dst8Ptr[7] = U8Src;   
8000d522:	c1 91       	ST.B      [R0 + #7], R1
##@@@P_:kfstdlib.c:184
##@@@L0182_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0183_:    case 7U:   
##@@@L0184_:        Dst8Ptr[6] = U8Src;   
8000d524:	81 91       	ST.B      [R0 + #6], R1
##@@@P_:kfstdlib.c:187
##@@@L0185_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0186_:    case 6U:   
##@@@L0187_:        Dst8Ptr[5] = U8Src;   
8000d526:	41 91       	ST.B      [R0 + #5], R1
##@@@P_:kfstdlib.c:190
##@@@L0188_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0189_:    case 5U:   
##@@@L0190_:        Dst8Ptr[4] = U8Src;   
8000d528:	01 91       	ST.B      [R0 + #4], R1
##@@@P_:kfstdlib.c:193
##@@@L0191_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0192_:    case 4U:   
##@@@L0193_:        Dst8Ptr[3] = U8Src;   
8000d52a:	c1 90       	ST.B      [R0 + #3], R1
8000d52c:	37 04       	SJMP      $+55                  ;->0x8000d59a
##@@@F_:kfStdLib_MemSet():
8000d52e:	83 10       	MOV       R8, #3			;->0x0003
##@@@P_:kfstdlib.c:727
##@@@L0722_:    }   
##@@@L0723_:    else   
##@@@L0724_:    {   
##@@@L0725_:        /* Get the destination pointer offset to the next 32-bit boundary */   
##@@@L0726_:        /* PRQA S 0326 3 # Cast between a pointer to void and an integral type. */   
##@@@L0727_:        const uint32_t DstOffset = KFSTDLIB_ALIGN_OFFSET(DstPtr);   
8000d530:	80 58       	MOV       R4, R0
8000d532:	48 69       	ANL       R4, R8
8000d534:	64 58       	MOV       R3, R4
8000d536:	1e 46       	LD        R6, [PC + #30]        ;->0x8000d5ac  :=0x80001218
8000d538:	1a 7a       	LSL       R3, #2			;->0x02
8000d53a:	de e8       	LD.W      R3, [R6 + R3]
8000d53c:	13 5c       	JMP       R3
##@@@F_:kfStdLib_MemSet_8bits_3bytes():
##@@@P_:kfstdlib.c:78
##@@@L0073_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0074_:    /*  Initialize up to 3 bytes using a jump table */   
##@@@L0075_:    switch (Length)   
##@@@L0076_:    {   
##@@@L0077_:    case 3U:   
##@@@L0078_:        Dst8Ptr[2] = U8Src;   
8000d53e:	81 90       	ST.B      [R0 + #2], R1
##@@@P_:kfstdlib.c:81
##@@@L0079_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0080_:    case 2U:   
##@@@L0081_:        Dst8Ptr[1] = U8Src;   
8000d540:	41 90       	ST.B      [R0 + #1], R1
##@@@P_:kfstdlib.c:84
##@@@L0082_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0083_:    case 1U:   
##@@@L0084_:        Dst8Ptr[0] = U8Src;   
8000d542:	01 83       	ST.B      [R0], R1
##@@@F_:kfStdLib_MemSet():
##@@@P_:kfstdlib.c:737
##@@@L0732_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0733_:            kfStdLib_MemSet_8bits_3bytes((uint8_t *)DstPtr, U8Src, DstOffset);   
##@@@L0734_:            /* PRQA S 1338 2 # The parameter '%1s' is being modified. */   
##@@@L0735_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0736_:            DstPtr = &((uint8_t *)DstPtr)[DstOffset];   
##@@@L0737_:            RemainLength -= DstOffset;   
8000d544:	12 c7       	SUB       R2, R2, R4
##@@@P_:kfstdlib.c:736
##@@@L0731_:            /*  Initialize the amount of to reach the boundary on 'DstPtr' and adjust the pointer */   
##@@@L0732_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0733_:            kfStdLib_MemSet_8bits_3bytes((uint8_t *)DstPtr, U8Src, DstOffset);   
##@@@L0734_:            /* PRQA S 1338 2 # The parameter '%1s' is being modified. */   
##@@@L0735_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0736_:            DstPtr = &((uint8_t *)DstPtr)[DstOffset];   
8000d546:	00 c3       	ADD       R0, R0, R4
8000d548:	1a 44       	LD        R4, [PC + #26]        ;->0x8000d5b0  :=0x1010101
##@@@F_:kfStdLib_MemSet_32bitsAligned():
##@@@P_:kfstdlib.c:236
##@@@L0231_: */   
##@@@L0232_:KF_FORCE_INLINE void kfStdLib_MemSet_32bitsAligned(uint32_t *Dst32Ptr, const uint8_t U8Src, const uint32_t Length)   
##@@@L0233_:{   
##@@@L0234_:    uint32_t u32Pos       = 0U;   
##@@@L0235_:    uint32_t RemainLength = 0U;   
##@@@L0236_:    uint32_t u32Src = (uint32_t)(((uint32_t)U8Src << 24U) | ((uint32_t)U8Src << 16U) | ((uint32_t)U8Src << 8U) | U8Src);   
8000d54a:	21 cb       	MULS      R4, R1, R4
8000d54c:	31 10       	MOV       R3, #1			;->0x0001
8000d54e:	c0 58       	MOV       R6, R0
##@@@P_:kfstdlib.c:245
##@@@L0240_:    {   
##@@@L0241_:        /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0242_:        Dst32Ptr[u32Pos + 0U] = u32Src;   
##@@@L0243_:        Dst32Ptr[u32Pos + 1U] = u32Src;   
##@@@L0244_:        Dst32Ptr[u32Pos + 2U] = u32Src;   
##@@@L0245_:        Dst32Ptr[u32Pos + 3U] = u32Src;   
8000d550:	f4 a0       	ST.W      [R6 + #3], R4
##@@@P_:kfstdlib.c:244
##@@@L0239_:    for (RemainLength = Length; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0240_:    {   
##@@@L0241_:        /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0242_:        Dst32Ptr[u32Pos + 0U] = u32Src;   
##@@@L0243_:        Dst32Ptr[u32Pos + 1U] = u32Src;   
##@@@L0244_:        Dst32Ptr[u32Pos + 2U] = u32Src;   
8000d552:	b4 a0       	ST.W      [R6 + #2], R4
##@@@P_:kfstdlib.c:243
##@@@L0238_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0239_:    for (RemainLength = Length; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0240_:    {   
##@@@L0241_:        /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0242_:        Dst32Ptr[u32Pos + 0U] = u32Src;   
##@@@L0243_:        Dst32Ptr[u32Pos + 1U] = u32Src;   
8000d554:	74 a0       	ST.W      [R6 + #1], R4
##@@@P_:kfstdlib.c:242
##@@@L0237_:    /* Linearly initialize 16-byte blocks using 32-bit accesses in a loop */   
##@@@L0238_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0239_:    for (RemainLength = Length; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0240_:    {   
##@@@L0241_:        /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0242_:        Dst32Ptr[u32Pos + 0U] = u32Src;   
8000d556:	64 85       	ST.W      [R6], R4
##@@@P_:kfstdlib.c:239
##@@@L0234_:    uint32_t u32Pos       = 0U;   
##@@@L0235_:    uint32_t RemainLength = 0U;   
##@@@L0236_:    uint32_t u32Src = (uint32_t)(((uint32_t)U8Src << 24U) | ((uint32_t)U8Src << 16U) | ((uint32_t)U8Src << 8U) | U8Src);   
##@@@L0237_:    /* Linearly initialize 16-byte blocks using 32-bit accesses in a loop */   
##@@@L0238_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0239_:    for (RemainLength = Length; RemainLength >= 16U; RemainLength -= 16U)   
8000d558:	60 29       	ADD       R6, #16			;->0x10
8000d55a:	1b c1       	ADD       R3, R3, #4
8000d55c:	20 31       	SUB       R2, #16			;->0x10
8000d55e:	2f 38       	CMP       R2, #15			;->0x0F
8000d560:	f8 f8       	JHI       $-8                   ;->0x8000d550
##@@@P_:kfstdlib.c:250
##@@@L0245_:        Dst32Ptr[u32Pos + 3U] = u32Src;   
##@@@L0246_:        u32Pos += 4U;   
##@@@L0247_:    }   
##@@@L0248_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0249_:    /*  Initialize the RemainLength block using a jump table */   
##@@@L0250_:    switch (RemainLength)   
8000d562:	7a cc       	SUB       R7, R2, #1
8000d564:	7e 38       	CMP       R7, #14			;->0x0E
8000d566:	1d f8       	JHI       $+29                  ;->0x8000d5a0
8000d568:	13 45       	LD        R5, [PC + #19]        ;->0x8000d5b4  :=0x80001228
8000d56a:	3a 7a       	LSL       R7, #2			;->0x02
8000d56c:	ed e9       	LD.W      R5, [R5 + R7]
8000d56e:	20 29       	ADD       R2, #16			;->0x10
8000d570:	7b cc       	SUB       R7, R3, #1
8000d572:	15 5c       	JMP       R5
8000d574:	67 58       	MOV       R3, R7
8000d576:	06 04       	SJMP      $+6                   ;->0x8000d582
##@@@P_:kfstdlib.c:256
##@@@L0251_:    {   
##@@@L0252_:    case 15U:   
##@@@L0253_:    case 14U:   
##@@@L0254_:    case 13U:   
##@@@L0255_:    case 12U:   
##@@@L0256_:        Dst32Ptr[u32Pos] = u32Src;   
8000d578:	64 85       	ST.W      [R6], R4
8000d57a:	e3 58       	MOV       R7, R3
##@@@P_:kfstdlib.c:264
##@@@L0259_:    case 11U:   
##@@@L0260_:    case 10U:   
##@@@L0261_:    case 9U:   
##@@@L0262_:    case 8U:   
##@@@L0263_:        Dst32Ptr[u32Pos] = u32Src;   
##@@@L0264_:        u32Pos++;   
8000d57c:	5f c0       	ADD       R3, R7, #1
##@@@P_:kfstdlib.c:263
##@@@L0258_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0259_:    case 11U:   
##@@@L0260_:    case 10U:   
##@@@L0261_:    case 9U:   
##@@@L0262_:    case 8U:   
##@@@L0263_:        Dst32Ptr[u32Pos] = u32Src;   
8000d57e:	3a 7a       	LSL       R7, #2			;->0x02
8000d580:	c4 ef       	ST.W      [R0 + R7], R4
##@@@P_:kfstdlib.c:271
##@@@L0266_:    case 7U:   
##@@@L0267_:    case 6U:   
##@@@L0268_:    case 5U:   
##@@@L0269_:    case 4U:   
##@@@L0270_:        Dst32Ptr[u32Pos] = u32Src;   
##@@@L0271_:        u32Pos++;   
8000d582:	7b c0       	ADD       R7, R3, #1
##@@@P_:kfstdlib.c:270
##@@@L0265_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0266_:    case 7U:   
##@@@L0267_:    case 6U:   
##@@@L0268_:    case 5U:   
##@@@L0269_:    case 4U:   
##@@@L0270_:        Dst32Ptr[u32Pos] = u32Src;   
8000d584:	1a 7a       	LSL       R3, #2			;->0x02
8000d586:	c4 ee       	ST.W      [R0 + R3], R4
##@@@P_:kfstdlib.c:277
##@@@L0272_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0273_:    case 3U:   
##@@@L0274_:    case 2U:   
##@@@L0275_:    case 1U:   
##@@@L0276_:        /* PRQA S 0751 3 # Casting to char pointer type.*/   
##@@@L0277_:        kfStdLib_MemSet_8bits_3bytes((uint8_t *)&Dst32Ptr[u32Pos], U8Src, (uint32_t)(RemainLength & KFSTDLIB_MASK_3));   
8000d588:	3a 7a       	LSL       R7, #2			;->0x02
8000d58a:	c0 c3       	ADD       R0, R0, R7
8000d58c:	28 69       	ANL       R2, R8
##@@@F_:kfStdLib_MemSet_8bits_3bytes():
##@@@P_:kfstdlib.c:75
##@@@L0070_: */   
##@@@L0071_:KF_FORCE_INLINE void kfStdLib_MemSet_8bits_3bytes(uint8_t *const Dst8Ptr, uint8_t U8Src, uint32_t Length)   
##@@@L0072_:{   
##@@@L0073_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0074_:    /*  Initialize up to 3 bytes using a jump table */   
##@@@L0075_:    switch (Length)   
8000d58e:	21 38       	CMP       R2, #1			;->0x01
8000d590:	07 f0       	JZ        $+7                   ;->0x8000d59e
8000d592:	22 38       	CMP       R2, #2			;->0x02
8000d594:	04 f0       	JZ        $+4                   ;->0x8000d59c
8000d596:	23 38       	CMP       R2, #3			;->0x03
8000d598:	04 f1       	JNZ       $+4                   ;->0x8000d5a0
##@@@F_:kfStdLib_MemSet():
8000d59a:	81 90       	ST.B      [R0 + #2], R1
8000d59c:	41 90       	ST.B      [R0 + #1], R1
8000d59e:	01 83       	ST.B      [R0], R1
##@@@P_:kfstdlib.c:753
##@@@L0748_:    for (RemainLength = 0; RemainLength < Length; RemainLength++)   
##@@@L0749_:    {   
##@@@L0750_:        ((uint8_t *)(DstPtr))[RemainLength] = U8Src;   
##@@@L0751_:    }   
##@@@L0752_:#endif   
##@@@L0753_:}   
8000d5a0:	e4 28       	ADD       SP, #4			;->0x04
8000d5a2:	07 5e       	POP       {R6-R8}
8000d5a4:	1d 5c       	JMP       LR
8000d5a6:	00 00       	NOP      NOP      
8000d5a8:	64 12 00 80 	.long     0x80001264 ->-2147478940  [!!!@2@:MOV       R6, #36	@@: LD.B      R0, [R0]
8000d5ac:	18 12 00 80 	.long     0x80001218 ->-2147479016  [!!!@2@:MOV       R1, #40	@@: LD.B      R0, [R0]
8000d5b0:	01 01 01 01 	.long     0x01010101 ->016843009  [!!!@2@:CMN       R0, R1	@@: CMN       R0, R1
8000d5b4:	28 12 00 80 	.long     0x80001228 ->-2147479000  [!!!@2@:MOV       R2, #40	@@: LD.B      R0, [R0]

8000d5b8 <kfStdLib_MemCopy>:
##@@@F_:kfStdLib_MemCopy():
##@@@P_:kfstdlib.c:763
##@@@L0758_: * @param DstPtr   
##@@@L0759_: * @param SrcPtr   
##@@@L0760_: * @param Length   
##@@@L0761_: */   
##@@@L0762_:void kfStdLib_MemCopy(void *DstPtr, void *SrcPtr, kfStdLib_LengthType Length)   
##@@@L0763_:{   
8000d5b8:	0f 5f       	PUSH      {R6-R9}
8000d5ba:	e0 32       	SUB       SP, #32			;->0x20
8000d5bc:	e2 58       	MOV       R7, R2
##@@@P_:kfstdlib.c:770
##@@@L0765_:    KF_STDLIB_ASSERT(SrcPtr != NULL_PTR);   
##@@@L0766_:    kfStdLib_LengthType RemainLength = Length;   
##@@@L0767_:
##@@@L0768_:#if (KFSTDLIB_RUNTIME_OPTIMIZATION == STD_ON)   
##@@@L0769_:    /*  If less than 32 bytes have to be copied */   
##@@@L0770_:    if (RemainLength < 32U)   
8000d5be:	2f 39       	CMP       R2, #31			;->0x1F
8000d5c0:	09 f8       	JHI       $+9                   ;->0x8000d5d2
##@@@F_:kfStdLib_MemCopy_8bits_31bytes():
##@@@P_:kfstdlib.c:338
##@@@L0333_:KF_FORCE_INLINE void   
##@@@L0334_:kfStdLib_MemCopy_8bits_31bytes(uint8_t *Dst8Ptr, const uint8_t *const Src8Ptr, const uint32_t Length)   
##@@@L0335_:{   
##@@@L0336_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0337_:    /*  Copy up to 31 bytes using a jump table */   
##@@@L0338_:    switch (Length)   
8000d5c2:	6f cc       	SUB       R5, R7, #1
8000d5c4:	5e 39       	CMP       R5, #30			;->0x1E
8000d5c6:	02 f9       	JLS       $+2                   ;->0x8000d5ca
8000d5c8:	83 05       	SJMP      $+387                 ;->0x8000d8ce
##@@@F_:kfStdLib_MemCopy():
8000d5ca:	c3 44       	LD        R4, [PC + #195]       ;->0x8000d8d4  :=0x800013a8
8000d5cc:	2a 7a       	LSL       R5, #2			;->0x02
8000d5ce:	6c e9       	LD.W      R5, [R4 + R5]
8000d5d0:	15 5c       	JMP       R5
8000d5d2:	43 10       	MOV       R4, #3			;->0x0003
##@@@P_:kfstdlib.c:780
##@@@L0775_:    }   
##@@@L0776_:    else   
##@@@L0777_:    {   
##@@@L0778_:        /* Get the source pointer offset to the next 32-bit boundary */   
##@@@L0779_:        /* PRQA S 0326 3 # Cast between a pointer to void and an integral type. */   
##@@@L0780_:        uint32_t nSrcOffset = KFSTDLIB_ALIGN_OFFSET(SrcPtr);   
8000d5d4:	a1 58       	MOV       R5, R1
8000d5d6:	54 69       	ANL       R5, R4
8000d5d8:	65 58       	MOV       R3, R5
8000d5da:	c0 42       	LD        R2, [PC + #192]       ;->0x8000d8d8  :=0x800012e0
8000d5dc:	1a 7a       	LSL       R3, #2			;->0x02
8000d5de:	da e8       	LD.W      R3, [R2 + R3]
8000d5e0:	13 5c       	JMP       R3
##@@@F_:kfStdLib_MemCopy_8bits_3bytes():
##@@@P_:kfstdlib.c:304
##@@@L0299_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0300_:    /*  Copy up to 3 bytes using a jump table */   
##@@@L0301_:    switch (Length)   
##@@@L0302_:    {   
##@@@L0303_:    case 3U:   
##@@@L0304_:        Dst8Ptr[2] = Src8Ptr[2];   
8000d5e2:	99 88       	LD.B      R3, [R1 + #2]
8000d5e4:	83 90       	ST.B      [R0 + #2], R3
##@@@P_:kfstdlib.c:307
##@@@L0305_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0306_:    case 2U:   
##@@@L0307_:        Dst8Ptr[1] = Src8Ptr[1];   
8000d5e6:	59 88       	LD.B      R3, [R1 + #1]
8000d5e8:	43 90       	ST.B      [R0 + #1], R3
##@@@P_:kfstdlib.c:310
##@@@L0308_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0309_:    case 1U:   
##@@@L0310_:        Dst8Ptr[0] = Src8Ptr[0];   
8000d5ea:	31 80       	LD.B      R3, [R1]
8000d5ec:	03 83       	ST.B      [R0], R3
##@@@F_:kfStdLib_MemCopy():
##@@@P_:kfstdlib.c:794
##@@@L0789_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0790_:            SrcPtr = &((uint8_t *)SrcPtr)[nSrcOffset];   
##@@@L0791_:            /* PRQA S 1338 2 # The parameter '%1s' is being modified. */   
##@@@L0792_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0793_:            DstPtr = &((uint8_t *)DstPtr)[nSrcOffset];   
##@@@L0794_:            RemainLength -= nSrcOffset;   
8000d5ee:	7f c7       	SUB       R7, R7, R5
##@@@P_:kfstdlib.c:793
##@@@L0788_:            /* PRQA S 1338 2 # The parameter '%1s' is being modified. */   
##@@@L0789_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0790_:            SrcPtr = &((uint8_t *)SrcPtr)[nSrcOffset];   
##@@@L0791_:            /* PRQA S 1338 2 # The parameter '%1s' is being modified. */   
##@@@L0792_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0793_:            DstPtr = &((uint8_t *)DstPtr)[nSrcOffset];   
8000d5f0:	40 c3       	ADD       R0, R0, R5
##@@@P_:kfstdlib.c:790
##@@@L0785_:            /*  Copy the amount of bytes to reach the boundary on 'SrcPtr' and adjust the pointers */   
##@@@L0786_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0787_:            kfStdLib_MemCopy_8bits_3bytes((uint8_t *)DstPtr, (const uint8_t *)SrcPtr, nSrcOffset);   
##@@@L0788_:            /* PRQA S 1338 2 # The parameter '%1s' is being modified. */   
##@@@L0789_:            /* PRQA S 0316 1 # This cast is ensured for address conversion  */   
##@@@L0790_:            SrcPtr = &((uint8_t *)SrcPtr)[nSrcOffset];   
8000d5f2:	49 c3       	ADD       R1, R1, R5
##@@@P_:kfstdlib.c:802
##@@@L0797_:        {   
##@@@L0798_:            /* deliberately left blank to avoid QAC violation * (Rule 2000 ) */   
##@@@L0799_:        }   
##@@@L0800_:        /* Get the destination pointer offset to the next 32-bit boundary */   
##@@@L0801_:        /* PRQA S 0326 3 # Cast between a pointer to void and an integral type. */   
##@@@L0802_:        DstOffset = KFSTDLIB_ALIGN_OFFSET(DstPtr);   
8000d5f4:	a0 58       	MOV       R5, R0
8000d5f6:	54 69       	ANL       R5, R4
##@@@P_:kfstdlib.c:804
##@@@L0803_:        /*  If destination is aligned */   
##@@@L0804_:        if (DstOffset == 0U)   
8000d5f8:	50 38       	CMP       R5, #0			;->0x00
8000d5fa:	02 f1       	JNZ       $+2                   ;->0x8000d5fe
8000d5fc:	4b 04       	SJMP      $+75                  ;->0x8000d692
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:574
##@@@L0569_:{   
##@@@L0570_:    uint32_t Pos          = 0U;   
##@@@L0571_:    uint32_t SrcPos       = 0U;   
##@@@L0572_:    uint32_t RemainLength = Length;   
##@@@L0573_:    /*  If more than 32 bytes have to be copied */   
##@@@L0574_:    if (RemainLength >= 32U)   
8000d5fe:	70 3a       	CMP       R7, #32			;->0x20
8000d600:	02 f2       	JC        $+2                   ;->0x8000d604
8000d602:	69 04       	SJMP      $+105                 ;->0x8000d6d4
##@@@P_:kfstdlib.c:580
##@@@L0575_:    {   
##@@@L0576_:        uint32_t  u32Prev = 0U;   
##@@@L0577_:        uint32_t *Dst32Ptr;   
##@@@L0578_:        /*  Copy the first partial word to reach the 32-bit boundary and adjust the destination pointer */   
##@@@L0579_:        u32Prev = Src32Ptr[SrcPos];   
##@@@L0580_:        RemainLength -= 4U;   
8000d604:	3f cd       	SUB       R7, R7, #4
##@@@P_:kfstdlib.c:579
##@@@L0574_:    if (RemainLength >= 32U)   
##@@@L0575_:    {   
##@@@L0576_:        uint32_t  u32Prev = 0U;   
##@@@L0577_:        uint32_t *Dst32Ptr;   
##@@@L0578_:        /*  Copy the first partial word to reach the 32-bit boundary and adjust the destination pointer */   
##@@@L0579_:        u32Prev = Src32Ptr[SrcPos];   
8000d606:	91 82       	LD.W      R9, [R1]
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:528
##@@@L0523_:KF_FORCE_INLINE void kfStdLib_MemCopy_8bits_PartialWord(   
##@@@L0524_:  uint8_t *Dst8Ptr, uint32_t *const Src32Ptr, const uint32_t Length, uint32_t *const Pos)   
##@@@L0525_:{   
##@@@L0526_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0527_:    /* Copy 1 to 3 bytes using a jump table and adapt '*Pos' and '*Src32Ptr' for little endian byte order */   
##@@@L0528_:    switch (Length)   
8000d608:	53 38       	CMP       R5, #3			;->0x03
8000d60a:	04 21       	ST.W      [SP + #4], R1
8000d60c:	02 25       	ST.W      [SP + #2], R5
8000d60e:	02 f1       	JNZ       $+2                   ;->0x8000d612
8000d610:	65 04       	SJMP      $+101                 ;->0x8000d6da
8000d612:	52 38       	CMP       R5, #2			;->0x02
8000d614:	02 f0       	JZ        $+2                   ;->0x8000d618
8000d616:	9e 04       	SJMP      $+158                 ;->0x8000d752
##@@@P_:kfstdlib.c:538
##@@@L0533_:        (*Src32Ptr) >>= 8U;   
##@@@L0534_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0535_:    case 2U:   
##@@@L0536_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0537_:        (*Pos)++;   
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
8000d618:	a9 58       	MOV       R5, R9
8000d61a:	a8 7c       	LSR       R5, #8			;->0x08
##@@@P_:kfstdlib.c:541
##@@@L0539_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0540_:    default: /* case 1 - Length is always in range [1..3] */   
##@@@L0541_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d61c:	45 90       	ST.B      [R0 + #1], R5
8000d61e:	41 10       	MOV       R4, #1			;->0x0001
8000d620:	41 58       	MOV       R2, R1
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:617
##@@@L0612_:                SrcPos += 4U;   
##@@@L0613_:            }   
##@@@L0614_:        }   
##@@@L0615_:        else if (DstOffset == 2U) /* 16-bit displacement */   
##@@@L0616_:        {   
##@@@L0617_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d622:	28 28       	ADD       R2, #8			;->0x08
8000d624:	60 58       	MOV       R3, R0
8000d626:	3a 28       	ADD       R3, #10			;->0x0A
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:536
##@@@L0531_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0532_:        (*Pos)++;   
##@@@L0533_:        (*Src32Ptr) >>= 8U;   
##@@@L0534_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0535_:    case 2U:   
##@@@L0536_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d628:	09 83       	ST.B      [R0], R9
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:585
##@@@L0580_:        RemainLength -= 4U;   
##@@@L0581_:        kfStdLib_MemCopy_8bits_PartialWord(Dst8Ptr, &u32Prev, DstOffset, &Pos);   
##@@@L0582_:        /* At this point 'Dst8Ptr[Pos]' is aligned to a 32-bit boundary */   
##@@@L0583_:        /* PRQA S 0310 4 # Casting to different object pointer type. */   
##@@@L0584_:        /* PRQA S 3305 2 # Pointer cast to stricter alignment. */   
##@@@L0585_:        Dst32Ptr = (uint32_t *)&Dst8Ptr[Pos];   
8000d62a:	a8 c0       	ADD       R5, R0, #2
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:543
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
##@@@L0539_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0540_:    default: /* case 1 - Length is always in range [1..3] */   
##@@@L0541_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0542_:        (*Pos)++;   
##@@@L0543_:        (*Src32Ptr) >>= 8U;   
8000d62c:	03 25       	ST.W      [SP + #3], R5
8000d62e:	48 7d       	LSR       R9, #16			;->0x10
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:621
##@@@L0616_:        {   
##@@@L0617_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0618_:            {   
##@@@L0619_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0620_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0621_:                x1 = Src32Ptr[SrcPos + 0U];   
8000d630:	07 24       	ST.W      [SP + #7], R4
8000d632:	06 27       	ST.W      [SP + #6], R7
8000d634:	2a cd       	SUB       R5, R2, #4
##@@@P_:kfstdlib.c:622
##@@@L0622_:                x2 = Src32Ptr[SrcPos + 1U];   
8000d636:	42 82       	LD.W      R4, [R2]
##@@@P_:kfstdlib.c:621
##@@@L0616_:        {   
##@@@L0617_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0618_:            {   
##@@@L0619_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0620_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0621_:                x1 = Src32Ptr[SrcPos + 0U];   
8000d638:	15 82       	LD.W      R1, [R5]
##@@@P_:kfstdlib.c:627
##@@@L0622_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0623_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0624_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0625_:
##@@@L0626_:                x0      = u32Prev | (x1 << 16U);   
##@@@L0627_:                x1      = (x1 >> 16U) | (x2 << 16U);   
8000d63a:	c4 58       	MOV       R6, R4
8000d63c:	30 7b       	LSL       R6, #16			;->0x10
8000d63e:	a1 58       	MOV       R5, R1
8000d640:	28 7d       	LSR       R5, #16			;->0x10
8000d642:	65 6a       	ORL       R6, R5
##@@@P_:kfstdlib.c:624
##@@@L0619_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0620_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0621_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0622_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0623_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0624_:                x4 = Src32Ptr[SrcPos + 3U];   
8000d644:	82 98       	LD.W      R0, [R2 + #2]
##@@@P_:kfstdlib.c:623
##@@@L0618_:            {   
##@@@L0619_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0620_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0621_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0622_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0623_:                x3 = Src32Ptr[SrcPos + 2U];   
8000d646:	6a 98       	LD.W      R5, [R2 + #1]
##@@@P_:kfstdlib.c:634
##@@@L0629_:                x3      = (x3 >> 16U) | (x4 << 16U);   
##@@@L0630_:                u32Prev = x4 >> 16U;   
##@@@L0631_:
##@@@L0632_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0633_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0634_:                Dst32Ptr[Pos + 1U] = x1;   
8000d648:	3b cd       	SUB       R7, R3, #4
8000d64a:	76 85       	ST.W      [R7], R6
8000d64c:	06 0f       	LD.W      R7, [SP + #6]
##@@@P_:kfstdlib.c:626
##@@@L0621_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0622_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0623_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0624_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0625_:
##@@@L0626_:                x0      = u32Prev | (x1 << 16U);   
8000d64e:	08 7b       	LSL       R1, #16			;->0x10
8000d650:	19 6a       	ORL       R1, R9
##@@@P_:kfstdlib.c:633
##@@@L0628_:                x2      = (x2 >> 16U) | (x3 << 16U);   
##@@@L0629_:                x3      = (x3 >> 16U) | (x4 << 16U);   
##@@@L0630_:                u32Prev = x4 >> 16U;   
##@@@L0631_:
##@@@L0632_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0633_:                Dst32Ptr[Pos + 0U] = x0;   
8000d652:	c3 58       	MOV       R6, R3
8000d654:	68 30       	SUB       R6, #8			;->0x08
8000d656:	61 85       	ST.W      [R6], R1
##@@@P_:kfstdlib.c:628
##@@@L0623_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0624_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0625_:
##@@@L0626_:                x0      = u32Prev | (x1 << 16U);   
##@@@L0627_:                x1      = (x1 >> 16U) | (x2 << 16U);   
##@@@L0628_:                x2      = (x2 >> 16U) | (x3 << 16U);   
8000d658:	20 7d       	LSR       R4, #16			;->0x10
8000d65a:	25 58       	MOV       R1, R5
8000d65c:	08 7b       	LSL       R1, #16			;->0x10
8000d65e:	14 6a       	ORL       R1, R4
##@@@P_:kfstdlib.c:629
##@@@L0629_:                x3      = (x3 >> 16U) | (x4 << 16U);   
8000d660:	28 7d       	LSR       R5, #16			;->0x10
8000d662:	80 58       	MOV       R4, R0
8000d664:	20 7b       	LSL       R4, #16			;->0x10
8000d666:	45 6a       	ORL       R4, R5
##@@@P_:kfstdlib.c:636
##@@@L0631_:
##@@@L0632_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0633_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0634_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0635_:                Dst32Ptr[Pos + 2U] = x2;   
##@@@L0636_:                Dst32Ptr[Pos + 3U] = x3;   
8000d668:	5c a0       	ST.W      [R3 + #1], R4
8000d66a:	07 0c       	LD.W      R4, [SP + #7]
##@@@P_:kfstdlib.c:635
##@@@L0630_:                u32Prev = x4 >> 16U;   
##@@@L0631_:
##@@@L0632_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0633_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0634_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0635_:                Dst32Ptr[Pos + 2U] = x2;   
8000d66c:	31 85       	ST.W      [R3], R1
##@@@P_:kfstdlib.c:617
##@@@L0612_:                SrcPos += 4U;   
##@@@L0613_:            }   
##@@@L0614_:        }   
##@@@L0615_:        else if (DstOffset == 2U) /* 16-bit displacement */   
##@@@L0616_:        {   
##@@@L0617_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d66e:	20 29       	ADD       R2, #16			;->0x10
8000d670:	30 29       	ADD       R3, #16			;->0x10
##@@@P_:kfstdlib.c:638
##@@@L0633_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0634_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0635_:                Dst32Ptr[Pos + 2U] = x2;   
##@@@L0636_:                Dst32Ptr[Pos + 3U] = x3;   
##@@@L0637_:                Pos += 4U;   
##@@@L0638_:                SrcPos += 4U;   
8000d672:	24 c1       	ADD       R4, R4, #4
##@@@P_:kfstdlib.c:630
##@@@L0625_:
##@@@L0626_:                x0      = u32Prev | (x1 << 16U);   
##@@@L0627_:                x1      = (x1 >> 16U) | (x2 << 16U);   
##@@@L0628_:                x2      = (x2 >> 16U) | (x3 << 16U);   
##@@@L0629_:                x3      = (x3 >> 16U) | (x4 << 16U);   
##@@@L0630_:                u32Prev = x4 >> 16U;   
8000d674:	00 7d       	LSR       R0, #16			;->0x10
##@@@P_:kfstdlib.c:617
##@@@L0612_:                SrcPos += 4U;   
##@@@L0613_:            }   
##@@@L0614_:        }   
##@@@L0615_:        else if (DstOffset == 2U) /* 16-bit displacement */   
##@@@L0616_:        {   
##@@@L0617_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d676:	70 31       	SUB       R7, #16			;->0x10
8000d678:	7f 38       	CMP       R7, #15			;->0x0F
8000d67a:	20 59       	MOV       R9, R0
8000d67c:	da f8       	JHI       $-38                  ;->0x8000d630
##@@@P_:kfstdlib.c:669
##@@@L0664_:                SrcPos += 4U;   
##@@@L0665_:            }   
##@@@L0666_:        }   
##@@@L0667_:        /*  Linearly copy the RemainLength words using a loop */   
##@@@L0668_:        {   
##@@@L0669_:            uint32_t prevShift = (DstOffset << 3U) & KFSTDLIB_MASK_31;   
8000d67e:	74 cc       	SUB       R6, R4, #1
8000d680:	04 09       	LD.W      R1, [SP + #4]
8000d682:	02 0b       	LD.W      R3, [SP + #2]
8000d684:	44 58       	MOV       R2, R4
##@@@P_:kfstdlib.c:672
##@@@L0670_:            uint32_t xShift    = 32U - prevShift;   
##@@@L0671_:            /* At this point RemainLength is < 16 byte */   
##@@@L0672_:            for (; RemainLength >= 4U; RemainLength -= 4U)   
8000d686:	74 38       	CMP       R7, #4			;->0x04
8000d688:	02 f3       	JNC       $+2                   ;->0x8000d68c
8000d68a:	9c 04       	SJMP      $+156                 ;->0x8000d7c2
##@@@F_:kfStdLib_MemCopy():
8000d68c:	87 58       	MOV       R4, R7
8000d68e:	e0 58       	MOV       R7, R0
8000d690:	c2 04       	SJMP      $+194                 ;->0x8000d814
8000d692:	51 10       	MOV       R5, #1			;->0x0001
8000d694:	60 58       	MOV       R3, R0
8000d696:	41 58       	MOV       R2, R1
##@@@F_:kfStdLib_MemCopy_32bitsAligned():
##@@@P_:kfstdlib.c:464
##@@@L0459_:    /*  Linearly copy 16-byte blocks using 32-bit accesses in a loop */   
##@@@L0460_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0461_:    for (RemainLength = Length; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0462_:    {   
##@@@L0463_:        /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0464_:        Dst32Ptr[Pos + 0U] = Src32Ptr[Pos + 0U];   
8000d698:	62 82       	LD.W      R6, [R2]
8000d69a:	36 85       	ST.W      [R3], R6
##@@@P_:kfstdlib.c:465
##@@@L0465_:        Dst32Ptr[Pos + 1U] = Src32Ptr[Pos + 1U];   
8000d69c:	72 98       	LD.W      R6, [R2 + #1]
8000d69e:	5e a0       	ST.W      [R3 + #1], R6
##@@@P_:kfstdlib.c:466
##@@@L0466_:        Dst32Ptr[Pos + 2U] = Src32Ptr[Pos + 2U];   
8000d6a0:	b2 98       	LD.W      R6, [R2 + #2]
8000d6a2:	9e a0       	ST.W      [R3 + #2], R6
##@@@P_:kfstdlib.c:467
##@@@L0467_:        Dst32Ptr[Pos + 3U] = Src32Ptr[Pos + 3U];   
8000d6a4:	f2 98       	LD.W      R6, [R2 + #3]
8000d6a6:	de a0       	ST.W      [R3 + #3], R6
##@@@P_:kfstdlib.c:461
##@@@L0456_:{   
##@@@L0457_:    uint32_t Pos          = 0U;   
##@@@L0458_:    uint32_t RemainLength = 0U;   
##@@@L0459_:    /*  Linearly copy 16-byte blocks using 32-bit accesses in a loop */   
##@@@L0460_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0461_:    for (RemainLength = Length; RemainLength >= 16U; RemainLength -= 16U)   
8000d6a8:	2d c1       	ADD       R5, R5, #4
8000d6aa:	30 29       	ADD       R3, #16			;->0x10
8000d6ac:	20 29       	ADD       R2, #16			;->0x10
8000d6ae:	70 31       	SUB       R7, #16			;->0x10
8000d6b0:	7f 38       	CMP       R7, #15			;->0x0F
8000d6b2:	f3 f8       	JHI       $-13                  ;->0x8000d698
##@@@P_:kfstdlib.c:472
##@@@L0467_:        Dst32Ptr[Pos + 3U] = Src32Ptr[Pos + 3U];   
##@@@L0468_:        Pos += 4U;   
##@@@L0469_:    }   
##@@@L0470_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0471_:    /*  Copy the RemainLength block using a jump table */   
##@@@L0472_:    switch (RemainLength)   
8000d6b4:	77 cc       	SUB       R6, R7, #1
8000d6b6:	6e 38       	CMP       R6, #14			;->0x0E
8000d6b8:	02 f9       	JLS       $+2                   ;->0x8000d6bc
8000d6ba:	0a 05       	SJMP      $+266                 ;->0x8000d8ce
##@@@F_:kfStdLib_MemCopy():
8000d6bc:	04 21       	ST.W      [SP + #4], R1
8000d6be:	27 58       	MOV       R1, R7
8000d6c0:	87 47       	LD        R7, [PC + #135]       ;->0x8000d8dc  :=0x8000136c
8000d6c2:	32 7a       	LSL       R6, #2			;->0x02
8000d6c4:	bf e9       	LD.W      R7, [R7 + R6]
8000d6c6:	75 cc       	SUB       R6, R5, #1
8000d6c8:	10 29       	ADD       R1, #16			;->0x10
8000d6ca:	17 5c       	JMP       R7
8000d6cc:	a6 58       	MOV       R5, R6
8000d6ce:	41 58       	MOV       R2, R1
8000d6d0:	04 09       	LD.W      R1, [SP + #4]
8000d6d2:	13 05       	SJMP      $+275                 ;->0x8000d8f8
8000d6d4:	50 10       	MOV       R5, #0			;->0x0000
8000d6d6:	45 58       	MOV       R2, R5
8000d6d8:	b1 04       	SJMP      $+177                 ;->0x8000d83a
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:538
##@@@L0533_:        (*Src32Ptr) >>= 8U;   
##@@@L0534_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0535_:    case 2U:   
##@@@L0536_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0537_:        (*Pos)++;   
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
8000d6da:	a9 58       	MOV       R5, R9
8000d6dc:	28 7d       	LSR       R5, #16			;->0x10
##@@@P_:kfstdlib.c:541
##@@@L0539_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0540_:    default: /* case 1 - Length is always in range [1..3] */   
##@@@L0541_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d6de:	85 90       	ST.B      [R0 + #2], R5
##@@@P_:kfstdlib.c:533
##@@@L0528_:    switch (Length)   
##@@@L0529_:    {   
##@@@L0530_:    case 3U:   
##@@@L0531_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0532_:        (*Pos)++;   
##@@@L0533_:        (*Src32Ptr) >>= 8U;   
8000d6e0:	a9 58       	MOV       R5, R9
8000d6e2:	a8 7c       	LSR       R5, #8			;->0x08
##@@@P_:kfstdlib.c:536
##@@@L0534_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0535_:    case 2U:   
##@@@L0536_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d6e4:	45 90       	ST.B      [R0 + #1], R5
8000d6e6:	21 10       	MOV       R2, #1			;->0x0001
8000d6e8:	a1 58       	MOV       R5, R1
8000d6ea:	27 58       	MOV       R1, R7
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:591
##@@@L0586_:        Pos      = 0U;   
##@@@L0587_:        SrcPos   = 1U;   
##@@@L0588_:        /*  Linearly copy 16-byte blocks using 32-bit accesses by correcting the byte displacement of dst and src */   
##@@@L0589_:        if (DstOffset == 3U) /* 24-bit displacement */   
##@@@L0590_:        {   
##@@@L0591_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d6ec:	e5 58       	MOV       R7, R5
8000d6ee:	78 28       	ADD       R7, #8			;->0x08
8000d6f0:	60 58       	MOV       R3, R0
8000d6f2:	3f 28       	ADD       R3, #15			;->0x0F
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:531
##@@@L0526_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0527_:    /* Copy 1 to 3 bytes using a jump table and adapt '*Pos' and '*Src32Ptr' for little endian byte order */   
##@@@L0528_:    switch (Length)   
##@@@L0529_:    {   
##@@@L0530_:    case 3U:   
##@@@L0531_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d6f4:	09 83       	ST.B      [R0], R9
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:585
##@@@L0580_:        RemainLength -= 4U;   
##@@@L0581_:        kfStdLib_MemCopy_8bits_PartialWord(Dst8Ptr, &u32Prev, DstOffset, &Pos);   
##@@@L0582_:        /* At this point 'Dst8Ptr[Pos]' is aligned to a 32-bit boundary */   
##@@@L0583_:        /* PRQA S 0310 4 # Casting to different object pointer type. */   
##@@@L0584_:        /* PRQA S 3305 2 # Pointer cast to stricter alignment. */   
##@@@L0585_:        Dst32Ptr = (uint32_t *)&Dst8Ptr[Pos];   
8000d6f6:	e8 c0       	ADD       R5, R0, #3
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:543
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
##@@@L0539_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0540_:    default: /* case 1 - Length is always in range [1..3] */   
##@@@L0541_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0542_:        (*Pos)++;   
##@@@L0543_:        (*Src32Ptr) >>= 8U;   
8000d6f8:	03 25       	ST.W      [SP + #3], R5
8000d6fa:	c8 7d       	LSR       R9, #24			;->0x18
##@@@F_:kfStdLib_MemCopy32Unaligned():
8000d6fc:	07 22       	ST.W      [SP + #7], R2
##@@@P_:kfstdlib.c:596
##@@@L0591_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0592_:            {   
##@@@L0593_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0594_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0595_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0596_:                x2 = Src32Ptr[SrcPos + 1U];   
8000d6fe:	27 82       	LD.W      R2, [R7]
##@@@P_:kfstdlib.c:597
##@@@L0597_:                x3 = Src32Ptr[SrcPos + 2U];   
8000d700:	67 98       	LD.W      R4, [R7 + #1]
##@@@P_:kfstdlib.c:602
##@@@L0598_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0599_:
##@@@L0600_:                x0      = u32Prev | (x1 << 8U);   
##@@@L0601_:                x1      = (x1 >> 24U) | (x2 << 8U);   
##@@@L0602_:                x2      = (x2 >> 24U) | (x3 << 8U);   
8000d702:	02 58       	MOV       R0, R2
8000d704:	80 7d       	LSR       R0, #24			;->0x18
8000d706:	a4 58       	MOV       R5, R4
8000d708:	a8 7a       	LSL       R5, #8			;->0x08
8000d70a:	50 6a       	ORL       R5, R0
##@@@P_:kfstdlib.c:595
##@@@L0590_:        {   
##@@@L0591_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0592_:            {   
##@@@L0593_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0594_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0595_:                x1 = Src32Ptr[SrcPos + 0U];   
8000d70c:	07 cd       	SUB       R0, R7, #4
8000d70e:	80 82       	LD.W      R8, [R0]
##@@@P_:kfstdlib.c:598
##@@@L0596_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0597_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0598_:                x4 = Src32Ptr[SrcPos + 3U];   
8000d710:	87 98       	LD.W      R0, [R7 + #2]
##@@@P_:kfstdlib.c:609
##@@@L0604_:                u32Prev = x4 >> 24U;   
##@@@L0605_:
##@@@L0606_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0607_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0608_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0609_:                Dst32Ptr[Pos + 2U] = x2;   
8000d712:	33 cd       	SUB       R6, R3, #4
8000d714:	65 85       	ST.W      [R6], R5
##@@@P_:kfstdlib.c:601
##@@@L0596_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0597_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0598_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0599_:
##@@@L0600_:                x0      = u32Prev | (x1 << 8U);   
##@@@L0601_:                x1      = (x1 >> 24U) | (x2 << 8U);   
8000d716:	90 7a       	LSL       R2, #8			;->0x08
8000d718:	a8 58       	MOV       R5, R8
8000d71a:	a8 7d       	LSR       R5, #24			;->0x18
8000d71c:	25 6a       	ORL       R2, R5
##@@@P_:kfstdlib.c:608
##@@@L0603_:                x3      = (x3 >> 24U) | (x4 << 8U);   
##@@@L0604_:                u32Prev = x4 >> 24U;   
##@@@L0605_:
##@@@L0606_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0607_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0608_:                Dst32Ptr[Pos + 1U] = x1;   
8000d71e:	a3 58       	MOV       R5, R3
8000d720:	58 30       	SUB       R5, #8			;->0x08
8000d722:	52 85       	ST.W      [R5], R2
8000d724:	07 0a       	LD.W      R2, [SP + #7]
##@@@P_:kfstdlib.c:600
##@@@L0595_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0596_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0597_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0598_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0599_:
##@@@L0600_:                x0      = u32Prev | (x1 << 8U);   
8000d726:	c0 7a       	LSL       R8, #8			;->0x08
8000d728:	89 6a       	ORL       R8, R9
##@@@P_:kfstdlib.c:607
##@@@L0602_:                x2      = (x2 >> 24U) | (x3 << 8U);   
##@@@L0603_:                x3      = (x3 >> 24U) | (x4 << 8U);   
##@@@L0604_:                u32Prev = x4 >> 24U;   
##@@@L0605_:
##@@@L0606_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0607_:                Dst32Ptr[Pos + 0U] = x0;   
8000d72a:	a3 58       	MOV       R5, R3
8000d72c:	5c 30       	SUB       R5, #12			;->0x0C
8000d72e:	58 85       	ST.W      [R5], R8
##@@@P_:kfstdlib.c:603
##@@@L0598_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0599_:
##@@@L0600_:                x0      = u32Prev | (x1 << 8U);   
##@@@L0601_:                x1      = (x1 >> 24U) | (x2 << 8U);   
##@@@L0602_:                x2      = (x2 >> 24U) | (x3 << 8U);   
##@@@L0603_:                x3      = (x3 >> 24U) | (x4 << 8U);   
8000d730:	a0 7d       	LSR       R4, #24			;->0x18
8000d732:	a0 58       	MOV       R5, R0
8000d734:	a8 7a       	LSL       R5, #8			;->0x08
8000d736:	54 6a       	ORL       R5, R4
##@@@P_:kfstdlib.c:610
##@@@L0605_:
##@@@L0606_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0607_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0608_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0609_:                Dst32Ptr[Pos + 2U] = x2;   
##@@@L0610_:                Dst32Ptr[Pos + 3U] = x3;   
8000d738:	35 85       	ST.W      [R3], R5
##@@@P_:kfstdlib.c:591
##@@@L0586_:        Pos      = 0U;   
##@@@L0587_:        SrcPos   = 1U;   
##@@@L0588_:        /*  Linearly copy 16-byte blocks using 32-bit accesses by correcting the byte displacement of dst and src */   
##@@@L0589_:        if (DstOffset == 3U) /* 24-bit displacement */   
##@@@L0590_:        {   
##@@@L0591_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d73a:	70 29       	ADD       R7, #16			;->0x10
8000d73c:	30 29       	ADD       R3, #16			;->0x10
##@@@P_:kfstdlib.c:612
##@@@L0607_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0608_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0609_:                Dst32Ptr[Pos + 2U] = x2;   
##@@@L0610_:                Dst32Ptr[Pos + 3U] = x3;   
##@@@L0611_:                Pos += 4U;   
##@@@L0612_:                SrcPos += 4U;   
8000d73e:	12 c1       	ADD       R2, R2, #4
##@@@P_:kfstdlib.c:604
##@@@L0599_:
##@@@L0600_:                x0      = u32Prev | (x1 << 8U);   
##@@@L0601_:                x1      = (x1 >> 24U) | (x2 << 8U);   
##@@@L0602_:                x2      = (x2 >> 24U) | (x3 << 8U);   
##@@@L0603_:                x3      = (x3 >> 24U) | (x4 << 8U);   
##@@@L0604_:                u32Prev = x4 >> 24U;   
8000d740:	80 7d       	LSR       R0, #24			;->0x18
##@@@P_:kfstdlib.c:591
##@@@L0586_:        Pos      = 0U;   
##@@@L0587_:        SrcPos   = 1U;   
##@@@L0588_:        /*  Linearly copy 16-byte blocks using 32-bit accesses by correcting the byte displacement of dst and src */   
##@@@L0589_:        if (DstOffset == 3U) /* 24-bit displacement */   
##@@@L0590_:        {   
##@@@L0591_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d742:	10 31       	SUB       R1, #16			;->0x10
8000d744:	1f 38       	CMP       R1, #15			;->0x0F
8000d746:	20 59       	MOV       R9, R0
8000d748:	da f8       	JHI       $-38                  ;->0x8000d6fc
##@@@P_:kfstdlib.c:669
##@@@L0664_:                SrcPos += 4U;   
##@@@L0665_:            }   
##@@@L0666_:        }   
##@@@L0667_:        /*  Linearly copy the RemainLength words using a loop */   
##@@@L0668_:        {   
##@@@L0669_:            uint32_t prevShift = (DstOffset << 3U) & KFSTDLIB_MASK_31;   
8000d74a:	72 cc       	SUB       R6, R2, #1
8000d74c:	e1 58       	MOV       R7, R1
8000d74e:	04 09       	LD.W      R1, [SP + #4]
8000d750:	35 04       	SJMP      $+53                  ;->0x8000d7ba
8000d752:	21 10       	MOV       R2, #1			;->0x0001
8000d754:	87 58       	MOV       R4, R7
##@@@P_:kfstdlib.c:643
##@@@L0638_:                SrcPos += 4U;   
##@@@L0639_:            }   
##@@@L0640_:        }   
##@@@L0641_:        else /* DstOffset == 1 - 8-bit displacement */   
##@@@L0642_:        {   
##@@@L0643_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d756:	e1 58       	MOV       R7, R1
8000d758:	78 28       	ADD       R7, #8			;->0x08
8000d75a:	60 58       	MOV       R3, R0
8000d75c:	39 28       	ADD       R3, #9			;->0x09
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:541
##@@@L0536_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0537_:        (*Pos)++;   
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
##@@@L0539_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0540_:    default: /* case 1 - Length is always in range [1..3] */   
##@@@L0541_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d75e:	09 83       	ST.B      [R0], R9
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:585
##@@@L0580_:        RemainLength -= 4U;   
##@@@L0581_:        kfStdLib_MemCopy_8bits_PartialWord(Dst8Ptr, &u32Prev, DstOffset, &Pos);   
##@@@L0582_:        /* At this point 'Dst8Ptr[Pos]' is aligned to a 32-bit boundary */   
##@@@L0583_:        /* PRQA S 0310 4 # Casting to different object pointer type. */   
##@@@L0584_:        /* PRQA S 3305 2 # Pointer cast to stricter alignment. */   
##@@@L0585_:        Dst32Ptr = (uint32_t *)&Dst8Ptr[Pos];   
8000d760:	68 c0       	ADD       R5, R0, #1
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:543
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
##@@@L0539_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0540_:    default: /* case 1 - Length is always in range [1..3] */   
##@@@L0541_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0542_:        (*Pos)++;   
##@@@L0543_:        (*Src32Ptr) >>= 8U;   
8000d762:	03 25       	ST.W      [SP + #3], R5
8000d764:	c8 7c       	LSR       R9, #8			;->0x08
##@@@F_:kfStdLib_MemCopy32Unaligned():
##@@@P_:kfstdlib.c:647
##@@@L0642_:        {   
##@@@L0643_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0644_:            {   
##@@@L0645_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0646_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0647_:                x1 = Src32Ptr[SrcPos + 0U];   
8000d766:	06 24       	ST.W      [SP + #6], R4
8000d768:	07 22       	ST.W      [SP + #7], R2
8000d76a:	2f cd       	SUB       R5, R7, #4
##@@@P_:kfstdlib.c:648
##@@@L0648_:                x2 = Src32Ptr[SrcPos + 1U];   
8000d76c:	47 82       	LD.W      R4, [R7]
##@@@P_:kfstdlib.c:647
##@@@L0642_:        {   
##@@@L0643_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
##@@@L0644_:            {   
##@@@L0645_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0646_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0647_:                x1 = Src32Ptr[SrcPos + 0U];   
8000d76e:	25 82       	LD.W      R2, [R5]
##@@@P_:kfstdlib.c:653
##@@@L0648_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0649_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0650_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0651_:
##@@@L0652_:                x0      = u32Prev | (x1 << 24U);   
##@@@L0653_:                x1      = (x1 >> 8U) | (x2 << 24U);   
8000d770:	24 58       	MOV       R1, R4
8000d772:	88 7b       	LSL       R1, #24			;->0x18
8000d774:	a2 58       	MOV       R5, R2
8000d776:	a8 7c       	LSR       R5, #8			;->0x08
8000d778:	15 6a       	ORL       R1, R5
##@@@P_:kfstdlib.c:650
##@@@L0645_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0646_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0647_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0648_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0649_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0650_:                x4 = Src32Ptr[SrcPos + 3U];   
8000d77a:	87 98       	LD.W      R0, [R7 + #2]
##@@@P_:kfstdlib.c:649
##@@@L0644_:            {   
##@@@L0645_:                uint32_t x0, x1, x2, x3, x4;   
##@@@L0646_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0647_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0648_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0649_:                x3 = Src32Ptr[SrcPos + 2U];   
8000d77c:	6f 98       	LD.W      R5, [R7 + #1]
##@@@P_:kfstdlib.c:660
##@@@L0655_:                x3      = (x3 >> 8U) | (x4 << 24U);   
##@@@L0656_:                u32Prev = x4 >> 8U;   
##@@@L0657_:
##@@@L0658_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0659_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0660_:                Dst32Ptr[Pos + 1U] = x1;   
8000d77e:	33 cd       	SUB       R6, R3, #4
8000d780:	61 85       	ST.W      [R6], R1
##@@@P_:kfstdlib.c:652
##@@@L0647_:                x1 = Src32Ptr[SrcPos + 0U];   
##@@@L0648_:                x2 = Src32Ptr[SrcPos + 1U];   
##@@@L0649_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0650_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0651_:
##@@@L0652_:                x0      = u32Prev | (x1 << 24U);   
8000d782:	90 7b       	LSL       R2, #24			;->0x18
8000d784:	29 6a       	ORL       R2, R9
##@@@P_:kfstdlib.c:659
##@@@L0654_:                x2      = (x2 >> 8U) | (x3 << 24U);   
##@@@L0655_:                x3      = (x3 >> 8U) | (x4 << 24U);   
##@@@L0656_:                u32Prev = x4 >> 8U;   
##@@@L0657_:
##@@@L0658_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0659_:                Dst32Ptr[Pos + 0U] = x0;   
8000d786:	23 58       	MOV       R1, R3
8000d788:	18 30       	SUB       R1, #8			;->0x08
8000d78a:	12 85       	ST.W      [R1], R2
##@@@P_:kfstdlib.c:654
##@@@L0649_:                x3 = Src32Ptr[SrcPos + 2U];   
##@@@L0650_:                x4 = Src32Ptr[SrcPos + 3U];   
##@@@L0651_:
##@@@L0652_:                x0      = u32Prev | (x1 << 24U);   
##@@@L0653_:                x1      = (x1 >> 8U) | (x2 << 24U);   
##@@@L0654_:                x2      = (x2 >> 8U) | (x3 << 24U);   
8000d78c:	a0 7c       	LSR       R4, #8			;->0x08
8000d78e:	45 58       	MOV       R2, R5
8000d790:	90 7b       	LSL       R2, #24			;->0x18
8000d792:	24 6a       	ORL       R2, R4
##@@@P_:kfstdlib.c:655
##@@@L0655_:                x3      = (x3 >> 8U) | (x4 << 24U);   
8000d794:	a8 7c       	LSR       R5, #8			;->0x08
8000d796:	80 58       	MOV       R4, R0
8000d798:	a0 7b       	LSL       R4, #24			;->0x18
8000d79a:	45 6a       	ORL       R4, R5
##@@@P_:kfstdlib.c:662
##@@@L0657_:
##@@@L0658_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0659_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0660_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0661_:                Dst32Ptr[Pos + 2U] = x2;   
##@@@L0662_:                Dst32Ptr[Pos + 3U] = x3;   
8000d79c:	5c a0       	ST.W      [R3 + #1], R4
8000d79e:	06 0c       	LD.W      R4, [SP + #6]
##@@@P_:kfstdlib.c:661
##@@@L0656_:                u32Prev = x4 >> 8U;   
##@@@L0657_:
##@@@L0658_:                /* PRQA S 2985 1 # This redundant is to improve readability */   
##@@@L0659_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0660_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0661_:                Dst32Ptr[Pos + 2U] = x2;   
8000d7a0:	32 85       	ST.W      [R3], R2
8000d7a2:	07 0a       	LD.W      R2, [SP + #7]
##@@@P_:kfstdlib.c:643
##@@@L0638_:                SrcPos += 4U;   
##@@@L0639_:            }   
##@@@L0640_:        }   
##@@@L0641_:        else /* DstOffset == 1 - 8-bit displacement */   
##@@@L0642_:        {   
##@@@L0643_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d7a4:	70 29       	ADD       R7, #16			;->0x10
8000d7a6:	30 29       	ADD       R3, #16			;->0x10
##@@@P_:kfstdlib.c:664
##@@@L0659_:                Dst32Ptr[Pos + 0U] = x0;   
##@@@L0660_:                Dst32Ptr[Pos + 1U] = x1;   
##@@@L0661_:                Dst32Ptr[Pos + 2U] = x2;   
##@@@L0662_:                Dst32Ptr[Pos + 3U] = x3;   
##@@@L0663_:                Pos += 4U;   
##@@@L0664_:                SrcPos += 4U;   
8000d7a8:	12 c1       	ADD       R2, R2, #4
##@@@P_:kfstdlib.c:656
##@@@L0651_:
##@@@L0652_:                x0      = u32Prev | (x1 << 24U);   
##@@@L0653_:                x1      = (x1 >> 8U) | (x2 << 24U);   
##@@@L0654_:                x2      = (x2 >> 8U) | (x3 << 24U);   
##@@@L0655_:                x3      = (x3 >> 8U) | (x4 << 24U);   
##@@@L0656_:                u32Prev = x4 >> 8U;   
8000d7aa:	80 7c       	LSR       R0, #8			;->0x08
##@@@P_:kfstdlib.c:643
##@@@L0638_:                SrcPos += 4U;   
##@@@L0639_:            }   
##@@@L0640_:        }   
##@@@L0641_:        else /* DstOffset == 1 - 8-bit displacement */   
##@@@L0642_:        {   
##@@@L0643_:            for (; RemainLength >= 16U; RemainLength -= 16U)   
8000d7ac:	40 31       	SUB       R4, #16			;->0x10
8000d7ae:	4f 38       	CMP       R4, #15			;->0x0F
8000d7b0:	20 59       	MOV       R9, R0
8000d7b2:	da f8       	JHI       $-38                  ;->0x8000d766
##@@@P_:kfstdlib.c:669
##@@@L0664_:                SrcPos += 4U;   
##@@@L0665_:            }   
##@@@L0666_:        }   
##@@@L0667_:        /*  Linearly copy the RemainLength words using a loop */   
##@@@L0668_:        {   
##@@@L0669_:            uint32_t prevShift = (DstOffset << 3U) & KFSTDLIB_MASK_31;   
8000d7b4:	72 cc       	SUB       R6, R2, #1
8000d7b6:	04 09       	LD.W      R1, [SP + #4]
8000d7b8:	e4 58       	MOV       R7, R4
8000d7ba:	02 0b       	LD.W      R3, [SP + #2]
##@@@P_:kfstdlib.c:672
##@@@L0670_:            uint32_t xShift    = 32U - prevShift;   
##@@@L0671_:            /* At this point RemainLength is < 16 byte */   
##@@@L0672_:            for (; RemainLength >= 4U; RemainLength -= 4U)   
8000d7bc:	74 38       	CMP       R7, #4			;->0x04
8000d7be:	02 f2       	JC        $+2                   ;->0x8000d7c2
8000d7c0:	66 07       	SJMP      $-154                 ;->0x8000d68c
8000d7c2:	1b 7a       	LSL       R3, #3			;->0x03
8000d7c4:	50 12       	MOV       R5, #32			;->0x0020
8000d7c6:	06 23       	ST.W      [SP + #6], R3
8000d7c8:	ed c6       	SUB       R5, R5, R3
8000d7ca:	05 25       	ST.W      [SP + #5], R5
8000d7cc:	a6 58       	MOV       R5, R6
8000d7ce:	2a 7a       	LSL       R5, #2			;->0x02
8000d7d0:	03 0c       	LD.W      R4, [SP + #3]
8000d7d2:	6c c3       	ADD       R5, R4, R5
8000d7d4:	82 58       	MOV       R4, R2
8000d7d6:	22 7a       	LSL       R4, #2			;->0x02
8000d7d8:	09 c3       	ADD       R1, R1, R4
8000d7da:	27 cd       	SUB       R4, R7, #4
8000d7dc:	22 7c       	LSR       R4, #2			;->0x02
8000d7de:	9c c2       	ADD       R3, R4, R2
8000d7e0:	01 23       	ST.W      [SP + #1], R3
8000d7e2:	64 c0       	ADD       R4, R4, #1
8000d7e4:	67 58       	MOV       R3, R7
##@@@P_:kfstdlib.c:675
##@@@L0673_:            {   
##@@@L0674_:                uint32_t x0, x1;   
##@@@L0675_:                x1            = Src32Ptr[SrcPos];   
8000d7e6:	07 26       	ST.W      [SP + #7], R6
8000d7e8:	71 82       	LD.W      R7, [R1]
##@@@P_:kfstdlib.c:676
##@@@L0676_:                x0            = u32Prev | (x1 << xShift);   
8000d7ea:	47 58       	MOV       R2, R7
8000d7ec:	05 0e       	LD.W      R6, [SP + #5]
8000d7ee:	26 6c       	LSL       R2, R6
8000d7f0:	07 0e       	LD.W      R6, [SP + #7]
8000d7f2:	20 6a       	ORL       R2, R0
##@@@P_:kfstdlib.c:678
##@@@L0677_:                u32Prev       = x1 >> prevShift;   
##@@@L0678_:                Dst32Ptr[Pos] = x0;   
8000d7f4:	52 85       	ST.W      [R5], R2
##@@@P_:kfstdlib.c:677
##@@@L0672_:            for (; RemainLength >= 4U; RemainLength -= 4U)   
##@@@L0673_:            {   
##@@@L0674_:                uint32_t x0, x1;   
##@@@L0675_:                x1            = Src32Ptr[SrcPos];   
##@@@L0676_:                x0            = u32Prev | (x1 << xShift);   
##@@@L0677_:                u32Prev       = x1 >> prevShift;   
8000d7f6:	06 0a       	LD.W      R2, [SP + #6]
8000d7f8:	72 6d       	LSR       R7, R2
##@@@P_:kfstdlib.c:672
##@@@L0667_:        /*  Linearly copy the RemainLength words using a loop */   
##@@@L0668_:        {   
##@@@L0669_:            uint32_t prevShift = (DstOffset << 3U) & KFSTDLIB_MASK_31;   
##@@@L0670_:            uint32_t xShift    = 32U - prevShift;   
##@@@L0671_:            /* At this point RemainLength is < 16 byte */   
##@@@L0672_:            for (; RemainLength >= 4U; RemainLength -= 4U)   
8000d7fa:	2d c1       	ADD       R5, R5, #4
8000d7fc:	09 c1       	ADD       R1, R1, #4
8000d7fe:	1b cd       	SUB       R3, R3, #4
##@@@P_:kfstdlib.c:679
##@@@L0674_:                uint32_t x0, x1;   
##@@@L0675_:                x1            = Src32Ptr[SrcPos];   
##@@@L0676_:                x0            = u32Prev | (x1 << xShift);   
##@@@L0677_:                u32Prev       = x1 >> prevShift;   
##@@@L0678_:                Dst32Ptr[Pos] = x0;   
##@@@L0679_:                Pos++;   
8000d800:	76 c0       	ADD       R6, R6, #1
##@@@P_:kfstdlib.c:672
##@@@L0667_:        /*  Linearly copy the RemainLength words using a loop */   
##@@@L0668_:        {   
##@@@L0669_:            uint32_t prevShift = (DstOffset << 3U) & KFSTDLIB_MASK_31;   
##@@@L0670_:            uint32_t xShift    = 32U - prevShift;   
##@@@L0671_:            /* At this point RemainLength is < 16 byte */   
##@@@L0672_:            for (; RemainLength >= 4U; RemainLength -= 4U)   
8000d802:	64 cc       	SUB       R4, R4, #1
8000d804:	40 38       	CMP       R4, #0			;->0x00
8000d806:	07 58       	MOV       R0, R7
8000d808:	ef f1       	JNZ       $-17                  ;->0x8000d7e6
8000d80a:	83 58       	MOV       R4, R3
8000d80c:	01 0d       	LD.W      R5, [SP + #1]
8000d80e:	55 c0       	ADD       R2, R5, #1
8000d810:	04 09       	LD.W      R1, [SP + #4]
8000d812:	02 0b       	LD.W      R3, [SP + #2]
##@@@P_:kfstdlib.c:685
##@@@L0680_:                SrcPos++;   
##@@@L0681_:            }   
##@@@L0682_:        }   
##@@@L0683_:        /* Copy the RemainLength partial word using a byte-wise algorithm */   
##@@@L0684_:        /* PRQA S 1338,0751 3 # The parameter '%1s' is being modified. */   
##@@@L0685_:        Dst8Ptr = (uint8_t *)&Dst32Ptr[Pos];   
8000d814:	32 7a       	LSL       R6, #2			;->0x02
8000d816:	03 0d       	LD.W      R5, [SP + #3]
8000d818:	85 c3       	ADD       R0, R5, R6
8000d81a:	54 10       	MOV       R5, #4			;->0x0004
##@@@P_:kfstdlib.c:687
##@@@L0686_:        Pos     = 0U;   
##@@@L0687_:        kfStdLib_MemCopy_8bits_PartialWord(Dst8Ptr, &u32Prev, (4U - DstOffset), &Pos);   
8000d81c:	dd c6       	SUB       R3, R5, R3
8000d81e:	50 10       	MOV       R5, #0			;->0x0000
##@@@F_:kfStdLib_MemCopy_8bits_PartialWord():
##@@@P_:kfstdlib.c:528
##@@@L0523_:KF_FORCE_INLINE void kfStdLib_MemCopy_8bits_PartialWord(   
##@@@L0524_:  uint8_t *Dst8Ptr, uint32_t *const Src32Ptr, const uint32_t Length, uint32_t *const Pos)   
##@@@L0525_:{   
##@@@L0526_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0527_:    /* Copy 1 to 3 bytes using a jump table and adapt '*Pos' and '*Src32Ptr' for little endian byte order */   
##@@@L0528_:    switch (Length)   
8000d820:	32 38       	CMP       R3, #2			;->0x02
8000d822:	06 f0       	JZ        $+6                   ;->0x8000d82e
8000d824:	33 38       	CMP       R3, #3			;->0x03
8000d826:	07 f1       	JNZ       $+7                   ;->0x8000d834
##@@@P_:kfstdlib.c:531
##@@@L0529_:    {   
##@@@L0530_:    case 3U:   
##@@@L0531_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d828:	07 83       	ST.B      [R0], R7
8000d82a:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:kfstdlib.c:533
##@@@L0532_:        (*Pos)++;   
##@@@L0533_:        (*Src32Ptr) >>= 8U;   
8000d82c:	b8 7c       	LSR       R7, #8			;->0x08
##@@@P_:kfstdlib.c:536
##@@@L0534_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0535_:    case 2U:   
##@@@L0536_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d82e:	47 eb       	ST.B      [R0 + R5], R7
##@@@P_:kfstdlib.c:538
##@@@L0537_:        (*Pos)++;   
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
8000d830:	b8 7c       	LSR       R7, #8			;->0x08
##@@@P_:kfstdlib.c:537
##@@@L0532_:        (*Pos)++;   
##@@@L0533_:        (*Src32Ptr) >>= 8U;   
##@@@L0534_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0535_:    case 2U:   
##@@@L0536_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
##@@@L0537_:        (*Pos)++;   
8000d832:	6d c0       	ADD       R5, R5, #1
##@@@P_:kfstdlib.c:541
##@@@L0538_:        (*Src32Ptr) >>= 8U;   
##@@@L0539_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0540_:    default: /* case 1 - Length is always in range [1..3] */   
##@@@L0541_:        Dst8Ptr[*Pos] = (uint8_t)*Src32Ptr;   
8000d834:	47 eb       	ST.B      [R0 + R5], R7
##@@@P_:kfstdlib.c:542
##@@@L0542_:        (*Pos)++;   
8000d836:	6d c0       	ADD       R5, R5, #1
8000d838:	e4 58       	MOV       R7, R4
##@@@F_:kfStdLib_MemCopy_8bits_31bytes():
##@@@P_:kfstdlib.c:338
##@@@L0333_:KF_FORCE_INLINE void   
##@@@L0334_:kfStdLib_MemCopy_8bits_31bytes(uint8_t *Dst8Ptr, const uint8_t *const Src8Ptr, const uint32_t Length)   
##@@@L0335_:{   
##@@@L0336_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0337_:    /*  Copy up to 31 bytes using a jump table */   
##@@@L0338_:    switch (Length)   
8000d83a:	5f cc       	SUB       R3, R7, #1
8000d83c:	3e 39       	CMP       R3, #30			;->0x1E
8000d83e:	02 f9       	JLS       $+2                   ;->0x8000d842
8000d840:	47 04       	SJMP      $+71                  ;->0x8000d8ce
##@@@F_:kfStdLib_MemCopy():
8000d842:	40 c3       	ADD       R0, R0, R5
8000d844:	27 45       	LD        R5, [PC + #39]        ;->0x8000d8e0  :=0x800012f0
8000d846:	1a 7a       	LSL       R3, #2			;->0x02
8000d848:	ed e8       	LD.W      R5, [R5 + R3]
8000d84a:	12 7a       	LSL       R2, #2			;->0x02
8000d84c:	89 c2       	ADD       R1, R1, R2
8000d84e:	15 5c       	JMP       R5
8000d850:	a9 8f       	LD.B      R5, [R1 + #30]
8000d852:	85 97       	ST.B      [R0 + #30], R5
8000d854:	69 8f       	LD.B      R5, [R1 + #29]
8000d856:	45 97       	ST.B      [R0 + #29], R5
8000d858:	29 8f       	LD.B      R5, [R1 + #28]
8000d85a:	05 97       	ST.B      [R0 + #28], R5
8000d85c:	e9 8e       	LD.B      R5, [R1 + #27]
8000d85e:	c5 96       	ST.B      [R0 + #27], R5
8000d860:	a9 8e       	LD.B      R5, [R1 + #26]
8000d862:	85 96       	ST.B      [R0 + #26], R5
8000d864:	69 8e       	LD.B      R5, [R1 + #25]
8000d866:	45 96       	ST.B      [R0 + #25], R5
8000d868:	29 8e       	LD.B      R5, [R1 + #24]
8000d86a:	05 96       	ST.B      [R0 + #24], R5
8000d86c:	e9 8d       	LD.B      R5, [R1 + #23]
8000d86e:	c5 95       	ST.B      [R0 + #23], R5
8000d870:	a9 8d       	LD.B      R5, [R1 + #22]
8000d872:	85 95       	ST.B      [R0 + #22], R5
8000d874:	69 8d       	LD.B      R5, [R1 + #21]
8000d876:	45 95       	ST.B      [R0 + #21], R5
8000d878:	29 8d       	LD.B      R5, [R1 + #20]
8000d87a:	05 95       	ST.B      [R0 + #20], R5
8000d87c:	e9 8c       	LD.B      R5, [R1 + #19]
8000d87e:	c5 94       	ST.B      [R0 + #19], R5
8000d880:	a9 8c       	LD.B      R5, [R1 + #18]
8000d882:	85 94       	ST.B      [R0 + #18], R5
8000d884:	69 8c       	LD.B      R5, [R1 + #17]
8000d886:	45 94       	ST.B      [R0 + #17], R5
8000d888:	29 8c       	LD.B      R5, [R1 + #16]
8000d88a:	05 94       	ST.B      [R0 + #16], R5
8000d88c:	e9 8b       	LD.B      R5, [R1 + #15]
8000d88e:	c5 93       	ST.B      [R0 + #15], R5
8000d890:	a9 8b       	LD.B      R5, [R1 + #14]
8000d892:	85 93       	ST.B      [R0 + #14], R5
8000d894:	69 8b       	LD.B      R5, [R1 + #13]
8000d896:	45 93       	ST.B      [R0 + #13], R5
8000d898:	29 8b       	LD.B      R5, [R1 + #12]
8000d89a:	05 93       	ST.B      [R0 + #12], R5
8000d89c:	e9 8a       	LD.B      R5, [R1 + #11]
8000d89e:	c5 92       	ST.B      [R0 + #11], R5
8000d8a0:	a9 8a       	LD.B      R5, [R1 + #10]
8000d8a2:	85 92       	ST.B      [R0 + #10], R5
8000d8a4:	69 8a       	LD.B      R5, [R1 + #9]
8000d8a6:	45 92       	ST.B      [R0 + #9], R5
8000d8a8:	29 8a       	LD.B      R5, [R1 + #8]
8000d8aa:	05 92       	ST.B      [R0 + #8], R5
8000d8ac:	e9 89       	LD.B      R5, [R1 + #7]
8000d8ae:	c5 91       	ST.B      [R0 + #7], R5
8000d8b0:	a9 89       	LD.B      R5, [R1 + #6]
8000d8b2:	85 91       	ST.B      [R0 + #6], R5
8000d8b4:	69 89       	LD.B      R5, [R1 + #5]
8000d8b6:	45 91       	ST.B      [R0 + #5], R5
8000d8b8:	29 c1       	ADD       R5, R1, #4
8000d8ba:	55 80       	LD.B      R5, [R5]
8000d8bc:	05 91       	ST.B      [R0 + #4], R5
8000d8be:	e9 88       	LD.B      R5, [R1 + #3]
8000d8c0:	c5 90       	ST.B      [R0 + #3], R5
8000d8c2:	a9 88       	LD.B      R5, [R1 + #2]
8000d8c4:	85 90       	ST.B      [R0 + #2], R5
8000d8c6:	69 88       	LD.B      R5, [R1 + #1]
8000d8c8:	45 90       	ST.B      [R0 + #1], R5
8000d8ca:	51 80       	LD.B      R5, [R1]
8000d8cc:	05 83       	ST.B      [R0], R5
##@@@P_:kfstdlib.c:824
##@@@L0819_:    for (RemainLength = 0; RemainLength < Length; RemainLength++)   
##@@@L0820_:    {   
##@@@L0821_:        ((uint8_t *)(DstPtr))[RemainLength] = ((const uint8_t *)(SrcPtr))[RemainLength];   
##@@@L0822_:    }   
##@@@L0823_:#endif   
##@@@L0824_:}   
8000d8ce:	e0 2a       	ADD       SP, #32			;->0x20
8000d8d0:	0f 5e       	POP       {R6-R9}
8000d8d2:	1d 5c       	JMP       LR
8000d8d4:	a8 13 00 80 	.long     0x800013a8 ->-2147478616  [!!!@2@:MOV       R10, #56	@@: LD.B      R0, [R0]
8000d8d8:	e0 12 00 80 	.long     0x800012e0 ->-2147478816  [!!!@2@:MOV       SP, #32	@@: LD.B      R0, [R0]
8000d8dc:	6c 13 00 80 	.long     0x8000136c ->-2147478676  [!!!@2@:MOV       R6, #60	@@: LD.B      R0, [R0]
8000d8e0:	f0 12 00 80 	.long     0x800012f0 ->-2147478800  [!!!@2@:MOV       PC, #32	@@: LD.B      R0, [R0]
##@@@F_:kfStdLib_MemCopy_32bitsAligned():
##@@@P_:kfstdlib.c:478
##@@@L0473_:    {   
##@@@L0474_:    case 15U:   
##@@@L0475_:    case 14U:   
##@@@L0476_:    case 13U:   
##@@@L0477_:    case 12U:   
##@@@L0478_:        Dst32Ptr[Pos] = Src32Ptr[Pos];   
8000d8e4:	22 82       	LD.W      R2, [R2]
8000d8e6:	32 85       	ST.W      [R3], R2
8000d8e8:	c5 58       	MOV       R6, R5
##@@@P_:kfstdlib.c:486
##@@@L0481_:    case 11U:   
##@@@L0482_:    case 10U:   
##@@@L0483_:    case 9U:   
##@@@L0484_:    case 8U:   
##@@@L0485_:        Dst32Ptr[Pos] = Src32Ptr[Pos];   
##@@@L0486_:        Pos++;   
8000d8ea:	6e c0       	ADD       R5, R6, #1
##@@@P_:kfstdlib.c:485
##@@@L0480_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0481_:    case 11U:   
##@@@L0482_:    case 10U:   
##@@@L0483_:    case 9U:   
##@@@L0484_:    case 8U:   
##@@@L0485_:        Dst32Ptr[Pos] = Src32Ptr[Pos];   
8000d8ec:	32 7a       	LSL       R6, #2			;->0x02
8000d8ee:	04 0f       	LD.W      R7, [SP + #4]
8000d8f0:	9f e9       	LD.W      R3, [R7 + R6]
8000d8f2:	83 ef       	ST.W      [R0 + R6], R3
8000d8f4:	41 58       	MOV       R2, R1
8000d8f6:	27 58       	MOV       R1, R7
##@@@P_:kfstdlib.c:493
##@@@L0488_:    case 7U:   
##@@@L0489_:    case 6U:   
##@@@L0490_:    case 5U:   
##@@@L0491_:    case 4U:   
##@@@L0492_:        Dst32Ptr[Pos] = Src32Ptr[Pos];   
##@@@L0493_:        Pos++;   
8000d8f8:	75 c0       	ADD       R6, R5, #1
##@@@P_:kfstdlib.c:492
##@@@L0487_:        /* PRQA S 2003 1 # intentionally no break */   
##@@@L0488_:    case 7U:   
##@@@L0489_:    case 6U:   
##@@@L0490_:    case 5U:   
##@@@L0491_:    case 4U:   
##@@@L0492_:        Dst32Ptr[Pos] = Src32Ptr[Pos];   
8000d8fa:	2a 7a       	LSL       R5, #2			;->0x02
8000d8fc:	59 e9       	LD.W      R3, [R1 + R5]
8000d8fe:	43 ef       	ST.W      [R0 + R5], R3
8000d900:	03 04       	SJMP      $+3                   ;->0x8000d906
8000d902:	41 58       	MOV       R2, R1
8000d904:	04 09       	LD.W      R1, [SP + #4]
##@@@P_:kfstdlib.c:500
##@@@L0495_:    case 3U:   
##@@@L0496_:    case 2U:   
##@@@L0497_:    case 1U:   
##@@@L0498_:        /* PRQA S 0751 3 # Casting to char pointer type.*/   
##@@@L0499_:        kfStdLib_MemCopy_8bits_3bytes(   
##@@@L0500_:          (uint8_t *)&Dst32Ptr[Pos], (const uint8_t *)&Src32Ptr[Pos], (uint32_t)(RemainLength & KFSTDLIB_MASK_3));   
8000d906:	32 7a       	LSL       R6, #2			;->0x02
8000d908:	89 c3       	ADD       R1, R1, R6
8000d90a:	80 c3       	ADD       R0, R0, R6
8000d90c:	24 69       	ANL       R2, R4
##@@@F_:kfStdLib_MemCopy_8bits_3bytes():
##@@@P_:kfstdlib.c:301
##@@@L0296_:KF_FORCE_INLINE void   
##@@@L0297_:kfStdLib_MemCopy_8bits_3bytes(uint8_t *Dst8Ptr, const uint8_t *const Src8Ptr, const uint32_t Length)   
##@@@L0298_:{   
##@@@L0299_:#if (KFSTDLIB_USE_JUMPTABLES == STD_ON)   
##@@@L0300_:    /*  Copy up to 3 bytes using a jump table */   
##@@@L0301_:    switch (Length)   
8000d90e:	21 38       	CMP       R2, #1			;->0x01
8000d910:	dd f0       	JZ        $-35                  ;->0x8000d8ca
8000d912:	22 38       	CMP       R2, #2			;->0x02
8000d914:	d9 f0       	JZ        $-39                  ;->0x8000d8c6
8000d916:	23 38       	CMP       R2, #3			;->0x03
8000d918:	d5 f0       	JZ        $-43                  ;->0x8000d8c2
8000d91a:	da 07       	SJMP      $-38                  ;->0x8000d8ce

8000d91c <kfStdLib_MemCopy16>:
##@@@F_:kfStdLib_MemCopy16():
##@@@P_:kfstdlib.c:841
##@@@L0836_:    KF_STDLIB_ASSERT(Src16Ptr != NULL_PTR);   
##@@@L0837_:    kfStdLib_LengthType RemainLength = 0U;   
##@@@L0838_:
##@@@L0839_:    /* Linearly copy Length 16-bit blocks using a loop */   
##@@@L0840_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0841_:    for (RemainLength = 0U; RemainLength < Length; RemainLength++)   
8000d91c:	20 38       	CMP       R2, #0			;->0x00
8000d91e:	08 f0       	JZ        $+8                   ;->0x8000d92e
##@@@P_:kfstdlib.c:843
##@@@L0842_:    {   
##@@@L0843_:        (Dst16Ptr)[RemainLength] = (Src16Ptr)[RemainLength];   
8000d920:	51 81       	LD.H      R5, [R1]
8000d922:	05 84       	ST.H      [R0], R5
##@@@P_:kfstdlib.c:841
##@@@L0836_:    KF_STDLIB_ASSERT(Src16Ptr != NULL_PTR);   
##@@@L0837_:    kfStdLib_LengthType RemainLength = 0U;   
##@@@L0838_:
##@@@L0839_:    /* Linearly copy Length 16-bit blocks using a loop */   
##@@@L0840_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0841_:    for (RemainLength = 0U; RemainLength < Length; RemainLength++)   
8000d924:	89 c0       	ADD       R1, R1, #2
8000d926:	80 c0       	ADD       R0, R0, #2
8000d928:	52 cc       	SUB       R2, R2, #1
8000d92a:	20 38       	CMP       R2, #0			;->0x00
8000d92c:	fa f1       	JNZ       $-6                   ;->0x8000d920
##@@@P_:kfstdlib.c:845
##@@@L0842_:    {   
##@@@L0843_:        (Dst16Ptr)[RemainLength] = (Src16Ptr)[RemainLength];   
##@@@L0844_:    }   
##@@@L0845_:}   
8000d92e:	1d 5c       	JMP       LR

8000d930 <kfStdLib_MemCopy32>:
##@@@F_:kfStdLib_MemCopy32():
##@@@P_:kfstdlib.c:862
##@@@L0857_:    KF_STDLIB_ASSERT(Src32Ptr != NULL_PTR);   
##@@@L0858_:    kfStdLib_LengthType RemainLength = 0U;   
##@@@L0859_:
##@@@L0860_:    /* Linearly copy Length 32-bit blocks using a loop */   
##@@@L0861_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0862_:    for (RemainLength = 0U; RemainLength < Length; RemainLength++)   
8000d930:	20 38       	CMP       R2, #0			;->0x00
8000d932:	08 f0       	JZ        $+8                   ;->0x8000d942
##@@@P_:kfstdlib.c:864
##@@@L0863_:    {   
##@@@L0864_:        (Dst32Ptr)[RemainLength] = (Src32Ptr)[RemainLength];   
8000d934:	51 82       	LD.W      R5, [R1]
8000d936:	05 85       	ST.W      [R0], R5
##@@@P_:kfstdlib.c:862
##@@@L0857_:    KF_STDLIB_ASSERT(Src32Ptr != NULL_PTR);   
##@@@L0858_:    kfStdLib_LengthType RemainLength = 0U;   
##@@@L0859_:
##@@@L0860_:    /* Linearly copy Length 32-bit blocks using a loop */   
##@@@L0861_:    /* PRQA S 3544 3 # Possible: Using a tainted variable in a loop control expression */   
##@@@L0862_:    for (RemainLength = 0U; RemainLength < Length; RemainLength++)   
8000d938:	09 c1       	ADD       R1, R1, #4
8000d93a:	00 c1       	ADD       R0, R0, #4
8000d93c:	52 cc       	SUB       R2, R2, #1
8000d93e:	20 38       	CMP       R2, #0			;->0x00
8000d940:	fa f1       	JNZ       $-6                   ;->0x8000d934
##@@@P_:kfstdlib.c:866
##@@@L0863_:    {   
##@@@L0864_:        (Dst32Ptr)[RemainLength] = (Src32Ptr)[RemainLength];   
##@@@L0865_:    }   
##@@@L0866_:}   
8000d942:	1d 5c       	JMP       LR

8000d944 <kfStdLib_MemCopy_s>:
##@@@F_:kfStdLib_MemCopy_s():
##@@@P_:kfstdlib.c:880
##@@@L0875_: * @param DstSize   
##@@@L0876_: * @param SrcPtr   
##@@@L0877_: * @param Length   
##@@@L0878_: */   
##@@@L0879_:void kfStdLib_MemCopy_s(void *DstPtr, kfStdLib_LengthType DstSize, void *SrcPtr, kfStdLib_LengthType Length)   
##@@@L0880_:{   
8000d944:	2d 5d       	PUSH      LR
8000d946:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:kfstdlib.c:881
##@@@L0881_:    if (Length > DstSize)   
8000d948:	31 70       	CMP       R3, R1
8000d94a:	05 f8       	JHI       $+5                   ;->0x8000d954
##@@@P_:kfstdlib.c:887
##@@@L0882_:    {   
##@@@L0883_:    }   
##@@@L0884_:    else   
##@@@L0885_:    {   
##@@@L0886_:        /*  Call kfStdLib_MemCopy() */   
##@@@L0887_:        kfStdLib_MemCopy(DstPtr, SrcPtr, Length);   
8000d94c:	22 58       	MOV       R1, R2
8000d94e:	43 58       	MOV       R2, R3
8000d950:	03 45       	LD        R5, [PC + #3]         ;->0x8000d95c  :=0x8000d5b8
8000d952:	05 5c       	LJMP      R5
##@@@P_:kfstdlib.c:889
##@@@L0888_:    }   
##@@@L0889_:}   
8000d954:	e4 28       	ADD       SP, #4			;->0x04
8000d956:	0d 5d       	POP       LR
8000d958:	1d 5c       	JMP       LR
8000d95a:	00 00       	NOP      NOP      
8000d95c:	b8 d5 00 80 	.long     0x8000d5b8 ->-2147428936  [!!!@2@:ANL       R7, R0, R6	@@: LD.B      R0, [R0]

8000d960 <__lshrdi3>:
##@@@F_:__lshrdi3():
8000d960:	a1 58       	MOV       R5, R1
8000d962:	40 12       	MOV       R4, #32			;->0x0020
8000d964:	62 58       	MOV       R3, R2
8000d966:	34 69       	ANL       R3, R4
8000d968:	30 38       	CMP       R3, #0			;->0x00
8000d96a:	0c f1       	JNZ       $+12                  ;->0x8000d982
8000d96c:	20 38       	CMP       R2, #0			;->0x00
8000d96e:	0f f0       	JZ        $+15                  ;->0x8000d98c
8000d970:	02 6d       	LSR       R0, R2
8000d972:	a4 c6       	SUB       R4, R4, R2
8000d974:	65 58       	MOV       R3, R5
8000d976:	34 6c       	LSL       R3, R4
8000d978:	30 6a       	ORL       R3, R0
8000d97a:	52 6d       	LSR       R5, R2
8000d97c:	25 58       	MOV       R1, R5
8000d97e:	03 58       	MOV       R0, R3
8000d980:	1d 5c       	JMP       LR
8000d982:	20 32       	SUB       R2, #32			;->0x20
8000d984:	52 6d       	LSR       R5, R2
8000d986:	10 10       	MOV       R1, #0			;->0x0000
8000d988:	05 58       	MOV       R0, R5
8000d98a:	1d 5c       	JMP       LR
8000d98c:	25 58       	MOV       R1, R5
8000d98e:	1d 5c       	JMP       LR

8000d990 <__muldi3>:
##@@@F_:__muldi3():
8000d990:	03 5f       	PUSH      {R6-R7}
8000d992:	e8 30       	SUB       SP, #8			;->0x08
8000d994:	83 58       	MOV       R4, R3
8000d996:	15 47       	LD        R7, [PC + #21]        ;->0x8000d9e8  :=0xffff
8000d998:	a0 58       	MOV       R5, R0
8000d99a:	57 69       	ANL       R5, R7
8000d99c:	c2 58       	MOV       R6, R2
8000d99e:	67 69       	ANL       R6, R7
8000d9a0:	5e cb       	MULS      R3, R6, R5
8000d9a2:	00 00       	NOP      NOP      
8000d9a4:	24 ca       	MULS      R4, R4, R0
8000d9a6:	00 00       	NOP      NOP      
8000d9a8:	01 24       	ST.W      [SP + #1], R4
8000d9aa:	00 7d       	LSR       R0, #16			;->0x10
8000d9ac:	36 ca       	MULS      R6, R6, R0
8000d9ae:	00 00       	NOP      NOP      
8000d9b0:	83 58       	MOV       R4, R3
8000d9b2:	20 7d       	LSR       R4, #16			;->0x10
8000d9b4:	b4 c3       	ADD       R6, R4, R6
8000d9b6:	37 69       	ANL       R3, R7
8000d9b8:	86 58       	MOV       R4, R6
8000d9ba:	47 69       	ANL       R4, R7
8000d9bc:	89 ca       	MULS      R1, R1, R2
8000d9be:	00 00       	NOP      NOP      
8000d9c0:	10 7d       	LSR       R2, #16			;->0x10
8000d9c2:	6a cb       	MULS      R5, R2, R5
8000d9c4:	00 00       	NOP      NOP      
8000d9c6:	64 c3       	ADD       R4, R4, R5
8000d9c8:	a4 58       	MOV       R5, R4
8000d9ca:	28 7b       	LSL       R5, #16			;->0x10
8000d9cc:	53 6a       	ORL       R5, R3
8000d9ce:	01 0b       	LD.W      R3, [SP + #1]
8000d9d0:	5b c2       	ADD       R3, R3, R1
8000d9d2:	12 ca       	MULS      R2, R2, R0
8000d9d4:	00 00       	NOP      NOP      
8000d9d6:	9b c2       	ADD       R3, R3, R2
8000d9d8:	30 7d       	LSR       R6, #16			;->0x10
8000d9da:	9b c3       	ADD       R3, R3, R6
8000d9dc:	20 7d       	LSR       R4, #16			;->0x10
8000d9de:	0b c3       	ADD       R1, R3, R4
8000d9e0:	05 58       	MOV       R0, R5
8000d9e2:	e8 28       	ADD       SP, #8			;->0x08
8000d9e4:	03 5e       	POP       {R6-R7}
8000d9e6:	1d 5c       	JMP       LR
8000d9e8:	ff ff 00 00 	.long     0x0000ffff ->000065535 

8000d9ec <memcpy>:
##@@@F_:memcpy():
##@@@P_:memcpy.c:78
8000d9ec:	20 38       	CMP       R2, #0			;->0x00
8000d9ee:	09 f0       	JZ        $+9                   ;->0x8000da00
8000d9f0:	a0 58       	MOV       R5, R0
##@@@P_:memcpy.c:80
8000d9f2:	41 80       	LD.B      R4, [R1]
8000d9f4:	54 83       	ST.B      [R5], R4
8000d9f6:	6d c0       	ADD       R5, R5, #1
8000d9f8:	49 c0       	ADD       R1, R1, #1
##@@@P_:memcpy.c:78
8000d9fa:	52 cc       	SUB       R2, R2, #1
8000d9fc:	20 38       	CMP       R2, #0			;->0x00
8000d9fe:	fa f1       	JNZ       $-6                   ;->0x8000d9f2
##@@@P_:memcpy.c:83
8000da00:	1d 5c       	JMP       LR
	...

8000da04 <memset>:
##@@@F_:memset():
##@@@P_:memset.c:111
8000da04:	20 38       	CMP       R2, #0			;->0x00
8000da06:	07 f0       	JZ        $+7                   ;->0x8000da14
8000da08:	a0 58       	MOV       R5, R0
##@@@P_:memset.c:112
8000da0a:	51 83       	ST.B      [R5], R1
8000da0c:	6d c0       	ADD       R5, R5, #1
##@@@P_:memset.c:111
8000da0e:	52 cc       	SUB       R2, R2, #1
8000da10:	20 38       	CMP       R2, #0			;->0x00
8000da12:	fc f1       	JNZ       $-4                   ;->0x8000da0a
##@@@P_:memset.c:114
8000da14:	1d 5c       	JMP       LR
	...

8000da18 <strcpy>:
##@@@F_:strcpy():
##@@@P_:strcpy.c:76
8000da18:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:strcpy.c:81
8000da1a:	61 e5       	LD.B      R4, [R1 + R5]
8000da1c:	44 eb       	ST.B      [R0 + R5], R4
8000da1e:	6d c0       	ADD       R5, R5, #1
8000da20:	40 38       	CMP       R4, #0			;->0x00
8000da22:	fc f1       	JNZ       $-4                   ;->0x8000da1a
##@@@P_:strcpy.c:84
8000da24:	1d 5c       	JMP       LR
	...

8000da28 <strlen>:
##@@@F_:strlen():
##@@@P_:strlen.c:70
8000da28:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:strlen.c:97
8000da2a:	60 e5       	LD.B      R4, [R0 + R5]
8000da2c:	6d c0       	ADD       R5, R5, #1
8000da2e:	40 38       	CMP       R4, #0			;->0x00
8000da30:	fd f1       	JNZ       $-3                   ;->0x8000da2a
##@@@P_:strlen.c:99
8000da32:	45 cc       	SUB       R0, R5, #1
8000da34:	1d 5c       	JMP       LR
	...

8000da38 <snprintf_usart>:
##@@@F_:snprintf_usart():
##@@@P_:_usart_snprintf.c:13
8000da38:	e8 30       	SUB       SP, #8			;->0x08
8000da3a:	2d 5d       	PUSH      LR
8000da3c:	e8 30       	SUB       SP, #8			;->0x08
8000da3e:	04 24       	ST.W      [SP + #4], R4
8000da40:	03 23       	ST.W      [SP + #3], R3
8000da42:	05 43       	LD        R3, [PC + #5]         ;->0x8000da54  :=0xc
8000da44:	3e 64       	ADD       R3, SP
##@@@P_:_usart_snprintf.c:16
8000da46:	01 23       	ST.W      [SP + #1], R3
##@@@P_:_usart_snprintf.c:17
8000da48:	04 45       	LD        R5, [PC + #4]         ;->0x8000da58  :=0x8000da5c
8000da4a:	05 5c       	LJMP      R5
##@@@P_:_usart_snprintf.c:19
8000da4c:	e8 28       	ADD       SP, #8			;->0x08
8000da4e:	0d 5d       	POP       LR
8000da50:	e8 28       	ADD       SP, #8			;->0x08
8000da52:	1d 5c       	JMP       LR
8000da54:	0c 00 00 00 	.long     0x0000000c ->000000012  [!!!@2@:MRET     	@@: NOP      
8000da58:	5c da 00 80 	.long     0x8000da5c ->-2147427748  [!!!@2@:LSL       R3, R4, R1	@@: LD.B      R0, [R0]

8000da5c <vsnprintf_usart>:
##@@@F_:vsnprintf_usart():
##@@@P_:_usart_vsnprintf.c:14
8000da5c:	83 5f       	PUSH      {R6-R7,LR}
8000da5e:	19 45       	LD        R5, [PC + #25]        ;->0x8000dac0  :=0x20c
8000da60:	e5 66       	SUB       SP, R5
8000da62:	19 45       	LD        R5, [PC + #25]        ;->0x8000dac4  :=0x320
##@@@P_:_usart_vsnprintf.c:19
8000da64:	19 44       	LD        R4, [PC + #25]        ;->0x8000dac8  :=0x9000ed00
8000da66:	6c c3       	ADD       R5, R4, R5
8000da68:	19 44       	LD        R4, [PC + #25]        ;->0x8000dacc  :=0xc
8000da6a:	4e 64       	ADD       R4, SP
8000da6c:	45 70       	CMP       R4, R5
8000da6e:	04 f2       	JC        $+4                   ;->0x8000da76
8000da70:	60 10       	MOV       R6, #0			;->0x0000
##@@@P_:_usart_vsnprintf.c:20
8000da72:	06 83       	ST.B      [R0], R6
8000da74:	20 04       	SJMP      $+32                  ;->0x8000dab4
8000da76:	e1 58       	MOV       R7, R1
8000da78:	02 20       	ST.W      [SP + #2], R0
8000da7a:	15 40       	LD        R0, [PC + #21]        ;->0x8000dacc  :=0xc
8000da7c:	0e 64       	ADD       R0, SP
##@@@P_:_usart_vsnprintf.c:23
8000da7e:	22 58       	MOV       R1, R2
8000da80:	43 58       	MOV       R2, R3
8000da82:	14 45       	LD        R5, [PC + #20]        ;->0x8000dad0  :=0x8000dad8
8000da84:	05 5c       	LJMP      R5
8000da86:	c0 58       	MOV       R6, R0
##@@@P_:_usart_vsnprintf.c:24
8000da88:	70 38       	CMP       R7, #0			;->0x00
8000da8a:	15 f0       	JZ        $+21                  ;->0x8000dab4
##@@@P_:_usart_vsnprintf.c:25
8000da8c:	67 70       	CMP       R6, R7
8000da8e:	08 fa       	JGE       $+8                   ;->0x8000da9e
##@@@P_:_usart_vsnprintf.c:26
8000da90:	56 c0       	ADD       R2, R6, #1
8000da92:	0f 41       	LD        R1, [PC + #15]        ;->0x8000dacc  :=0xc
8000da94:	1e 64       	ADD       R1, SP
8000da96:	02 08       	LD.W      R0, [SP + #2]
8000da98:	0f 45       	LD        R5, [PC + #15]        ;->0x8000dad4  :=0x8000d9ec
8000da9a:	05 5c       	LJMP      R5
8000da9c:	0c 04       	SJMP      $+12                  ;->0x8000dab4
##@@@P_:_usart_vsnprintf.c:28
8000da9e:	57 cc       	SUB       R2, R7, #1
8000daa0:	01 22       	ST.W      [SP + #1], R2
8000daa2:	0b 41       	LD        R1, [PC + #11]        ;->0x8000dacc  :=0xc
8000daa4:	1e 64       	ADD       R1, SP
8000daa6:	02 0f       	LD.W      R7, [SP + #2]
8000daa8:	07 58       	MOV       R0, R7
8000daaa:	0b 45       	LD        R5, [PC + #11]        ;->0x8000dad4  :=0x8000d9ec
8000daac:	05 5c       	LJMP      R5
8000daae:	50 10       	MOV       R5, #0			;->0x0000
8000dab0:	01 0c       	LD.W      R4, [SP + #1]
8000dab2:	3d eb       	ST.B      [R7 + R4], R5
##@@@P_:_usart_vsnprintf.c:33
8000dab4:	06 58       	MOV       R0, R6
8000dab6:	03 45       	LD        R5, [PC + #3]         ;->0x8000dac0  :=0x20c
8000dab8:	e5 64       	ADD       SP, R5
8000daba:	03 5e       	POP       {R6-R7}
8000dabc:	0d 5d       	POP       LR
8000dabe:	1d 5c       	JMP       LR
8000dac0:	0c 02 00 00 	.long     0x0000020c ->000000524 
8000dac4:	20 03 00 00 	.long     0x00000320 ->000000800  [!!!@4@:JMP       $+2097152             ;->0x8040dac4
8000dac8:	00 ed 00 90 	.long     0x9000ed00 ->-1878987520  [!!!@2@:ST.H      [R0 + R4], R0	@@: ST.B      [R0 + #0], R0
8000dacc:	0c 00 00 00 	.long     0x0000000c ->000000012  [!!!@2@:MRET     	@@: NOP      
8000dad0:	d8 da 00 80 	.long     0x8000dad8 ->-2147427624  [!!!@2@:LSL       R3, R0, R3	@@: LD.B      R0, [R0]
8000dad4:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]

8000dad8 <vsprintf_usart>:
##@@@F_:vsprintf_usart():
##@@@P_:_usart_vsprintf.c:13
8000dad8:	ff 5f       	PUSH      {R6-R12,LR}
8000dada:	e4 36       	SUB       SP, #100			;->0x64
8000dadc:	18 22       	ST.W      [SP + #24], R2
8000dade:	90 10       	MOV       R9, #0			;->0x0000
8000dae0:	c6 45       	LD        R5, [PC + #198]       ;->0x8000ddf8  :=0x38
8000dae2:	5e 64       	ADD       R5, SP
8000dae4:	6d c0       	ADD       R5, R5, #1
8000dae6:	04 25       	ST.W      [SP + #4], R5
8000dae8:	a1 10       	MOV       R10, #1			;->0x0001
8000daea:	50 12       	MOV       R5, #32			;->0x0020
8000daec:	08 25       	ST.W      [SP + #8], R5
8000daee:	52 10       	MOV       R5, #2			;->0x0002
8000daf0:	03 25       	ST.W      [SP + #3], R5
8000daf2:	50 13       	MOV       R5, #48			;->0x0030
8000daf4:	02 25       	ST.W      [SP + #2], R5
8000daf6:	cf 1f       	MOV       R12, #255			;->0x00FF
8000daf8:	5b 12       	MOV       R5, #43			;->0x002B
8000dafa:	01 25       	ST.W      [SP + #1], R5
8000dafc:	49 58       	MOV       R2, R9
##@@@P_:_usart_vsprintf.c:48
8000dafe:	51 80       	LD.B      R5, [R1]
8000db00:	55 3a       	CMP       R5, #37			;->0x25
8000db02:	08 f0       	JZ        $+8                   ;->0x8000db12
8000db04:	50 38       	CMP       R5, #0			;->0x00
8000db06:	02 f1       	JNZ       $+2                   ;->0x8000db0a
8000db08:	a9 05       	SJMP      $+425                 ;->0x8000de5a
##@@@P_:_usart_vsprintf.c:295
8000db0a:	05 83       	ST.B      [R0], R5
##@@@P_:_usart_vsprintf.c:296
8000db0c:	52 c0       	ADD       R2, R2, #1
##@@@P_:_usart_vsprintf.c:295
8000db0e:	40 c0       	ADD       R0, R0, #1
8000db10:	9d 05       	SJMP      $+413                 ;->0x8000de4a
##@@@P_:_usart_vsprintf.c:70
8000db12:	71 88       	LD.B      R6, [R1 + #1]
8000db14:	60 3b       	CMP       R6, #48			;->0x30
8000db16:	09 f0       	JZ        $+9                   ;->0x8000db28
8000db18:	65 3a       	CMP       R6, #37			;->0x25
8000db1a:	0c f1       	JNZ       $+12                  ;->0x8000db32
8000db1c:	55 12       	MOV       R5, #37			;->0x0025
##@@@P_:_usart_vsprintf.c:73
8000db1e:	05 83       	ST.B      [R0], R5
##@@@P_:_usart_vsprintf.c:75
8000db20:	89 c0       	ADD       R1, R1, #2
8000db22:	52 c0       	ADD       R2, R2, #1
8000db24:	40 c0       	ADD       R0, R0, #1
8000db26:	ec 07       	SJMP      $-20                  ;->0x8000dafe
##@@@P_:_usart_vsprintf.c:85
8000db28:	b1 88       	LD.B      R6, [R1 + #2]
8000db2a:	02 0b       	LD.W      R3, [SP + #2]
8000db2c:	a3 59       	MOV       LR, R3
8000db2e:	03 0d       	LD.W      R5, [SP + #3]
8000db30:	04 04       	SJMP      $+4                   ;->0x8000db38
8000db32:	08 0b       	LD.W      R3, [SP + #8]
8000db34:	a3 59       	MOV       LR, R3
8000db36:	aa 58       	MOV       R5, R10
##@@@P_:_usart_vsprintf.c:83
8000db38:	69 c3       	ADD       R5, R1, R5
##@@@P_:_usart_vsprintf.c:85
8000db3a:	6c 69       	ANL       R6, R12
8000db3c:	8a 58       	MOV       R4, R10
8000db3e:	6d 3a       	CMP       R6, #45			;->0x2D
8000db40:	02 f0       	JZ        $+2                   ;->0x8000db44
8000db42:	89 58       	MOV       R4, R9
##@@@P_:_usart_vsprintf.c:91
8000db44:	1d e5       	LD.B      R3, [R5 + R4]
8000db46:	08 0f       	LD.W      R7, [SP + #8]
8000db48:	30 3a       	CMP       R3, #32			;->0x20
8000db4a:	02 f0       	JZ        $+2                   ;->0x8000db4e
8000db4c:	01 0f       	LD.W      R7, [SP + #1]
8000db4e:	25 c3       	ADD       R4, R5, R4
8000db50:	2a 58       	MOV       R1, R10
8000db52:	30 3a       	CMP       R3, #32			;->0x20
8000db54:	02 f0       	JZ        $+2                   ;->0x8000db58
8000db56:	29 58       	MOV       R1, R9
8000db58:	0d 22       	ST.W      [SP + #13], R2
##@@@P_:_usart_vsprintf.c:98
8000db5a:	5c e4       	LD.B      R3, [R4 + R1]
8000db5c:	aa 58       	MOV       R5, R10
8000db5e:	3b 3a       	CMP       R3, #43			;->0x2B
8000db60:	02 f0       	JZ        $+2                   ;->0x8000db64
8000db62:	a9 58       	MOV       R5, R9
8000db64:	06 21       	ST.W      [SP + #6], R1
##@@@P_:_usart_vsprintf.c:91
8000db66:	64 c2       	ADD       R4, R4, R1
##@@@P_:_usart_vsprintf.c:105
8000db68:	5c e5       	LD.B      R3, [R4 + R5]
8000db6a:	23 58       	MOV       R1, R3
8000db6c:	11 33       	SUB       R1, #49			;->0x31
8000db6e:	1c 69       	ANL       R1, R12
8000db70:	0a 25       	ST.W      [SP + #10], R5
##@@@P_:_usart_vsprintf.c:98
8000db72:	54 c3       	ADD       R2, R4, R5
##@@@P_:_usart_vsprintf.c:105
8000db74:	18 38       	CMP       R1, #8			;->0x08
8000db76:	0c 26       	ST.W      [SP + #12], R6
8000db78:	10 f8       	JHI       $+16                  ;->0x8000db98
8000db7a:	60 10       	MOV       R6, #0			;->0x0000
8000db7c:	4a 10       	MOV       R4, #10			;->0x000A
8000db7e:	19 00 c4 0c 	MADD32    R3, R6, R4
##@@@P_:_usart_vsprintf.c:107
8000db82:	62 88       	LD.B      R4, [R2 + #1]
8000db84:	24 58       	MOV       R1, R4
8000db86:	10 33       	SUB       R1, #48			;->0x30
8000db88:	1c 69       	ANL       R1, R12
##@@@P_:_usart_vsprintf.c:110
8000db8a:	52 c0       	ADD       R2, R2, #1
##@@@P_:_usart_vsprintf.c:109
8000db8c:	30 33       	SUB       R3, #48			;->0x30
8000db8e:	c3 58       	MOV       R6, R3
##@@@P_:_usart_vsprintf.c:107
8000db90:	1a 38       	CMP       R1, #10			;->0x0A
8000db92:	64 58       	MOV       R3, R4
8000db94:	f4 f3       	JNC       $-12                  ;->0x8000db7c
8000db96:	03 04       	SJMP      $+3                   ;->0x8000db9c
8000db98:	83 58       	MOV       R4, R3
8000db9a:	c9 58       	MOV       R6, R9
##@@@P_:_usart_vsprintf.c:114
8000db9c:	64 58       	MOV       R3, R4
8000db9e:	3c 69       	ANL       R3, R12
8000dba0:	3e 3a       	CMP       R3, #46			;->0x2E
8000dba2:	18 f1       	JNZ       $+24                  ;->0x8000dbd2
##@@@P_:_usart_vsprintf.c:118
8000dba4:	62 88       	LD.B      R4, [R2 + #1]
8000dba6:	64 58       	MOV       R3, R4
8000dba8:	30 33       	SUB       R3, #48			;->0x30
8000dbaa:	3c 69       	ANL       R3, R12
8000dbac:	52 c0       	ADD       R2, R2, #1
8000dbae:	50 10       	MOV       R5, #0			;->0x0000
8000dbb0:	39 38       	CMP       R3, #9			;->0x09
8000dbb2:	11 f8       	JHI       $+17                  ;->0x8000dbd4
8000dbb4:	64 58       	MOV       R3, R4
8000dbb6:	4a 10       	MOV       R4, #10			;->0x000A
8000dbb8:	19 00 a4 0c 	MADD32    R3, R5, R4
8000dbbc:	62 88       	LD.B      R4, [R2 + #1]
8000dbbe:	24 58       	MOV       R1, R4
8000dbc0:	10 33       	SUB       R1, #48			;->0x30
8000dbc2:	1c 69       	ANL       R1, R12
8000dbc4:	52 c0       	ADD       R2, R2, #1
##@@@P_:_usart_vsprintf.c:120
8000dbc6:	30 33       	SUB       R3, #48			;->0x30
8000dbc8:	a3 58       	MOV       R5, R3
##@@@P_:_usart_vsprintf.c:118
8000dbca:	1a 38       	CMP       R1, #10			;->0x0A
8000dbcc:	64 58       	MOV       R3, R4
8000dbce:	f4 f3       	JNC       $-12                  ;->0x8000dbb6
8000dbd0:	02 04       	SJMP      $+2                   ;->0x8000dbd4
8000dbd2:	ac 58       	MOV       R5, R12
8000dbd4:	07 25       	ST.W      [SP + #7], R5
##@@@P_:_usart_vsprintf.c:127
8000dbd6:	4c 69       	ANL       R4, R12
8000dbd8:	80 10       	MOV       R8, #0			;->0x0000
8000dbda:	b1 10       	MOV       R11, #1			;->0x0001
8000dbdc:	48 3e       	CMP       R4, #104			;->0x68
8000dbde:	09 20       	ST.W      [SP + #9], R0
8000dbe0:	05 f0       	JZ        $+5                   ;->0x8000dbea
8000dbe2:	4c 3e       	CMP       R4, #108			;->0x6C
8000dbe4:	07 f1       	JNZ       $+7                   ;->0x8000dbf2
8000dbe6:	31 10       	MOV       R3, #1			;->0x0001
8000dbe8:	02 04       	SJMP      $+2                   ;->0x8000dbec
8000dbea:	30 10       	MOV       R3, #0			;->0x0000
8000dbec:	52 c0       	ADD       R2, R2, #1
8000dbee:	23 58       	MOV       R1, R3
8000dbf0:	03 04       	SJMP      $+3                   ;->0x8000dbf6
8000dbf2:	6b 58       	MOV       R3, R11
8000dbf4:	28 58       	MOV       R1, R8
##@@@P_:_usart_vsprintf.c:138
8000dbf6:	42 80       	LD.B      R4, [R2]
8000dbf8:	0b 58       	MOV       R0, R11
8000dbfa:	45 3f       	CMP       R4, #117			;->0x75
8000dbfc:	02 f0       	JZ        $+2                   ;->0x8000dc00
8000dbfe:	08 58       	MOV       R0, R8
8000dc00:	2a c2       	ADD       R5, R2, R0
##@@@P_:_usart_vsprintf.c:144
8000dc02:	0b 25       	ST.W      [SP + #11], R5
8000dc04:	12 e4       	LD.B      R2, [R2 + R0]
8000dc06:	22 3f       	CMP       R2, #114			;->0x72
8000dc08:	0e fc       	JGT       $+14                  ;->0x8000dc24
8000dc0a:	05 27       	ST.W      [SP + #5], R7
8000dc0c:	02 58       	MOV       R0, R2
8000dc0e:	02 36       	SUB       R0, #98			;->0x62
8000dc10:	0d 38       	CMP       R0, #13			;->0x0D
8000dc12:	11 f8       	JHI       $+17                  ;->0x8000dc34
8000dc14:	02 7a       	LSL       R0, #2			;->0x02
8000dc16:	7a 47       	LD        R7, [PC + #122]       ;->0x8000ddfc  :=0x80001424
8000dc18:	07 e8       	LD.W      R0, [R7 + R0]
8000dc1a:	10 5c       	JMP       R0
8000dc1c:	2a 10       	MOV       R2, #10			;->0x000A
8000dc1e:	70 10       	MOV       R7, #0			;->0x0000
8000dc20:	b1 10       	MOV       R11, #1			;->0x0001
8000dc22:	18 04       	SJMP      $+24                  ;->0x8000dc52
8000dc24:	23 3f       	CMP       R2, #115			;->0x73
8000dc26:	02 f1       	JNZ       $+2                   ;->0x8000dc2a
8000dc28:	88 04       	SJMP      $+136                 ;->0x8000dd38
8000dc2a:	05 27       	ST.W      [SP + #5], R7
8000dc2c:	28 3f       	CMP       R2, #120			;->0x78
8000dc2e:	09 f1       	JNZ       $+9                   ;->0x8000dc40
8000dc30:	20 11       	MOV       R2, #16			;->0x0010
8000dc32:	39 04       	SJMP      $+57                  ;->0x8000dca4
8000dc34:	28 3d       	CMP       R2, #88			;->0x58
8000dc36:	05 f1       	JNZ       $+5                   ;->0x8000dc40
8000dc38:	20 11       	MOV       R2, #16			;->0x0010
8000dc3a:	71 10       	MOV       R7, #1			;->0x0001
8000dc3c:	b0 10       	MOV       R11, #0			;->0x0000
8000dc3e:	11 04       	SJMP      $+17                  ;->0x8000dc60
##@@@P_:_usart_vsprintf.c:167
8000dc40:	45 3f       	CMP       R4, #117			;->0x75
8000dc42:	02 f0       	JZ        $+2                   ;->0x8000dc46
8000dc44:	05 05       	SJMP      $+261                 ;->0x8000de4e
8000dc46:	2a 10       	MOV       R2, #10			;->0x000A
8000dc48:	70 10       	MOV       R7, #0			;->0x0000
8000dc4a:	b1 10       	MOV       R11, #1			;->0x0001
##@@@P_:_usart_vsprintf.c:168
8000dc4c:	0b 0d       	LD.W      R5, [SP + #11]
8000dc4e:	6d cc       	SUB       R5, R5, #1
8000dc50:	0b 25       	ST.W      [SP + #11], R5
8000dc52:	07 59       	MOV       R8, R7
8000dc54:	29 04       	SJMP      $+41                  ;->0x8000dca6
8000dc56:	22 10       	MOV       R2, #2			;->0x0002
8000dc58:	24 04       	SJMP      $+36                  ;->0x8000dca0
8000dc5a:	20 10       	MOV       R2, #0			;->0x0000
8000dc5c:	b1 10       	MOV       R11, #1			;->0x0001
8000dc5e:	eb 58       	MOV       R7, R11
8000dc60:	0b 59       	MOV       R8, R11
8000dc62:	22 04       	SJMP      $+34                  ;->0x8000dca6
##@@@P_:_usart_vsprintf.c:189
8000dc64:	18 0d       	LD.W      R5, [SP + #24]
8000dc66:	ed c1       	ADD       R5, R5, #7
8000dc68:	66 44       	LD        R4, [PC + #102]       ;->0x8000de00  :=0xfffffff8
8000dc6a:	54 69       	ANL       R5, R4
8000dc6c:	44 10       	MOV       R4, #4			;->0x0004
8000dc6e:	65 58       	MOV       R3, R5
8000dc70:	34 6a       	ORL       R3, R4
8000dc72:	18 23       	ST.W      [SP + #24], R3
8000dc74:	05 82       	LD.W      R0, [R5]
8000dc76:	58 28       	ADD       R5, #8			;->0x08
8000dc78:	18 25       	ST.W      [SP + #24], R5
8000dc7a:	13 82       	LD.W      R1, [R3]
8000dc7c:	0d 59       	MOV       R8, LR
8000dc7e:	62 45       	LD        R5, [PC + #98]        ;->0x8000de04  :=0x8000e360
8000dc80:	05 5c       	LJMP      R5
8000dc82:	07 0a       	LD.W      R2, [SP + #7]
##@@@P_:_usart_vsprintf.c:191
8000dc84:	2c 69       	ANL       R2, R12
8000dc86:	5d 47       	LD        R7, [PC + #93]        ;->0x8000ddf8  :=0x38
8000dc88:	7e 64       	ADD       R7, SP
8000dc8a:	27 58       	MOV       R1, R7
8000dc8c:	5f 45       	LD        R5, [PC + #95]        ;->0x8000de08  :=0x8000de6c
8000dc8e:	05 5c       	LJMP      R5
8000dc90:	67 58       	MOV       R3, R7
8000dc92:	a8 59       	MOV       LR, R8
8000dc94:	b1 10       	MOV       R11, #1			;->0x0001
8000dc96:	4c 58       	MOV       R2, R12
8000dc98:	09 08       	LD.W      R0, [SP + #9]
8000dc9a:	0d 09       	LD.W      R1, [SP + #13]
8000dc9c:	57 04       	SJMP      $+87                  ;->0x8000dd4a
8000dc9e:	28 10       	MOV       R2, #8			;->0x0008
8000dca0:	80 10       	MOV       R8, #0			;->0x0000
8000dca2:	b1 10       	MOV       R11, #1			;->0x0001
8000dca4:	eb 58       	MOV       R7, R11
8000dca6:	18 08       	LD.W      R0, [SP + #24]
8000dca8:	28 c1       	ADD       R5, R0, #4
8000dcaa:	18 25       	ST.W      [SP + #24], R5
##@@@P_:_usart_vsprintf.c:199
8000dcac:	13 6a       	ORL       R1, R3
8000dcae:	00 82       	LD.W      R0, [R0]
8000dcb0:	10 38       	CMP       R1, #0			;->0x00
8000dcb2:	0d f1       	JNZ       $+13                  ;->0x8000dccc
8000dcb4:	60 58       	MOV       R3, R0
8000dcb6:	3c 69       	ANL       R3, R12
8000dcb8:	23 58       	MOV       R1, R3
##@@@P_:_usart_vsprintf.c:206
8000dcba:	45 3f       	CMP       R4, #117			;->0x75
8000dcbc:	04 f0       	JZ        $+4                   ;->0x8000dcc4
8000dcbe:	80 7b       	LSL       R0, #24			;->0x18
8000dcc0:	80 79       	ASR       R0, #24			;->0x18
8000dcc2:	20 58       	MOV       R1, R0
8000dcc4:	70 38       	CMP       R7, #0			;->0x00
8000dcc6:	02 f1       	JNZ       $+2                   ;->0x8000dcca
8000dcc8:	61 58       	MOV       R3, R1
8000dcca:	03 58       	MOV       R0, R3
##@@@P_:_usart_vsprintf.c:218
8000dccc:	80 38       	CMP       R8, #0			;->0x00
8000dcce:	0d 09       	LD.W      R1, [SP + #13]
8000dcd0:	0c f0       	JZ        $+12                  ;->0x8000dce8
8000dcd2:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:_usart_vsprintf.c:235
8000dcd4:	4e 44       	LD        R4, [PC + #78]        ;->0x8000de0c  :=0x3a
8000dcd6:	4e 64       	ADD       R4, SP
8000dcd8:	45 83       	ST.B      [R4], R5
##@@@P_:_usart_vsprintf.c:234
8000dcda:	4e 44       	LD        R4, [PC + #78]        ;->0x8000de10  :=0x39
8000dcdc:	4e 64       	ADD       R4, SP
8000dcde:	40 83       	ST.B      [R4], R0
8000dce0:	2f 1f       	MOV       R2, #255			;->0x00FF
8000dce2:	04 0b       	LD.W      R3, [SP + #4]
8000dce4:	09 08       	LD.W      R0, [SP + #9]
8000dce6:	32 04       	SJMP      $+50                  ;->0x8000dd4a
8000dce8:	0a 0d       	LD.W      R5, [SP + #10]
8000dcea:	06 0b       	LD.W      R3, [SP + #6]
8000dcec:	53 6a       	ORL       R5, R3
##@@@P_:_usart_vsprintf.c:220
8000dcee:	0a 25       	ST.W      [SP + #10], R5
8000dcf0:	45 3f       	CMP       R4, #117			;->0x75
8000dcf2:	06 f1       	JNZ       $+6                   ;->0x8000dcfe
##@@@P_:_usart_vsprintf.c:221
8000dcf4:	04 09       	LD.W      R1, [SP + #4]
8000dcf6:	ed 58       	MOV       R7, LR
8000dcf8:	47 45       	LD        R5, [PC + #71]        ;->0x8000de14  :=0x8000e1c8
8000dcfa:	05 5c       	LJMP      R5
8000dcfc:	05 04       	SJMP      $+5                   ;->0x8000dd06
##@@@P_:_usart_vsprintf.c:223
8000dcfe:	04 09       	LD.W      R1, [SP + #4]
8000dd00:	ed 58       	MOV       R7, LR
8000dd02:	46 45       	LD        R5, [PC + #70]        ;->0x8000de18  :=0x8000e240
8000dd04:	05 5c       	LJMP      R5
8000dd06:	a7 59       	MOV       LR, R7
8000dd08:	0d 09       	LD.W      R1, [SP + #13]
8000dd0a:	09 08       	LD.W      R0, [SP + #9]
8000dd0c:	05 0c       	LD.W      R4, [SP + #5]
8000dd0e:	0a 0b       	LD.W      R3, [SP + #10]
8000dd10:	51 10       	MOV       R5, #1			;->0x0001
##@@@P_:_usart_vsprintf.c:225
8000dd12:	35 69       	ANL       R3, R5
8000dd14:	2f 1f       	MOV       R2, #255			;->0x00FF
8000dd16:	39 45       	LD        R5, [PC + #57]        ;->0x8000ddf8  :=0x38
8000dd18:	5e 64       	ADD       R5, SP
8000dd1a:	30 38       	CMP       R3, #0			;->0x00
8000dd1c:	0c f0       	JZ        $+12                  ;->0x8000dd34
8000dd1e:	6d 88       	LD.B      R5, [R5 + #1]
8000dd20:	52 69       	ANL       R5, R2
8000dd22:	5d 3a       	CMP       R5, #45			;->0x2D
8000dd24:	08 f0       	JZ        $+8                   ;->0x8000dd34
##@@@P_:_usart_vsprintf.c:228
8000dd26:	35 45       	LD        R5, [PC + #53]        ;->0x8000ddf8  :=0x38
8000dd28:	5e 64       	ADD       R5, SP
8000dd2a:	54 83       	ST.B      [R5], R4
8000dd2c:	2f 1f       	MOV       R2, #255			;->0x00FF
8000dd2e:	33 43       	LD        R3, [PC + #51]        ;->0x8000ddf8  :=0x38
8000dd30:	3e 64       	ADD       R3, SP
8000dd32:	0c 04       	SJMP      $+12                  ;->0x8000dd4a
8000dd34:	04 0b       	LD.W      R3, [SP + #4]
8000dd36:	0a 04       	SJMP      $+10                  ;->0x8000dd4a
##@@@P_:_usart_vsprintf.c:184
8000dd38:	18 0d       	LD.W      R5, [SP + #24]
8000dd3a:	25 c1       	ADD       R4, R5, #4
8000dd3c:	18 24       	ST.W      [SP + #24], R4
8000dd3e:	d0 12       	MOV       LR, #32			;->0x0020
8000dd40:	b1 10       	MOV       R11, #1			;->0x0001
8000dd42:	35 82       	LD.W      R3, [R5]
8000dd44:	09 08       	LD.W      R0, [SP + #9]
8000dd46:	0d 09       	LD.W      R1, [SP + #13]
8000dd48:	07 0a       	LD.W      R2, [SP + #7]
##@@@P_:_usart_vsprintf.c:240
8000dd4a:	a6 58       	MOV       R5, R6
8000dd4c:	5c 69       	ANL       R5, R12
8000dd4e:	80 10       	MOV       R8, #0			;->0x0000
8000dd50:	50 38       	CMP       R5, #0			;->0x00
8000dd52:	0d f0       	JZ        $+13                  ;->0x8000dd6c
8000dd54:	a3 58       	MOV       R5, R3
8000dd56:	45 80       	LD.B      R4, [R5]
8000dd58:	40 38       	CMP       R4, #0			;->0x00
8000dd5a:	0b f0       	JZ        $+11                  ;->0x8000dd70
##@@@P_:_usart_vsprintf.c:243
8000dd5c:	76 cc       	SUB       R6, R6, #1
8000dd5e:	86 58       	MOV       R4, R6
8000dd60:	4c 69       	ANL       R4, R12
##@@@P_:_usart_vsprintf.c:242
8000dd62:	6d c0       	ADD       R5, R5, #1
##@@@P_:_usart_vsprintf.c:240
8000dd64:	40 38       	CMP       R4, #0			;->0x00
8000dd66:	f8 f1       	JNZ       $-8                   ;->0x8000dd56
8000dd68:	60 10       	MOV       R6, #0			;->0x0000
8000dd6a:	17 04       	SJMP      $+23                  ;->0x8000dd98
8000dd6c:	c8 58       	MOV       R6, R8
8000dd6e:	15 04       	SJMP      $+21                  ;->0x8000dd98
##@@@P_:_usart_vsprintf.c:246
8000dd70:	0c 0d       	LD.W      R5, [SP + #12]
8000dd72:	5d 3a       	CMP       R5, #45			;->0x2D
8000dd74:	12 f0       	JZ        $+18                  ;->0x8000dd98
##@@@P_:_usart_vsprintf.c:248
8000dd76:	76 cc       	SUB       R6, R6, #1
8000dd78:	6c 69       	ANL       R6, R12
8000dd7a:	07 22       	ST.W      [SP + #7], R2
8000dd7c:	56 c0       	ADD       R2, R6, #1
8000dd7e:	e0 58       	MOV       R7, R0
##@@@P_:_usart_vsprintf.c:251
8000dd80:	2d 58       	MOV       R1, LR
8000dd82:	0a 23       	ST.W      [SP + #10], R3
8000dd84:	26 45       	LD        R5, [PC + #38]        ;->0x8000de1c  :=0x8000da04
8000dd86:	05 5c       	LJMP      R5
8000dd88:	0a 0b       	LD.W      R3, [SP + #10]
8000dd8a:	07 0a       	LD.W      R2, [SP + #7]
##@@@P_:_usart_vsprintf.c:248
8000dd8c:	af c3       	ADD       R5, R7, R6
8000dd8e:	0d 0c       	LD.W      R4, [SP + #13]
8000dd90:	a4 c3       	ADD       R4, R4, R6
8000dd92:	60 10       	MOV       R6, #0			;->0x0000
8000dd94:	4c c0       	ADD       R1, R4, #1
8000dd96:	45 c0       	ADD       R0, R5, #1
##@@@P_:_usart_vsprintf.c:257
8000dd98:	53 80       	LD.B      R5, [R3]
##@@@P_:_usart_vsprintf.c:258
8000dd9a:	50 38       	CMP       R5, #0			;->0x00
8000dd9c:	29 f0       	JZ        $+41                  ;->0x8000ddee
##@@@P_:_usart_vsprintf.c:257
8000dd9e:	63 c0       	ADD       R4, R3, #1
##@@@P_:_usart_vsprintf.c:258
8000dda0:	62 58       	MOV       R3, R2
8000dda2:	3c 69       	ANL       R3, R12
8000dda4:	3c 70       	CMP       R3, R12
8000dda6:	05 f0       	JZ        $+5                   ;->0x8000ddb0
##@@@P_:_usart_vsprintf.c:257
8000dda8:	30 38       	CMP       R3, #0			;->0x00
8000ddaa:	22 f0       	JZ        $+34                  ;->0x8000ddee
8000ddac:	52 cc       	SUB       R2, R2, #1
8000ddae:	02 04       	SJMP      $+2                   ;->0x8000ddb2
8000ddb0:	4c 58       	MOV       R2, R12
##@@@P_:_usart_vsprintf.c:262
8000ddb2:	b0 38       	CMP       R11, #0			;->0x00
8000ddb4:	0d f1       	JNZ       $+13                  ;->0x8000ddce
8000ddb6:	e2 58       	MOV       R7, R2
##@@@P_:_usart_vsprintf.c:264
8000ddb8:	65 58       	MOV       R3, R5
8000ddba:	3c 69       	ANL       R3, R12
##@@@F_:__ctype_lookup():
##@@@P_:ctype.h:129
8000ddbc:	19 42       	LD        R2, [PC + #25]        ;->0x8000de20  :=0x800015dc
8000ddbe:	da c2       	ADD       R3, R2, R3
8000ddc0:	5b 88       	LD.B      R3, [R3 + #1]
8000ddc2:	23 10       	MOV       R2, #3			;->0x0003
##@@@F_:vsprintf_usart():
##@@@P_:_usart_vsprintf.c:264
8000ddc4:	32 69       	ANL       R3, R2
8000ddc6:	32 38       	CMP       R3, #2			;->0x02
8000ddc8:	02 f1       	JNZ       $+2                   ;->0x8000ddcc
8000ddca:	50 32       	SUB       R5, #32			;->0x20
8000ddcc:	47 58       	MOV       R2, R7
##@@@P_:_usart_vsprintf.c:271
8000ddce:	66 58       	MOV       R3, R6
8000ddd0:	3c 69       	ANL       R3, R12
8000ddd2:	e8 58       	MOV       R7, R8
8000ddd4:	30 38       	CMP       R3, #0			;->0x00
8000ddd6:	02 f0       	JZ        $+2                   ;->0x8000ddda
8000ddd8:	7e cc       	SUB       R7, R6, #1
##@@@P_:_usart_vsprintf.c:267
8000ddda:	05 83       	ST.B      [R0], R5
##@@@P_:_usart_vsprintf.c:258
8000dddc:	5c c0       	ADD       R3, R4, #1
##@@@P_:_usart_vsprintf.c:269
8000ddde:	49 c0       	ADD       R1, R1, #1
##@@@P_:_usart_vsprintf.c:267
8000dde0:	40 c0       	ADD       R0, R0, #1
##@@@P_:_usart_vsprintf.c:257
8000dde2:	54 80       	LD.B      R5, [R4]
##@@@P_:_usart_vsprintf.c:258
8000dde4:	50 38       	CMP       R5, #0			;->0x00
8000dde6:	83 58       	MOV       R4, R3
8000dde8:	c7 58       	MOV       R6, R7
8000ddea:	db f1       	JNZ       $-37                  ;->0x8000dda0
8000ddec:	02 04       	SJMP      $+2                   ;->0x8000ddf0
8000ddee:	e6 58       	MOV       R7, R6
##@@@P_:_usart_vsprintf.c:278
8000ddf0:	0c 0d       	LD.W      R5, [SP + #12]
8000ddf2:	5d 3a       	CMP       R5, #45			;->0x2D
8000ddf4:	29 f1       	JNZ       $+41                  ;->0x8000de46
8000ddf6:	17 04       	SJMP      $+23                  ;->0x8000de24
8000ddf8:	38 00 00 00 	.long     0x00000038 ->000000056 
8000ddfc:	24 14 00 80 	.long     0x80001424 ->-2147478492  [!!!@2@:MOV       R2, #68	@@: LD.B      R0, [R0]
8000de00:	f8 ff ff ff 	.long     0xfffffff8 ->-00000008 
8000de04:	60 e3 00 80 	.long     0x8000e360 ->-2147425440  [!!!@2@:ST.B      [SP + #0], R3	@@: LD.B      R0, [R0]
8000de08:	6c de 00 80 	.long     0x8000de6c ->-2147426708  [!!!@2@:ASR       R5, R4, R1	@@: LD.B      R0, [R0]
8000de0c:	3a 00 00 00 	.long     0x0000003a ->000000058 
8000de10:	39 00 00 00 	.long     0x00000039 ->000000057 
8000de14:	c8 e1 00 80 	.long     0x8000e1c8 ->-2147425848  [!!!@2@:LD.B      R6, [SP + #8]	@@: LD.B      R0, [R0]
8000de18:	40 e2 00 80 	.long     0x8000e240 ->-2147425728  [!!!@2@:ST.H      [SP + #0], R2	@@: LD.B      R0, [R0]
8000de1c:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]
8000de20:	dc 15 00 80 	.long     0x800015dc ->-2147478052  [!!!@2@:MOV       LR, #92	@@: LD.B      R0, [R0]
8000de24:	47 58       	MOV       R2, R7
8000de26:	2c 69       	ANL       R2, R12
8000de28:	20 38       	CMP       R2, #0			;->0x00
8000de2a:	0e f0       	JZ        $+14                  ;->0x8000de46
8000de2c:	0d 21       	ST.W      [SP + #13], R1
8000de2e:	10 12       	MOV       R1, #32			;->0x0020
8000de30:	c0 58       	MOV       R6, R0
##@@@P_:_usart_vsprintf.c:283
8000de32:	0e 45       	LD        R5, [PC + #14]        ;->0x8000de68  :=0x8000da04
8000de34:	05 5c       	LJMP      R5
##@@@P_:_usart_vsprintf.c:280
8000de36:	6f cc       	SUB       R5, R7, #1
8000de38:	5c 69       	ANL       R5, R12
8000de3a:	66 c3       	ADD       R4, R6, R5
8000de3c:	0d 0b       	LD.W      R3, [SP + #13]
8000de3e:	6b c3       	ADD       R5, R3, R5
8000de40:	55 c0       	ADD       R2, R5, #1
8000de42:	44 c0       	ADD       R0, R4, #1
8000de44:	02 04       	SJMP      $+2                   ;->0x8000de48
8000de46:	41 58       	MOV       R2, R1
8000de48:	0b 09       	LD.W      R1, [SP + #11]
##@@@P_:_usart_vsprintf.c:299
8000de4a:	49 c0       	ADD       R1, R1, #1
8000de4c:	59 06       	SJMP      $-423                 ;->0x8000dafe
8000de4e:	09 08       	LD.W      R0, [SP + #9]
##@@@P_:_usart_vsprintf.c:174
8000de50:	02 83       	ST.B      [R0], R2
8000de52:	0b 09       	LD.W      R1, [SP + #11]
##@@@P_:_usart_vsprintf.c:176
8000de54:	49 c0       	ADD       R1, R1, #1
8000de56:	0d 0a       	LD.W      R2, [SP + #13]
8000de58:	65 06       	SJMP      $-411                 ;->0x8000db22
8000de5a:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:_usart_vsprintf.c:301
8000de5c:	05 83       	ST.B      [R0], R5
##@@@P_:_usart_vsprintf.c:303
8000de5e:	02 58       	MOV       R0, R2
8000de60:	e4 2e       	ADD       SP, #100			;->0x64
8000de62:	7f 5e       	POP       {R6-R12}
8000de64:	0d 5d       	POP       LR
8000de66:	1d 5c       	JMP       LR
8000de68:	04 da 00 80 	.long     0x8000da04 ->-2147427836  [!!!@2@:LSL       R0, R4, R0	@@: LD.B      R0, [R0]

8000de6c <ftoa>:
##@@@F_:ftoa():
##@@@P_:ftoa.c:110
8000de6c:	9f 5f       	PUSH      {R6-R10,LR}
8000de6e:	ec 31       	SUB       SP, #28			;->0x1C
8000de70:	02 59       	MOV       R8, R2
##@@@P_:ftoa.c:112
8000de72:	b5 43       	LD        R3, [PC + #181]       ;->0x8000e144  :=0xd000cfa4
8000de74:	31 85       	ST.W      [R3], R1
##@@@P_:ftoa.c:111
8000de76:	b5 47       	LD        R7, [PC + #181]       ;->0x8000e148  :=0xd000cf98
8000de78:	70 85       	ST.W      [R7], R0
##@@@P_:ftoa.c:115
8000de7a:	b5 45       	LD        R5, [PC + #181]       ;->0x8000e14c  :=0xffffffff
8000de7c:	05 70       	CMP       R0, R5
8000de7e:	05 23       	ST.W      [SP + #5], R3
8000de80:	02 25       	ST.W      [SP + #2], R5
8000de82:	03 fd       	JLE       $+3                   ;->0x8000de88
8000de84:	81 58       	MOV       R4, R1
8000de86:	06 04       	SJMP      $+6                   ;->0x8000de92
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000de88:	61 c0       	ADD       R4, R1, #1
8000de8a:	34 85       	ST.W      [R3], R4
8000de8c:	5d 12       	MOV       R5, #45			;->0x002D
8000de8e:	15 83       	ST.B      [R1], R5
##@@@F_:ftoa():
##@@@P_:ftoa.c:118
8000de90:	07 82       	LD.W      R0, [R7]
8000de92:	b0 45       	LD        R5, [PC + #176]       ;->0x8000e150  :=0x7fffff
##@@@P_:ftoa.c:119
8000de94:	60 58       	MOV       R3, R0
8000de96:	35 69       	ANL       R3, R5
8000de98:	af 42       	LD        R2, [PC + #175]       ;->0x8000e154  :=0x800000
8000de9a:	a3 58       	MOV       R5, R3
8000de9c:	52 6a       	ORL       R5, R2
8000de9e:	75 85       	ST.W      [R7], R5
##@@@P_:ftoa.c:118
8000dea0:	07 7d       	LSR       R0, #23			;->0x17
8000dea2:	1f 1f       	MOV       R1, #255			;->0x00FF
8000dea4:	01 69       	ANL       R0, R1
8000dea6:	ad 46       	LD        R6, [PC + #173]       ;->0x8000e158  :=0xd000cf9c
8000dea8:	06 26       	ST.W      [SP + #6], R6
8000deaa:	60 85       	ST.W      [R6], R0
##@@@P_:ftoa.c:122
8000deac:	00 38       	CMP       R0, #0			;->0x00
8000deae:	08 f0       	JZ        $+8                   ;->0x8000debe
8000deb0:	01 70       	CMP       R0, R1
8000deb2:	21 f1       	JNZ       $+33                  ;->0x8000def4
8000deb4:	3e 16       	MOV       R3, #110			;->0x006E
8000deb6:	52 70       	CMP       R5, R2
8000deb8:	20 f0       	JZ        $+32                  ;->0x8000def8
8000deba:	23 58       	MOV       R1, R3
8000debc:	1f 04       	SJMP      $+31                  ;->0x8000defa
##@@@P_:ftoa.c:145
8000debe:	52 70       	CMP       R5, R2
8000dec0:	2d f1       	JNZ       $+45                  ;->0x8000df1a
8000dec2:	50 13       	MOV       R5, #48			;->0x0030
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000dec4:	45 83       	ST.B      [R4], R5
8000dec6:	3f 11       	MOV       R3, #31			;->0x001F
##@@@F_:ftoa():
##@@@P_:ftoa.c:149
8000dec8:	48 58       	MOV       R2, R8
8000deca:	23 69       	ANL       R2, R3
8000decc:	a4 43       	LD        R3, [PC + #164]       ;->0x8000e15c  :=0xd000cfa0
8000dece:	32 85       	ST.W      [R3], R2
##@@@P_:ftoa.c:150
8000ded0:	20 38       	CMP       R2, #0			;->0x00
8000ded2:	02 f1       	JNZ       $+2                   ;->0x8000ded6
8000ded4:	1e 05       	SJMP      $+286                 ;->0x8000e110
8000ded6:	2e 12       	MOV       R2, #46			;->0x002E
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000ded8:	62 90       	ST.B      [R4 + #1], R2
##@@@F_:ftoa():
##@@@P_:ftoa.c:153
8000deda:	23 82       	LD.W      R2, [R3]
8000dedc:	4a cc       	SUB       R1, R2, #1
8000dede:	31 85       	ST.W      [R3], R1
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000dee0:	a4 c0       	ADD       R4, R4, #2
##@@@F_:ftoa():
##@@@P_:ftoa.c:153
8000dee2:	20 38       	CMP       R2, #0			;->0x00
8000dee4:	02 f1       	JNZ       $+2                   ;->0x8000dee8
8000dee6:	16 05       	SJMP      $+278                 ;->0x8000e112
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000dee8:	45 83       	ST.B      [R4], R5
##@@@F_:ftoa():
##@@@P_:ftoa.c:153
8000deea:	23 82       	LD.W      R2, [R3]
8000deec:	4a cc       	SUB       R1, R2, #1
8000deee:	31 85       	ST.W      [R3], R1
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000def0:	64 c0       	ADD       R4, R4, #1
8000def2:	f8 07       	SJMP      $-8                   ;->0x8000dee2
##@@@F_:ftoa():
8000def4:	05 0c       	LD.W      R4, [SP + #5]
8000def6:	1b 04       	SJMP      $+27                  ;->0x8000df2c
8000def8:	19 16       	MOV       R1, #105			;->0x0069
8000defa:	03 58       	MOV       R0, R3
8000defc:	52 70       	CMP       R5, R2
8000defe:	02 f0       	JZ        $+2                   ;->0x8000df02
8000df00:	01 16       	MOV       R0, #97			;->0x0061
8000df02:	52 70       	CMP       R5, R2
8000df04:	02 f1       	JNZ       $+2                   ;->0x8000df08
8000df06:	36 14       	MOV       R3, #70			;->0x0046
8000df08:	a3 90       	ST.B      [R4 + #2], R3
8000df0a:	60 90       	ST.B      [R4 + #1], R0
8000df0c:	41 83       	ST.B      [R4], R1
##@@@F_:_ftoa_put_char():
8000df0e:	2c c1       	ADD       R5, R4, #4
8000df10:	05 0b       	LD.W      R3, [SP + #5]
8000df12:	35 85       	ST.W      [R3], R5
8000df14:	50 10       	MOV       R5, #0			;->0x0000
8000df16:	e5 90       	ST.B      [R4 + #3], R5
8000df18:	12 05       	SJMP      $+274                 ;->0x8000e13c
##@@@F_:ftoa():
8000df1a:	05 0d       	LD.W      R5, [SP + #5]
8000df1c:	01 10       	MOV       R0, #1			;->0x0001
8000df1e:	91 44       	LD        R4, [PC + #145]       ;->0x8000e160  :=0x400000
##@@@F_:_mul2():
##@@@P_:ftoa.c:54
8000df20:	a3 58       	MOV       R5, R3
##@@@F_:ftoa():
##@@@P_:ftoa.c:174
8000df22:	40 cc       	SUB       R0, R0, #1
##@@@F_:_mul2():
##@@@P_:ftoa.c:54
8000df24:	29 7a       	LSL       R5, #1			;->0x01
##@@@F_:ftoa():
##@@@P_:ftoa.c:171
8000df26:	34 70       	CMP       R3, R4
8000df28:	65 58       	MOV       R3, R5
8000df2a:	fc f3       	JNC       $-4                   ;->0x8000df22
##@@@P_:ftoa.c:191
8000df2c:	8c 46       	LD        R6, [PC + #140]       ;->0x8000e15c  :=0xd000cfa0
8000df2e:	40 10       	MOV       R4, #0			;->0x0000
8000df30:	01 24       	ST.W      [SP + #1], R4
8000df32:	64 85       	ST.W      [R6], R4
##@@@P_:ftoa.c:190
8000df34:	40 58       	MOV       R2, R0
8000df36:	2f 37       	SUB       R2, #127			;->0x7F
8000df38:	06 0c       	LD.W      R4, [SP + #6]
8000df3a:	42 85       	ST.W      [R4], R2
##@@@P_:ftoa.c:189
8000df3c:	2d 7a       	LSL       R5, #5			;->0x05
8000df3e:	75 85       	ST.W      [R7], R5
##@@@P_:ftoa.c:193
8000df40:	40 18       	MOV       R4, #128			;->0x0080
8000df42:	04 70       	CMP       R0, R4
8000df44:	12 fb       	JLT       $+18                  ;->0x8000df68
8000df46:	40 10       	MOV       R4, #0			;->0x0000
8000df48:	0e 37       	SUB       R0, #126			;->0x7E
8000df4a:	87 43       	LD        R3, [PC + #135]       ;->0x8000e164  :=0x4fffffff
8000df4c:	25 10       	MOV       R2, #5			;->0x0005
##@@@P_:ftoa.c:195
8000df4e:	53 70       	CMP       R5, R3
8000df50:	03 f8       	JHI       $+3                   ;->0x8000df56
##@@@F_:_mul2():
##@@@P_:ftoa.c:54
8000df52:	29 7a       	LSL       R5, #1			;->0x01
8000df54:	05 04       	SJMP      $+5                   ;->0x8000df5e
##@@@F_:ftoa():
##@@@P_:ftoa.c:202
8000df56:	64 c0       	ADD       R4, R4, #1
8000df58:	64 85       	ST.W      [R6], R4
##@@@F_:_div5():
##@@@P_:ftoa.c:59
8000df5a:	ad c0       	ADD       R5, R5, #2
8000df5c:	ad d2       	DIVU      R5, R5, R2
##@@@F_:ftoa():
8000df5e:	75 85       	ST.W      [R7], R5
##@@@P_:ftoa.c:193
8000df60:	40 cc       	SUB       R0, R0, #1
8000df62:	01 38       	CMP       R0, #1			;->0x01
8000df64:	f5 fc       	JGT       $-11                  ;->0x8000df4e
8000df66:	1d 04       	SJMP      $+29                  ;->0x8000dfa0
8000df68:	10 10       	MOV       R1, #0			;->0x0000
##@@@P_:ftoa.c:207
8000df6a:	0f 3f       	CMP       R0, #127			;->0x7F
8000df6c:	03 f1       	JNZ       $+3                   ;->0x8000df72
8000df6e:	81 58       	MOV       R4, R1
8000df70:	1b 04       	SJMP      $+27                  ;->0x8000dfa6
8000df72:	7e 40       	LD        R0, [PC + #126]       ;->0x8000e168  :=0x1fffffff
8000df74:	45 10       	MOV       R4, #5			;->0x0005
8000df76:	04 24       	ST.W      [SP + #4], R4
8000df78:	91 10       	MOV       R9, #1			;->0x0001
8000df7a:	81 58       	MOV       R4, R1
##@@@P_:ftoa.c:209
8000df7c:	50 70       	CMP       R5, R0
8000df7e:	06 f8       	JHI       $+6                   ;->0x8000df8a
##@@@P_:ftoa.c:212
8000df80:	64 cc       	SUB       R4, R4, #1
8000df82:	64 85       	ST.W      [R6], R4
##@@@F_:_mul5():
##@@@P_:ftoa.c:64
8000df84:	04 0b       	LD.W      R3, [SP + #4]
8000df86:	ed ca       	MULS      R5, R5, R3
8000df88:	03 04       	SJMP      $+3                   ;->0x8000df8e
##@@@F_:_div2():
##@@@P_:ftoa.c:49
8000df8a:	6d c0       	ADD       R5, R5, #1
8000df8c:	29 7c       	LSR       R5, #1			;->0x01
##@@@F_:ftoa():
8000df8e:	75 85       	ST.W      [R7], R5
##@@@P_:ftoa.c:218
8000df90:	5a c0       	ADD       R3, R2, #1
8000df92:	49 59       	MOV       R10, R9
8000df94:	32 70       	CMP       R3, R2
8000df96:	02 f3       	JNC       $+2                   ;->0x8000df9a
8000df98:	41 59       	MOV       R10, R1
##@@@P_:ftoa.c:207
8000df9a:	a1 38       	CMP       R10, #1			;->0x01
8000df9c:	43 58       	MOV       R2, R3
8000df9e:	ef f1       	JNZ       $-17                  ;->0x8000df7c
8000dfa0:	06 0b       	LD.W      R3, [SP + #6]
8000dfa2:	01 0a       	LD.W      R2, [SP + #1]
8000dfa4:	32 85       	ST.W      [R3], R2
##@@@P_:ftoa.c:221
8000dfa6:	72 41       	LD        R1, [PC + #114]       ;->0x8000e16c  :=0xfffffff
8000dfa8:	51 70       	CMP       R5, R1
8000dfaa:	09 f8       	JHI       $+9                   ;->0x8000dfbc
8000dfac:	3a 10       	MOV       R3, #10			;->0x000A
8000dfae:	71 42       	LD        R2, [PC + #113]       ;->0x8000e170  :=0x10000000
##@@@F_:_mul10():
##@@@P_:ftoa.c:74
8000dfb0:	ed ca       	MULS      R5, R5, R3
##@@@F_:ftoa():
##@@@P_:ftoa.c:224
8000dfb2:	64 cc       	SUB       R4, R4, #1
##@@@P_:ftoa.c:221
8000dfb4:	52 70       	CMP       R5, R2
8000dfb6:	fd f3       	JNC       $-3                   ;->0x8000dfb0
##@@@P_:ftoa.c:224
8000dfb8:	64 85       	ST.W      [R6], R4
##@@@F_:_mul10():
##@@@P_:ftoa.c:74
8000dfba:	75 85       	ST.W      [R7], R5
##@@@F_:ftoa():
8000dfbc:	50 16       	MOV       R5, #96			;->0x0060
##@@@P_:ftoa.c:231
8000dfbe:	68 58       	MOV       R3, R8
8000dfc0:	35 69       	ANL       R3, R5
8000dfc2:	30 38       	CMP       R3, #0			;->0x00
8000dfc4:	03 f1       	JNZ       $+3                   ;->0x8000dfca
8000dfc6:	50 12       	MOV       R5, #32			;->0x0020
8000dfc8:	85 6a       	ORL       R8, R5
8000dfca:	03 21       	ST.W      [SP + #3], R1
8000dfcc:	5f 11       	MOV       R5, #31			;->0x001F
8000dfce:	68 58       	MOV       R3, R8
8000dfd0:	35 69       	ANL       R3, R5
8000dfd2:	50 14       	MOV       R5, #64			;->0x0040
##@@@P_:ftoa.c:240
8000dfd4:	85 69       	ANL       R8, R5
8000dfd6:	80 38       	CMP       R8, #0			;->0x00
8000dfd8:	04 23       	ST.W      [SP + #4], R3
8000dfda:	1c f1       	JNZ       $+28                  ;->0x8000e012
##@@@P_:ftoa.c:270
8000dfdc:	c4 c2       	ADD       R0, R4, R3
8000dfde:	66 45       	LD        R5, [PC + #102]       ;->0x8000e174  :=0x8000e180
8000dfe0:	05 5c       	LJMP      R5
8000dfe2:	05 0d       	LD.W      R5, [SP + #5]
8000dfe4:	55 82       	LD.W      R5, [R5]
##@@@P_:ftoa.c:272
8000dfe6:	46 82       	LD.W      R4, [R6]
8000dfe8:	40 38       	CMP       R4, #0			;->0x00
8000dfea:	40 fb       	JLT       $+64                  ;->0x8000e06a
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:104
8000dfec:	27 82       	LD.W      R2, [R7]
8000dfee:	80 13       	MOV       R8, #48			;->0x0030
8000dff0:	3a 10       	MOV       R3, #10			;->0x000A
8000dff2:	06 08       	LD.W      R0, [SP + #6]
8000dff4:	03 0c       	LD.W      R4, [SP + #3]
8000dff6:	94 7d       	LSR       R2, #28			;->0x1C
8000dff8:	28 6a       	ORL       R2, R8
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000dffa:	52 83       	ST.B      [R5], R2
##@@@F_:ftoa():
##@@@P_:ftoa.c:277
8000dffc:	16 82       	LD.W      R1, [R6]
8000dffe:	51 cc       	SUB       R2, R1, #1
8000e000:	62 85       	ST.W      [R6], R2
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:105
8000e002:	27 82       	LD.W      R2, [R7]
8000e004:	24 69       	ANL       R2, R4
##@@@F_:_mul10():
##@@@P_:ftoa.c:74
8000e006:	d2 ca       	MULS      R2, R2, R3
8000e008:	72 85       	ST.W      [R7], R2
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e00a:	6d c0       	ADD       R5, R5, #1
##@@@F_:ftoa():
##@@@P_:ftoa.c:274
8000e00c:	10 38       	CMP       R1, #0			;->0x00
8000e00e:	f4 fc       	JGT       $-12                  ;->0x8000dff6
8000e010:	31 04       	SJMP      $+49                  ;->0x8000e072
8000e012:	03 58       	MOV       R0, R3
##@@@P_:ftoa.c:242
8000e014:	58 45       	LD        R5, [PC + #88]        ;->0x8000e174  :=0x8000e180
8000e016:	05 5c       	LJMP      R5
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:104
8000e018:	37 82       	LD.W      R3, [R7]
8000e01a:	9c 7d       	LSR       R3, #28			;->0x1C
8000e01c:	80 13       	MOV       R8, #48			;->0x0030
8000e01e:	38 6a       	ORL       R3, R8
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e020:	05 0d       	LD.W      R5, [SP + #5]
8000e022:	55 82       	LD.W      R5, [R5]
8000e024:	53 83       	ST.B      [R5], R3
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:105
8000e026:	27 82       	LD.W      R2, [R7]
8000e028:	03 0c       	LD.W      R4, [SP + #3]
8000e02a:	24 69       	ANL       R2, R4
8000e02c:	3a 10       	MOV       R3, #10			;->0x000A
##@@@F_:_mul10():
##@@@P_:ftoa.c:74
8000e02e:	d2 ca       	MULS      R2, R2, R3
8000e030:	72 85       	ST.W      [R7], R2
8000e032:	06 08       	LD.W      R0, [SP + #6]
8000e034:	04 0a       	LD.W      R2, [SP + #4]
##@@@F_:ftoa():
##@@@P_:ftoa.c:244
8000e036:	02 85       	ST.W      [R0], R2
##@@@P_:ftoa.c:245
8000e038:	20 38       	CMP       R2, #0			;->0x00
8000e03a:	02 f1       	JNZ       $+2                   ;->0x8000e03e
8000e03c:	52 04       	SJMP      $+82                  ;->0x8000e0e0
8000e03e:	2e 12       	MOV       R2, #46			;->0x002E
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e040:	6a 90       	ST.B      [R5 + #1], R2
8000e042:	ad c0       	ADD       R5, R5, #2
##@@@F_:ftoa():
##@@@P_:ftoa.c:248
8000e044:	20 82       	LD.W      R2, [R0]
8000e046:	21 38       	CMP       R2, #1			;->0x01
8000e048:	02 fa       	JGE       $+2                   ;->0x8000e04c
8000e04a:	4c 04       	SJMP      $+76                  ;->0x8000e0e2
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:104
8000e04c:	27 82       	LD.W      R2, [R7]
8000e04e:	94 7d       	LSR       R2, #28			;->0x1C
8000e050:	28 6a       	ORL       R2, R8
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e052:	52 83       	ST.B      [R5], R2
##@@@F_:ftoa():
##@@@P_:ftoa.c:251
8000e054:	10 82       	LD.W      R1, [R0]
8000e056:	51 cc       	SUB       R2, R1, #1
8000e058:	02 85       	ST.W      [R0], R2
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:105
8000e05a:	27 82       	LD.W      R2, [R7]
8000e05c:	24 69       	ANL       R2, R4
##@@@F_:_mul10():
##@@@P_:ftoa.c:74
8000e05e:	d2 ca       	MULS      R2, R2, R3
8000e060:	72 85       	ST.W      [R7], R2
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e062:	6d c0       	ADD       R5, R5, #1
##@@@F_:ftoa():
##@@@P_:ftoa.c:248
8000e064:	11 38       	CMP       R1, #1			;->0x01
8000e066:	f4 fc       	JGT       $-12                  ;->0x8000e04e
8000e068:	3d 04       	SJMP      $+61                  ;->0x8000e0e2
8000e06a:	40 13       	MOV       R4, #48			;->0x0030
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e06c:	54 83       	ST.B      [R5], R4
8000e06e:	6d c0       	ADD       R5, R5, #1
8000e070:	06 08       	LD.W      R0, [SP + #6]
##@@@F_:ftoa():
8000e072:	04 0c       	LD.W      R4, [SP + #4]
##@@@P_:ftoa.c:284
8000e074:	04 85       	ST.W      [R0], R4
##@@@P_:ftoa.c:285
8000e076:	40 38       	CMP       R4, #0			;->0x00
8000e078:	2e f0       	JZ        $+46                  ;->0x8000e0d4
8000e07a:	4e 12       	MOV       R4, #46			;->0x002E
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e07c:	54 83       	ST.B      [R5], R4
8000e07e:	6d c0       	ADD       R5, R5, #1
##@@@F_:ftoa():
##@@@P_:ftoa.c:289
8000e080:	40 82       	LD.W      R4, [R0]
8000e082:	41 38       	CMP       R4, #1			;->0x01
8000e084:	28 fb       	JLT       $+40                  ;->0x8000e0d4
##@@@P_:ftoa.c:291
8000e086:	26 82       	LD.W      R2, [R6]
8000e088:	3c 44       	LD        R4, [PC + #60]        ;->0x8000e178  :=0xfffffffe
8000e08a:	04 24       	ST.W      [SP + #4], R4
8000e08c:	30 13       	MOV       R3, #48			;->0x0030
8000e08e:	04 0c       	LD.W      R4, [SP + #4]
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e090:	4d c0       	ADD       R1, R5, #1
##@@@F_:ftoa():
##@@@P_:ftoa.c:291
8000e092:	24 70       	CMP       R2, R4
8000e094:	08 fc       	JGT       $+8                   ;->0x8000e0a4
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e096:	05 0a       	LD.W      R2, [SP + #5]
8000e098:	21 85       	ST.W      [R2], R1
8000e09a:	53 83       	ST.B      [R5], R3
##@@@F_:ftoa():
##@@@P_:ftoa.c:294
8000e09c:	56 82       	LD.W      R5, [R6]
8000e09e:	55 c0       	ADD       R2, R5, #1
8000e0a0:	62 85       	ST.W      [R6], R2
8000e0a2:	0e 04       	SJMP      $+14                  ;->0x8000e0be
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e0a4:	05 0a       	LD.W      R2, [SP + #5]
8000e0a6:	21 85       	ST.W      [R2], R1
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:104
8000e0a8:	27 82       	LD.W      R2, [R7]
8000e0aa:	94 7d       	LSR       R2, #28			;->0x1C
8000e0ac:	23 6a       	ORL       R2, R3
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e0ae:	52 83       	ST.B      [R5], R2
##@@@F_:_ftoa_put_digit():
##@@@P_:ftoa.c:105
8000e0b0:	57 82       	LD.W      R5, [R7]
8000e0b2:	03 0c       	LD.W      R4, [SP + #3]
8000e0b4:	54 69       	ANL       R5, R4
8000e0b6:	2a 10       	MOV       R2, #10			;->0x000A
##@@@F_:_mul10():
##@@@P_:ftoa.c:74
8000e0b8:	ad ca       	MULS      R5, R5, R2
8000e0ba:	75 85       	ST.W      [R7], R5
##@@@F_:ftoa():
##@@@P_:ftoa.c:291
8000e0bc:	26 82       	LD.W      R2, [R6]
8000e0be:	a1 58       	MOV       R5, R1
##@@@P_:ftoa.c:300
8000e0c0:	10 82       	LD.W      R1, [R0]
8000e0c2:	41 cc       	SUB       R0, R1, #1
8000e0c4:	06 0c       	LD.W      R4, [SP + #6]
8000e0c6:	40 85       	ST.W      [R4], R0
8000e0c8:	06 08       	LD.W      R0, [SP + #6]
##@@@P_:ftoa.c:289
8000e0ca:	11 38       	CMP       R1, #1			;->0x01
8000e0cc:	e1 fc       	JGT       $-31                  ;->0x8000e08e
8000e0ce:	05 0b       	LD.W      R3, [SP + #5]
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e0d0:	53 82       	LD.W      R5, [R3]
8000e0d2:	02 04       	SJMP      $+2                   ;->0x8000e0d6
8000e0d4:	05 0b       	LD.W      R3, [SP + #5]
8000e0d6:	65 c0       	ADD       R4, R5, #1
8000e0d8:	34 85       	ST.W      [R3], R4
8000e0da:	01 0c       	LD.W      R4, [SP + #1]
8000e0dc:	54 83       	ST.B      [R5], R4
8000e0de:	2f 04       	SJMP      $+47                  ;->0x8000e13c
##@@@F_:ftoa():
8000e0e0:	6d c0       	ADD       R5, R5, #1
8000e0e2:	45 14       	MOV       R4, #69			;->0x0045
##@@@F_:_ftoa_put_char():
8000e0e4:	54 83       	ST.B      [R5], R4
##@@@F_:ftoa():
8000e0e6:	8d c0       	ADD       R1, R5, #2
8000e0e8:	05 0c       	LD.W      R4, [SP + #5]
8000e0ea:	41 85       	ST.W      [R4], R1
##@@@P_:ftoa.c:255
8000e0ec:	46 82       	LD.W      R4, [R6]
8000e0ee:	02 0b       	LD.W      R3, [SP + #2]
8000e0f0:	43 70       	CMP       R4, R3
8000e0f2:	05 fd       	JLE       $+5                   ;->0x8000e0fc
8000e0f4:	4b 12       	MOV       R4, #43			;->0x002B
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e0f6:	6c 90       	ST.B      [R5 + #1], R4
##@@@F_:ftoa():
##@@@P_:ftoa.c:264
8000e0f8:	06 82       	LD.W      R0, [R6]
8000e0fa:	07 04       	SJMP      $+7                   ;->0x8000e108
8000e0fc:	4d 12       	MOV       R4, #45			;->0x002D
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e0fe:	6c 90       	ST.B      [R5 + #1], R4
##@@@F_:ftoa():
##@@@P_:ftoa.c:258
8000e100:	56 82       	LD.W      R5, [R6]
8000e102:	01 0c       	LD.W      R4, [SP + #1]
8000e104:	44 c7       	SUB       R0, R4, R5
8000e106:	60 85       	ST.W      [R6], R0
8000e108:	2a 10       	MOV       R2, #10			;->0x000A
##@@@P_:ftoa.c:264
8000e10a:	1d 45       	LD        R5, [PC + #29]        ;->0x8000e17c  :=0x8000e2d0
8000e10c:	05 5c       	LJMP      R5
8000e10e:	17 04       	SJMP      $+23                  ;->0x8000e13c
8000e110:	64 c0       	ADD       R4, R4, #1
8000e112:	30 14       	MOV       R3, #64			;->0x0040
##@@@P_:ftoa.c:156
8000e114:	83 69       	ANL       R8, R3
8000e116:	80 38       	CMP       R8, #0			;->0x00
8000e118:	03 f1       	JNZ       $+3                   ;->0x8000e11e
8000e11a:	05 0b       	LD.W      R3, [SP + #5]
8000e11c:	0c 04       	SJMP      $+12                  ;->0x8000e134
8000e11e:	35 14       	MOV       R3, #69			;->0x0045
##@@@F_:_ftoa_put_char():
##@@@P_:ftoa.c:99
8000e120:	43 83       	ST.B      [R4], R3
8000e122:	9c c0       	ADD       R3, R4, #2
8000e124:	05 0a       	LD.W      R2, [SP + #5]
8000e126:	23 85       	ST.W      [R2], R3
8000e128:	62 58       	MOV       R3, R2
8000e12a:	e5 90       	ST.B      [R4 + #3], R5
8000e12c:	a5 90       	ST.B      [R4 + #2], R5
8000e12e:	5b 12       	MOV       R5, #43			;->0x002B
8000e130:	65 90       	ST.B      [R4 + #1], R5
8000e132:	24 c1       	ADD       R4, R4, #4
8000e134:	6c c0       	ADD       R5, R4, #1
8000e136:	35 85       	ST.W      [R3], R5
8000e138:	50 10       	MOV       R5, #0			;->0x0000
8000e13a:	45 83       	ST.B      [R4], R5
##@@@F_:ftoa():
##@@@P_:ftoa.c:306
8000e13c:	ec 29       	ADD       SP, #28			;->0x1C
8000e13e:	1f 5e       	POP       {R6-R10}
8000e140:	0d 5d       	POP       LR
8000e142:	1d 5c       	JMP       LR
8000e144:	a4 cf 00 d0 	.long     0xd000cfa4 ->-805253212  [!!!@2@:DIVS      R4, R4, R6	@@: ZXT.H     R0, R0
8000e148:	98 cf 00 d0 	.long     0xd000cf98 ->-805253224  [!!!@2@:DIVS      R3, R0, R6	@@: ZXT.H     R0, R0
8000e14c:	ff ff ff ff 	.long     0xffffffff ->-00000001 
8000e150:	ff ff 7f 00 	.long     0x007fffff ->008388607 
8000e154:	00 00 80 00 	.long     0x00800000 ->008388608  [!!!@2@:NOP      	@@: LJMP      $+128                 ;->0x8000e254
8000e158:	9c cf 00 d0 	.long     0xd000cf9c ->-805253220  [!!!@2@:DIVS      R3, R4, R6	@@: ZXT.H     R0, R0
8000e15c:	a0 cf 00 d0 	.long     0xd000cfa0 ->-805253216  [!!!@2@:DIVS      R4, R0, R6	@@: ZXT.H     R0, R0
8000e160:	00 00 40 00 	.long     0x00400000 ->004194304  [!!!@2@:NOP      	@@: LD.W      R0, [R2 + #0]
8000e164:	ff ff ff 4f 	.long     0x4fffffff ->1342177279 
8000e168:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000e16c:	ff ff ff 0f 	.long     0x0fffffff ->268435455 
8000e170:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
8000e174:	80 e1 00 80 	.long     0x8000e180 ->-2147425920  [!!!@2@:LD.B      R4, [SP + #0]	@@: LD.B      R0, [R0]
8000e178:	fe ff ff ff 	.long     0xfffffffe ->-00000002 
8000e17c:	d0 e2 00 80 	.long     0x8000e2d0 ->-2147425584  [!!!@2@:ST.H      [SP + #16], R6	@@: LD.B      R0, [R0]

8000e180 <_ftoa_round>:
##@@@F_:_ftoa_round():
##@@@P_:ftoa.c:79
8000e180:	00 38       	CMP       R0, #0			;->0x00
8000e182:	1a fb       	JLT       $+26                  ;->0x8000e1b6
##@@@P_:ftoa.c:81
8000e184:	0d 45       	LD        R5, [PC + #13]        ;->0x8000e1b8  :=0xd000cf98
8000e186:	45 82       	LD.W      R4, [R5]
8000e188:	0d 43       	LD        R3, [PC + #13]        ;->0x8000e1bc  :=0x8000000
##@@@P_:ftoa.c:83
8000e18a:	00 38       	CMP       R0, #0			;->0x00
8000e18c:	08 f0       	JZ        $+8                   ;->0x8000e19c
8000e18e:	50 c0       	ADD       R2, R0, #1
8000e190:	1a 10       	MOV       R1, #10			;->0x000A
##@@@F_:_div10():
##@@@P_:ftoa.c:69
8000e192:	5b c1       	ADD       R3, R3, #5
8000e194:	5b d2       	DIVU      R3, R3, R1
##@@@F_:_ftoa_round():
##@@@P_:ftoa.c:83
8000e196:	52 cc       	SUB       R2, R2, #1
8000e198:	21 38       	CMP       R2, #1			;->0x01
8000e19a:	fc f8       	JHI       $-4                   ;->0x8000e192
##@@@P_:ftoa.c:88
8000e19c:	23 c3       	ADD       R4, R3, R4
8000e19e:	54 85       	ST.W      [R5], R4
##@@@P_:ftoa.c:89
8000e1a0:	08 43       	LD        R3, [PC + #8]         ;->0x8000e1c0  :=0xa0000000
8000e1a2:	43 70       	CMP       R4, R3
8000e1a4:	09 f3       	JNC       $+9                   ;->0x8000e1b6
##@@@F_:_div10():
##@@@P_:ftoa.c:69
8000e1a6:	64 c1       	ADD       R4, R4, #5
8000e1a8:	3a 10       	MOV       R3, #10			;->0x000A
8000e1aa:	e4 d2       	DIVU      R4, R4, R3
8000e1ac:	54 85       	ST.W      [R5], R4
##@@@F_:_ftoa_round():
##@@@P_:ftoa.c:92
8000e1ae:	06 45       	LD        R5, [PC + #6]         ;->0x8000e1c4  :=0xd000cfa0
8000e1b0:	45 82       	LD.W      R4, [R5]
8000e1b2:	64 c0       	ADD       R4, R4, #1
8000e1b4:	54 85       	ST.W      [R5], R4
##@@@P_:ftoa.c:95
8000e1b6:	1d 5c       	JMP       LR
8000e1b8:	98 cf 00 d0 	.long     0xd000cf98 ->-805253224  [!!!@2@:DIVS      R3, R0, R6	@@: ZXT.H     R0, R0
8000e1bc:	00 00 00 08 	.long     0x08000000 ->134217728  [!!!@2@:NOP      	@@: LD.W      R0, [SP + #0]
8000e1c0:	00 00 00 a0 	.long     0xa0000000 ->-1610612736  [!!!@2@:NOP      	@@: ST.W      [R0 + #0], R0
8000e1c4:	a0 cf 00 d0 	.long     0xd000cfa0 ->-805253216  [!!!@2@:DIVS      R4, R0, R6	@@: ZXT.H     R0, R0

8000e1c8 <ultoa>:
##@@@F_:ultoa():
##@@@P_:ltoa.c:12
8000e1c8:	87 5f       	PUSH      {R6-R8,LR}
8000e1ca:	e4 33       	SUB       SP, #52			;->0x34
8000e1cc:	02 21       	ST.W      [SP + #2], R1
8000e1ce:	30 10       	MOV       R3, #0			;->0x0000
8000e1d0:	51 12       	MOV       R5, #33			;->0x0021
8000e1d2:	19 44       	LD        R4, [PC + #25]        ;->0x8000e234  :=0xffffffe0
8000e1d4:	8f 1f       	MOV       R8, #255			;->0x00FF
8000e1d6:	01 23       	ST.W      [SP + #1], R3
8000e1d8:	03 22       	ST.W      [SP + #3], R2
##@@@P_:ltoa.c:24
8000e1da:	88 d2       	DIVU      R1, R0, R2
8000e1dc:	04 21       	ST.W      [SP + #4], R1
8000e1de:	89 ca       	MULS      R1, R1, R2
8000e1e0:	78 c6       	SUB       R7, R0, R1
##@@@P_:ltoa.c:20
8000e1e2:	27 58       	MOV       R1, R7
8000e1e4:	10 2b       	ADD       R1, #48			;->0x30
8000e1e6:	c1 58       	MOV       R6, R1
8000e1e8:	68 69       	ANL       R6, R8
##@@@P_:ltoa.c:21
8000e1ea:	69 3b       	CMP       R6, #57			;->0x39
8000e1ec:	03 f8       	JHI       $+3                   ;->0x8000e1f2
8000e1ee:	e1 58       	MOV       R7, R1
8000e1f0:	02 04       	SJMP      $+2                   ;->0x8000e1f4
8000e1f2:	77 2d       	ADD       R7, #87			;->0x57
8000e1f4:	03 0a       	LD.W      R2, [SP + #3]
8000e1f6:	04 0e       	LD.W      R6, [SP + #4]
8000e1f8:	10 41       	LD        R1, [PC + #16]        ;->0x8000e238  :=0x14
8000e1fa:	1e 64       	ADD       R1, SP
##@@@P_:ltoa.c:23
8000e1fc:	c9 c2       	ADD       R1, R1, R3
8000e1fe:	cf 97       	ST.B      [R1 + #31], R7
##@@@P_:ltoa.c:25
8000e200:	64 c0       	ADD       R4, R4, #1
8000e202:	6d cc       	SUB       R5, R5, #1
8000e204:	5b cc       	SUB       R3, R3, #1
8000e206:	02 70       	CMP       R0, R2
8000e208:	06 58       	MOV       R0, R6
8000e20a:	e8 f2       	JC        $-24                  ;->0x8000e1da
##@@@P_:ltoa.c:28
8000e20c:	50 3a       	CMP       R5, #32			;->0x20
8000e20e:	02 f8       	JHI       $+2                   ;->0x8000e212
8000e210:	50 12       	MOV       R5, #32			;->0x0020
8000e212:	3d c3       	ADD       R7, R5, R4
8000e214:	09 45       	LD        R5, [PC + #9]         ;->0x8000e238  :=0x14
8000e216:	5e 64       	ADD       R5, SP
##@@@P_:ltoa.c:27
8000e218:	cd c2       	ADD       R1, R5, R3
8000e21a:	10 2a       	ADD       R1, #32			;->0x20
8000e21c:	02 0e       	LD.W      R6, [SP + #2]
##@@@P_:ltoa.c:28
8000e21e:	06 58       	MOV       R0, R6
8000e220:	47 58       	MOV       R2, R7
8000e222:	07 45       	LD        R5, [PC + #7]         ;->0x8000e23c  :=0x8000d9ec
8000e224:	05 5c       	LJMP      R5
##@@@P_:ltoa.c:31
8000e226:	01 0d       	LD.W      R5, [SP + #1]
8000e228:	f5 eb       	ST.B      [R6 + R7], R5
##@@@P_:ltoa.c:32
8000e22a:	e4 2b       	ADD       SP, #52			;->0x34
8000e22c:	07 5e       	POP       {R6-R8}
8000e22e:	0d 5d       	POP       LR
8000e230:	1d 5c       	JMP       LR
8000e232:	00 00       	NOP      NOP      
8000e234:	e0 ff ff ff 	.long     0xffffffe0 ->-00000032 
8000e238:	14 00 00 00 	.long     0x00000014 ->000000020  [!!!@4@:DMSC16LL  ACC0, ACC0, R0, R0
8000e23c:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]

8000e240 <ltoa>:
##@@@F_:ltoa():
##@@@P_:ltoa.c:35
8000e240:	87 5f       	PUSH      {R6-R8,LR}
8000e242:	e4 33       	SUB       SP, #52			;->0x34
##@@@P_:ltoa.c:37
8000e244:	1f 45       	LD        R5, [PC + #31]        ;->0x8000e2c0  :=0xffffffff
8000e246:	05 70       	CMP       R0, R5
8000e248:	08 fc       	JGT       $+8                   ;->0x8000e258
8000e24a:	2a 38       	CMP       R2, #10			;->0x0A
8000e24c:	06 f1       	JNZ       $+6                   ;->0x8000e258
8000e24e:	5d 12       	MOV       R5, #45			;->0x002D
##@@@P_:ltoa.c:38
8000e250:	15 83       	ST.B      [R1], R5
8000e252:	50 10       	MOV       R5, #0			;->0x0000
##@@@P_:ltoa.c:39
8000e254:	05 c6       	SUB       R0, R5, R0
##@@@P_:ltoa.c:38
8000e256:	49 c0       	ADD       R1, R1, #1
8000e258:	01 21       	ST.W      [SP + #1], R1
8000e25a:	30 10       	MOV       R3, #0			;->0x0000
8000e25c:	51 12       	MOV       R5, #33			;->0x0021
8000e25e:	1a 44       	LD        R4, [PC + #26]        ;->0x8000e2c4  :=0xffffffe0
8000e260:	8f 1f       	MOV       R8, #255			;->0x00FF
8000e262:	02 23       	ST.W      [SP + #2], R3
8000e264:	03 22       	ST.W      [SP + #3], R2
##@@@F_:ultoa():
##@@@P_:ltoa.c:24
8000e266:	88 d2       	DIVU      R1, R0, R2
8000e268:	04 21       	ST.W      [SP + #4], R1
8000e26a:	89 ca       	MULS      R1, R1, R2
8000e26c:	78 c6       	SUB       R7, R0, R1
##@@@P_:ltoa.c:20
8000e26e:	27 58       	MOV       R1, R7
8000e270:	10 2b       	ADD       R1, #48			;->0x30
8000e272:	c1 58       	MOV       R6, R1
8000e274:	68 69       	ANL       R6, R8
##@@@P_:ltoa.c:21
8000e276:	69 3b       	CMP       R6, #57			;->0x39
8000e278:	03 f8       	JHI       $+3                   ;->0x8000e27e
8000e27a:	e1 58       	MOV       R7, R1
8000e27c:	02 04       	SJMP      $+2                   ;->0x8000e280
8000e27e:	77 2d       	ADD       R7, #87			;->0x57
8000e280:	03 0a       	LD.W      R2, [SP + #3]
8000e282:	04 0e       	LD.W      R6, [SP + #4]
8000e284:	11 41       	LD        R1, [PC + #17]        ;->0x8000e2c8  :=0x14
8000e286:	1e 64       	ADD       R1, SP
##@@@P_:ltoa.c:23
8000e288:	c9 c2       	ADD       R1, R1, R3
8000e28a:	cf 97       	ST.B      [R1 + #31], R7
##@@@P_:ltoa.c:25
8000e28c:	64 c0       	ADD       R4, R4, #1
8000e28e:	6d cc       	SUB       R5, R5, #1
8000e290:	5b cc       	SUB       R3, R3, #1
8000e292:	02 70       	CMP       R0, R2
8000e294:	06 58       	MOV       R0, R6
8000e296:	e8 f2       	JC        $-24                  ;->0x8000e266
##@@@P_:ltoa.c:28
8000e298:	50 3a       	CMP       R5, #32			;->0x20
8000e29a:	02 f8       	JHI       $+2                   ;->0x8000e29e
8000e29c:	50 12       	MOV       R5, #32			;->0x0020
8000e29e:	3d c3       	ADD       R7, R5, R4
8000e2a0:	0a 45       	LD        R5, [PC + #10]        ;->0x8000e2c8  :=0x14
8000e2a2:	5e 64       	ADD       R5, SP
##@@@P_:ltoa.c:27
8000e2a4:	cd c2       	ADD       R1, R5, R3
8000e2a6:	10 2a       	ADD       R1, #32			;->0x20
8000e2a8:	01 0e       	LD.W      R6, [SP + #1]
##@@@P_:ltoa.c:28
8000e2aa:	06 58       	MOV       R0, R6
8000e2ac:	47 58       	MOV       R2, R7
8000e2ae:	08 45       	LD        R5, [PC + #8]         ;->0x8000e2cc  :=0x8000d9ec
8000e2b0:	05 5c       	LJMP      R5
##@@@P_:ltoa.c:31
8000e2b2:	02 0d       	LD.W      R5, [SP + #2]
8000e2b4:	f5 eb       	ST.B      [R6 + R7], R5
##@@@F_:ltoa():
##@@@P_:ltoa.c:43
8000e2b6:	e4 2b       	ADD       SP, #52			;->0x34
8000e2b8:	07 5e       	POP       {R6-R8}
8000e2ba:	0d 5d       	POP       LR
8000e2bc:	1d 5c       	JMP       LR
8000e2be:	00 00       	NOP      NOP      
8000e2c0:	ff ff ff ff 	.long     0xffffffff ->-00000001 
8000e2c4:	e0 ff ff ff 	.long     0xffffffe0 ->-00000032 
8000e2c8:	14 00 00 00 	.long     0x00000014 ->000000020  [!!!@4@:DMSC16LL  ACC0, ACC0, R0, R0
8000e2cc:	ec d9 00 80 	.long     0x8000d9ec ->-2147427860  [!!!@2@:XRL       R5, R4, R7	@@: LD.B      R0, [R0]

8000e2d0 <__utoa>:
##@@@F_:__utoa():
##@@@P_:utoa.c:35
8000e2d0:	03 5f       	PUSH      {R6-R7}
8000e2d2:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:utoa.c:42
8000e2d4:	a2 58       	MOV       R5, R2
8000e2d6:	55 32       	SUB       R5, #37			;->0x25
8000e2d8:	16 44       	LD        R4, [PC + #22]        ;->0x8000e330  :=0xffffffdd
8000e2da:	54 70       	CMP       R5, R4
8000e2dc:	04 f2       	JC        $+4                   ;->0x8000e2e4
8000e2de:	00 10       	MOV       R0, #0			;->0x0000
##@@@P_:utoa.c:44
8000e2e0:	10 83       	ST.B      [R1], R0
8000e2e2:	23 04       	SJMP      $+35                  ;->0x8000e328
8000e2e4:	40 10       	MOV       R4, #0			;->0x0000
8000e2e6:	14 43       	LD        R3, [PC + #20]        ;->0x8000e334  :=0x800016dd
8000e2e8:	a4 58       	MOV       R5, R4
##@@@P_:utoa.c:54
8000e2ea:	b8 d2       	DIVU      R7, R0, R2
8000e2ec:	b7 ca       	MULS      R6, R7, R2
8000e2ee:	b0 c7       	SUB       R6, R0, R6
##@@@P_:utoa.c:53
8000e2f0:	b3 e5       	LD.B      R6, [R3 + R6]
8000e2f2:	4e eb       	ST.B      [R1 + R5], R6
8000e2f4:	6d c0       	ADD       R5, R5, #1
##@@@P_:utoa.c:55
8000e2f6:	02 70       	CMP       R0, R2
8000e2f8:	07 58       	MOV       R0, R7
8000e2fa:	f8 f2       	JC        $-8                   ;->0x8000e2ea
##@@@P_:utoa.c:56
8000e2fc:	4c eb       	ST.B      [R1 + R5], R4
##@@@P_:utoa.c:59
8000e2fe:	51 38       	CMP       R5, #1			;->0x01
8000e300:	13 f0       	JZ        $+19                  ;->0x8000e326
8000e302:	65 cc       	SUB       R4, R5, #1
##@@@P_:utoa.c:61
8000e304:	31 80       	LD.B      R3, [R1]
##@@@P_:utoa.c:62
8000e306:	16 83       	ST.B      [R1], R6
8000e308:	51 c3       	ADD       R2, R1, R5
8000e30a:	52 cc       	SUB       R2, R2, #1
##@@@P_:utoa.c:63
8000e30c:	23 83       	ST.B      [R2], R3
##@@@P_:utoa.c:59
8000e30e:	43 38       	CMP       R4, #3			;->0x03
8000e310:	0b f3       	JNC       $+11                  ;->0x8000e326
8000e312:	41 10       	MOV       R4, #1			;->0x0001
8000e314:	ad cc       	SUB       R5, R5, #2
##@@@P_:utoa.c:61
8000e316:	19 e5       	LD.B      R3, [R1 + R4]
##@@@P_:utoa.c:62
8000e318:	51 e5       	LD.B      R2, [R1 + R5]
8000e31a:	0a eb       	ST.B      [R1 + R4], R2
##@@@P_:utoa.c:63
8000e31c:	4b eb       	ST.B      [R1 + R5], R3
##@@@P_:utoa.c:59
8000e31e:	6d cc       	SUB       R5, R5, #1
8000e320:	64 c0       	ADD       R4, R4, #1
8000e322:	45 70       	CMP       R4, R5
8000e324:	f9 fb       	JLT       $-7                   ;->0x8000e316
8000e326:	01 58       	MOV       R0, R1
##@@@P_:utoa.c:67
8000e328:	e4 28       	ADD       SP, #4			;->0x04
8000e32a:	03 5e       	POP       {R6-R7}
8000e32c:	1d 5c       	JMP       LR
8000e32e:	00 00       	NOP      NOP      
8000e330:	dd ff ff ff 	.long     0xffffffdd ->-00000035 
8000e334:	dd 16 00 80 	.long     0x800016dd ->-2147477795  [!!!@2@:MOV       LR, #109	@@: LD.B      R0, [R0]

8000e338 <utoa>:
##@@@F_:utoa():
##@@@P_:utoa.c:73
8000e338:	2d 5d       	PUSH      LR
8000e33a:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:utoa.c:74
8000e33c:	03 45       	LD        R5, [PC + #3]         ;->0x8000e348  :=0x8000e2d0
8000e33e:	05 5c       	LJMP      R5
8000e340:	e4 28       	ADD       SP, #4			;->0x04
8000e342:	0d 5d       	POP       LR
8000e344:	1d 5c       	JMP       LR
8000e346:	00 00       	NOP      NOP      
8000e348:	d0 e2 00 80 	.long     0x8000e2d0 ->-2147425584  [!!!@2@:ST.H      [SP + #16], R6	@@: LD.B      R0, [R0]

8000e34c <uitoa>:
##@@@F_:uitoa():
##@@@P_:utoa.c:81
8000e34c:	2d 5d       	PUSH      LR
8000e34e:	e4 30       	SUB       SP, #4			;->0x04
##@@@P_:utoa.c:82
8000e350:	03 45       	LD        R5, [PC + #3]         ;->0x8000e35c  :=0x8000e2d0
8000e352:	05 5c       	LJMP      R5
8000e354:	e4 28       	ADD       SP, #4			;->0x04
8000e356:	0d 5d       	POP       LR
8000e358:	1d 5c       	JMP       LR
8000e35a:	00 00       	NOP      NOP      
8000e35c:	d0 e2 00 80 	.long     0x8000e2d0 ->-2147425584  [!!!@2@:ST.H      [SP + #16], R6	@@: LD.B      R0, [R0]

8000e360 <__truncdfsf2>:
##@@@F_:__truncdfsf2():
8000e360:	bf 5f       	PUSH      {R6-R11,LR}
8000e362:	e4 30       	SUB       SP, #4			;->0x04
8000e364:	01 59       	MOV       R8, R1
8000e366:	e0 58       	MOV       R7, R0
8000e368:	43 45       	LD        R5, [PC + #67]        ;->0x8000e474  :=0x7fffffff
8000e36a:	c1 58       	MOV       R6, R1
8000e36c:	65 69       	ANL       R6, R5
8000e36e:	43 45       	LD        R5, [PC + #67]        ;->0x8000e478  :=0xb8100000
8000e370:	6e c3       	ADD       R5, R6, R5
8000e372:	43 44       	LD        R4, [PC + #67]        ;->0x8000e47c  :=0xc7f00000
8000e374:	26 c3       	ADD       R4, R6, R4
8000e376:	45 70       	CMP       R4, R5
8000e378:	0e f2       	JC        $+14                  ;->0x8000e394
8000e37a:	42 44       	LD        R4, [PC + #66]        ;->0x8000e480  :=0x1fffffff
8000e37c:	a7 58       	MOV       R5, R7
8000e37e:	54 69       	ANL       R5, R4
8000e380:	bd 7d       	LSR       R7, #29			;->0x1D
8000e382:	88 58       	MOV       R4, R8
8000e384:	23 7a       	LSL       R4, #3			;->0x03
8000e386:	74 6a       	ORL       R7, R4
8000e388:	3f 44       	LD        R4, [PC + #63]        ;->0x8000e484  :=0x10000001
8000e38a:	54 70       	CMP       R5, R4
8000e38c:	1c f3       	JNC       $+28                  ;->0x8000e3c4
8000e38e:	3f 45       	LD        R5, [PC + #63]        ;->0x8000e488  :=0x40000001
8000e390:	77 c3       	ADD       R6, R7, R5
8000e392:	68 04       	SJMP      $+104                 ;->0x8000e462
8000e394:	30 10       	MOV       R3, #0			;->0x0000
8000e396:	51 10       	MOV       R5, #1			;->0x0001
8000e398:	85 58       	MOV       R4, R5
8000e39a:	70 38       	CMP       R7, #0			;->0x00
8000e39c:	1f f1       	JNZ       $+31                  ;->0x8000e3da
8000e39e:	3c 41       	LD        R1, [PC + #60]        ;->0x8000e48c  :=0x7ff00000
8000e3a0:	45 58       	MOV       R2, R5
8000e3a2:	61 70       	CMP       R6, R1
8000e3a4:	20 f2       	JC        $+32                  ;->0x8000e3e4
8000e3a6:	61 70       	CMP       R6, R1
8000e3a8:	21 f1       	JNZ       $+33                  ;->0x8000e3ea
8000e3aa:	45 69       	ANL       R4, R5
8000e3ac:	40 38       	CMP       R4, #0			;->0x00
8000e3ae:	22 f1       	JNZ       $+34                  ;->0x8000e3f2
8000e3b0:	bd 7d       	LSR       R7, #29			;->0x1D
8000e3b2:	a8 58       	MOV       R5, R8
8000e3b4:	2b 7a       	LSL       R5, #3			;->0x03
8000e3b6:	75 6a       	ORL       R7, R5
8000e3b8:	36 45       	LD        R5, [PC + #54]        ;->0x8000e490  :=0x3fffff
8000e3ba:	75 69       	ANL       R7, R5
8000e3bc:	36 45       	LD        R5, [PC + #54]        ;->0x8000e494  :=0x7fc00000
8000e3be:	75 6a       	ORL       R7, R5
8000e3c0:	c7 58       	MOV       R6, R7
8000e3c2:	50 04       	SJMP      $+80                  ;->0x8000e462
8000e3c4:	35 44       	LD        R4, [PC + #53]        ;->0x8000e498  :=0x40000000
8000e3c6:	37 c3       	ADD       R6, R7, R4
8000e3c8:	35 44       	LD        R4, [PC + #53]        ;->0x8000e49c  :=0x10000000
8000e3ca:	54 6b       	XRL       R5, R4
8000e3cc:	50 38       	CMP       R5, #0			;->0x00
8000e3ce:	02 f0       	JZ        $+2                   ;->0x8000e3d2
8000e3d0:	49 04       	SJMP      $+73                  ;->0x8000e462
8000e3d2:	51 10       	MOV       R5, #1			;->0x0001
8000e3d4:	75 69       	ANL       R7, R5
8000e3d6:	f6 c3       	ADD       R6, R6, R7
8000e3d8:	45 04       	SJMP      $+69                  ;->0x8000e462
8000e3da:	83 58       	MOV       R4, R3
8000e3dc:	2c 41       	LD        R1, [PC + #44]        ;->0x8000e48c  :=0x7ff00000
8000e3de:	45 58       	MOV       R2, R5
8000e3e0:	61 70       	CMP       R6, R1
8000e3e2:	e2 f3       	JNC       $-30                  ;->0x8000e3a6
8000e3e4:	43 58       	MOV       R2, R3
8000e3e6:	61 70       	CMP       R6, R1
8000e3e8:	e1 f0       	JZ        $-31                  ;->0x8000e3aa
8000e3ea:	82 58       	MOV       R4, R2
8000e3ec:	45 69       	ANL       R4, R5
8000e3ee:	40 38       	CMP       R4, #0			;->0x00
8000e3f0:	e0 f0       	JZ        $-32                  ;->0x8000e3b0
8000e3f2:	2c 45       	LD        R5, [PC + #44]        ;->0x8000e4a0  :=0x47efffff
8000e3f4:	65 70       	CMP       R6, R5
8000e3f6:	03 f9       	JLS       $+3                   ;->0x8000e3fc
8000e3f8:	2b 46       	LD        R6, [PC + #43]        ;->0x8000e4a4  :=0x7f800000
8000e3fa:	34 04       	SJMP      $+52                  ;->0x8000e462
8000e3fc:	34 7d       	LSR       R6, #20			;->0x14
8000e3fe:	2b 45       	LD        R5, [PC + #43]        ;->0x8000e4a8  :=0x34d
8000e400:	65 70       	CMP       R6, R5
8000e402:	03 f2       	JC        $+3                   ;->0x8000e408
8000e404:	60 10       	MOV       R6, #0			;->0x0000
8000e406:	2e 04       	SJMP      $+46                  ;->0x8000e462
8000e408:	29 45       	LD        R5, [PC + #41]        ;->0x8000e4ac  :=0xfffff
8000e40a:	68 59       	MOV       R11, R8
8000e40c:	b5 69       	ANL       R11, R5
8000e40e:	29 45       	LD        R5, [PC + #41]        ;->0x8000e4b0  :=0x100000
8000e410:	b5 6a       	ORL       R11, R5
8000e412:	29 45       	LD        R5, [PC + #41]        ;->0x8000e4b4  :=0x381
8000e414:	95 c7       	SUB       R2, R5, R6
8000e416:	07 58       	MOV       R0, R7
8000e418:	2b 58       	MOV       R1, R11
8000e41a:	28 45       	LD        R5, [PC + #40]        ;->0x8000e4b8  :=0x8000d960
8000e41c:	05 5c       	LJMP      R5
8000e41e:	20 59       	MOV       R9, R0
8000e420:	41 59       	MOV       R10, R1
8000e422:	27 45       	LD        R5, [PC + #39]        ;->0x8000e4bc  :=0xfffffcbf
8000e424:	56 c3       	ADD       R2, R6, R5
8000e426:	53 7a       	LSL       R10, #3			;->0x03
8000e428:	c0 58       	MOV       R6, R0
8000e42a:	b5 7d       	LSR       R6, #29			;->0x1D
8000e42c:	07 58       	MOV       R0, R7
8000e42e:	2b 58       	MOV       R1, R11
8000e430:	24 45       	LD        R5, [PC + #36]        ;->0x8000e4c0  :=0x8000e4c8
8000e432:	05 5c       	LJMP      R5
8000e434:	01 6a       	ORL       R0, R1
8000e436:	00 38       	CMP       R0, #0			;->0x00
8000e438:	03 f1       	JNZ       $+3                   ;->0x8000e43e
8000e43a:	50 10       	MOV       R5, #0			;->0x0000
8000e43c:	02 04       	SJMP      $+2                   ;->0x8000e440
8000e43e:	51 10       	MOV       R5, #1			;->0x0001
8000e440:	6a 6a       	ORL       R6, R10
8000e442:	95 6a       	ORL       R9, R5
8000e444:	0f 45       	LD        R5, [PC + #15]        ;->0x8000e480  :=0x1fffffff
8000e446:	95 69       	ANL       R9, R5
8000e448:	0f 45       	LD        R5, [PC + #15]        ;->0x8000e484  :=0x10000001
8000e44a:	95 70       	CMP       R9, R5
8000e44c:	03 f3       	JNC       $+3                   ;->0x8000e452
8000e44e:	76 c0       	ADD       R6, R6, #1
8000e450:	09 04       	SJMP      $+9                   ;->0x8000e462
8000e452:	13 45       	LD        R5, [PC + #19]        ;->0x8000e49c  :=0x10000000
8000e454:	95 6b       	XRL       R9, R5
8000e456:	90 38       	CMP       R9, #0			;->0x00
8000e458:	05 f1       	JNZ       $+5                   ;->0x8000e462
8000e45a:	51 10       	MOV       R5, #1			;->0x0001
8000e45c:	86 58       	MOV       R4, R6
8000e45e:	45 69       	ANL       R4, R5
8000e460:	b4 c3       	ADD       R6, R4, R6
8000e462:	19 45       	LD        R5, [PC + #25]        ;->0x8000e4c4  :=0x80000000
8000e464:	85 69       	ANL       R8, R5
8000e466:	68 6a       	ORL       R6, R8
8000e468:	06 58       	MOV       R0, R6
8000e46a:	e4 28       	ADD       SP, #4			;->0x04
8000e46c:	3f 5e       	POP       {R6-R11}
8000e46e:	0d 5d       	POP       LR
8000e470:	1d 5c       	JMP       LR
8000e472:	00 00       	NOP      NOP      
8000e474:	ff ff ff 7f 	.long     0x7fffffff ->2147483647 
8000e478:	00 00 10 b8 	.long     0xb8100000 ->-1206910976  [!!!@2@:NOP      	@@: LDP.B     R2, [R0] << #0
8000e47c:	00 00 f0 c7 	.long     0xc7f00000 ->-940572672  [!!!@2@:NOP      	@@: SUB       R6, R0, R7
8000e480:	ff ff ff 1f 	.long     0x1fffffff ->536870911 
8000e484:	01 00 00 10 	.long     0x10000001 ->268435457  [!!!@2@:.short    0x0001	@@: MOV       R0, #0
8000e488:	01 00 00 40 	.long     0x40000001 ->1073741825  [!!!@2@:.short    0x0001	@@: LD        R0, [PC + #0]         ;->0x8000e488  :=0x40000001
8000e48c:	00 00 f0 7f 	.long     0x7ff00000 ->2146435072  [!!!@2@:NOP      	@@: ROR       SP, #24
8000e490:	ff ff 3f 00 	.long     0x003fffff ->004194303 
8000e494:	00 00 c0 7f 	.long     0x7fc00000 ->2143289344  [!!!@2@:NOP      	@@: ROR       R8, #24
8000e498:	00 00 00 40 	.long     0x40000000 ->1073741824  [!!!@2@:NOP      	@@: LD        R0, [PC + #0]         ;->0x8000e498  :=0x40000000
8000e49c:	00 00 00 10 	.long     0x10000000 ->268435456  [!!!@2@:NOP      	@@: MOV       R0, #0
8000e4a0:	ff ff ef 47 	.long     0x47efffff ->1206910975 
8000e4a4:	00 00 80 7f 	.long     0x7f800000 ->2139095040  [!!!@2@:NOP      	@@: ROR       R0, #24
8000e4a8:	4d 03 00 00 	.long     0x0000034d ->000000845  [!!!@4@:JMP       $+5046272             ;->0x809ae4a8
8000e4ac:	ff ff 0f 00 	.long     0x000fffff ->001048575 
8000e4b0:	00 00 10 00 	.long     0x00100000 ->001048576  [!!!@2@:NOP      	@@: DMAC16LL  ACC0, ACC0, R0, R16
8000e4b4:	81 03 00 00 	.long     0x00000381 ->000000897  [!!!@4@:JMP       $-8323072             ;->0x7f02e4b4
8000e4b8:	60 d9 00 80 	.long     0x8000d960 ->-2147428000  [!!!@2@:XRL       R4, R0, R5	@@: LD.B      R0, [R0]
8000e4bc:	bf fc ff ff 	.long     0xfffffcbf ->-00000833 
8000e4c0:	c8 e4 00 80 	.long     0x8000e4c8 ->-2147425080  [!!!@2@:LD.B      R1, [R0 + R3]	@@: LD.B      R0, [R0]
8000e4c4:	00 00 00 80 	.long     0x80000000 ->-2147483648  [!!!@2@:NOP      	@@: LD.B      R0, [R0]

8000e4c8 <__ashldi3>:
##@@@F_:__ashldi3():
8000e4c8:	a0 58       	MOV       R5, R0
8000e4ca:	40 12       	MOV       R4, #32			;->0x0020
8000e4cc:	62 58       	MOV       R3, R2
8000e4ce:	34 69       	ANL       R3, R4
8000e4d0:	30 38       	CMP       R3, #0			;->0x00
8000e4d2:	0b f1       	JNZ       $+11                  ;->0x8000e4e8
8000e4d4:	20 38       	CMP       R2, #0			;->0x00
8000e4d6:	0e f0       	JZ        $+14                  ;->0x8000e4f2
8000e4d8:	12 6c       	LSL       R1, R2
8000e4da:	a4 c6       	SUB       R4, R4, R2
8000e4dc:	65 58       	MOV       R3, R5
8000e4de:	34 6d       	LSR       R3, R4
8000e4e0:	13 6a       	ORL       R1, R3
8000e4e2:	05 58       	MOV       R0, R5
8000e4e4:	02 6c       	LSL       R0, R2
8000e4e6:	1d 5c       	JMP       LR
8000e4e8:	20 32       	SUB       R2, #32			;->0x20
8000e4ea:	52 6c       	LSL       R5, R2
8000e4ec:	00 10       	MOV       R0, #0			;->0x0000
8000e4ee:	25 58       	MOV       R1, R5
8000e4f0:	1d 5c       	JMP       LR
8000e4f2:	05 58       	MOV       R0, R5
8000e4f4:	1d 5c       	JMP       LR
