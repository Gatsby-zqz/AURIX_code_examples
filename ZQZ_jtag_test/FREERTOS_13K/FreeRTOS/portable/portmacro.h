/*
 * FreeRTOS Kernel V10.2.1
 * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/**
 * \file portmacro.h
 * \brief FreeRTOS portable file which defines the TriCore specific macros.
 *
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *                               IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef PORTMACRO_H
#define PORTMACRO_H

#ifdef __cplusplus
extern "C" {
#endif

/* System Includes. */
#include <stdint.h>
#include "kf_types.h"
/*-----------------------------------------------------------
 * Port specific definitions.
 *
 * The settings in this file configure FreeRTOS correctly for the
 * given hardware and compiler.
 *
 * These settings should not be altered.
 *-----------------------------------------------------------
 */

#ifndef FREERTOS_CORE_ID
#define FREERTOS_CORE_ID 0
#endif

/* Type definitions. */
#define portCHAR       char
#define portFLOAT      float
#define portDOUBLE     double
#define portLONG       long
#define portSHORT      short
#define portSTACK_TYPE unsigned long
#define portBASE_TYPE  long

typedef portSTACK_TYPE StackType_t;
typedef long           BaseType_t;
typedef unsigned long  UBaseType_t;

#if (configUSE_16_BIT_TICKS == 1)
typedef unsigned TickType_t;
#define portMAX_DELAY (TickType_t)0xffff
#else
typedef unsigned TickType_t;
#define portMAX_DELAY           (TickType_t)0xffffffffUL

/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
not need to be guarded with a critical section. */
#define portTICK_TYPE_IS_ATOMIC 1

#endif
/*---------------------------------------------------------------------------*/

/* Architecture specifics. */
#define portSTACK_GROWTH   (-1)
#define portTICK_PERIOD_MS ((TickType_t)1000 / configTICK_RATE_HZ)
#define portBYTE_ALIGNMENT 4
#define portASSERT_IF_IN_ISR()
#define portNOP()                     TriCore__nop()
#define portCRITICAL_NESTING_IN_TCB   1
#define portLOWEST_INTERRUPT_PRIORITY 0

/*---------------------------------------------------------------------------*/

typedef struct MPU_SETTINGS
{
    unsigned long ulNotUsed;
} xMPU_SETTINGS;

/* Define away the instruction from the Restore Context Macro. */
#define portPRIVILEGE_BIT 0x0UL

/*TODO: CCPN[0:8]对应512个SRN，和INT模块描述相符 */
#define portCCPN_MASK (0x000001FFUL)

extern void                               vPortSystemTickHandler(void);
extern void                               vPortSystemTaskHandler(void);
extern void                               vTaskEnterCritical(void);
extern void                               vTaskExitCritical(void);
extern __attribute__((__noreturn__)) void vPortLoopForever(void);
#define portENTER_CRITICAL() vTaskEnterCritical()
#define portEXIT_CRITICAL()  vTaskExitCritical()
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
#define portYIELD()                                                                                                    \
    {                                                                                                                  \
        extern void vPortYield(void);                                                                                  \
        vPortYield();                                                                                                  \
    }

/* Port Restore is implicit in the platform when the function is returned from the original PSW is automatically
 * replaced. */
#define portSYSCALL_TASK_YIELD 0
/*---------------------------------------------------------------------------*/

/* Critical section management. */

/* Set ICR.CCPN to configMAX_SYSCALL_INTERRUPT_PRIORITY. */
#define portDISABLE_INTERRUPTS()                                                                                       \
    {                                                                                                                  \
        DISABLE_INTERRUPT();                                                                                           \
        __asm__ volatile("PUSH R0" ::: "memory");                                                                      \
        __asm__ volatile("PUSH R1" ::: "memory");                                                                      \
        __asm__ volatile("CSRR R0, #0x187" ::: "R0"); /* Get current ICR value. */                                     \
        __asm__ volatile("MOV R1, %0" ::"r"((unsigned int)portCCPN_MASK) : "R1");                                      \
        __asm__ volatile("NOT R1, R1");                                                                                \
        __asm__ volatile("ANL R0, R1"); /* Clear down mask bits. */                                                    \
        __asm__ volatile("MOV R1, %0" ::"r"((unsigned int)configMAX_SYSCALL_INTERRUPT_PRIORITY) : "R1");               \
        __asm__ volatile("ORL R0, R1");      /* Set mask bits to required priority mask. */                            \
        __asm__ volatile("CSRW R0, #0x187"); /* Write back updated ICR. */                                             \
        __asm__ volatile("SYNC");                                                                                      \
        __asm__ volatile("POP R1" ::: "memory");                                                                                    \
        __asm__ volatile("POP R0" ::: "memory");                                                                                    \
        ENABLE_INTERRUPT();                                                                                            \
    }

/* Clear ICR.CCPN to allow all interrupt priorities. */
#define portENABLE_INTERRUPTS()                                                                                        \
    {                                                                                                                  \
        DISABLE_INTERRUPT();                                                                                           \
        __asm__ volatile("PUSH R0" ::: "memory");                                                                                   \
        __asm__ volatile("PUSH R1" ::: "memory");                                                                                   \
        __asm__ volatile("CSRR R0, #0x187" ::: "R0"); /* Get current ICR value. */                                     \
        __asm__ volatile("MOV R1, %0" ::"r"((unsigned int)portCCPN_MASK) : "R1");                                      \
        __asm__ volatile("NOT R1, R1");                                                                                \
        __asm__ volatile("ANL R0, R1");      /* Clear down mask bits. */                                               \
        __asm__ volatile("CSRW R0, #0x187"); /* Write back updated ICR. */                                             \
        __asm__ volatile("SYNC");                                                                                      \
        __asm__ volatile("POP R1" ::: "memory");                                                                                    \
        __asm__ volatile("POP R0" ::: "memory");                                                                                    \
        ENABLE_INTERRUPT();                                                                                            \
    }

/* Set ICR.CCPN to uxSavedMaskValue. */
extern void uxPortClearInterruptMaskFromISR(unsigned long uxSavedMaskValue);
#define portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedMaskValue) uxPortClearInterruptMaskFromISR(uxSavedMaskValue)

/* Set ICR.CCPN to configMAX_SYSCALL_INTERRUPT_PRIORITY */
extern unsigned long uxPortSetInterruptMaskFromISR(void);
#define portSET_INTERRUPT_MASK_FROM_ISR() uxPortSetInterruptMaskFromISR()

/* Pend a priority 1 interrupt, which will take care of the context switch. */
#define portYIELD_FROM_ISR(xHigherPriorityTaskWoken)                                                                   \
    if (xHigherPriorityTaskWoken != pdFALSE)                                                                           \
    {                                                                                                                  \
        portYIELD;                                                                                                     \
    }
/*---------------------------------------------------------------------------*/

/* Task function macros as described on the FreeRTOS.org WEB site. */
#define portTASK_FUNCTION_PROTO(vFunction, pvParameters) void vFunction(void *pvParameters)
#define portTASK_FUNCTION(vFunction, pvParameters)       void vFunction(void *pvParameters)
/*---------------------------------------------------------------------------*/

#define portMEMORY_BARRIER() __asm__ volatile("" ::: "memory")

void interruptSwGp0Sr0(void);

#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
/* Generic helper function. */
__attribute__((always_inline)) static inline uint8_t ucPortCountLeadingZeros(uint32_t ulBitmap)
{
    uint8_t ucReturn;

    __asm volatile("CLZ %0, %1" : "=r"(ucReturn) : "r"(ulBitmap));
    return ucReturn;
}

/* Check the configuration. */
#if (configMAX_PRIORITIES > 32)
#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
#endif

/* Store/clear the ready priorities in a bit map. */
#define portRECORD_READY_PRIORITY(uxPriority, uxReadyPriorities) (uxReadyPriorities) |= (1UL << (uxPriority))
#define portRESET_READY_PRIORITY(uxPriority, uxReadyPriorities)  (uxReadyPriorities) &= ~(1UL << (uxPriority))

/*-----------------------------------------------------------*/

#define portGET_HIGHEST_PRIORITY(uxTopPriority, uxReadyPriorities)                                                     \
    uxTopPriority = (31UL - (uint32_t)ucPortCountLeadingZeros((uxReadyPriorities)))
#endif
#ifdef __cplusplus
}
#endif

#endif /* PORTMACRO_H */
