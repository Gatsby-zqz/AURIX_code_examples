/*
 * FreeRTOS Kernel V10.3.1
 * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/**
 * \file port.c
 * \brief File defining the FreeRTOS portable functions towards TriCore CPUs
 *
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *                               IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* Standard includes. */
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/* Kernel includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "list.h"
#include "kf32a13k_hw_systick.h"
#include "kf32a13k_drv_systick.h"
#include "kf32a13k_drv_int.h"
#include "portmacro.h"
/*-----------------------------------------------------------*/

/* System register Definitions. */
/*TODO: 核实xPSR、PSW和SYSCON的初始值 */
#define portSYSTEM_PROGRAM_STATUS_WORD (0x00004000UL) /* MODE=?; IS = 1 */
#define portINITIAL_XPSR               (0x00000000UL) /* */
#define portINITIAL_SYSCON             (0x00000000UL) /* TPROTEN = 0; PROTEN = 0; TS = 0; IS = 0;*/

/* For strict compliance with the Cortex-M spec the task start address should
have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
#define portSTART_ADDRESS_MASK ((StackType_t)0xfffffffeUL)

/*-----------------------------------------------------------*/
/*
 * Exception handlers.
 */
/* See vector.c */
/*
 * Start first task is a separate function so it can be tested in isolation.
 */
static void prvPortStartFirstTask(void) __attribute__((naked));

/*-----------------------------------------------------------*/

/* This reference is required by the save/restore context macros. */
extern volatile unsigned long *pxCurrentTCB;

/*
 * Setup the timer to generate the tick interrupts.  The implementation in this
 * file is weak to allow application writers to change the timer used to
 * generate the tick interrupt.
 */
void vPortSetupTimerInterrupt(void);

/*-----------------------------------------------------------*/
/* Let the user override the pre-loading of the initial LR with the address of
prvTaskExitError() in case it messes up unwinding of the stack in the
debugger. */
#ifdef configTASK_RETURN_ADDRESS
#define portTASK_RETURN_ADDRESS configTASK_RETURN_ADDRESS
#else
#define portTASK_RETURN_ADDRESS prvTaskExitError
#endif

static void prvTaskExitError(void)
{
    /* A function that implements a task must not exit or attempt to return to
    its caller as there is nothing to return to.  If a task wants to exit it
    should instead call vTaskDelete( NULL ).

    Artificially force an assert() to be triggered if configASSERT() is
    defined, then stop here so application writers can catch the error. */
    portDISABLE_INTERRUPTS();
    for (;;)
        ;
}

extern unsigned int __INTTAB_CPU0[];
StackType_t        *pxPortInitialiseStack(portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters)
{
    /* Simulate the stack frame as it would be created by a context switch
    interrupt. */
    pxTopOfStack--;                   /* Offset added to account for the way the MCU uses the
                                         stack on entry/exit of interrupts. */
    *pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    pxTopOfStack--;
    /** @attention 该LR是任务的返回地址；由于任务不允许返回，只能销毁，因此该LR指向prvTaskExitError */
    *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    pxTopOfStack--;
    *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    pxTopOfStack -= 4;                         /* R4, R3, R2 and R1. */

    /** @attention R5是由中断引导程序在跳转时压栈，按照自动压栈处理 */
    pxTopOfStack--; /* R5. */
    pxTopOfStack--; /* LR */
    /** @attention 该LR是中断引导程序MRET返回时使用的LR，即任务函数地址 */
    /** @attention 该LR在中断引导程序跳转时压栈，按照自动压栈处理 */
    /** @attention MRET指令中POP操作和JMP LR操作并行，POP的LR为任务的返回地址，JMP LR使用的LR为当前中断的返回地址 */
    *pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* LR */
    pxTopOfStack--;                                                 /* LR */
    /** @attention 该LR是中断服务程序返回时使用的LR，即中断引导程序中POP LR地址 */
    /** @attention 该LR在Systick或Gpsr中断服务程序入口出压栈，返回前出栈 */
    /** @attention 该LR初始化为Systick或Gpsr中断引导程序的相应位置，由于中断引导程序的后续指令都一样，因此可以任意指定
     */
    *pxTopOfStack = (portSTACK_TYPE)__INTTAB_CPU0 + 0x20 * portLOWEST_INTERRUPT_PRIORITY + 0x0E;
    pxTopOfStack -= 23; /* 手动压栈 R31, R30, R29, R28, R27, R26, R25, R24, R23, R22, R21, R20, R19,
                                           R18, R17, R16, R12, R11, R10, R9, R8, R7, R6. */

    return pxTopOfStack;
}

/*-----------------------------------------------------------*/
/* TODO: 通过软件中断来开启第一个任务，保证不丢失任务栈初始化的XPSR和R6 */
BaseType_t __attribute__((optnone)) xPortStartScheduler(void)
{
    DISABLE_INTERRUPT();
    /* Load the initial SYSCON. */
    /** @brief 初始化SYSCON*/
    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)portINITIAL_SYSCON));
    __asm__ volatile("CSRW R0, #0x185");
    /** @brief 初始化PSW*/
    /** @attention PSW.IS=1，中断使用全局栈, 进入中断时压当前的SP，在中断服务内由软件决定使用SP或ISP */
    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)portSYSTEM_PROGRAM_STATUS_WORD));
    __asm__ volatile("CSRSET R0, R0, #0x180");
    // TriCore__mtcr(TRICORE_CPU_SYSCON, portINITIAL_SYSCON);
    __asm__ volatile("SYNC");

    /* TODO: 是否需要解锁CPUENDINIT */

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
    here already. */
    vPortSetupTimerInterrupt();

    /* Start the first task. */
    /* 修改栈指针指向任务栈 */
    /** @brief R2 = &pxCurrentTCB */
    __asm__ volatile("LD R2, #pxCurrentTCB" ::: "R2");
    /** @brief R1 = pxCurrentTCB = &CurrentTCB = &CurrentTCB.pxTopOfStack */
    __asm__ volatile("LD.W R1, [R2]" ::: "R1");
    /** @brief R1 = (unsigned int)CurrentTCB.pxTopOfStack */
    __asm__ volatile("LD.W R1, [R1]");
    /** @brief SP = (unsigned int)CurrentTCB.pxTopOfStack */
    __asm__ volatile("MOV SP, R1");
    __asm__ volatile("SYNC");
    /* 手动出栈 */
    __asm__ volatile("POP {R6-R12}");
    __asm__ volatile("" ::: "memory");
    __asm__ volatile("POP {R16-R31}");
    __asm__ volatile("" ::: "memory");
    /** @note 丢弃掉初始化的中断服务函数返回地址LR */
    __asm__ volatile("POP R6" ::: "memory");
    /** @note 此处将任务函数地址LR赋值给R6，通过JMP R6跳转任务，此处会丢弃任务函数R6的初始值 */
    __asm__ volatile("POP R6" ::: "memory");
    __asm__ volatile("POP R5" ::: "memory");
    __asm__ volatile("POP R4" ::: "memory");
    __asm__ volatile("POP R3" ::: "memory");
    __asm__ volatile("POP R2" ::: "memory");
    __asm__ volatile("POP R1" ::: "memory");
    __asm__ volatile("POP R0" ::: "memory");
    __asm__ volatile("POP LR" ::: "memory");

    __asm__ volatile("DSYNC");
    ENABLE_INTERRUPT();
    __asm__ volatile("JMP R6");

    /* Return from function, which would return to the first task selected to execute. */
    return 0;
}
/*-----------------------------------------------------------*/
/* 在任务中触发调度 */
__attribute__((always_inline)) void vPortYield(void)
{
    /* 触发软件中断 */
    Int_LL_SetIntRequestState(HW_GP0SR0_IRQn, true);
}

__attribute__((noinline)) void vPortSystemTickHandler(void)
{
    unsigned long ulSavedInterruptMask;
    long          lYieldRequired;
    /* Kernel API calls require Critical Sections. */
    ulSavedInterruptMask = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Increment the Tick. */
        lYieldRequired = xTaskIncrementTick();
    }

    portCLEAR_INTERRUPT_MASK_FROM_ISR(ulSavedInterruptMask);

    if (lYieldRequired != pdFALSE)
    {
        vPortYield();
    }
}

__attribute__((optnone)) void interruptSystick(void)
{
    /** @attention 编译器不会因为嵌入汇编使用了LJMP而自动保存LR,因此需要手动PUSH LR */
    __asm__ volatile("PUSH LR");
    /** @attention disable global interrupts to avoid preemption by different priority interrupt */
    DISABLE_INTERRUPT();
    /*======================任务栈====================*/
    /* 中断内将栈指针手动切换为ISP */
    /** @attention 使用R16/R17后，编译器会自动压栈 */
    /* 将R16,R17压栈入任务栈中 */
    __asm__ volatile("PUSH {R16,R17}");
    __asm__ volatile("" ::: "memory");
    /* 在R16内保存当前的SP */
    __asm__ volatile("MOV R16, SP" ::: "R16");
    /* 读取ISP, 在R17内保存当前ISP */
    __asm__ volatile("CSRR R17, #0x189" ::: "R17");
    __asm__ volatile("SYNC");
    /* 更新SP为中断栈ISP */
    __asm__ volatile("MOV SP, R17");
    /* 等待以上指令完成后再执行后续指令 */
    __asm__ volatile("SYNC");
    /* 等待以上指令完成后再访问内存 */
    __asm__ volatile("DSYNC");
    /* 内存屏障，保证指令顺序 */
    __asm__ volatile("" ::: "memory");
    /*======================中断栈====================*/
    /* 保存全局寄存器至中断栈，使用全局寄存器存储临时变量 */
    __asm__ volatile("PUSH {R6-R9}");
    __asm__ volatile("" ::: "memory");
    /* ISCR.CMP0 = 1 */
    __asm__ volatile("MOV R0, #0xF0000150");
    __asm__ volatile("SET [R0], #0");

    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)SYSTICK0_PTR));
    __asm__ volatile("MOV R6, %0" ::"r"((unsigned int)Systick_LL_GetLowerTimer));

    __asm__ volatile("LJMP R6");
// register uint32_t stmCount = Systick_LL_GetLowerTimer(SYSTICK0_PTR);
/* TODO: DIVU指令不支持 */
#if 0
    __asm__ volatile("MOV R7, %0" ::"r"((unsigned int)configSTM_CLOCK_HZ));
    __asm__ volatile("MOV R8, %0" ::"r"((unsigned int)configTICK_RATE_HZ));
    __asm__ volatile("DIVU R9, R7, R8");
#endif
    __asm__ volatile("MOV R9, %0" ::"r"((unsigned int)(configSTM_CLOCK_HZ / configTICK_RATE_HZ)));
    __asm__ volatile("ADD R2, R0, R9"); // stmCount + configSTM_CLOCK_HZ / configTICK_RATE_HZ
    __asm__ volatile("MOV R1, %0" ::"r"((unsigned int)SYSTICK_HW_COMPARATOR_0));
    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)SYSTICK0_PTR));
    __asm__ volatile("MOV R6, %0" ::"r"((unsigned int)Systick_Hw_UpdateCompare));

    __asm__ volatile("LJMP R6");
    // Systick_Hw_UpdateCompare(SYSTICK0_PTR,
    //                          SYSTICK_HW_COMPARATOR_0,
    //                          stmCount + configSTM_CLOCK_HZ / configTICK_RATE_HZ);

    __asm__ volatile("MOV R6, %0" ::"r"((unsigned int)vPortSystemTickHandler));
    __asm__ volatile("LJMP R6");
    // vPortSystemTickHandler();

    /* 全局变量恢复 */
    __asm__ volatile("POP {R6-R9}");
    /* 内存屏障，保证指令顺序 */
    __asm__ volatile("" ::: "memory");
    /* 等待以上指令完成后再访问内存 */
    __asm__ volatile("DSYNC");
    /* 等待以上指令完成后再执行后续指令 */
    __asm__ volatile("SYNC");
    /* 准备中断返回 */
    /* 恢复ISP为中断入口保存的ISP */
    /** @note 该指令可以去除，因为全程ISP未改变 */
    __asm__ volatile("CSRW R17, #0x189");
    __asm__ volatile("SYNC");
    /* 恢复SP为任务栈 */
    __asm__ volatile("MOV SP, R16");

    /** @attention 使用R16/R17后，编译器会自动出栈 */
    /* 从任务栈内恢复R16, R17 */
    __asm__ volatile("POP {R16, R17}");
    __asm__ volatile("" ::: "memory");
    /*======================任务栈====================*/
    ENABLE_INTERRUPT();
    __asm__ volatile("POP LR");
}

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

void vPortEndScheduler(void)
{
    /* Nothing to do. Unlikely to want to end. */
}
/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/

/*-----------------------------------------------------------*/
__attribute__((noinline)) void uxPortClearInterruptMaskFromISR(unsigned long uxSavedMaskValue)
{
    DISABLE_INTERRUPT();
    __asm__ volatile("MOV R0, %0" ::"r"((unsigned int)uxSavedMaskValue) : "R0");
    __asm__ volatile("CSRR R1, #0x187" ::: "R1"); /* Get current ICR value. */
    __asm__ volatile("MOV R1, %0" ::"r"((unsigned int)portCCPN_MASK) : "R1");
    __asm__ volatile("NOT R0, R0");
    __asm__ volatile("ANL R1, R0");      /* Clear down mask bits. */
    __asm__ volatile("CSRW R1, #0x187"); /* Write back updated ICR. */
    __asm__ volatile("SYNC");
    ENABLE_INTERRUPT();
}

unsigned long uxPortSetInterruptMaskFromISR(void)
{
    unsigned long uxReturn = 0UL;

    DISABLE_INTERRUPT();
    __asm__ volatile("CSRR R1, #0x187" ::: "R1"); /* Get current ICR value. */
    __asm__ volatile("MOV R2, %0" ::"r"((unsigned int)portCCPN_MASK) : "R2");
    __asm__ volatile("NOT R2, R2");
    __asm__ volatile("ANL R1, R2"); /* Clear down mask bits. */
    __asm__ volatile("MOV R2, %0" ::"r"((unsigned int)configMAX_SYSCALL_INTERRUPT_PRIORITY));
    __asm__ volatile("ORL R1, R2");      /* Set mask bits to required priority mask. */
    __asm__ volatile("CSRW R1, #0x187"); /* Write back updated ICR. */
    __asm__ volatile("SYNC");
    ENABLE_INTERRUPT();
    __asm__ volatile("MOV %0, R1" : "=r"(uxReturn) : : "memory");

    /* Return just the interrupt mask bits. */
    return (uxReturn & portCCPN_MASK);
}
/*-----------------------------------------------------------*/

__attribute__((__noreturn__)) void vPortLoopForever(void)
{
    while (1)
        ;
}

/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void vPortSetupTimerInterrupt(void)
{
    Systick_CompareConfig_t Config = {
      .Comparator          = SYSTICK_HW_COMPARATOR_0,
      .ComparatorInterrupt = SYSTICK_HW_INTERRUPT_STIR0,
      .ComparatorOffset    = SYSTICK_HW_COMPARATOR_OFFSET0,
      .ComparatorSize      = SYSTICK_HW_COMPARATOR_SIZE_32BITS,
      .Ticks               = configSTM_CLOCK_HZ / configTICK_RATE_HZ,
      .EnableInterrupt     = true,
    };
    Systick_Hw_IntrRequestNodeInit(
      SYSTICK0_PTR, configKERNEL_INTERRUPT_PRIORITY, INT_SOURCECPU0, SYSTICK_HW_INTERRUPT_LINE_0, true);
    Systick_Hw_ResetModule(SYSTICK0_PTR);
    Systick_Hw_InitCompare(SYSTICK0_PTR, &Config);

    /* 初始化软件中断 */
    Intr_IrqEnumType ServiceRequestNodeIndex = HW_GP0SR0_IRQn;
    do
    {
        Int_LL_EnableServiceRequest(ServiceRequestNodeIndex, false);
    } while (Int_LL_GetServiceRequest(ServiceRequestNodeIndex));
    do
    {
        Int_LL_ClearIntRequestState(ServiceRequestNodeIndex, true);
    } while (Int_LL_GetIntRequestState(ServiceRequestNodeIndex));
    Int_LL_SetServiceType(ServiceRequestNodeIndex, INT_SOURCECPU0);
    Int_LL_SetServiceRequestPriority(ServiceRequestNodeIndex, portLOWEST_INTERRUPT_PRIORITY);
    Int_LL_EnableServiceRequest(ServiceRequestNodeIndex, true);

    /* TODO: 初始化软件中断作为SVC，用来开启第一个任务 */

    /** @attention 优先级决定了服务函数在中断向量表的位置，因此Systick和Svc中断优先级不能一致*/
    /** @attention Systick优先级应当高于Svc中断优先级，避免Systick中vPortYield引起中断嵌套 */
    /* TODO: 配置Systick和Svc处于相同的优先级组中，避免互相抢占 */
}

#if (configSUPPORT_STATIC_ALLOCATION == 1)
static StackType_t  IdleTaskStack[configMINIMAL_STACK_SIZE];
static StaticTask_t IdleTaskTCB;
static StackType_t  TimerTaskStack[configTIMER_TASK_STACK_DEPTH];
static StaticTask_t TimerTaskTCB;

void vApplicationGetIdleTaskMemory(
  StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize)
{
    *ppxIdleTaskStackBuffer = IdleTaskStack;
    *ppxIdleTaskTCBBuffer   = &IdleTaskTCB;
    *pulIdleTaskStackSize   = configMINIMAL_STACK_SIZE;
}

void vApplicationGetTimerTaskMemory(
  StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize)
{
    *ppxTimerTaskStackBuffer = TimerTaskStack;
    *ppxTimerTaskTCBBuffer   = &TimerTaskTCB;
    *pulTimerTaskStackSize   = configTIMER_TASK_STACK_DEPTH;
}
#endif
